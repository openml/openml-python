{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenML","text":"<p>Collaborative Machine Learning in Python</p> <p>Welcome to the documentation of the OpenML Python API, a connector to the collaborative machine learning platform OpenML.org. The OpenML Python package allows to use datasets and tasks from OpenML together with scikit-learn and share the results online.</p>"},{"location":"#example","title":"Example","text":"<pre><code>import openml\nfrom sklearn import impute, tree, pipeline\n\n# Define a scikit-learn classifier or pipeline\nclf = pipeline.Pipeline(\n    steps=[\n        ('imputer', impute.SimpleImputer()),\n        ('estimator', tree.DecisionTreeClassifier())\n    ]\n)\n# Download the OpenML task for the pendigits dataset with 10-fold\n# cross-validation.\ntask = openml.tasks.get_task(32)\n# Run the scikit-learn model on the task.\nrun = openml.runs.run_model_on_task(clf, task)\n# Publish the experiment on OpenML (optional, requires an API key.\n# You can get your own API key by signing up to OpenML.org)\nrun.publish()\nprint(f'View the run online: {run.openml_url}')\n</code></pre> <p>Find more examples in the sidebar on the left.</p>"},{"location":"#how-to-get-openml-for-python","title":"How to get OpenML for python","text":"<p>You can install the OpenML package via <code>pip</code> (we recommend using a virtual environment):</p> <pre><code>python -m pip install openml\n</code></pre> <p>For more advanced installation information, please see the \"Introduction\" example.</p>"},{"location":"#further-information","title":"Further information","text":"<ul> <li>OpenML documentation</li> <li>OpenML client APIs</li> <li>OpenML developer guide</li> <li>Contact information</li> <li>Citation request</li> <li>OpenML blog</li> <li>OpenML twitter account</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contribution to the OpenML package is highly appreciated. Please see the \"Contributing\" page for more information.</p>"},{"location":"#citing-openml-python","title":"Citing OpenML-Python","text":"<p>If you use OpenML-Python in a scientific publication, we would appreciate a reference to our JMLR-MLOSS paper  \"OpenML-Python: an extensible Python API for OpenML\":</p> BibtexMLA <pre><code>@article{JMLR:v22:19-920,\n    author  = {Matthias Feurer and Jan N. van Rijn and Arlind Kadra and Pieter Gijsbers and Neeratyoy Mallik and Sahithya Ravi and Andreas M\u00c3\u00bcller and Joaquin Vanschoren and Frank Hutter},\n    title   = {OpenML-Python: an extensible Python API for OpenML},\n    journal = {Journal of Machine Learning Research},\n    year    = {2021},\n    volume  = {22},\n    number  = {100},\n    pages   = {1--5},\n    url     = {http://jmlr.org/papers/v22/19-920.html}\n}\n</code></pre> <p>Feurer, Matthias, et al.  \"OpenML-Python: an extensible Python API for OpenML.\" Journal of Machine Learning Research 22.100 (2021):1\u22125.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contribution to the OpenML package is highly appreciated in all forms. In particular, a few ways to contribute to openml-python are:</p> <ul> <li>A direct contribution to the package, by means of improving the     code, documentation or examples. To get started, see this     file     with details on how to set up your environment to develop for     openml-python.</li> <li>A contribution to an openml-python extension. An extension package     allows OpenML to interface with a machine learning package (such     as scikit-learn or keras). These extensions are hosted in separate     repositories and may have their own guidelines. For more     information, see also extensions.</li> <li>Bug reports. If something doesn't work for you or is cumbersome,     please open a new issue to let us know about the problem. See     this     section.</li> <li>Cite OpenML if you use it in a     scientific publication.</li> <li>Visit one of our hackathons.</li> <li>Contribute to another OpenML project, such as the main OpenML     project.</li> </ul>"},{"location":"extensions/","title":"Extensions","text":"<p>OpenML-Python provides an extension interface to connect other machine learning libraries than scikit-learn to OpenML. Please check the <code>api_extensions</code> and use the scikit-learn extension in <code>openml.extensions.sklearn.SklearnExtension</code>{.interpreted-text role=\"class\"} as a starting point.</p>"},{"location":"extensions/#list-of-extensions","title":"List of extensions","text":"<p>Here is a list of currently maintained OpenML extensions:</p> <ul> <li><code>openml.extensions.sklearn.SklearnExtension</code>{.interpreted-text     role=\"class\"}</li> <li>openml-keras</li> <li>openml-pytorch</li> <li>openml-tensorflow (for tensorflow     2+)</li> </ul>"},{"location":"extensions/#connecting-new-machine-learning-libraries","title":"Connecting new machine learning libraries","text":""},{"location":"extensions/#content-of-the-library","title":"Content of the Library","text":"<p>To leverage support from the community and to tap in the potential of OpenML, interfacing with popular machine learning libraries is essential. The OpenML-Python package is capable of downloading meta-data and results (data, flows, runs), regardless of the library that was used to upload it. However, in order to simplify the process of uploading flows and runs from a specific library, an additional interface can be built. The OpenML-Python team does not have the capacity to develop and maintain such interfaces on its own. For this reason, we have built an extension interface to allows others to contribute back. Building a suitable extension for therefore requires an understanding of the current OpenML-Python support.</p> <p>The <code>sphx_glr_examples_20_basic_simple_flows_and_runs_tutorial.py</code>{.interpreted-text role=\"ref\"} tutorial shows how scikit-learn currently works with OpenML-Python as an extension. The sklearn extension packaged with the openml-python repository can be used as a template/benchmark to build the new extension.</p>"},{"location":"extensions/#api","title":"API","text":"<ul> <li>The extension scripts must import the [openml]{.title-ref} package     and be able to interface with any function from the OpenML-Python     <code>api</code>.</li> <li>The extension has to be defined as a Python class and must inherit     from <code>openml.extensions.Extension</code>.</li> <li>This class needs to have all the functions from [class     Extension]{.title-ref} overloaded as required.</li> <li>The redefined functions should have adequate and appropriate     docstrings. The [Sklearn Extension API     :class:`openml.extensions.sklearn.SklearnExtension.html]{.title-ref}     is a good example to follow.</li> </ul>"},{"location":"extensions/#interfacing-with-openml-python","title":"Interfacing with OpenML-Python","text":"<p>Once the new extension class has been defined, the openml-python module to <code>openml.extensions.register_extension</code> must be called to allow OpenML-Python to interface the new extension.</p> <p>The following methods should get implemented. Although the documentation in the [Extension]{.title-ref} interface should always be leading, here we list some additional information and best practices. The [Sklearn Extension API :class:`openml.extensions.sklearn.SklearnExtension.html]{.title-ref} is a good example to follow. Note that most methods are relatively simple and can be implemented in several lines of code.</p> <ul> <li>General setup (required)<ul> <li><code>can_handle_flow</code>: Takes as     argument an OpenML flow, and checks whether this can be handled     by the current extension. The OpenML database consists of many     flows, from various workbenches (e.g., scikit-learn, Weka, mlr).     This method is called before a model is being deserialized.     Typically, the flow-dependency field is used to check whether     the specific library is present, and no unknown libraries are     present there.</li> <li><code>can_handle_model</code>: Similar as     <code>can_handle_flow</code>, except that in     this case a Python object is given. As such, in many cases, this     method can be implemented by checking whether this adheres to a     certain base class.</li> </ul> </li> <li>Serialization and De-serialization (required)<ul> <li><code>flow_to_model</code>: deserializes the     OpenML Flow into a model (if the library can indeed handle the     flow). This method has an important interplay with     <code>model_to_flow</code>. Running these     two methods in succession should result in exactly the same     model (or flow). This property can be used for unit testing     (e.g., build a model with hyperparameters, make predictions on a     task, serialize it to a flow, deserialize it back, make it     predict on the same task, and check whether the predictions are     exactly the same.) The example in the scikit-learn interface     might seem daunting, but note that here some complicated design     choices were made, that allow for all sorts of interesting     research questions. It is probably good practice to start easy.</li> <li><code>model_to_flow</code>: The inverse of     <code>flow_to_model</code>. Serializes a     model into an OpenML Flow. The flow should preserve the class,     the library version, and the tunable hyperparameters.</li> <li><code>get_version_information</code>: Return     a tuple with the version information of the important libraries.</li> <li><code>create_setup_string</code>: No longer     used, and will be deprecated soon.</li> </ul> </li> <li>Performing runs (required)<ul> <li><code>is_estimator</code>: Gets as input a     class, and checks whether it has the status of estimator in the     library (typically, whether it has a train method and a predict     method).</li> <li><code>seed_model</code>: Sets a random seed     to the model.</li> <li><code>_run_model_on_fold</code>: One of the     main requirements for a library to generate run objects for the     OpenML server. Obtains a train split (with labels) and a test     split (without labels) and the goal is to train a model on the     train split and return the predictions on the test split. On top     of the actual predictions, also the class probabilities should     be determined. For classifiers that do not return class     probabilities, this can just be the hot-encoded predicted label.     The predictions will be evaluated on the OpenML server. Also,     additional information can be returned, for example,     user-defined measures (such as runtime information, as this can     not be inferred on the server). Additionally, information about     a hyperparameter optimization trace can be provided.</li> <li><code>obtain_parameter_values</code>:     Obtains the hyperparameters of a given model and the current     values. Please note that in the case of a hyperparameter     optimization procedure (e.g., random search), you only should     return the hyperparameters of this procedure (e.g., the     hyperparameter grid, budget, etc) and that the chosen model will     be inferred from the optimization trace.</li> <li><code>check_if_model_fitted</code>: Check     whether the train method of the model has been called (and as     such, whether the predict method can be used).</li> </ul> </li> <li>Hyperparameter optimization (optional)<ul> <li><code>instantiate_model_from_hpo_class</code>{.interpreted-text     role=\"meth\"}: If a given run has recorded the hyperparameter     optimization trace, then this method can be used to     reinstantiate the model with hyperparameters of a given     hyperparameter optimization iteration. Has some similarities     with <code>flow_to_model</code> (as this     method also sets the hyperparameters of a model). Note that     although this method is required, it is not necessary to     implement any logic if hyperparameter optimization is not     implemented. Simply raise a [NotImplementedError]{.title-ref}     then.</li> </ul> </li> </ul>"},{"location":"extensions/#hosting-the-library","title":"Hosting the library","text":"<p>Each extension created should be a stand-alone repository, compatible with the OpenML-Python repository. The extension repository should work off-the-shelf with OpenML-Python installed.</p> <p>Create a public Github repo with the following directory structure:</p> <pre><code>| [repo name]\n|    |-- [extension name]\n|    |    |-- __init__.py\n|    |    |-- extension.py\n|    |    |-- config.py (optionally)\n</code></pre>"},{"location":"extensions/#recommended","title":"Recommended","text":"<ul> <li>Test cases to keep the extension up to date with the     [openml-python]{.title-ref} upstream changes.</li> <li>Documentation of the extension API, especially if any new     functionality added to OpenML-Python\\'s extension design.</li> <li>Examples to show how the new extension interfaces and works with     OpenML-Python.</li> <li>Create a PR to add the new extension to the OpenML-Python API     documentation.</li> </ul> <p>Happy contributing!</p>"},{"location":"progress/","title":"Changelog","text":""},{"location":"progress/#next","title":"next","text":"<ul> <li>MAINT #1340: Add Numpy 2.0 support. Update tests to work with     scikit-learn \\&lt;= 1.5.</li> <li>ADD #1342: Add HTTP header to requests to indicate they are from     openml-python.</li> </ul>"},{"location":"progress/#0142","title":"0.14.2","text":"<ul> <li>MAINT #1280: Use the server-provided <code>parquet_url</code> instead of     <code>minio_url</code> to determine the location of the parquet file.</li> <li>ADD #716: add documentation for remaining attributes of classes     and functions.</li> <li>ADD #1261: more annotations for type hints.</li> <li>MAINT #1294: update tests to new tag specification.</li> <li>FIX #1314: Update fetching a bucket from MinIO.</li> <li>FIX #1315: Make class label retrieval more lenient.</li> <li>ADD #1316: add feature descriptions ontologies support.</li> <li>MAINT #1310/#1307: switch to ruff and resolve all mypy errors.</li> </ul>"},{"location":"progress/#0141","title":"0.14.1","text":"<ul> <li>FIX: Fallback on downloading ARFF when failing to download parquet     from MinIO due to a ServerError.</li> </ul>"},{"location":"progress/#0140","title":"0.14.0","text":"<p>IMPORTANT: This release paves the way towards a breaking update of OpenML-Python. From version 0.15, functions that had the option to return a pandas DataFrame will return a pandas DataFrame by default. This version (0.14) emits a warning if you still use the old access functionality. More concretely:</p> <ul> <li>In 0.15 we will drop the ability to return dictionaries in listing     calls and only provide pandas DataFrames. To disable warnings in     0.14 you have to request a pandas DataFrame (using     <code>output_format=\"dataframe\"</code>).</li> <li>In 0.15 we will drop the ability to return datasets as numpy arrays     and only provide pandas DataFrames. To disable warnings in 0.14 you     have to request a pandas DataFrame (using     <code>dataset_format=\"dataframe\"</code>).</li> </ul> <p>Furthermore, from version 0.15, OpenML-Python will no longer download datasets and dataset metadata by default. This version (0.14) emits a warning if you don\\'t explicitly specifiy the desired behavior.</p> <p>Please see the pull requests #1258 and #1260 for further information.</p> <ul> <li>ADD #1081: New flag that allows disabling downloading dataset     features.</li> <li>ADD #1132: New flag that forces a redownload of cached data.</li> <li>FIX #1244: Fixes a rare bug where task listing could fail when the     server returned invalid data.</li> <li>DOC #1229: Fixes a comment string for the main example.</li> <li>DOC #1241: Fixes a comment in an example.</li> <li>MAINT #1124: Improve naming of helper functions that govern the     cache directories.</li> <li>MAINT #1223, #1250: Update tools used in pre-commit to the latest     versions (<code>black==23.30</code>, <code>mypy==1.3.0</code>, <code>flake8==6.0.0</code>).</li> <li>MAINT #1253: Update the citation request to the JMLR paper.</li> <li>MAINT #1246: Add a warning that warns the user that checking for     duplicate runs on the server cannot be done without an API key.</li> </ul>"},{"location":"progress/#0131","title":"0.13.1","text":"<ul> <li>ADD #1081 #1132: Add additional options for (not) downloading     datasets <code>openml.datasets.get_dataset</code> and cache management.</li> <li>ADD #1028: Add functions to delete runs, flows, datasets, and tasks     (e.g., <code>openml.datasets.delete_dataset</code>).</li> <li>ADD #1144: Add locally computed results to the <code>OpenMLRun</code> object\\'s     representation if the run was created locally and not downloaded     from the server.</li> <li>ADD #1180: Improve the error message when the checksum of a     downloaded dataset does not match the checksum provided by the API.</li> <li>ADD #1201: Make <code>OpenMLTraceIteration</code> a dataclass.</li> <li>DOC #1069: Add argument documentation for the <code>OpenMLRun</code> class.</li> <li>DOC #1241 #1229 #1231: Minor documentation fixes and resolve     documentation examples not working.</li> <li>FIX #1197 #559 #1131: Fix the order of ground truth and predictions     in the <code>OpenMLRun</code> object and in <code>format_prediction</code>.</li> <li>FIX #1198: Support numpy 1.24 and higher.</li> <li>FIX #1216: Allow unknown task types on the server. This is only     relevant when new task types are added to the test server.</li> <li>FIX #1223: Fix mypy errors for implicit optional typing.</li> <li>MAINT #1155: Add dependabot github action to automatically update     other github actions.</li> <li>MAINT #1199: Obtain pre-commit\\'s flake8 from github.com instead of     gitlab.com.</li> <li>MAINT #1215: Support latest numpy version.</li> <li>MAINT #1218: Test Python3.6 on Ubuntu 20.04 instead of the latest     Ubuntu (which is 22.04).</li> <li>MAINT #1221 #1212 #1206 #1211: Update github actions to the latest     versions.</li> </ul>"},{"location":"progress/#0130","title":"0.13.0","text":"<ul> <li>FIX #1030: <code>pre-commit</code> hooks now no longer should issue a     warning.</li> <li>FIX #1058, #1100: Avoid <code>NoneType</code> error when printing task     without <code>class_labels</code> attribute.</li> <li>FIX #1110: Make arguments to <code>create_study</code> and <code>create_suite</code>     that are defined as optional by the OpenML XSD actually optional.</li> <li>FIX #1147: <code>openml.flow.flow_exists</code> no longer requires an API     key.</li> <li>FIX #1184: Automatically resolve proxies when downloading from     minio. Turn this off by setting environment variable     <code>no_proxy=\"*\"</code>.</li> <li>MAINT #1088: Do CI for Windows on Github Actions instead of     Appveyor.</li> <li>MAINT #1104: Fix outdated docstring for <code>list_task</code>.</li> <li>MAINT #1146: Update the pre-commit dependencies.</li> <li>ADD #1103: Add a <code>predictions</code> property to OpenMLRun for easy     accessibility of prediction data.</li> <li>ADD #1188: EXPERIMENTAL. Allow downloading all files from a minio     bucket with <code>download_all_files=True</code> for <code>get_dataset</code>.</li> </ul>"},{"location":"progress/#0122","title":"0.12.2","text":"<ul> <li>ADD #1065: Add a <code>retry_policy</code> configuration option that determines     the frequency and number of times to attempt to retry server     requests.</li> <li>ADD #1075: A docker image is now automatically built on a push to     develop. It can be used to build docs or run tests in an isolated     environment.</li> <li>ADD: You can now avoid downloading \\'qualities\\' meta-data when     downloading a task with the <code>download_qualities</code> parameter of     <code>openml.tasks.get_task[s]</code> functions.</li> <li>DOC: Fixes a few broken links in the documentation.</li> <li>DOC #1061: Improve examples to always show a warning when they     switch to the test server.</li> <li>DOC #1067: Improve documentation on the scikit-learn extension     interface.</li> <li>DOC #1068: Create dedicated extensions page.</li> <li>FIX #1075: Correctly convert [y]{.title-ref} to a pandas series when     downloading sparse data.</li> <li>MAINT: Rename [master]{.title-ref} brach to [ main]{.title-ref}     branch.</li> <li>MAINT/DOC: Automatically check for broken external links when     building the documentation.</li> <li>MAINT/DOC: Fail documentation building on warnings. This will make     the documentation building fail if a reference cannot be found (i.e.     an internal link is broken).</li> </ul>"},{"location":"progress/#0121","title":"0.12.1","text":"<ul> <li>ADD #895/#1038: Measure runtimes of scikit-learn runs also for     models which are parallelized via the joblib.</li> <li>DOC #1050: Refer to the webpage instead of the XML file in the main     example.</li> <li>DOC #1051: Document existing extensions to OpenML-Python besides the     shipped scikit-learn extension.</li> <li>FIX #1035: Render class attributes and methods again.</li> <li>ADD #1049: Add a command line tool for configuration openml-python.</li> <li>FIX #1042: Fixes a rare concurrency issue with OpenML-Python and     joblib which caused the joblib worker pool to fail.</li> <li>FIX #1053: Fixes a bug which could prevent importing the package in     a docker container.</li> </ul>"},{"location":"progress/#0120","title":"0.12.0","text":"<ul> <li>ADD #964: Validate <code>ignore_attribute</code>, <code>default_target_attribute</code>,     <code>row_id_attribute</code> are set to attributes that exist on the dataset     when calling <code>create_dataset</code>.</li> <li>ADD #979: Dataset features and qualities are now also cached in     pickle format.</li> <li>ADD #982: Add helper functions for column transformers.</li> <li>ADD #989: <code>run_model_on_task</code> will now warn the user the the model     passed has already been fitted.</li> <li>ADD #1009 : Give possibility to not download the dataset qualities.     The cached version is used even so download attribute is false.</li> <li>ADD #1016: Add scikit-learn 0.24 support.</li> <li>ADD #1020: Add option to parallelize evaluation of tasks with     joblib.</li> <li>ADD #1022: Allow minimum version of dependencies to be listed for a     flow, use more accurate minimum versions for scikit-learn     dependencies.</li> <li>ADD #1023: Add admin-only calls for adding topics to datasets.</li> <li>ADD #1029: Add support for fetching dataset from a minio server in     parquet format.</li> <li>ADD #1031: Generally improve runtime measurements, add them for some     previously unsupported flows (e.g. BaseSearchCV derived flows).</li> <li>DOC #973 : Change the task used in the welcome page example so it no     longer fails using numerical dataset.</li> <li>MAINT #671: Improved the performance of <code>check_datasets_active</code> by     only querying the given list of datasets in contrast to querying all     datasets. Modified the corresponding unit test.</li> <li>MAINT #891: Changed the way that numerical features are stored.     Numerical features that range from 0 to 255 are now stored as uint8,     which reduces the storage space required as well as storing and     loading times.</li> <li>MAINT #975, #988: Add CI through Github Actions.</li> <li>MAINT #977: Allow <code>short</code> and <code>long</code> scenarios for unit tests.     Reduce the workload for some unit tests.</li> <li>MAINT #985, #1000: Improve unit test stability and output     readability, and adds load balancing.</li> <li>MAINT #1018: Refactor data loading and storage. Data is now     compressed on the first call to [get_data]{.title-ref}.</li> <li>MAINT #1024: Remove flaky decorator for study unit test.</li> <li>FIX #883 #884 #906 #972: Various improvements to the caching system.</li> <li>FIX #980: Speed up <code>check_datasets_active</code>.</li> <li>FIX #984: Add a retry mechanism when the server encounters a     database issue.</li> <li>FIX #1004: Fixed an issue that prevented installation on some     systems (e.g. Ubuntu).</li> <li>FIX #1013: Fixes a bug where <code>OpenMLRun.setup_string</code> was not     uploaded to the server, prepares for <code>run_details</code> being sent from     the server.</li> <li>FIX #1021: Fixes an issue that could occur when running unit tests     and openml-python was not in PATH.</li> <li>FIX #1037: Fixes a bug where a dataset could not be loaded if a     categorical value had listed nan-like as a possible category.</li> </ul>"},{"location":"progress/#0110","title":"0.11.0","text":"<ul> <li>ADD #753: Allows uploading custom flows to OpenML via OpenML-Python.</li> <li>ADD #777: Allows running a flow on pandas dataframes (in addition to     numpy arrays).</li> <li>ADD #888: Allow passing a [task_id]{.title-ref} to     [run_model_on_task]{.title-ref}.</li> <li>ADD #894: Support caching of datasets using feather format as an     option.</li> <li>ADD #929: Add <code>edit_dataset</code> and <code>fork_dataset</code> to allow editing and     forking of uploaded datasets.</li> <li>ADD #866, #943: Add support for scikit-learn\\'s     [passthrough]{.title-ref} and [drop]{.title-ref} when uploading     flows to OpenML.</li> <li>ADD #879: Add support for scikit-learn\\'s MLP hyperparameter     [layer_sizes]{.title-ref}.</li> <li>ADD #894: Support caching of datasets using feather format as an     option.</li> <li>ADD #945: PEP 561 compliance for distributing Type information.</li> <li>DOC #660: Remove nonexistent argument from docstring.</li> <li>DOC #901: The API reference now documents the config file and its     options.</li> <li>DOC #912: API reference now shows [create_task]{.title-ref}.</li> <li>DOC #954: Remove TODO text from documentation.</li> <li>DOC #960: document how to upload multiple ignore attributes.</li> <li>FIX #873: Fixes an issue which resulted in incorrect URLs when     printing OpenML objects after switching the server.</li> <li>FIX #885: Logger no longer registered by default. Added utility     functions to easily register logging to console and file.</li> <li>FIX #890: Correct the scaling of data in the SVM example.</li> <li>MAINT #371: <code>list_evaluations</code> default <code>size</code> changed from <code>None</code> to     <code>10_000</code>.</li> <li>MAINT #767: Source distribution installation is now unit-tested.</li> <li>MAINT #781: Add pre-commit and automated code formatting with black.</li> <li>MAINT #804: Rename arguments of list_evaluations to indicate they     expect lists of ids.</li> <li>MAINT #836: OpenML supports only pandas version 1.0.0 or above.</li> <li>MAINT #865: OpenML no longer bundles test files in the source     distribution.</li> <li>MAINT #881: Improve the error message for too-long URIs.</li> <li>MAINT #897: Dropping support for Python 3.5.</li> <li>MAINT #916: Adding support for Python 3.8.</li> <li>MAINT #920: Improve error messages for dataset upload.</li> <li>MAINT #921: Improve hangling of the OpenML server URL in the config     file.</li> <li>MAINT #925: Improve error handling and error message when loading     datasets.</li> <li>MAINT #928: Restructures the contributing documentation.</li> <li>MAINT #936: Adding support for scikit-learn 0.23.X.</li> <li>MAINT #945: Make OpenML-Python PEP562 compliant.</li> <li>MAINT #951: Converts TaskType class to a TaskType enum.</li> </ul>"},{"location":"progress/#0102","title":"0.10.2","text":"<ul> <li>ADD #857: Adds task type ID to list_runs</li> <li>DOC #862: Added license BSD 3-Clause to each of the source files.</li> </ul>"},{"location":"progress/#0101","title":"0.10.1","text":"<ul> <li>ADD #175: Automatically adds the docstring of scikit-learn objects     to flow and its parameters.</li> <li>ADD #737: New evaluation listing call that includes the     hyperparameter settings.</li> <li>ADD #744: It is now possible to only issue a warning and not raise     an exception if the package versions for a flow are not met when     deserializing it.</li> <li>ADD #783: The URL to download the predictions for a run is now     stored in the run object.</li> <li>ADD #790: Adds the uploader name and id as new filtering options for     <code>list_evaluations</code>.</li> <li>ADD #792: New convenience function <code>openml.flow.get_flow_id</code>.</li> <li>ADD #861: Debug-level log information now being written to a file in     the cache directory (at most 2 MB).</li> <li>DOC #778: Introduces instructions on how to publish an extension to     support other libraries than scikit-learn.</li> <li>DOC #785: The examples section is completely restructured into     simple simple examples, advanced examples and examples showcasing     the use of OpenML-Python to reproduce papers which were done with     OpenML-Python.</li> <li>DOC #788: New example on manually iterating through the split of a     task.</li> <li>DOC #789: Improve the usage of dataframes in the examples.</li> <li>DOC #791: New example for the paper Efficient and Robust Automated     Machine Learning by Feurer et al. (2015).</li> <li>DOC #803: New example for the paper Don't Rule Out Simple Models     Prematurely: A Large Scale Benchmark Comparing Linear and Non-linear     Classifiers in OpenML by Benjamin Strang et al. (2018).</li> <li>DOC #808: New example demonstrating basic use cases of a dataset.</li> <li>DOC #810: New example demonstrating the use of benchmarking studies     and suites.</li> <li>DOC #832: New example for the paper Scalable Hyperparameter     Transfer Learning by Valerio Perrone et al. (2019)</li> <li>DOC #834: New example showing how to plot the loss surface for a     support vector machine.</li> <li>FIX #305: Do not require the external version in the flow XML when     loading an object.</li> <li>FIX #734: Better handling of \\\"old\\\" flows.</li> <li>FIX #736: Attach a StreamHandler to the openml logger instead of the     root logger.</li> <li>FIX #758: Fixes an error which made the client API crash when     loading a sparse data with categorical variables.</li> <li>FIX #779: Do not fail on corrupt pickle</li> <li>FIX #782: Assign the study id to the correct class attribute.</li> <li>FIX #819: Automatically convert column names to type string when     uploading a dataset.</li> <li>FIX #820: Make <code>__repr__</code> work for datasets which do not have an id.</li> <li>MAINT #796: Rename an argument to make the function     <code>list_evaluations</code> more consistent.</li> <li>MAINT #811: Print the full error message given by the server.</li> <li>MAINT #828: Create base class for OpenML entity classes.</li> <li>MAINT #829: Reduce the number of data conversion warnings.</li> <li>MAINT #831: Warn if there\\'s an empty flow description when     publishing a flow.</li> <li>MAINT #837: Also print the flow XML if a flow fails to validate.</li> <li>FIX #838: Fix list_evaluations_setups to work when evaluations are     not a 100 multiple.</li> <li>FIX #847: Fixes an issue where the client API would crash when     trying to download a dataset when there are no qualities available     on the server.</li> <li>MAINT #849: Move logic of most different <code>publish</code> functions into     the base class.</li> <li>MAINt #850: Remove outdated test code.</li> </ul>"},{"location":"progress/#0100","title":"0.10.0","text":"<ul> <li>ADD #737: Add list_evaluations_setups to return hyperparameters     along with list of evaluations.</li> <li>FIX #261: Test server is cleared of all files uploaded during unit     testing.</li> <li>FIX #447: All files created by unit tests no longer persist in     local.</li> <li>FIX #608: Fixing dataset_id referenced before assignment error in     get_run function.</li> <li>FIX #447: All files created by unit tests are deleted after the     completion of all unit tests.</li> <li>FIX #589: Fixing a bug that did not successfully upload the columns     to ignore when creating and publishing a dataset.</li> <li>FIX #608: Fixing dataset_id referenced before assignment error in     get_run function.</li> <li>DOC #639: More descriptive documention for function to convert array     format.</li> <li>DOC #719: Add documentation on uploading tasks.</li> <li>ADD #687: Adds a function to retrieve the list of evaluation     measures available.</li> <li>ADD #695: A function to retrieve all the data quality measures     available.</li> <li>ADD #412: Add a function to trim flow names for scikit-learn flows.</li> <li>ADD #715: [list_evaluations]{.title-ref} now has an option to sort     evaluations by score (value).</li> <li>ADD #722: Automatic reinstantiation of flow in     [run_model_on_task]{.title-ref}. Clearer errors if that\\'s not     possible.</li> <li>ADD #412: The scikit-learn extension populates the short name field     for flows.</li> <li>MAINT #726: Update examples to remove deprecation warnings from     scikit-learn</li> <li>MAINT #752: Update OpenML-Python to be compatible with sklearn 0.21</li> <li>ADD #790: Add user ID and name to list_evaluations</li> </ul>"},{"location":"progress/#090","title":"0.9.0","text":"<ul> <li>ADD #560: OpenML-Python can now handle regression tasks as well.</li> <li>ADD #620, #628, #632, #649, #682: Full support for studies and     distinguishes suites from studies.</li> <li>ADD #607: Tasks can now be created and uploaded.</li> <li>ADD #647, #673: Introduced the extension interface. This provides an     easy way to create a hook for machine learning packages to perform     e.g. automated runs.</li> <li>ADD #548, #646, #676: Support for Pandas DataFrame and     SparseDataFrame</li> <li>ADD #662: Results of listing functions can now be returned as     pandas.DataFrame.</li> <li>ADD #59: Datasets can now also be retrieved by name.</li> <li>ADD #672: Add timing measurements for runs, when possible.</li> <li>ADD #661: Upload time and error messages now displayed with     [list_runs]{.title-ref}.</li> <li>ADD #644: Datasets can now be downloaded \\'lazily\\', retrieving only     metadata at first, and the full dataset only when necessary.</li> <li>ADD #659: Lazy loading of task splits.</li> <li>ADD #516: [run_flow_on_task]{.title-ref} flow uploading is now     optional.</li> <li>ADD #680: Adds     [openml.config.start_using_configuration_for_example]{.title-ref}     (and resp. stop) to easily connect to the test server.</li> <li>ADD #75, #653: Adds a pretty print for objects of the top-level     classes.</li> <li>FIX #642: [check_datasets_active]{.title-ref} now correctly also     returns active status of deactivated datasets.</li> <li>FIX #304, #636: Allow serialization of numpy datatypes and list of     lists of more types (e.g. bools, ints) for flows.</li> <li>FIX #651: Fixed a bug that would prevent openml-python from finding     the user\\'s config file.</li> <li>FIX #693: OpenML-Python uses liac-arff instead of scipy.io for     loading task splits now.</li> <li>DOC #678: Better color scheme for code examples in documentation.</li> <li>DOC #681: Small improvements and removing list of missing functions.</li> <li>DOC #684: Add notice to examples that connect to the test server.</li> <li>DOC #688: Add new example on retrieving evaluations.</li> <li>DOC #691: Update contributing guidelines to use Github draft feature     instead of tags in title.</li> <li>DOC #692: All functions are documented now.</li> <li>MAINT #184: Dropping Python2 support.</li> <li>MAINT #596: Fewer dependencies for regular pip install.</li> <li>MAINT #652: Numpy and Scipy are no longer required before     installation.</li> <li>MAINT #655: Lazy loading is now preferred in unit tests.</li> <li>MAINT #667: Different tag functions now share code.</li> <li>MAINT #666: More descriptive error message for     [TypeError]{.title-ref} in [list_runs]{.title-ref}.</li> <li>MAINT #668: Fix some type hints.</li> <li>MAINT #677: [dataset.get_data]{.title-ref} now has consistent     behavior in its return type.</li> <li>MAINT #686: Adds ignore directives for several [mypy]{.title-ref}     folders.</li> <li>MAINT #629, #630: Code now adheres to single PEP8 standard.</li> </ul>"},{"location":"progress/#080","title":"0.8.0","text":"<ul> <li>ADD #440: Improved dataset upload.</li> <li>ADD #545, #583: Allow uploading a dataset from a pandas DataFrame.</li> <li>ADD #528: New functions to update the status of a dataset.</li> <li>ADD #523: Support for scikit-learn 0.20\\'s new ColumnTransformer.</li> <li>ADD #459: Enhanced support to store runs on disk prior to uploading     them to OpenML.</li> <li>ADD #564: New helpers to access the structure of a flow (and find     its subflows).</li> <li>ADD #618: The software will from now on retry to connect to the     server if a connection failed. The number of retries can be     configured.</li> <li>FIX #538: Support loading clustering tasks.</li> <li>FIX #464: Fixes a bug related to listing functions (returns correct     listing size).</li> <li>FIX #580: Listing function now works properly when there are less     results than requested.</li> <li>FIX #571: Fixes an issue where tasks could not be downloaded in     parallel.</li> <li>FIX #536: Flows can now be printed when the flow name is None.</li> <li>FIX #504: Better support for hierarchical hyperparameters when     uploading scikit-learn\\'s grid and random search.</li> <li>FIX #569: Less strict checking of flow dependencies when loading     flows.</li> <li>FIX #431: Pickle of task splits are no longer cached.</li> <li>DOC #540: More examples for dataset uploading.</li> <li>DOC #554: Remove the doubled progress entry from the docs.</li> <li>MAINT #613: Utilize the latest updates in OpenML evaluation     listings.</li> <li>MAINT #482: Cleaner interface for handling search traces.</li> <li>MAINT #557: Continuous integration works for scikit-learn 0.18-0.20.</li> <li>MAINT #542: Continuous integration now runs python3.7 as well.</li> <li>MAINT #535: Continuous integration now enforces PEP8 compliance for     new code.</li> <li>MAINT #527: Replace deprecated nose by pytest.</li> <li>MAINT #510: Documentation is now built by travis-ci instead of     circle-ci.</li> <li>MAINT: Completely re-designed documentation built on sphinx gallery.</li> <li>MAINT #462: Appveyor CI support.</li> <li>MAINT #477: Improve error handling for issue     #479: the OpenML     connector fails earlier and with a better error message when failing     to create a flow from the OpenML description.</li> <li>MAINT #561: Improve documentation on running specific unit tests.</li> </ul>"},{"location":"progress/#04-07","title":"0.4.-0.7","text":"<p>There is no changelog for these versions.</p>"},{"location":"progress/#030","title":"0.3.0","text":"<ul> <li>Add this changelog</li> <li>2nd example notebook PyOpenML.ipynb</li> <li>Pagination support for list datasets and list tasks</li> </ul>"},{"location":"progress/#prior","title":"Prior","text":"<p>There is no changelog for prior versions.</p>"},{"location":"usage/","title":"User Guide","text":"<p>This document will guide you through the most important use cases, functions and classes in the OpenML Python API. Throughout this document, we will use pandas to format and filter tables.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>The OpenML Python package is a connector to OpenML. It allows you to use and share datasets and tasks, run machine learning algorithms on them and then share the results online.</p> <p>The \"intruduction tutorial and setup\" tutorial gives a short introduction on how to install and set up the OpenML Python connector, followed up by a simple example.</p>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>The configuration file resides in a directory <code>.config/openml</code> in the home directory of the user and is called config (More specifically, it resides in the configuration directory specified by the XDGB Base Directory Specification). It consists of <code>key = value</code> pairs which are separated by newlines. The following keys are defined:</p> <ul> <li>apikey: required to access the server. The introduction tutorial describes how to obtain an API key.</li> <li>server: the server to connect to (default: <code>http://www.openml.org</code>).           For connection to the test server, set this to <code>test.openml.org</code>.</li> <li>cachedir: the root folder where the cache file directories should be created.     If not given, will default to <code>~/.openml/cache</code></li> <li>avoid_duplicate_runs: if set to <code>True</code> (default), when <code>run_flow_on_task</code> or similar methods             are called a lookup is performed to see if there already             exists such a run on the server. If so, download those             results instead.</li> <li> <p>retry_policy: Defines how to react when the server is unavailable or             experiencing high load. It determines both how often to             attempt to reconnect and how quickly to do so. Please don't             use <code>human</code> in an automated script that you run more than             one instance of, it might increase the time to complete your             jobs and that of others. One of:             -   human (default): For people running openml in interactive                 fashion. Try only a few times, but in quick succession.             -   robot: For people using openml in an automated fashion. Keep                 trying to reconnect for a longer time, quickly increasing                 the time between retries.</p> </li> <li> <p>connection_n_retries: number of times to retry a request if they fail.  Default depends on retry_policy (5 for <code>human</code>, 50 for <code>robot</code>)</p> </li> <li>verbosity: the level of output:<ul> <li>0: normal output</li> <li>1: info output</li> <li>2: debug output</li> </ul> </li> </ul> <p>This file is easily configurable by the <code>openml</code> command line interface. To see where the file is stored, and what its values are, use openml configure none. </p>"},{"location":"usage/#docker","title":"Docker","text":"<p>It is also possible to try out the latest development version of <code>openml-python</code> with docker:</p> <pre><code>docker run -it openml/openml-python\n</code></pre> <p>See the openml-python docker documentation for more information.</p>"},{"location":"usage/#key-concepts","title":"Key concepts","text":"<p>OpenML contains several key concepts which it needs to make machine learning research shareable. A machine learning experiment consists of one or several runs, which describe the performance of an algorithm (called a flow in OpenML), its hyperparameter settings (called a setup) on a task. A Task is the combination of a dataset, a split and an evaluation metric. In this user guide we will go through listing and exploring existing tasks to actually running machine learning algorithms on them. In a further user guide we will examine how to search through datasets in order to curate a list of tasks.</p> <p>A further explanation is given in the OpenML user guide.</p>"},{"location":"usage/#working-with-tasks","title":"Working with tasks","text":"<p>You can think of a task as an experimentation protocol, describing how to apply a machine learning model to a dataset in a way that is comparable with the results of others (more on how to do that further down). Tasks are containers, defining which dataset to use, what kind of task we\\'re solving (regression, classification, clustering, etc...) and which column to predict. Furthermore, it also describes how to split the dataset into a train and test set, whether to use several disjoint train and test splits (cross-validation) and whether this should be repeated several times. Also, the task defines a target metric for which a flow should be optimized.</p> <p>If you want to know more about tasks, try the \"Task tutorial\"</p>"},{"location":"usage/#running-machine-learning-algorithms-and-uploading-results","title":"Running machine learning algorithms and uploading results","text":"<p>In order to upload and share results of running a machine learning algorithm on a task, we need to create an openml.runs.OpenMLRun. A run object can be created by running a openml.flows.OpenMLFlow or a scikit-learn compatible model on a task. We will focus on the simpler example of running a scikit-learn model.</p> <p>Flows are descriptions of something runnable which does the machine learning. A flow contains all information to set up the necessary machine learning library and its dependencies as well as all possible parameters.</p> <p>A run is the outcome of running a flow on a task. It contains all parameter settings for the flow, a setup string (most likely a command line call) and all predictions of that run. When a run is uploaded to the server, the server automatically calculates several metrics which can be used to compare the performance of different flows to each other.</p> <p>So far, the OpenML Python connector works only with estimator objects following the scikit-learn estimator API. Those can be directly run on a task, and a flow will automatically be created or downloaded from the server if it already exists.</p> <p>See \"Simple Flows and Runs\" for a tutorial covers how to train different machine learning models, how to run machine learning models on OpenML data and how to share the results.</p>"},{"location":"usage/#datasets","title":"Datasets","text":"<p>OpenML provides a large collection of datasets and the benchmark OpenML100 which consists of a curated list of datasets.</p> <p>You can find the dataset that best fits your requirements by making use of the available metadata. The tutorial \"extended datasets\" which follows explains how to get a list of datasets, how to filter the list to find the dataset that suits your requirements and how to download a dataset.</p> <p>OpenML is about sharing machine learning results and the datasets they were obtained on. Learn how to share your datasets in the following tutorial \"Upload\" tutorial.</p>"},{"location":"usage/#extending-openml-python","title":"Extending OpenML-Python","text":"<p>OpenML-Python provides an extension interface to connect machine learning libraries directly to the API and ships a <code>scikit-learn</code> extension. Read more about them in the \"Extensions\" section.</p>"},{"location":"examples/SUMMARY/","title":"SUMMARY","text":"<ul> <li>20_basic<ul> <li>introduction_tutorial.py</li> <li>simple_datasets_tutorial.py</li> <li>simple_flows_and_runs_tutorial.py</li> <li>simple_suites_tutorial.py</li> </ul> </li> <li>30_extended<ul> <li>benchmark_with_optunahub.py</li> <li>configure_logging.py</li> <li>create_upload_tutorial.py</li> <li>custom_flow_.py</li> <li>datasets_tutorial.py</li> <li>fetch_evaluations_tutorial.py</li> <li>fetch_runtimes_tutorial.py</li> <li>flow_id_tutorial.py</li> <li>flows_and_runs_tutorial.py</li> <li>plot_svm_hyperparameters_tutorial.py</li> <li>run_setup_tutorial.py</li> <li>study_tutorial.py</li> <li>suites_tutorial.py</li> <li>task_manual_iteration_tutorial.py</li> <li>tasks_tutorial.py</li> </ul> </li> <li>40_paper<ul> <li>2015_neurips_feurer_example.py</li> <li>2018_ida_strang_example.py</li> <li>2018_kdd_rijn_example.py</li> <li>2018_neurips_perrone_example.py</li> </ul> </li> </ul>"},{"location":"examples/20_basic/introduction_tutorial/","title":"Introduction tutorial &amp; Setup","text":"<p>OpenML is an online collaboration platform for machine learning which allows you to:</p> <ul> <li>Find or share interesting, well-documented datasets</li> <li>Define research / modelling goals (tasks)</li> <li>Explore large amounts of machine learning algorithms, with APIs in Java, R, Python</li> <li>Log and share reproducible experiments, models, results</li> <li>Works seamlessly with scikit-learn and other libraries</li> <li>Large scale benchmarking, compare to state of the art</li> </ul> In\u00a0[\u00a0]: Copied! <pre>import openml\nfrom sklearn import neighbors\n</pre>  import openml from sklearn import neighbors <p>Warning</p> <p>         This example uploads data. For that reason, this example connects to the         test server at test.openml.org.         This prevents the main server from becoming overloaded with example datasets, tasks,         runs, and other submissions.         Using this test server may affect the behavior and performance of the         OpenML-Python API.     </p> In\u00a0[\u00a0]: Copied! <pre># openml.config.start_using_configuration_for_example()\n</pre> # openml.config.start_using_configuration_for_example() <p>When using the main server instead, make sure your apikey is configured. This can be done with the following line of code (uncomment it!). Never share your apikey with others.</p> In\u00a0[\u00a0]: Copied! <pre># openml.config.apikey = 'YOURKEY'\n</pre> # openml.config.apikey = 'YOURKEY' In\u00a0[\u00a0]: Copied! <pre># Uncomment and set your OpenML cache directory\n# import os\n# openml.config.cache_directory = os.path.expanduser('YOURDIR')\nopenml.config.set_root_cache_directory(\"YOURDIR\")\n</pre> # Uncomment and set your OpenML cache directory # import os # openml.config.cache_directory = os.path.expanduser('YOURDIR') openml.config.set_root_cache_directory(\"YOURDIR\") In\u00a0[\u00a0]: Copied! <pre>task = openml.tasks.get_task(403)\nclf = neighbors.KNeighborsClassifier(n_neighbors=5)\nopenml.config.start_using_configuration_for_example()\n\nrun = openml.runs.run_model_on_task(clf, task, avoid_duplicate_runs=False)\n# Publish the experiment on OpenML (optional, requires an API key).\n# For this tutorial, our configuration publishes to the test server\n# as to not crowd the main server with runs created by examples.\nmyrun = run.publish()\n</pre> task = openml.tasks.get_task(403) clf = neighbors.KNeighborsClassifier(n_neighbors=5) openml.config.start_using_configuration_for_example()  run = openml.runs.run_model_on_task(clf, task, avoid_duplicate_runs=False) # Publish the experiment on OpenML (optional, requires an API key). # For this tutorial, our configuration publishes to the test server # as to not crowd the main server with runs created by examples. myrun = run.publish() In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/20_basic/introduction_tutorial/#introduction-tutorial-setup","title":"Introduction tutorial &amp; Setup\u00b6","text":"<p>An example how to set up OpenML-Python followed up by a simple example.</p>"},{"location":"examples/20_basic/introduction_tutorial/#installation","title":"Installation\u00b6","text":"<p>Installation is done via <code>pip</code>:</p> <pre>pip install openml\n</pre>"},{"location":"examples/20_basic/introduction_tutorial/#authentication","title":"Authentication\u00b6","text":"<p>The OpenML server can only be accessed by users who have signed up on the OpenML platform. If you don\u2019t have an account yet, sign up now. You will receive an API key, which will authenticate you to the server and allow you to download and upload datasets, tasks, runs and flows.</p> <ul> <li>Create an OpenML account (free) on https://www.openml.org.</li> <li>After logging in, open your account page (avatar on the top right)</li> <li>Open 'Account Settings', then 'API authentication' to find your API key.</li> </ul> <p>There are two ways to permanently authenticate:</p> <ul> <li>Use the <code>openml</code> CLI tool with <code>openml configure apikey MYKEY</code>, replacing MYKEY with your API key.</li> <li>Create a plain text file ~/.openml/config with the line 'apikey=MYKEY', replacing MYKEY with your API key. The config file must be in the directory ~/.openml/config and exist prior to importing the openml module.</li> </ul> <p>Alternatively, by running the code below and replacing 'YOURKEY' with your API key, you authenticate for the duration of the python process.</p>"},{"location":"examples/20_basic/introduction_tutorial/#caching","title":"Caching\u00b6","text":"<p>When downloading datasets, tasks, runs and flows, they will be cached to retrieve them without calling the server later. As with the API key, the cache directory can be either specified through the config file or through the API:</p> <ul> <li>Add the  line cachedir = 'MYDIR' to the config file, replacing 'MYDIR' with the path to the cache directory. By default, OpenML will use ~/.openml/cache as the cache directory.</li> <li>Run the code below, replacing 'YOURDIR' with the path to the cache directory.</li> </ul>"},{"location":"examples/20_basic/introduction_tutorial/#simple-example","title":"Simple Example\u00b6","text":"<p>Download the OpenML task for the eeg-eye-state.</p>"},{"location":"examples/20_basic/simple_datasets_tutorial/","title":"Datasets","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\n</pre>  import openml In\u00a0[\u00a0]: Copied! <pre>datasets_df = openml.datasets.list_datasets(output_format=\"dataframe\")\nprint(datasets_df.head(n=10))\n</pre> datasets_df = openml.datasets.list_datasets(output_format=\"dataframe\") print(datasets_df.head(n=10)) In\u00a0[\u00a0]: Copied! <pre># Iris dataset https://www.openml.org/d/61\ndataset = openml.datasets.get_dataset(dataset_id=61, version=1)\n\n# Print a summary\nprint(\n    f\"This is dataset '{dataset.name}', the target feature is \"\n    f\"'{dataset.default_target_attribute}'\"\n)\nprint(f\"URL: {dataset.url}\")\nprint(dataset.description[:500])\n</pre> # Iris dataset https://www.openml.org/d/61 dataset = openml.datasets.get_dataset(dataset_id=61, version=1)  # Print a summary print(     f\"This is dataset '{dataset.name}', the target feature is \"     f\"'{dataset.default_target_attribute}'\" ) print(f\"URL: {dataset.url}\") print(dataset.description[:500]) In\u00a0[\u00a0]: Copied! <pre>X, y, categorical_indicator, attribute_names = dataset.get_data(\n    target=dataset.default_target_attribute\n)\n</pre> X, y, categorical_indicator, attribute_names = dataset.get_data(     target=dataset.default_target_attribute ) <p>Visualize the dataset</p> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; docs/mkdoc -- Incoming Change</p> In\u00a0[\u00a0]: Copied! <pre>=======\nimport matplotlib.pyplot as plt\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop -- Current Change\nimport pandas as pd\nimport seaborn as sns\n\nsns.set_style(\"darkgrid\")\n\n\ndef hide_current_axis(*args, **kwds):\n    plt.gca().set_visible(False)\n\n\n# We combine all the data so that we can map the different\n# examples to different colors according to the classes.\ncombined_data = pd.concat([X, y], axis=1)\niris_plot = sns.pairplot(combined_data, hue=\"class\")\niris_plot.map_upper(hide_current_axis)\nplt.show()\n\n# License: BSD 3-Clause\n</pre> ======= import matplotlib.pyplot as plt &gt;&gt;&gt;&gt;&gt;&gt;&gt; develop -- Current Change import pandas as pd import seaborn as sns  sns.set_style(\"darkgrid\")   def hide_current_axis(*args, **kwds):     plt.gca().set_visible(False)   # We combine all the data so that we can map the different # examples to different colors according to the classes. combined_data = pd.concat([X, y], axis=1) iris_plot = sns.pairplot(combined_data, hue=\"class\") iris_plot.map_upper(hide_current_axis) plt.show()  # License: BSD 3-Clause"},{"location":"examples/20_basic/simple_datasets_tutorial/#datasets","title":"Datasets\u00b6","text":"<p>A basic tutorial on how to list, load and visualize datasets.</p> <p>In general, we recommend working with tasks, so that the results can be easily reproduced. Furthermore, the results can be compared to existing results at OpenML. However, for the purposes of this tutorial, we are going to work with the datasets directly.</p>"},{"location":"examples/20_basic/simple_datasets_tutorial/#list-datasets","title":"List datasets\u00b6","text":""},{"location":"examples/20_basic/simple_datasets_tutorial/#download-a-dataset","title":"Download a dataset\u00b6","text":""},{"location":"examples/20_basic/simple_datasets_tutorial/#load-a-dataset","title":"Load a dataset\u00b6","text":"<p>X - An array/dataframe where each row represents one example with the corresponding feature values.</p> <p>y - the classes for each example</p> <p>categorical_indicator - an array that indicates which feature is categorical</p> <p>attribute_names - the names of the features for the examples (X) and target feature (y)</p>"},{"location":"examples/20_basic/simple_flows_and_runs_tutorial/","title":"Flows and Runs","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\nfrom sklearn import ensemble, neighbors\n\nfrom openml.utils import thread_safe_if_oslo_installed\n</pre> import openml from sklearn import ensemble, neighbors  from openml.utils import thread_safe_if_oslo_installed <p>Warning</p> <p>         This example uploads data. For that reason, this example connects to the         test server at test.openml.org.         This prevents the main server from becoming overloaded with example datasets, tasks,         runs, and other submissions.         Using this test server may affect the behavior and performance of the         OpenML-Python API.     </p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() In\u00a0[\u00a0]: Copied! <pre>dataset = openml.datasets.get_dataset(20)\nX, y, categorical_indicator, attribute_names = dataset.get_data(\n    dataset_format=\"dataframe\", target=dataset.default_target_attribute\n)\nif y is None:\n    y = X[\"class\"]\n    X = X.drop(columns=[\"class\"], axis=1)\nclf = neighbors.KNeighborsClassifier(n_neighbors=3)\nclf.fit(X, y)\n</pre> dataset = openml.datasets.get_dataset(20) X, y, categorical_indicator, attribute_names = dataset.get_data(     dataset_format=\"dataframe\", target=dataset.default_target_attribute ) if y is None:     y = X[\"class\"]     X = X.drop(columns=[\"class\"], axis=1) clf = neighbors.KNeighborsClassifier(n_neighbors=3) clf.fit(X, y) In\u00a0[\u00a0]: Copied! <pre>task = openml.tasks.get_task(119)\n\nclf = ensemble.RandomForestClassifier()\nrun = openml.runs.run_model_on_task(clf, task)\nprint(run)\n</pre> task = openml.tasks.get_task(119)  clf = ensemble.RandomForestClassifier() run = openml.runs.run_model_on_task(clf, task) print(run) In\u00a0[\u00a0]: Copied! <pre>myrun = run.publish()\nprint(f\"Run was uploaded to {myrun.openml_url}\")\nprint(f\"The flow can be found at {myrun.flow.openml_url}\")\n</pre> myrun = run.publish() print(f\"Run was uploaded to {myrun.openml_url}\") print(f\"The flow can be found at {myrun.flow.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/20_basic/simple_flows_and_runs_tutorial/#flows-and-runs","title":"Flows and Runs\u00b6","text":"<p>A simple tutorial on how to train/run a model and how to upload the results.</p>"},{"location":"examples/20_basic/simple_flows_and_runs_tutorial/#train-a-machine-learning-model","title":"Train a machine learning model\u00b6","text":"<p>NOTE: We are using dataset 20 from the test server: https://test.openml.org/d/20</p>"},{"location":"examples/20_basic/simple_flows_and_runs_tutorial/#running-a-model-on-a-task","title":"Running a model on a task\u00b6","text":""},{"location":"examples/20_basic/simple_flows_and_runs_tutorial/#publishing-the-run","title":"Publishing the run\u00b6","text":""},{"location":"examples/20_basic/simple_suites_tutorial/","title":"Benchmark suites","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\n</pre> import openml In\u00a0[\u00a0]: Copied! <pre>suite = openml.study.get_suite(99)\nprint(suite)\n</pre> suite = openml.study.get_suite(99) print(suite) <p>The benchmark suite does not download the included tasks and datasets itself, but only contains a list of which tasks constitute the study.</p> <p>Tasks can then be accessed via</p> In\u00a0[\u00a0]: Copied! <pre>tasks = suite.tasks\nprint(tasks)\n</pre> tasks = suite.tasks print(tasks) <p>and iterated over for benchmarking. For speed reasons we only iterate over the first three tasks:</p> In\u00a0[\u00a0]: Copied! <pre>for task_id in tasks[:3]:\n    task = openml.tasks.get_task(task_id)\n    print(task)\n</pre> for task_id in tasks[:3]:     task = openml.tasks.get_task(task_id)     print(task)"},{"location":"examples/20_basic/simple_suites_tutorial/#benchmark-suites","title":"Benchmark suites\u00b6","text":"<p>This is a brief showcase of OpenML benchmark suites, which were introduced by Bischl et al. (2019). Benchmark suites standardize the datasets and splits to be used in an experiment or paper. They are fully integrated into OpenML and simplify both the sharing of the setup and the results.</p>"},{"location":"examples/20_basic/simple_suites_tutorial/#openml-cc18","title":"OpenML-CC18\u00b6","text":"<p>As an example we have a look at the OpenML-CC18, which is a suite of 72 classification datasets from OpenML which were carefully selected to be usable by many algorithms and also represent datasets commonly used in machine learning research. These are all datasets from mid-2018 that satisfy a large set of clear requirements for thorough yet practical benchmarking:</p> <ol> <li>the number of observations are between 500 and 100,000 to focus on medium-sized datasets,</li> <li>the number of features does not exceed 5,000 features to keep the runtime of the algorithms low</li> <li>the target attribute has at least two classes with no class having less than 20 observations</li> <li>the ratio of the minority class and the majority class is above 0.05 (to eliminate highly imbalanced datasets which require special treatment for both algorithms and evaluation measures).</li> </ol> <p>A full description can be found in the OpenML benchmarking docs.</p> <p>In this example we'll focus on how to use benchmark suites in practice.</p>"},{"location":"examples/20_basic/simple_suites_tutorial/#downloading-benchmark-suites","title":"Downloading benchmark suites\u00b6","text":""},{"location":"examples/20_basic/simple_suites_tutorial/#further-examples","title":"Further examples\u00b6","text":"<ul> <li>Suites Tutorial</li> <li>Study Tutoral</li> <li>Paper example: Strang et al.</li> </ul> <p>License: BSD 3-Clause</p>"},{"location":"examples/30_extended/benchmark_with_optunahub/","title":"Prepare for preprocessors and an OpenML task","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline <p>Please make sure to install the dependencies with: <code>pip install \"openml&gt;=0.15.1\" plotly</code> Then we import all the necessary modules.</p> In\u00a0[\u00a0]: Copied! <pre># License: BSD 3-Clause\n\nimport logging\n\nimport optuna\n\nimport openml\nfrom openml.extensions.sklearn import cat\nfrom openml.extensions.sklearn import cont\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import OneHotEncoder\n\n\nlogger = logging.Logger(name=\"Experiment Logger\", level=1)\n\n# Set your openml api key if you want to upload your results to OpenML (eg:\n# https://openml.org/search?type=run&amp;sort=date) . To get one, simply make an\n# account (you don't need one for anything else, just to upload your results),\n# go to your profile and select the API-KEY.\n# Or log in, and navigate to https://www.openml.org/auth/api-key\nopenml.config.apikey = \"\"\n</pre> # License: BSD 3-Clause  import logging  import optuna  import openml from openml.extensions.sklearn import cat from openml.extensions.sklearn import cont from sklearn.compose import ColumnTransformer from sklearn.ensemble import RandomForestClassifier from sklearn.impute import SimpleImputer from sklearn.pipeline import Pipeline from sklearn.preprocessing import OneHotEncoder   logger = logging.Logger(name=\"Experiment Logger\", level=1)  # Set your openml api key if you want to upload your results to OpenML (eg: # https://openml.org/search?type=run&amp;sort=date) . To get one, simply make an # account (you don't need one for anything else, just to upload your results), # go to your profile and select the API-KEY. # Or log in, and navigate to https://www.openml.org/auth/api-key openml.config.apikey = \"\" In\u00a0[\u00a0]: Copied! <pre># OpenML contains several key concepts which it needs to make machine learning research shareable.\n# A machine learning experiment consists of one or several runs, which describe the performance of\n# an algorithm (called a flow in OpenML), its hyperparameter settings (called a setup) on a task.\n# A Task is the combination of a dataset, a split and an evaluation metric We choose a dataset from\n# OpenML, (https://www.openml.org/d/1464) and a subsequent task (https://www.openml.org/t/10101) To\n# make your own dataset and task, please refer to\n# https://openml.github.io/openml-python/main/examples/30_extended/create_upload_tutorial.html\n\n# https://www.openml.org/search?type=study&amp;study_type=task&amp;id=218\ntask_id = 10101\nseed = 42\ncategorical_preproc = (\n    \"categorical\",\n    OneHotEncoder(sparse_output=False, handle_unknown=\"ignore\"),\n    cat,\n)\nnumerical_preproc = (\"numerical\", SimpleImputer(strategy=\"median\"), cont)\npreproc = ColumnTransformer([categorical_preproc, numerical_preproc])\n</pre> # OpenML contains several key concepts which it needs to make machine learning research shareable. # A machine learning experiment consists of one or several runs, which describe the performance of # an algorithm (called a flow in OpenML), its hyperparameter settings (called a setup) on a task. # A Task is the combination of a dataset, a split and an evaluation metric We choose a dataset from # OpenML, (https://www.openml.org/d/1464) and a subsequent task (https://www.openml.org/t/10101) To # make your own dataset and task, please refer to # https://openml.github.io/openml-python/main/examples/30_extended/create_upload_tutorial.html  # https://www.openml.org/search?type=study&amp;study_type=task&amp;id=218 task_id = 10101 seed = 42 categorical_preproc = (     \"categorical\",     OneHotEncoder(sparse_output=False, handle_unknown=\"ignore\"),     cat, ) numerical_preproc = (\"numerical\", SimpleImputer(strategy=\"median\"), cont) preproc = ColumnTransformer([categorical_preproc, numerical_preproc]) In\u00a0[\u00a0]: Copied! <pre># Optuna explanation\n# we follow the `Optuna &lt;https://github.com/optuna/optuna/&gt;`__ search space design.\n\n# OpenML runs\n# We can simply pass the parametrized classifier to `run_model_on_task` to obtain the performance\n# of the pipeline\n# on the specified OpenML task.\n# Do you want to share your results along with an easily reproducible pipeline, you can set an API\n# key and just upload your results.\n# You can find more examples on https://www.openml.org/\n\n\ndef objective(trial: optuna.Trial) -&gt; Pipeline:\n    clf = RandomForestClassifier(\n        max_depth=trial.suggest_int(\"max_depth\", 2, 32, log=True),\n        min_samples_leaf=trial.suggest_float(\"min_samples_leaf\", 0.0, 1.0),\n        random_state=seed,\n    )\n    pipe = Pipeline(steps=[(\"preproc\", preproc), (\"model\", clf)])\n    logger.log(1, f\"Running pipeline - {pipe}\")\n    run = openml.runs.run_model_on_task(pipe, task=task_id, avoid_duplicate_runs=False)\n\n    logger.log(1, f\"Model has been trained - {run}\")\n    if openml.config.apikey != \"\":\n        try:\n            run.publish()\n\n            logger.log(1, f\"Run was uploaded to - {run.openml_url}\")\n        except Exception as e:\n            logger.log(1, f\"Could not publish run - {e}\")\n    else:\n        logger.log(\n            0,\n            \"If you want to publish your results to OpenML, please set an apikey\",\n        )\n    accuracy = max(run.fold_evaluations[\"predictive_accuracy\"][0].values())\n    logger.log(0, f\"Accuracy {accuracy}\")\n\n    return accuracy\n</pre> # Optuna explanation # we follow the `Optuna `__ search space design.  # OpenML runs # We can simply pass the parametrized classifier to `run_model_on_task` to obtain the performance # of the pipeline # on the specified OpenML task. # Do you want to share your results along with an easily reproducible pipeline, you can set an API # key and just upload your results. # You can find more examples on https://www.openml.org/   def objective(trial: optuna.Trial) -&gt; Pipeline:     clf = RandomForestClassifier(         max_depth=trial.suggest_int(\"max_depth\", 2, 32, log=True),         min_samples_leaf=trial.suggest_float(\"min_samples_leaf\", 0.0, 1.0),         random_state=seed,     )     pipe = Pipeline(steps=[(\"preproc\", preproc), (\"model\", clf)])     logger.log(1, f\"Running pipeline - {pipe}\")     run = openml.runs.run_model_on_task(pipe, task=task_id, avoid_duplicate_runs=False)      logger.log(1, f\"Model has been trained - {run}\")     if openml.config.apikey != \"\":         try:             run.publish()              logger.log(1, f\"Run was uploaded to - {run.openml_url}\")         except Exception as e:             logger.log(1, f\"Could not publish run - {e}\")     else:         logger.log(             0,             \"If you want to publish your results to OpenML, please set an apikey\",         )     accuracy = max(run.fold_evaluations[\"predictive_accuracy\"][0].values())     logger.log(0, f\"Accuracy {accuracy}\")      return accuracy  In\u00a0[\u00a0]: Copied! <pre>study = optuna.create_study(direction=\"maximize\")\nlogger.log(0, f\"Study {study}\")\nstudy.optimize(objective, n_trials=15)\n</pre> study = optuna.create_study(direction=\"maximize\") logger.log(0, f\"Study {study}\") study.optimize(objective, n_trials=15) In\u00a0[\u00a0]: Copied! <pre>fig = optuna.visualization.plot_optimization_history(study)\nfig.show()\n</pre> fig = optuna.visualization.plot_optimization_history(study) fig.show()"},{"location":"examples/30_extended/benchmark_with_optunahub/#hyperparameter-optimization-benchmark-with-optunahub","title":"==================================================== Hyperparameter Optimization Benchmark with OptunaHub\u00b6","text":"<p>In this tutorial, we walk through how to conduct hyperparameter optimization experiments using OpenML and OptunaHub.</p>"},{"location":"examples/30_extended/benchmark_with_optunahub/#prepare-for-preprocessors-and-an-openml-task","title":"Prepare for preprocessors and an OpenML task\u00b6","text":""},{"location":"examples/30_extended/benchmark_with_optunahub/#define-a-pipeline-for-the-hyperparameter-optimization-this-is-standark-for-optuna","title":"Define a pipeline for the hyperparameter optimization (this is standark for Optuna)\u00b6","text":""},{"location":"examples/30_extended/benchmark_with_optunahub/#optimize-the-pipeline","title":"Optimize the pipeline\u00b6","text":""},{"location":"examples/30_extended/benchmark_with_optunahub/#visualize-the-optimization-history","title":"Visualize the optimization history\u00b6","text":""},{"location":"examples/30_extended/configure_logging/","title":"Logging","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\n\nopenml.datasets.get_dataset(\"iris\", version=1)\n</pre> import openml  openml.datasets.get_dataset(\"iris\", version=1) <p>With default configuration, the above example will show no output to console. However, in your cache directory you should find a file named 'openml_python.log', which has a DEBUG message written to it. It should be either like \"[DEBUG] [10:46:19:openml.datasets.dataset] Saved dataset 61: iris to file ...\" or like \"[DEBUG] [10:49:38:openml.datasets.dataset] Data pickle file already exists and is up to date.\" , depending on whether or not you had downloaded iris before. The processed log levels can be configured programmatically:</p> In\u00a0[\u00a0]: Copied! <pre>import logging\n\nopenml.config.set_console_log_level(logging.DEBUG)\nopenml.config.set_file_log_level(logging.WARNING)\nopenml.datasets.get_dataset(\"iris\", version=1)\n</pre> import logging  openml.config.set_console_log_level(logging.DEBUG) openml.config.set_file_log_level(logging.WARNING) openml.datasets.get_dataset(\"iris\", version=1) <p>Now the log level that was previously written to file should also be shown in the console. The message is now no longer written to file as the <code>file_log</code> was set to level <code>WARNING</code>.</p> <p>It is also possible to specify the desired log levels through the configuration file. This way you will not need to set them on each script separately. Add the  line verbosity = NUMBER and/or file_verbosity = NUMBER to the config file, where 'NUMBER' should be one of:</p> <ul> <li>0: <code>logging.WARNING</code> and up.</li> <li>1: <code>logging.INFO</code> and up.</li> <li>2: <code>logging.DEBUG</code> and up (i.e. all messages).</li> </ul> <p>License: BSD 3-Clause</p>"},{"location":"examples/30_extended/configure_logging/#logging","title":"Logging\u00b6","text":"<p>This tutorial explains openml-python logging, and shows how to configure it. Openml-python uses the Python logging module to provide users with log messages. Each log message is assigned a level of importance, see the table in Python's logging tutorial here.</p> <p>By default, openml-python will print log messages of level <code>WARNING</code> and above to console. All log messages (including <code>DEBUG</code> and <code>INFO</code>) are also saved in a file, which can be found in your cache directory (see also the introduction tutorial. These file logs are automatically deleted if needed, and use at most 2MB of space.</p> <p>It is possible to configure what log levels to send to console and file. When downloading a dataset from OpenML, a <code>DEBUG</code>-level message is written:</p>"},{"location":"examples/30_extended/create_upload_tutorial/","title":"Dataset upload tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport sklearn.datasets\nfrom scipy.sparse import coo_matrix\n\nimport openml\nfrom openml.datasets.functions import create_dataset\n</pre> import numpy as np import pandas as pd import sklearn.datasets from scipy.sparse import coo_matrix  import openml from openml.datasets.functions import create_dataset <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() <p>Below we will cover the following cases of the dataset object:</p> <ul> <li>A numpy array</li> <li>A list</li> <li>A pandas dataframe</li> <li>A sparse matrix</li> <li>A pandas sparse dataframe</li> </ul> In\u00a0[\u00a0]: Copied! <pre>diabetes = sklearn.datasets.load_diabetes()\nname = \"Diabetes(scikit-learn)\"\nX = diabetes.data\ny = diabetes.target\nattribute_names = diabetes.feature_names\ndescription = diabetes.DESCR\n</pre> diabetes = sklearn.datasets.load_diabetes() name = \"Diabetes(scikit-learn)\" X = diabetes.data y = diabetes.target attribute_names = diabetes.feature_names description = diabetes.DESCR <p>OpenML does not distinguish between the attributes and targets on the data level and stores all data in a single matrix.</p> <p>The target feature is indicated as meta-data of the dataset (and tasks on that data).</p> In\u00a0[\u00a0]: Copied! <pre>data = np.concatenate((X, y.reshape((-1, 1))), axis=1)\nattribute_names = list(attribute_names)\nattributes = [(attribute_name, \"REAL\") for attribute_name in attribute_names] + [\n    (\"class\", \"INTEGER\")\n]\ncitation = (\n    \"Bradley Efron, Trevor Hastie, Iain Johnstone and \"\n    \"Robert Tibshirani (2004) (Least Angle Regression) \"\n    \"Annals of Statistics (with discussion), 407-499\"\n)\npaper_url = \"https://web.stanford.edu/~hastie/Papers/LARS/LeastAngle_2002.pdf\"\n</pre> data = np.concatenate((X, y.reshape((-1, 1))), axis=1) attribute_names = list(attribute_names) attributes = [(attribute_name, \"REAL\") for attribute_name in attribute_names] + [     (\"class\", \"INTEGER\") ] citation = (     \"Bradley Efron, Trevor Hastie, Iain Johnstone and \"     \"Robert Tibshirani (2004) (Least Angle Regression) \"     \"Annals of Statistics (with discussion), 407-499\" ) paper_url = \"https://web.stanford.edu/~hastie/Papers/LARS/LeastAngle_2002.pdf\" In\u00a0[\u00a0]: Copied! <pre>diabetes_dataset = create_dataset(\n    # The name of the dataset (needs to be unique).\n    # Must not be longer than 128 characters and only contain\n    # a-z, A-Z, 0-9 and the following special characters: _\\-\\.(),\n    name=name,\n    # Textual description of the dataset.\n    description=description,\n    # The person who created the dataset.\n    creator=\"Bradley Efron, Trevor Hastie, Iain Johnstone and Robert Tibshirani\",\n    # People who contributed to the current version of the dataset.\n    contributor=None,\n    # The date the data was originally collected, given by the uploader.\n    collection_date=\"09-01-2012\",\n    # Language in which the data is represented.\n    # Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    language=\"English\",\n    # License under which the data is/will be distributed.\n    licence=\"BSD (from scikit-learn)\",\n    # Name of the target. Can also have multiple values (comma-separated).\n    default_target_attribute=\"class\",\n    # The attribute that represents the row-id column, if present in the\n    # dataset.\n    row_id_attribute=None,\n    # Attribute or list of attributes that should be excluded in modelling, such as\n    # identifiers and indexes. E.g. \"feat1\" or [\"feat1\",\"feat2\"]\n    ignore_attribute=None,\n    # How to cite the paper.\n    citation=citation,\n    # Attributes of the data\n    attributes=attributes,\n    data=data,\n    # A version label which is provided by the user.\n    version_label=\"test\",\n    original_data_url=\"https://www4.stat.ncsu.edu/~boos/var.select/diabetes.html\",\n    paper_url=paper_url,\n)\n</pre> diabetes_dataset = create_dataset(     # The name of the dataset (needs to be unique).     # Must not be longer than 128 characters and only contain     # a-z, A-Z, 0-9 and the following special characters: _\\-\\.(),     name=name,     # Textual description of the dataset.     description=description,     # The person who created the dataset.     creator=\"Bradley Efron, Trevor Hastie, Iain Johnstone and Robert Tibshirani\",     # People who contributed to the current version of the dataset.     contributor=None,     # The date the data was originally collected, given by the uploader.     collection_date=\"09-01-2012\",     # Language in which the data is represented.     # Starts with 1 upper case letter, rest lower case, e.g. 'English'.     language=\"English\",     # License under which the data is/will be distributed.     licence=\"BSD (from scikit-learn)\",     # Name of the target. Can also have multiple values (comma-separated).     default_target_attribute=\"class\",     # The attribute that represents the row-id column, if present in the     # dataset.     row_id_attribute=None,     # Attribute or list of attributes that should be excluded in modelling, such as     # identifiers and indexes. E.g. \"feat1\" or [\"feat1\",\"feat2\"]     ignore_attribute=None,     # How to cite the paper.     citation=citation,     # Attributes of the data     attributes=attributes,     data=data,     # A version label which is provided by the user.     version_label=\"test\",     original_data_url=\"https://www4.stat.ncsu.edu/~boos/var.select/diabetes.html\",     paper_url=paper_url, ) In\u00a0[\u00a0]: Copied! <pre>diabetes_dataset.publish()\nprint(f\"URL for dataset: {diabetes_dataset.openml_url}\")\n</pre>  diabetes_dataset.publish() print(f\"URL for dataset: {diabetes_dataset.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>data = [\n    [\"sunny\", 85, 85, \"FALSE\", \"no\"],\n    [\"sunny\", 80, 90, \"TRUE\", \"no\"],\n    [\"overcast\", 83, 86, \"FALSE\", \"yes\"],\n    [\"rainy\", 70, 96, \"FALSE\", \"yes\"],\n    [\"rainy\", 68, 80, \"FALSE\", \"yes\"],\n    [\"rainy\", 65, 70, \"TRUE\", \"no\"],\n    [\"overcast\", 64, 65, \"TRUE\", \"yes\"],\n    [\"sunny\", 72, 95, \"FALSE\", \"no\"],\n    [\"sunny\", 69, 70, \"FALSE\", \"yes\"],\n    [\"rainy\", 75, 80, \"FALSE\", \"yes\"],\n    [\"sunny\", 75, 70, \"TRUE\", \"yes\"],\n    [\"overcast\", 72, 90, \"TRUE\", \"yes\"],\n    [\"overcast\", 81, 75, \"FALSE\", \"yes\"],\n    [\"rainy\", 71, 91, \"TRUE\", \"no\"],\n]\n\nattribute_names = [\n    (\"outlook\", [\"sunny\", \"overcast\", \"rainy\"]),\n    (\"temperature\", \"REAL\"),\n    (\"humidity\", \"REAL\"),\n    (\"windy\", [\"TRUE\", \"FALSE\"]),\n    (\"play\", [\"yes\", \"no\"]),\n]\n\ndescription = (\n    \"The weather problem is a tiny dataset that we will use repeatedly\"\n    \" to illustrate machine learning methods. Entirely fictitious, it \"\n    \"supposedly concerns the conditions that are suitable for playing \"\n    \"some unspecified game. In general, instances in a dataset are \"\n    \"characterized by the values of features, or attributes, that measure \"\n    \"different aspects of the instance. In this case there are four \"\n    \"attributes: outlook, temperature, humidity, and windy. \"\n    \"The outcome is whether to play or not.\"\n)\n\ncitation = (\n    \"I. H. Witten, E. Frank, M. A. Hall, and ITPro,\"\n    \"Data mining practical machine learning tools and techniques, \"\n    \"third edition. Burlington, Mass.: Morgan Kaufmann Publishers, 2011\"\n)\n\nweather_dataset = create_dataset(\n    name=\"Weather\",\n    description=description,\n    creator=\"I. H. Witten, E. Frank, M. A. Hall, and ITPro\",\n    contributor=None,\n    collection_date=\"01-01-2011\",\n    language=\"English\",\n    licence=None,\n    default_target_attribute=\"play\",\n    row_id_attribute=None,\n    ignore_attribute=None,\n    citation=citation,\n    attributes=attribute_names,\n    data=data,\n    version_label=\"example\",\n)\n</pre> data = [     [\"sunny\", 85, 85, \"FALSE\", \"no\"],     [\"sunny\", 80, 90, \"TRUE\", \"no\"],     [\"overcast\", 83, 86, \"FALSE\", \"yes\"],     [\"rainy\", 70, 96, \"FALSE\", \"yes\"],     [\"rainy\", 68, 80, \"FALSE\", \"yes\"],     [\"rainy\", 65, 70, \"TRUE\", \"no\"],     [\"overcast\", 64, 65, \"TRUE\", \"yes\"],     [\"sunny\", 72, 95, \"FALSE\", \"no\"],     [\"sunny\", 69, 70, \"FALSE\", \"yes\"],     [\"rainy\", 75, 80, \"FALSE\", \"yes\"],     [\"sunny\", 75, 70, \"TRUE\", \"yes\"],     [\"overcast\", 72, 90, \"TRUE\", \"yes\"],     [\"overcast\", 81, 75, \"FALSE\", \"yes\"],     [\"rainy\", 71, 91, \"TRUE\", \"no\"], ]  attribute_names = [     (\"outlook\", [\"sunny\", \"overcast\", \"rainy\"]),     (\"temperature\", \"REAL\"),     (\"humidity\", \"REAL\"),     (\"windy\", [\"TRUE\", \"FALSE\"]),     (\"play\", [\"yes\", \"no\"]), ]  description = (     \"The weather problem is a tiny dataset that we will use repeatedly\"     \" to illustrate machine learning methods. Entirely fictitious, it \"     \"supposedly concerns the conditions that are suitable for playing \"     \"some unspecified game. In general, instances in a dataset are \"     \"characterized by the values of features, or attributes, that measure \"     \"different aspects of the instance. In this case there are four \"     \"attributes: outlook, temperature, humidity, and windy. \"     \"The outcome is whether to play or not.\" )  citation = (     \"I. H. Witten, E. Frank, M. A. Hall, and ITPro,\"     \"Data mining practical machine learning tools and techniques, \"     \"third edition. Burlington, Mass.: Morgan Kaufmann Publishers, 2011\" )  weather_dataset = create_dataset(     name=\"Weather\",     description=description,     creator=\"I. H. Witten, E. Frank, M. A. Hall, and ITPro\",     contributor=None,     collection_date=\"01-01-2011\",     language=\"English\",     licence=None,     default_target_attribute=\"play\",     row_id_attribute=None,     ignore_attribute=None,     citation=citation,     attributes=attribute_names,     data=data,     version_label=\"example\", ) In\u00a0[\u00a0]: Copied! <pre>weather_dataset.publish()\nprint(f\"URL for dataset: {weather_dataset.openml_url}\")\n</pre> weather_dataset.publish() print(f\"URL for dataset: {weather_dataset.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>df = pd.DataFrame(data, columns=[col_name for col_name, _ in attribute_names])\n\n# enforce the categorical column to have a categorical dtype\ndf[\"outlook\"] = df[\"outlook\"].astype(\"category\")\ndf[\"windy\"] = df[\"windy\"].astype(\"bool\")\ndf[\"play\"] = df[\"play\"].astype(\"category\")\nprint(df.info())\n</pre> df = pd.DataFrame(data, columns=[col_name for col_name, _ in attribute_names])  # enforce the categorical column to have a categorical dtype df[\"outlook\"] = df[\"outlook\"].astype(\"category\") df[\"windy\"] = df[\"windy\"].astype(\"bool\") df[\"play\"] = df[\"play\"].astype(\"category\") print(df.info()) <p>We enforce the column 'outlook' and 'play' to be a categorical dtype while the column 'windy' is kept as a boolean column. 'temperature' and 'humidity' are kept as numeric columns. Then, we can call :func:<code>openml.datasets.create_dataset</code> by passing the dataframe and fixing the parameter <code>attributes</code> to <code>'auto'</code>.</p> In\u00a0[\u00a0]: Copied! <pre>weather_dataset = create_dataset(\n    name=\"Weather\",\n    description=description,\n    creator=\"I. H. Witten, E. Frank, M. A. Hall, and ITPro\",\n    contributor=None,\n    collection_date=\"01-01-2011\",\n    language=\"English\",\n    licence=None,\n    default_target_attribute=\"play\",\n    row_id_attribute=None,\n    ignore_attribute=None,\n    citation=citation,\n    attributes=\"auto\",\n    data=df,\n    version_label=\"example\",\n)\n</pre> weather_dataset = create_dataset(     name=\"Weather\",     description=description,     creator=\"I. H. Witten, E. Frank, M. A. Hall, and ITPro\",     contributor=None,     collection_date=\"01-01-2011\",     language=\"English\",     licence=None,     default_target_attribute=\"play\",     row_id_attribute=None,     ignore_attribute=None,     citation=citation,     attributes=\"auto\",     data=df,     version_label=\"example\", ) In\u00a0[\u00a0]: Copied! <pre>weather_dataset.publish()\nprint(f\"URL for dataset: {weather_dataset.openml_url}\")\n</pre> weather_dataset.publish() print(f\"URL for dataset: {weather_dataset.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>sparse_data = coo_matrix(\n    ([0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], ([0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1]))\n)\n\ncolumn_names = [\n    (\"input1\", \"REAL\"),\n    (\"input2\", \"REAL\"),\n    (\"y\", \"REAL\"),\n]\n\nxor_dataset = create_dataset(\n    name=\"XOR\",\n    description=\"Dataset representing the XOR operation\",\n    creator=None,\n    contributor=None,\n    collection_date=None,\n    language=\"English\",\n    licence=None,\n    default_target_attribute=\"y\",\n    row_id_attribute=None,\n    ignore_attribute=None,\n    citation=None,\n    attributes=column_names,\n    data=sparse_data,\n    version_label=\"example\",\n)\n</pre> sparse_data = coo_matrix(     ([0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], ([0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1])) )  column_names = [     (\"input1\", \"REAL\"),     (\"input2\", \"REAL\"),     (\"y\", \"REAL\"), ]  xor_dataset = create_dataset(     name=\"XOR\",     description=\"Dataset representing the XOR operation\",     creator=None,     contributor=None,     collection_date=None,     language=\"English\",     licence=None,     default_target_attribute=\"y\",     row_id_attribute=None,     ignore_attribute=None,     citation=None,     attributes=column_names,     data=sparse_data,     version_label=\"example\", ) In\u00a0[\u00a0]: Copied! <pre>xor_dataset.publish()\nprint(f\"URL for dataset: {xor_dataset.openml_url}\")\n</pre> xor_dataset.publish() print(f\"URL for dataset: {xor_dataset.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>xor_dataset.publish()\nprint(f\"URL for dataset: {xor_dataset.openml_url}\")\n</pre>  xor_dataset.publish() print(f\"URL for dataset: {xor_dataset.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/30_extended/create_upload_tutorial/#dataset-upload-tutorial","title":"Dataset upload tutorial\u00b6","text":"<p>A tutorial on how to create and upload a dataset to OpenML.</p>"},{"location":"examples/30_extended/create_upload_tutorial/#dataset-is-a-numpy-array","title":"Dataset is a numpy array\u00b6","text":"<p>A numpy array can contain lists in the case of dense data or it can contain OrderedDicts in the case of sparse data.</p>"},{"location":"examples/30_extended/create_upload_tutorial/#prepare-dataset","title":"Prepare dataset\u00b6","text":"<p>Load an example dataset from scikit-learn which we will upload to OpenML.org via the API.</p>"},{"location":"examples/30_extended/create_upload_tutorial/#create-the-dataset-object","title":"Create the dataset object\u00b6","text":"<p>The definition of all fields can be found in the XSD files describing the expected format:</p> <p>https://github.com/openml/OpenML/blob/master/openml_OS/views/pages/api_new/v1/xsd/openml.data.upload.xsd</p>"},{"location":"examples/30_extended/create_upload_tutorial/#dataset-is-a-list","title":"Dataset is a list\u00b6","text":"<p>A list can contain lists in the case of dense data or it can contain OrderedDicts in the case of sparse data.</p> <p>Weather dataset: https://storm.cis.fordham.edu/~gweiss/data-mining/datasets.html</p>"},{"location":"examples/30_extended/create_upload_tutorial/#dataset-is-a-pandas-dataframe","title":"Dataset is a pandas DataFrame\u00b6","text":"<p>It might happen that your dataset is made of heterogeneous data which can usually be stored as a Pandas DataFrame. DataFrames offer the advantage of storing the type of data for each column as well as the attribute names. Therefore, when providing a Pandas DataFrame, OpenML can infer this information without needing to explicitly provide it when calling the function :func:<code>openml.datasets.create_dataset</code>. In this regard, you only need to pass <code>'auto'</code> to the <code>attributes</code> parameter.</p>"},{"location":"examples/30_extended/create_upload_tutorial/#dataset-is-a-sparse-matrix","title":"Dataset is a sparse matrix\u00b6","text":""},{"location":"examples/30_extended/create_upload_tutorial/#dataset-is-a-pandas-dataframe-with-sparse-columns","title":"Dataset is a pandas dataframe with sparse columns\u00b6","text":"<p>sparse_data = coo_matrix( ([1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0], ([0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1])) ) column_names = [\"input1\", \"input2\", \"y\"] df = pd.DataFrame.sparse.from_spmatrix(sparse_data, columns=column_names) print(df.info())</p> <p>xor_dataset = create_dataset( name=\"XOR\", description=\"Dataset representing the XOR operation\", creator=None, contributor=None, collection_date=None, language=\"English\", licence=None, default_target_attribute=\"y\", row_id_attribute=None, ignore_attribute=None, citation=None, attributes=\"auto\", data=df, version_label=\"example\", )</p>"},{"location":"examples/30_extended/custom_flow_/","title":"Creating and Using a Custom Flow","text":"In\u00a0[\u00a0]: Copied! <pre>from collections import OrderedDict\nimport numpy as np\n\nimport openml\nfrom openml import OpenMLClassificationTask\nfrom openml.runs.functions import format_prediction\n</pre> from collections import OrderedDict import numpy as np  import openml from openml import OpenMLClassificationTask from openml.runs.functions import format_prediction <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() In\u00a0[\u00a0]: Copied! <pre>general = dict(\n    name=\"automlbenchmark_autosklearn\",\n    description=(\n        \"Auto-sklearn as set up by the AutoML Benchmark\"\n        \"Source: https://github.com/openml/automlbenchmark/releases/tag/v0.9\"\n    ),\n    external_version=\"amlb==0.9\",\n    language=\"English\",\n    tags=[\"amlb\", \"benchmark\", \"study_218\"],\n    dependencies=\"amlb==0.9\",\n)\n</pre> general = dict(     name=\"automlbenchmark_autosklearn\",     description=(         \"Auto-sklearn as set up by the AutoML Benchmark\"         \"Source: https://github.com/openml/automlbenchmark/releases/tag/v0.9\"     ),     external_version=\"amlb==0.9\",     language=\"English\",     tags=[\"amlb\", \"benchmark\", \"study_218\"],     dependencies=\"amlb==0.9\", ) <p>Next we define the flow hyperparameters. We define their name and default value in <code>parameters</code>, and provide meta-data for each hyperparameter through <code>parameters_meta_info</code>. Note that even though the argument name is <code>parameters</code> they describe the hyperparameters. The use of ordered dicts is required.</p> In\u00a0[\u00a0]: Copied! <pre>flow_hyperparameters = dict(\n    parameters=OrderedDict(time=\"240\", memory=\"32\", cores=\"8\"),\n    parameters_meta_info=OrderedDict(\n        cores=OrderedDict(description=\"number of available cores\", data_type=\"int\"),\n        memory=OrderedDict(description=\"memory in gigabytes\", data_type=\"int\"),\n        time=OrderedDict(description=\"time in minutes\", data_type=\"int\"),\n    ),\n)\n</pre> flow_hyperparameters = dict(     parameters=OrderedDict(time=\"240\", memory=\"32\", cores=\"8\"),     parameters_meta_info=OrderedDict(         cores=OrderedDict(description=\"number of available cores\", data_type=\"int\"),         memory=OrderedDict(description=\"memory in gigabytes\", data_type=\"int\"),         time=OrderedDict(description=\"time in minutes\", data_type=\"int\"),     ), ) <p>It is possible to build a flow which uses other flows. For example, the Random Forest Classifier is a flow, but you could also construct a flow which uses a Random Forest Classifier in a ML pipeline. When constructing the pipeline flow, you can use the Random Forest Classifier flow as a subflow. It allows for all hyperparameters of the Random Classifier Flow to also be specified in your pipeline flow.</p> <p>Note: you can currently only specific one subflow as part of the components.</p> <p>In this example, the auto-sklearn flow is a subflow: the auto-sklearn flow is entirely executed as part of this flow. This allows people to specify auto-sklearn hyperparameters used in this flow. In general, using a subflow is not required.</p> <p>Note: flow 9313 is not actually the right flow on the test server, but that does not matter for this demonstration.</p> In\u00a0[\u00a0]: Copied! <pre>autosklearn_flow = openml.flows.get_flow(9313)  # auto-sklearn 0.5.1\nsubflow = dict(\n    components=OrderedDict(automl_tool=autosklearn_flow),\n    # If you do not want to reference a subflow, you can use the following:\n    # components=OrderedDict(),\n)\n</pre> autosklearn_flow = openml.flows.get_flow(9313)  # auto-sklearn 0.5.1 subflow = dict(     components=OrderedDict(automl_tool=autosklearn_flow),     # If you do not want to reference a subflow, you can use the following:     # components=OrderedDict(), ) <p>With all parameters of the flow defined, we can now initialize the OpenMLFlow and publish. Because we provided all the details already, we do not need to provide a <code>model</code> to the flow.</p> <p>In our case, we don't even have a model. It is possible to have a model but still require to follow these steps when the model (python object) does not have an extensions from which to automatically extract the hyperparameters. So whether you have a model with no extension or no model at all, explicitly set the model of the flow to <code>None</code>.</p> In\u00a0[\u00a0]: Copied! <pre>autosklearn_amlb_flow = openml.flows.OpenMLFlow(\n    **general,\n    **flow_hyperparameters,\n    **subflow,\n    model=None,\n)\nautosklearn_amlb_flow.publish()\nprint(f\"autosklearn flow created: {autosklearn_amlb_flow.flow_id}\")\n</pre> autosklearn_amlb_flow = openml.flows.OpenMLFlow(     **general,     **flow_hyperparameters,     **subflow,     model=None, ) autosklearn_amlb_flow.publish() print(f\"autosklearn flow created: {autosklearn_amlb_flow.flow_id}\") In\u00a0[\u00a0]: Copied! <pre>flow_id = autosklearn_amlb_flow.flow_id\n\nparameters = [\n    OrderedDict([(\"oml:name\", \"cores\"), (\"oml:value\", 4), (\"oml:component\", flow_id)]),\n    OrderedDict([(\"oml:name\", \"memory\"), (\"oml:value\", 16), (\"oml:component\", flow_id)]),\n    OrderedDict([(\"oml:name\", \"time\"), (\"oml:value\", 120), (\"oml:component\", flow_id)]),\n]\n\ntask_id = 1200  # Iris Task\ntask = openml.tasks.get_task(task_id)\ndataset_id = task.get_dataset().dataset_id\n</pre> flow_id = autosklearn_amlb_flow.flow_id  parameters = [     OrderedDict([(\"oml:name\", \"cores\"), (\"oml:value\", 4), (\"oml:component\", flow_id)]),     OrderedDict([(\"oml:name\", \"memory\"), (\"oml:value\", 16), (\"oml:component\", flow_id)]),     OrderedDict([(\"oml:name\", \"time\"), (\"oml:value\", 120), (\"oml:component\", flow_id)]), ]  task_id = 1200  # Iris Task task = openml.tasks.get_task(task_id) dataset_id = task.get_dataset().dataset_id <p>The last bit of information for the run we need are the predicted values. The exact format of the predictions will depend on the task.</p> <p>The predictions should always be a list of lists, each list should contain:</p> <ul> <li>the repeat number: for repeated evaluation strategies. (e.g. repeated cross-validation)</li> <li>the fold number: for cross-validation. (what should this be for holdout?)</li> <li>0: this field is for backward compatibility.</li> <li>index: the row (of the original dataset) for which the prediction was made.</li> <li>p_1, ..., p_c: for each class the predicted probability of the sample belonging to that class. (no elements for regression tasks) Make sure the order of these elements follows the order of <code>task.class_labels</code>.</li> <li>the predicted class/value for the sample</li> <li>the true class/value for the sample</li> </ul> <p>When using openml-python extensions (such as through <code>run_model_on_task</code>), all of this formatting is automatic. Unfortunately we can not automate this procedure for custom flows, which means a little additional effort is required.</p> <p>Here we generated some random predictions in place. You can ignore this code, or use it to better understand the formatting of the predictions.</p> <p>Find the repeats/folds for this task:</p> In\u00a0[\u00a0]: Copied! <pre>n_repeats, n_folds, _ = task.get_split_dimensions()\nall_test_indices = [\n    (repeat, fold, index)\n    for repeat in range(n_repeats)\n    for fold in range(n_folds)\n    for index in task.get_train_test_split_indices(fold, repeat)[1]\n]\n\n# random class probabilities (Iris has 150 samples and 3 classes):\nr = np.random.rand(150 * n_repeats, 3)\n# scale the random values so that the probabilities of each sample sum to 1:\ny_proba = r / r.sum(axis=1).reshape(-1, 1)\ny_pred = y_proba.argmax(axis=1)\n\nclass_map = dict(zip(range(3), task.class_labels))\n_, y_true = task.get_X_and_y()\ny_true = [class_map[y] for y in y_true]\n\n# We format the predictions with the utility function `format_prediction`.\n# It will organize the relevant data in the expected format/order.\npredictions = []\nfor where, y, yp, proba in zip(all_test_indices, y_true, y_pred, y_proba):\n    repeat, fold, index = where\n\n    prediction = format_prediction(\n        task=task,\n        repeat=repeat,\n        fold=fold,\n        index=index,\n        prediction=class_map[yp],\n        truth=y,\n        proba={c: pb for (c, pb) in zip(task.class_labels, proba)},\n    )\n    predictions.append(prediction)\n</pre> n_repeats, n_folds, _ = task.get_split_dimensions() all_test_indices = [     (repeat, fold, index)     for repeat in range(n_repeats)     for fold in range(n_folds)     for index in task.get_train_test_split_indices(fold, repeat)[1] ]  # random class probabilities (Iris has 150 samples and 3 classes): r = np.random.rand(150 * n_repeats, 3) # scale the random values so that the probabilities of each sample sum to 1: y_proba = r / r.sum(axis=1).reshape(-1, 1) y_pred = y_proba.argmax(axis=1)  class_map = dict(zip(range(3), task.class_labels)) _, y_true = task.get_X_and_y() y_true = [class_map[y] for y in y_true]  # We format the predictions with the utility function `format_prediction`. # It will organize the relevant data in the expected format/order. predictions = [] for where, y, yp, proba in zip(all_test_indices, y_true, y_pred, y_proba):     repeat, fold, index = where      prediction = format_prediction(         task=task,         repeat=repeat,         fold=fold,         index=index,         prediction=class_map[yp],         truth=y,         proba={c: pb for (c, pb) in zip(task.class_labels, proba)},     )     predictions.append(prediction) <p>Finally we can create the OpenMLRun object and upload. We use the argument setup_string because the used flow was a script.</p> In\u00a0[\u00a0]: Copied! <pre>benchmark_command = f\"python3 runbenchmark.py auto-sklearn medium -m aws -t 119\"\nmy_run = openml.runs.OpenMLRun(\n    task_id=task_id,\n    flow_id=flow_id,\n    dataset_id=dataset_id,\n    parameter_settings=parameters,\n    setup_string=benchmark_command,\n    data_content=predictions,\n    tags=[\"study_218\"],\n    description_text=\"Run generated by the Custom Flow tutorial.\",\n)\nmy_run.publish()\nprint(\"run created:\", my_run.run_id)\n</pre> benchmark_command = f\"python3 runbenchmark.py auto-sklearn medium -m aws -t 119\" my_run = openml.runs.OpenMLRun(     task_id=task_id,     flow_id=flow_id,     dataset_id=dataset_id,     parameter_settings=parameters,     setup_string=benchmark_command,     data_content=predictions,     tags=[\"study_218\"],     description_text=\"Run generated by the Custom Flow tutorial.\", ) my_run.publish() print(\"run created:\", my_run.run_id) In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/30_extended/custom_flow_/#creating-and-using-a-custom-flow","title":"Creating and Using a Custom Flow\u00b6","text":"<p>The most convenient way to create a flow for your machine learning workflow is to generate it automatically as described in the \"Obtaining Flow IDs\" tutorial. However, there are scenarios where this is not possible, such as when the flow uses a framework without an extension or when the flow is described by a script.</p> <p>In those cases you can still create a custom flow by following the steps of this tutorial. As an example we will use the flows generated for the AutoML Benchmark, and also show how to link runs to the custom flow.</p>"},{"location":"examples/30_extended/custom_flow_/#1-defining-the-flow","title":"1. Defining the flow\u00b6","text":"<p>The first step is to define all the hyperparameters of your flow. The API pages feature a descriptions of each variable of the :class:<code>openml.flows.OpenMLFlow</code>. Note that <code>external version</code> and <code>name</code> together uniquely identify a flow.</p> <p>The AutoML Benchmark runs AutoML systems across a range of tasks. OpenML stores Flows for each AutoML system. However, the AutoML benchmark adds preprocessing to the flow, so should be described in a new flow.</p> <p>We will break down the flow arguments into several groups, for the tutorial. First we will define the name and version information. Make sure to leave enough information so others can determine exactly which version of the package/script is used. Use tags so users can find your flow easily.</p>"},{"location":"examples/30_extended/custom_flow_/#2-using-the-flow","title":"2. Using the flow\u00b6","text":"<p>This Section will show how to upload run data for your custom flow. Take care to change the values of parameters as well as the task id, to reflect the actual run. Task and parameter values in the example are fictional.</p>"},{"location":"examples/30_extended/datasets_tutorial/","title":"Datasets","text":"In\u00a0[\u00a0]: Copied! <pre>datalist[datalist.NumberOfInstances &gt; 10000].sort_values([\"NumberOfInstances\"]).head(n=20)\n</pre> datalist[datalist.NumberOfInstances &gt; 10000].sort_values([\"NumberOfInstances\"]).head(n=20) In\u00a0[\u00a0]: Copied! <pre>datalist.query('name == \"eeg-eye-state\"')\n</pre> datalist.query('name == \"eeg-eye-state\"') In\u00a0[\u00a0]: Copied! <pre>datalist.query(\"NumberOfClasses &gt; 50\")\n</pre> datalist.query(\"NumberOfClasses &gt; 50\") In\u00a0[\u00a0]: Copied! <pre># This is done based on the dataset ID.\ndataset = openml.datasets.get_dataset(dataset_id=\"eeg-eye-state\", version=1)\n\n# Print a summary\nprint(\n    f\"This is dataset '{dataset.name}', the target feature is \"\n    f\"'{dataset.default_target_attribute}'\"\n)\nprint(f\"URL: {dataset.url}\")\nprint(dataset.description[:500])\n</pre> # This is done based on the dataset ID. dataset = openml.datasets.get_dataset(dataset_id=\"eeg-eye-state\", version=1)  # Print a summary print(     f\"This is dataset '{dataset.name}', the target feature is \"     f\"'{dataset.default_target_attribute}'\" ) print(f\"URL: {dataset.url}\") print(dataset.description[:500]) <p>Get the actual data.</p> <p>openml-python returns data as pandas dataframes (stored in the <code>eeg</code> variable below), and also some additional metadata that we don't care about right now.</p> In\u00a0[\u00a0]: Copied! <pre>eeg, *_ = dataset.get_data()\n</pre> eeg, *_ = dataset.get_data() <p>You can optionally choose to have openml separate out a column from the dataset. In particular, many datasets for supervised problems have a set <code>default_target_attribute</code> which may help identify the target variable.</p> In\u00a0[\u00a0]: Copied! <pre>X, y, categorical_indicator, attribute_names = dataset.get_data(\n    target=dataset.default_target_attribute\n)\nprint(X.head())\nprint(X.info())\n</pre> X, y, categorical_indicator, attribute_names = dataset.get_data(     target=dataset.default_target_attribute ) print(X.head()) print(X.info()) <p>Sometimes you only need access to a dataset's metadata. In those cases, you can download the dataset without downloading the data file. The dataset object can be used as normal. Whenever you use any functionality that requires the data, such as <code>get_data</code>, the data will be downloaded. Starting from 0.15, not downloading data will be the default behavior instead. The data will be downloading automatically when you try to access it through openml objects, e.g., using <code>dataset.features</code>.</p> In\u00a0[\u00a0]: Copied! <pre>dataset = openml.datasets.get_dataset(1471)\n</pre> dataset = openml.datasets.get_dataset(1471) In\u00a0[\u00a0]: Copied! <pre>eegs = eeg.sample(n=1000)\n_ = pd.plotting.scatter_matrix(\n    X.iloc[:100, :4],\n    c=y[:100],\n    figsize=(10, 10),\n    marker=\"o\",\n    hist_kwds={\"bins\": 20},\n    alpha=0.8,\n    cmap=\"plasma\",\n)\n</pre> eegs = eeg.sample(n=1000) _ = pd.plotting.scatter_matrix(     X.iloc[:100, :4],     c=y[:100],     figsize=(10, 10),     marker=\"o\",     hist_kwds={\"bins\": 20},     alpha=0.8,     cmap=\"plasma\", ) In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() <p>Edit non-critical fields, allowed for all authorized users: description, creator, contributor, collection_date, language, citation, original_data_url, paper_url</p> In\u00a0[\u00a0]: Copied! <pre>desc = (\n    \"This data sets consists of 3 different types of irises' \"\n    \"(Setosa, Versicolour, and Virginica) petal and sepal length,\"\n    \" stored in a 150x4 numpy.ndarray\"\n)\ndid = 128\ndata_id = edit_dataset(\n    did,\n    description=desc,\n    creator=\"R.A.Fisher\",\n    collection_date=\"1937\",\n    citation=\"The use of multiple measurements in taxonomic problems\",\n    language=\"English\",\n)\nedited_dataset = get_dataset(data_id)\nprint(f\"Edited dataset ID: {data_id}\")\n</pre> desc = (     \"This data sets consists of 3 different types of irises' \"     \"(Setosa, Versicolour, and Virginica) petal and sepal length,\"     \" stored in a 150x4 numpy.ndarray\" ) did = 128 data_id = edit_dataset(     did,     description=desc,     creator=\"R.A.Fisher\",     collection_date=\"1937\",     citation=\"The use of multiple measurements in taxonomic problems\",     language=\"English\", ) edited_dataset = get_dataset(data_id) print(f\"Edited dataset ID: {data_id}\") <p>Editing critical fields (default_target_attribute, row_id_attribute, ignore_attribute) is allowed only for the dataset owner. Further, critical fields cannot be edited if the dataset has any tasks associated with it. To edit critical fields of a dataset (without tasks) owned by you, configure the API key: openml.config.apikey = 'FILL_IN_OPENML_API_KEY' This example here only shows a failure when trying to work on a dataset not owned by you:</p> In\u00a0[\u00a0]: Copied! <pre>try:\n    data_id = edit_dataset(1, default_target_attribute=\"shape\")\nexcept openml.exceptions.OpenMLServerException as e:\n    print(e)\n</pre> try:     data_id = edit_dataset(1, default_target_attribute=\"shape\") except openml.exceptions.OpenMLServerException as e:     print(e) In\u00a0[\u00a0]: Copied! <pre>data_id = fork_dataset(1)\nprint(data_id)\ndata_id = edit_dataset(data_id, default_target_attribute=\"shape\")\nprint(f\"Forked dataset ID: {data_id}\")\n</pre> data_id = fork_dataset(1) print(data_id) data_id = edit_dataset(data_id, default_target_attribute=\"shape\") print(f\"Forked dataset ID: {data_id}\") In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clauses\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clauses"},{"location":"examples/30_extended/datasets_tutorial/#datasets","title":"Datasets\u00b6","text":"<p>How to list and download datasets.</p> <p>import pandas as pd</p> <p>import openml from openml.datasets import edit_dataset, fork_dataset, get_dataset</p>"},{"location":"examples/30_extended/datasets_tutorial/#exercise-0","title":"Exercise 0\u00b6","text":"<ul> <li>List datasets and return a dataframe datalist = openml.datasets.list_datasets() datalist = datalist[[\"did\", \"name\", \"NumberOfInstances\", \"NumberOfFeatures\", \"NumberOfClasses\"]]</li> </ul> <p>print(f\"First 10 of {len(datalist)} datasets...\") datalist.head(n=10)</p> <p>The same can be done with lesser lines of code openml_df = openml.datasets.list_datasets() openml_df.head(n=10)</p>"},{"location":"examples/30_extended/datasets_tutorial/#exercise-1","title":"Exercise 1\u00b6","text":"<ul> <li>Find datasets with more than 10000 examples.</li> <li>Find a dataset called 'eeg_eye_state'.</li> <li>Find all datasets with more than 50 classes.</li> </ul>"},{"location":"examples/30_extended/datasets_tutorial/#download-datasets","title":"Download datasets\u00b6","text":""},{"location":"examples/30_extended/datasets_tutorial/#exercise-2","title":"Exercise 2\u00b6","text":"<ul> <li>Explore the data visually.</li> </ul>"},{"location":"examples/30_extended/datasets_tutorial/#edit-a-created-dataset","title":"Edit a created dataset\u00b6","text":"<p>This example uses the test server, to avoid editing a dataset on the main server.</p> <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p>"},{"location":"examples/30_extended/datasets_tutorial/#fork-dataset","title":"Fork dataset\u00b6","text":"<p>Used to create a copy of the dataset with you as the owner. Use this API only if you are unable to edit the critical fields (default_target_attribute, ignore_attribute, row_id_attribute) of a dataset through the edit_dataset API. After the dataset is forked, you can edit the new version of the dataset using edit_dataset.</p>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/","title":"Fetching Evaluations","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\n</pre> import openml In\u00a0[\u00a0]: Copied! <pre>openml.evaluations.list_evaluations(\n    function=\"predictive_accuracy\", size=10\n)\n\n# Using other evaluation metrics, 'precision' in this case\nevals = openml.evaluations.list_evaluations(\n    function=\"precision\", size=10, output_format=\"dataframe\"\n)\n\n# Querying the returned results for precision above 0.98\nprint(evals[evals.value &gt; 0.98])\n</pre> openml.evaluations.list_evaluations(     function=\"predictive_accuracy\", size=10 )  # Using other evaluation metrics, 'precision' in this case evals = openml.evaluations.list_evaluations(     function=\"precision\", size=10, output_format=\"dataframe\" )  # Querying the returned results for precision above 0.98 print(evals[evals.value &gt; 0.98]) In\u00a0[\u00a0]: Copied! <pre>task_id = 167140  # https://www.openml.org/t/167140\ntask = openml.tasks.get_task(task_id)\nprint(task)\n</pre> task_id = 167140  # https://www.openml.org/t/167140 task = openml.tasks.get_task(task_id) print(task) In\u00a0[\u00a0]: Copied! <pre>metric = \"predictive_accuracy\"\nevals = openml.evaluations.list_evaluations(\n    function=metric, tasks=[task_id], output_format=\"dataframe\"\n)\n# Displaying the first 10 rows\nprint(evals.head(n=10))\n# Sorting the evaluations in decreasing order of the metric chosen\nevals = evals.sort_values(by=\"value\", ascending=False)\nprint(\"\\nDisplaying head of sorted dataframe: \")\nprint(evals.head())\n</pre> metric = \"predictive_accuracy\" evals = openml.evaluations.list_evaluations(     function=metric, tasks=[task_id], output_format=\"dataframe\" ) # Displaying the first 10 rows print(evals.head(n=10)) # Sorting the evaluations in decreasing order of the metric chosen evals = evals.sort_values(by=\"value\", ascending=False) print(\"\\nDisplaying head of sorted dataframe: \") print(evals.head()) In\u00a0[\u00a0]: Copied! <pre>from matplotlib import pyplot as plt\n\n\ndef plot_cdf(values, metric=\"predictive_accuracy\"):\n    max_val = max(values)\n    n, bins, patches = plt.hist(values, density=True, histtype=\"step\", cumulative=True, linewidth=3)\n    patches[0].set_xy(patches[0].get_xy()[:-1])\n    plt.xlim(max(0, min(values) - 0.1), 1)\n    plt.title(\"CDF\")\n    plt.xlabel(metric)\n    plt.ylabel(\"Likelihood\")\n    plt.grid(visible=True, which=\"major\", linestyle=\"-\")\n    plt.minorticks_on()\n    plt.grid(visible=True, which=\"minor\", linestyle=\"--\")\n    plt.axvline(max_val, linestyle=\"--\", color=\"gray\")\n    plt.text(max_val, 0, f\"{max_val:.3f}\", fontsize=9)\n    plt.show()\n\n\nplot_cdf(evals.value, metric)\n</pre> from matplotlib import pyplot as plt   def plot_cdf(values, metric=\"predictive_accuracy\"):     max_val = max(values)     n, bins, patches = plt.hist(values, density=True, histtype=\"step\", cumulative=True, linewidth=3)     patches[0].set_xy(patches[0].get_xy()[:-1])     plt.xlim(max(0, min(values) - 0.1), 1)     plt.title(\"CDF\")     plt.xlabel(metric)     plt.ylabel(\"Likelihood\")     plt.grid(visible=True, which=\"major\", linestyle=\"-\")     plt.minorticks_on()     plt.grid(visible=True, which=\"minor\", linestyle=\"--\")     plt.axvline(max_val, linestyle=\"--\", color=\"gray\")     plt.text(max_val, 0, f\"{max_val:.3f}\", fontsize=9)     plt.show()   plot_cdf(evals.value, metric) <p>This CDF plot shows that for the given task, based on the results of the runs uploaded, it is almost certain to achieve an accuracy above 52%, i.e., with non-zero probability. While the maximum accuracy seen till now is 96.5%.</p> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport pandas as pd\n\n\ndef plot_flow_compare(evaluations, top_n=10, metric=\"predictive_accuracy\"):\n    # Collecting the top 10 performing unique flow_id\n    flow_ids = evaluations.flow_id.unique()[:top_n]\n\n    df = pd.DataFrame()\n    # Creating a data frame containing only the metric values of the selected flows\n    #   assuming evaluations is sorted in decreasing order of metric\n    for i in range(len(flow_ids)):\n        flow_values = evaluations[evaluations.flow_id == flow_ids[i]].value\n        df = pd.concat([df, flow_values], ignore_index=True, axis=1)\n    fig, axs = plt.subplots()\n    df.boxplot()\n    axs.set_title(\"Boxplot comparing \" + metric + \" for different flows\")\n    axs.set_ylabel(metric)\n    axs.set_xlabel(\"Flow ID\")\n    axs.set_xticklabels(flow_ids)\n    axs.grid(which=\"major\", linestyle=\"-\", linewidth=\"0.5\", color=\"gray\", axis=\"y\")\n    axs.minorticks_on()\n    axs.grid(which=\"minor\", linestyle=\"--\", linewidth=\"0.5\", color=\"gray\", axis=\"y\")\n    # Counting the number of entries for each flow in the data frame\n    #   which gives the number of runs for each flow\n    flow_freq = list(df.count(axis=0, numeric_only=True))\n    for i in range(len(flow_ids)):\n        axs.text(i + 1.05, np.nanmin(df.values), str(flow_freq[i]) + \"\\nrun(s)\", fontsize=7)\n    plt.show()\n\n\nplot_flow_compare(evals, metric=metric, top_n=10)\n</pre> import numpy as np import pandas as pd   def plot_flow_compare(evaluations, top_n=10, metric=\"predictive_accuracy\"):     # Collecting the top 10 performing unique flow_id     flow_ids = evaluations.flow_id.unique()[:top_n]      df = pd.DataFrame()     # Creating a data frame containing only the metric values of the selected flows     #   assuming evaluations is sorted in decreasing order of metric     for i in range(len(flow_ids)):         flow_values = evaluations[evaluations.flow_id == flow_ids[i]].value         df = pd.concat([df, flow_values], ignore_index=True, axis=1)     fig, axs = plt.subplots()     df.boxplot()     axs.set_title(\"Boxplot comparing \" + metric + \" for different flows\")     axs.set_ylabel(metric)     axs.set_xlabel(\"Flow ID\")     axs.set_xticklabels(flow_ids)     axs.grid(which=\"major\", linestyle=\"-\", linewidth=\"0.5\", color=\"gray\", axis=\"y\")     axs.minorticks_on()     axs.grid(which=\"minor\", linestyle=\"--\", linewidth=\"0.5\", color=\"gray\", axis=\"y\")     # Counting the number of entries for each flow in the data frame     #   which gives the number of runs for each flow     flow_freq = list(df.count(axis=0, numeric_only=True))     for i in range(len(flow_ids)):         axs.text(i + 1.05, np.nanmin(df.values), str(flow_freq[i]) + \"\\nrun(s)\", fontsize=7)     plt.show()   plot_flow_compare(evals, metric=metric, top_n=10) <p>The boxplots below show how the flows perform across multiple runs on the chosen task. The green horizontal lines represent the median accuracy of all the runs for that flow (number of runs denoted at the bottom of the boxplots). The higher the green line, the better the flow is for the task at hand. The ordering of the flows are in the descending order of the higest accuracy value seen under that flow.</p> <p>Printing the corresponding flow names for the top 10 performing flow IDs</p> In\u00a0[\u00a0]: Copied! <pre>top_n = 10\nflow_ids = evals.flow_id.unique()[:top_n]\nflow_names = evals.flow_name.unique()[:top_n]\nfor i in range(top_n):\n    print((flow_ids[i], flow_names[i]))\n</pre> top_n = 10 flow_ids = evals.flow_id.unique()[:top_n] flow_names = evals.flow_name.unique()[:top_n] for i in range(top_n):     print((flow_ids[i], flow_names[i])) In\u00a0[\u00a0]: Copied! <pre>evals_setups = openml.evaluations.list_evaluations_setups(\n    function=\"predictive_accuracy\",\n    tasks=[31],\n    size=100,\n    sort_order=\"desc\",\n)\n\nprint(evals_setups.head())\n</pre> evals_setups = openml.evaluations.list_evaluations_setups(     function=\"predictive_accuracy\",     tasks=[31],     size=100,     sort_order=\"desc\", )  print(evals_setups.head()) <p>Return evaluations for flow_id in descending order based on predictive_accuracy with hyperparameters. parameters_in_separate_columns returns parameters in separate columns</p> In\u00a0[\u00a0]: Copied! <pre>evals_setups = openml.evaluations.list_evaluations_setups(\n    function=\"predictive_accuracy\", flows=[6767], size=100, parameters_in_separate_columns=True\n)\n\nprint(evals_setups.head(10))\n\n# License: BSD 3-Clause\n</pre> evals_setups = openml.evaluations.list_evaluations_setups(     function=\"predictive_accuracy\", flows=[6767], size=100, parameters_in_separate_columns=True )  print(evals_setups.head(10))  # License: BSD 3-Clause"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#fetching-evaluations","title":"Fetching Evaluations\u00b6","text":"<p>Evaluations contain a concise summary of the results of all runs made. Each evaluation provides information on the dataset used, the flow applied, the setup used, the metric evaluated, and the result obtained on the metric, for each such run made. These collection of results can be used for efficient benchmarking of an algorithm and also allow transparent reuse of results from previous experiments on similar parameters.</p> <p>In this example, we shall do the following:</p> <ul> <li>Retrieve evaluations based on different metrics</li> <li>Fetch evaluations pertaining to a specific task</li> <li>Sort the obtained results in descending order of the metric</li> <li>Plot a cumulative distribution function for the evaluations</li> <li>Compare the top 10 performing flows based on the evaluation performance</li> <li>Retrieve evaluations with hyperparameter settings</li> </ul>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#listing-evaluations","title":"Listing evaluations\u00b6","text":"<p>Evaluations can be retrieved from the database in the chosen output format. Required filters can be applied to retrieve results from runs as required.</p> <p>We shall retrieve a small set (only 10 entries) to test the listing function for evaluations</p>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#viewing-a-sample-task","title":"Viewing a sample task\u00b6","text":"<p>Over here we shall briefly take a look at the details of the task. We will start by displaying a simple supervised classification task:</p>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#obtaining-all-the-evaluations-for-the-task","title":"Obtaining all the evaluations for the task\u00b6","text":"<p>We'll now obtain all the evaluations that were uploaded for the task we displayed previously. Note that we now filter the evaluations based on another parameter 'task'.</p>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#obtaining-cdf-of-metric-for-chosen-task","title":"Obtaining CDF of metric for chosen task\u00b6","text":"<p>We shall now analyse how the performance of various flows have been on this task, by seeing the likelihood of the accuracy obtained across all runs. We shall now plot a cumulative distributive function (CDF) for the accuracies obtained.</p>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#comparing-top-10-performing-flows","title":"Comparing top 10 performing flows\u00b6","text":"<p>Let us now try to see which flows generally performed the best for this task. For this, we shall compare the top performing flows.</p>"},{"location":"examples/30_extended/fetch_evaluations_tutorial/#obtaining-evaluations-with-hyperparameter-settings","title":"Obtaining evaluations with hyperparameter settings\u00b6","text":"<p>We'll now obtain the evaluations of a task and a flow with the hyperparameters</p> <p>List evaluations in descending order based on predictive_accuracy with hyperparameters</p>"},{"location":"examples/30_extended/fetch_runtimes_tutorial/","title":"Preparing tasks and scikit-learn models","text":"<p>Measuring runtimes for Scikit-learn models</p> <p>The runtime of machine learning models on specific datasets can be a deciding factor on the choice of algorithms, especially for benchmarking and comparison purposes. OpenML's scikit-learn extension provides runtime data from runs of model fit and prediction on tasks or datasets, for both the CPU-clock as well as the actual wallclock-time incurred. The objective of this example is to illustrate how to retrieve such timing measures, and also offer some potential means of usage and interpretation of the same.</p> <p>It should be noted that there are multiple levels at which parallelism can occur.</p> <ul> <li><p>At the outermost level, OpenML tasks contain fixed data splits, on which the defined model/flow is executed. Thus, a model can be fit on each OpenML dataset fold in parallel using the <code>n_jobs</code> parameter to <code>run_model_on_task</code> or <code>run_flow_on_task</code> (illustrated under Case 2 &amp; 3 below).</p> </li> <li><p>The model/flow specified can also include scikit-learn models that perform their own parallelization. For instance, by specifying <code>n_jobs</code> in a Random Forest model definition (covered under Case 2 below).</p> </li> <li><p>The sklearn model can further be an HPO estimator and contain it's own parallelization. If the base estimator used also supports <code>parallelization</code>, then there's at least a 2-level nested definition for parallelization possible (covered under Case 3 below).</p> </li> </ul> <p>We shall cover these 5 representative scenarios for:</p> <ul> <li><p>(Case 1) Retrieving runtimes for Random Forest training and prediction on each of the cross-validation folds</p> </li> <li><p>(Case 2) Testing the above setting in a parallel setup and monitor the difference using runtimes retrieved</p> </li> <li><p>(Case 3) Comparing RandomSearchCV and GridSearchCV on the above task based on runtimes</p> </li> <li><p>(Case 4) Running models that don't run in parallel or models which scikit-learn doesn't parallelize</p> </li> <li><p>(Case 5) Running models that do not release the Python Global Interpreter Lock (GIL)</p> </li> </ul> <p>import openml import numpy as np from matplotlib import pyplot as plt from joblib.parallel import parallel_backend</p> <p>from sklearn.naive_bayes import GaussianNB from sklearn.tree import DecisionTreeClassifier from sklearn.neural_network import MLPClassifier from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import GridSearchCV, RandomizedSearchCV</p> In\u00a0[\u00a0]: Copied! <pre>task_id = 167119\n\ntask = openml.tasks.get_task(task_id)\nprint(task)\n\n# Viewing associated data\nn_repeats, n_folds, n_samples = task.get_split_dimensions()\nprint(\n    \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(\n        task_id,\n        n_repeats,\n        n_folds,\n        n_samples,\n    )\n)\n\n\n# Creating utility function\ndef print_compare_runtimes(measures):\n    for repeat, val1 in measures[\"usercpu_time_millis_training\"].items():\n        for fold, val2 in val1.items():\n            print(\n                \"Repeat #{}-Fold #{}: CPU-{:.3f} vs Wall-{:.3f}\".format(\n                    repeat, fold, val2, measures[\"wall_clock_time_millis_training\"][repeat][fold]\n                )\n            )\n</pre> task_id = 167119  task = openml.tasks.get_task(task_id) print(task)  # Viewing associated data n_repeats, n_folds, n_samples = task.get_split_dimensions() print(     \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(         task_id,         n_repeats,         n_folds,         n_samples,     ) )   # Creating utility function def print_compare_runtimes(measures):     for repeat, val1 in measures[\"usercpu_time_millis_training\"].items():         for fold, val2 in val1.items():             print(                 \"Repeat #{}-Fold #{}: CPU-{:.3f} vs Wall-{:.3f}\".format(                     repeat, fold, val2, measures[\"wall_clock_time_millis_training\"][repeat][fold]                 )             ) In\u00a0[\u00a0]: Copied! <pre>clf = RandomForestClassifier(n_estimators=10)\n\nrun1 = openml.runs.run_model_on_task(\n    model=clf,\n    task=task,\n    upload_flow=False,\n    avoid_duplicate_runs=False,\n)\nmeasures = run1.fold_evaluations\n\nprint(\"The timing and performance metrics available: \")\nfor key in measures.keys():\n    print(key)\nprint()\n\nprint(\n    \"The performance metric is recorded under `predictive_accuracy` per \"\n    \"fold and can be retrieved as: \"\n)\nfor repeat, val1 in measures[\"predictive_accuracy\"].items():\n    for fold, val2 in val1.items():\n        print(f\"Repeat #{repeat}-Fold #{fold}: {val2:.4f}\")\n    print()\n</pre> clf = RandomForestClassifier(n_estimators=10)  run1 = openml.runs.run_model_on_task(     model=clf,     task=task,     upload_flow=False,     avoid_duplicate_runs=False, ) measures = run1.fold_evaluations  print(\"The timing and performance metrics available: \") for key in measures.keys():     print(key) print()  print(     \"The performance metric is recorded under `predictive_accuracy` per \"     \"fold and can be retrieved as: \" ) for repeat, val1 in measures[\"predictive_accuracy\"].items():     for fold, val2 in val1.items():         print(f\"Repeat #{repeat}-Fold #{fold}: {val2:.4f}\")     print() <p>The remaining entries recorded in <code>measures</code> are the runtime records related as:</p> <p>usercpu_time_millis = usercpu_time_millis_training + usercpu_time_millis_testing</p> <p>wall_clock_time_millis = wall_clock_time_millis_training + wall_clock_time_millis_testing</p> <p>The timing measures recorded as <code>*_millis_training</code> contain the per repeat-per fold timing incurred for the execution of the <code>.fit()</code> procedure of the model. For <code>usercpu_time_*</code> the time recorded using <code>time.process_time()</code> is converted to <code>milliseconds</code> and stored. Similarly, <code>time.time()</code> is used to record the time entry for <code>wall_clock_time_*</code>. The <code>*_millis_testing</code> entry follows the same procedure but for time taken for the <code>.predict()</code> procedure.</p> <p>Comparing the CPU and wall-clock training times of the Random Forest model</p> In\u00a0[\u00a0]: Copied! <pre>print_compare_runtimes(measures)\n</pre> print_compare_runtimes(measures) In\u00a0[\u00a0]: Copied! <pre>clf = RandomForestClassifier(n_estimators=10, n_jobs=2)\n\nrun2 = openml.runs.run_model_on_task(\n    model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False\n)\nmeasures = run2.fold_evaluations\n# The wall-clock time recorded per fold should be lesser than Case 1 above\nprint_compare_runtimes(measures)\n</pre> clf = RandomForestClassifier(n_estimators=10, n_jobs=2)  run2 = openml.runs.run_model_on_task(     model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False ) measures = run2.fold_evaluations # The wall-clock time recorded per fold should be lesser than Case 1 above print_compare_runtimes(measures) <p>Running a Random Forest model on an OpenML task in parallel (all cores available):</p> In\u00a0[\u00a0]: Copied! <pre># Redefining the model to use all available cores with `n_jobs=-1`\nclf = RandomForestClassifier(n_estimators=10, n_jobs=-1)\n\nrun3 = openml.runs.run_model_on_task(\n    model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False\n)\nmeasures = run3.fold_evaluations\n</pre> # Redefining the model to use all available cores with `n_jobs=-1` clf = RandomForestClassifier(n_estimators=10, n_jobs=-1)  run3 = openml.runs.run_model_on_task(     model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False ) measures = run3.fold_evaluations <p>The wall-clock time recorded per fold should be lesser than the case above, if more than 2 CPU cores are available. The speed-up is more pronounced for larger datasets. print_compare_runtimes(measures)</p> <p>We can now observe that the ratio of CPU time to wallclock time is lower than in case 1. This happens because joblib by default spawns subprocesses for the workloads for which CPU time cannot be tracked. Therefore, interpreting the reported CPU and wallclock time requires knowledge of the parallelization applied at runtime.</p> <p>Running the same task with a different parallel backend. Joblib provides multiple backends: {<code>loky</code> (default), <code>multiprocessing</code>, <code>dask</code>, <code>threading</code>, <code>sequential</code>}. The backend can be explicitly set using a joblib context manager. The behaviour of the job distribution can change and therefore the scale of runtimes recorded too.</p> In\u00a0[\u00a0]: Copied! <pre>with parallel_backend(backend=\"multiprocessing\", n_jobs=-1):\n    run3_ = openml.runs.run_model_on_task(\n        model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False\n    )\nmeasures = run3_.fold_evaluations\nprint_compare_runtimes(measures)\n</pre> with parallel_backend(backend=\"multiprocessing\", n_jobs=-1):     run3_ = openml.runs.run_model_on_task(         model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False     ) measures = run3_.fold_evaluations print_compare_runtimes(measures) <p>The CPU time interpretation becomes ambiguous when jobs are distributed over an unknown number of cores or when subprocesses are spawned for which the CPU time cannot be tracked, as in the examples above. It is impossible for OpenML-Python to capture the availability of the number of cores/threads, their eventual utilisation and whether workloads are executed in subprocesses, for various cases that can arise as demonstrated in the rest of the example. Therefore, the final interpretation of the runtimes is left to the <code>user</code>.</p> In\u00a0[\u00a0]: Copied! <pre>from sklearn.model_selection import GridSearchCV\n\nclf = RandomForestClassifier(n_estimators=10, n_jobs=2)\n\n# GridSearchCV model\nn_iter = 5\ngrid_pipe = GridSearchCV(\n    estimator=clf,\n    param_grid={\"n_estimators\": np.linspace(start=1, stop=50, num=n_iter).astype(int).tolist()},\n    cv=2,\n    n_jobs=2,\n)\n\nrun4 = openml.runs.run_model_on_task(\n    model=grid_pipe, task=task, upload_flow=False, avoid_duplicate_runs=False, n_jobs=2\n)\nmeasures = run4.fold_evaluations\nprint_compare_runtimes(measures)\n</pre> from sklearn.model_selection import GridSearchCV  clf = RandomForestClassifier(n_estimators=10, n_jobs=2)  # GridSearchCV model n_iter = 5 grid_pipe = GridSearchCV(     estimator=clf,     param_grid={\"n_estimators\": np.linspace(start=1, stop=50, num=n_iter).astype(int).tolist()},     cv=2,     n_jobs=2, )  run4 = openml.runs.run_model_on_task(     model=grid_pipe, task=task, upload_flow=False, avoid_duplicate_runs=False, n_jobs=2 ) measures = run4.fold_evaluations print_compare_runtimes(measures) <p>Like any optimisation problem, scikit-learn's HPO estimators also generate a sequence of configurations which are evaluated, using which the best found configuration is tracked throughout the trace. The OpenML run object stores these traces as OpenMLRunTrace objects accessible using keys of the pattern (repeat, fold, iterations). Here <code>fold</code> implies the outer-cross validation fold as obtained from the task data splits in OpenML. GridSearchCV here performs grid search over the inner-cross validation folds as parameterized by the <code>cv</code> parameter. Since <code>GridSearchCV</code> in this example performs a <code>2-fold</code> cross validation, the runtime recorded per repeat-per fold in the run object is for the entire <code>fit()</code> procedure of GridSearchCV thus subsuming the runtimes of the 2-fold (inner) CV search performed.</p> In\u00a0[\u00a0]: Copied! <pre># We earlier extracted the number of repeats and folds for this task:\nprint(f\"# repeats: {n_repeats}\\n# folds: {n_folds}\")\n\n# To extract the training runtime of the first repeat, first fold:\nprint(run4.fold_evaluations[\"wall_clock_time_millis_training\"][0][0])\n</pre> # We earlier extracted the number of repeats and folds for this task: print(f\"# repeats: {n_repeats}\\n# folds: {n_folds}\")  # To extract the training runtime of the first repeat, first fold: print(run4.fold_evaluations[\"wall_clock_time_millis_training\"][0][0]) <p>To extract the training runtime of the 1-st repeat, 4-th (outer) fold and also to fetch the parameters and performance of the evaluations made during the 1-st repeat, 4-th fold evaluation by the Grid Search model.</p> In\u00a0[\u00a0]: Copied! <pre>_repeat = 0\n_fold = 3\nprint(\n    \"Total runtime for repeat {}'s fold {}: {:4f} ms\".format(\n        _repeat, _fold, run4.fold_evaluations[\"wall_clock_time_millis_training\"][_repeat][_fold]\n    )\n)\nfor i in range(n_iter):\n    key = (_repeat, _fold, i)\n    r = run4.trace.trace_iterations[key]\n    print(\n        \"n_estimators: {:&gt;2} - score: {:.3f}\".format(\n            r.parameters[\"parameter_n_estimators\"], r.evaluation\n        )\n    )\n</pre> _repeat = 0 _fold = 3 print(     \"Total runtime for repeat {}'s fold {}: {:4f} ms\".format(         _repeat, _fold, run4.fold_evaluations[\"wall_clock_time_millis_training\"][_repeat][_fold]     ) ) for i in range(n_iter):     key = (_repeat, _fold, i)     r = run4.trace.trace_iterations[key]     print(         \"n_estimators: {:&gt;2} - score: {:.3f}\".format(             r.parameters[\"parameter_n_estimators\"], r.evaluation         )     ) <p>Scikit-learn's HPO estimators also come with an argument <code>refit=True</code> as a default. In our previous model definition it was set to True by default, which meant that the best found hyperparameter configuration was used to refit or retrain the model without any inner cross validation. This extra refit time measure is provided by the scikit-learn model as the attribute <code>refit_time_</code>. This time is included in the <code>wall_clock_time_millis_training</code> measure.</p> <p>For non-HPO estimators, <code>wall_clock_time_millis = wall_clock_time_millis_training + wall_clock_time_millis_testing</code>.</p> <p>For HPO estimators, <code>wall_clock_time_millis = wall_clock_time_millis_training + wall_clock_time_millis_testing + refit_time</code>.</p> <p>This refit time can therefore be explicitly extracted in this manner:</p> In\u00a0[\u00a0]: Copied! <pre>def extract_refit_time(run, repeat, fold):\n    refit_time = (\n        run.fold_evaluations[\"wall_clock_time_millis\"][repeat][fold]\n        - run.fold_evaluations[\"wall_clock_time_millis_training\"][repeat][fold]\n        - run.fold_evaluations[\"wall_clock_time_millis_testing\"][repeat][fold]\n    )\n    return refit_time\n\n\nfor repeat in range(n_repeats):\n    for fold in range(n_folds):\n        print(\n            \"Repeat #{}-Fold #{}: {:.4f}\".format(\n                repeat, fold, extract_refit_time(run4, repeat, fold)\n            )\n        )\n</pre>  def extract_refit_time(run, repeat, fold):     refit_time = (         run.fold_evaluations[\"wall_clock_time_millis\"][repeat][fold]         - run.fold_evaluations[\"wall_clock_time_millis_training\"][repeat][fold]         - run.fold_evaluations[\"wall_clock_time_millis_testing\"][repeat][fold]     )     return refit_time   for repeat in range(n_repeats):     for fold in range(n_folds):         print(             \"Repeat #{}-Fold #{}: {:.4f}\".format(                 repeat, fold, extract_refit_time(run4, repeat, fold)             )         ) <p>Along with the GridSearchCV already used above, we demonstrate how such optimisation traces can be retrieved by showing an application of these traces - comparing the speed of finding the best configuration using RandomizedSearchCV and GridSearchCV available with scikit-learn.</p> In\u00a0[\u00a0]: Copied! <pre># RandomizedSearchCV model\nrs_pipe = RandomizedSearchCV(\n    estimator=clf,\n    param_distributions={\n        \"n_estimators\": np.linspace(start=1, stop=50, num=15).astype(int).tolist()\n    },\n    cv=2,\n    n_iter=n_iter,\n    n_jobs=2,\n)\nrun5 = openml.runs.run_model_on_task(\n    model=rs_pipe, task=task, upload_flow=False, avoid_duplicate_runs=False, n_jobs=2\n)\n</pre> # RandomizedSearchCV model rs_pipe = RandomizedSearchCV(     estimator=clf,     param_distributions={         \"n_estimators\": np.linspace(start=1, stop=50, num=15).astype(int).tolist()     },     cv=2,     n_iter=n_iter,     n_jobs=2, ) run5 = openml.runs.run_model_on_task(     model=rs_pipe, task=task, upload_flow=False, avoid_duplicate_runs=False, n_jobs=2 ) <p>Since for the call to <code>openml.runs.run_model_on_task</code> the parameter <code>n_jobs</code> is set to its default <code>None</code>, the evaluations across the OpenML folds are not parallelized. Hence, the time recorded is agnostic to the <code>n_jobs</code> being set at both the HPO estimator <code>GridSearchCV</code> as well as the base estimator <code>RandomForestClassifier</code> in this case. The OpenML extension only records the time taken for the completion of the complete <code>fit()</code> call, per-repeat per-fold.</p> <p>This notion can be used to extract and plot the best found performance per fold by the HPO model and the corresponding time taken for search across that fold. Moreover, since <code>n_jobs=None</code> for <code>openml.runs.run_model_on_task</code> the runtimes per fold can be cumulatively added to plot the trace against time.</p> In\u00a0[\u00a0]: Copied! <pre>def extract_trace_data(run, n_repeats, n_folds, n_iter, key=None):\n    key = \"wall_clock_time_millis_training\" if key is None else key\n    data = {\"score\": [], \"runtime\": []}\n    for i_r in range(n_repeats):\n        for i_f in range(n_folds):\n            data[\"runtime\"].append(run.fold_evaluations[key][i_r][i_f])\n            for i_i in range(n_iter):\n                r = run.trace.trace_iterations[(i_r, i_f, i_i)]\n                if r.selected:\n                    data[\"score\"].append(r.evaluation)\n                    break\n    return data\n\n\ndef get_incumbent_trace(trace):\n    best_score = 1\n    inc_trace = []\n    for i, r in enumerate(trace):\n        if i == 0 or (1 - r) &lt; best_score:\n            best_score = 1 - r\n        inc_trace.append(best_score)\n    return inc_trace\n\n\ngrid_data = extract_trace_data(run4, n_repeats, n_folds, n_iter)\nrs_data = extract_trace_data(run5, n_repeats, n_folds, n_iter)\n\nplt.clf()\nplt.plot(\n    np.cumsum(grid_data[\"runtime\"]), get_incumbent_trace(grid_data[\"score\"]), label=\"Grid Search\"\n)\nplt.plot(\n    np.cumsum(rs_data[\"runtime\"]), get_incumbent_trace(rs_data[\"score\"]), label=\"Random Search\"\n)\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlabel(\"Wallclock time (in milliseconds)\")\nplt.ylabel(\"1 - Accuracy\")\nplt.title(\"Optimisation Trace Comparison\")\nplt.legend()\nplt.show()\n</pre> def extract_trace_data(run, n_repeats, n_folds, n_iter, key=None):     key = \"wall_clock_time_millis_training\" if key is None else key     data = {\"score\": [], \"runtime\": []}     for i_r in range(n_repeats):         for i_f in range(n_folds):             data[\"runtime\"].append(run.fold_evaluations[key][i_r][i_f])             for i_i in range(n_iter):                 r = run.trace.trace_iterations[(i_r, i_f, i_i)]                 if r.selected:                     data[\"score\"].append(r.evaluation)                     break     return data   def get_incumbent_trace(trace):     best_score = 1     inc_trace = []     for i, r in enumerate(trace):         if i == 0 or (1 - r) &lt; best_score:             best_score = 1 - r         inc_trace.append(best_score)     return inc_trace   grid_data = extract_trace_data(run4, n_repeats, n_folds, n_iter) rs_data = extract_trace_data(run5, n_repeats, n_folds, n_iter)  plt.clf() plt.plot(     np.cumsum(grid_data[\"runtime\"]), get_incumbent_trace(grid_data[\"score\"]), label=\"Grid Search\" ) plt.plot(     np.cumsum(rs_data[\"runtime\"]), get_incumbent_trace(rs_data[\"score\"]), label=\"Random Search\" ) plt.xscale(\"log\") plt.yscale(\"log\") plt.xlabel(\"Wallclock time (in milliseconds)\") plt.ylabel(\"1 - Accuracy\") plt.title(\"Optimisation Trace Comparison\") plt.legend() plt.show() In\u00a0[\u00a0]: Copied! <pre>dt = DecisionTreeClassifier()\n\nrun6 = openml.runs.run_model_on_task(\n    model=dt, task=task, upload_flow=False, avoid_duplicate_runs=False, n_jobs=2\n)\nmeasures = run6.fold_evaluations\nprint_compare_runtimes(measures)\n</pre> dt = DecisionTreeClassifier()  run6 = openml.runs.run_model_on_task(     model=dt, task=task, upload_flow=False, avoid_duplicate_runs=False, n_jobs=2 ) measures = run6.fold_evaluations print_compare_runtimes(measures) <p>Although the decision tree does not run in parallel, it can release the <code>Python GIL &lt;https://docs.python.org/dev/glossary.html#term-global-interpreter-lock&gt;</code>_. This can result in surprising runtime measures as demonstrated below:</p> In\u00a0[\u00a0]: Copied! <pre>with parallel_backend(\"threading\", n_jobs=-1):\n    run7 = openml.runs.run_model_on_task(\n        model=dt, task=task, upload_flow=False, avoid_duplicate_runs=False\n    )\nmeasures = run7.fold_evaluations\nprint_compare_runtimes(measures)\n</pre> with parallel_backend(\"threading\", n_jobs=-1):     run7 = openml.runs.run_model_on_task(         model=dt, task=task, upload_flow=False, avoid_duplicate_runs=False     ) measures = run7.fold_evaluations print_compare_runtimes(measures) <p>Running a Neural Network from scikit-learn that uses scikit-learn independent parallelism using libraries such as MKL, OpenBLAS or BLIS.</p> In\u00a0[\u00a0]: Copied! <pre>mlp = MLPClassifier(max_iter=10)\n\nrun8 = openml.runs.run_model_on_task(\n    model=mlp, task=task, upload_flow=False, avoid_duplicate_runs=False\n)\nmeasures = run8.fold_evaluations\nprint_compare_runtimes(measures)\n</pre> mlp = MLPClassifier(max_iter=10)  run8 = openml.runs.run_model_on_task(     model=mlp, task=task, upload_flow=False, avoid_duplicate_runs=False ) measures = run8.fold_evaluations print_compare_runtimes(measures) In\u00a0[\u00a0]: Copied! <pre>clf = GaussianNB()\n\nwith parallel_backend(\"multiprocessing\", n_jobs=-1):\n    run9 = openml.runs.run_model_on_task(\n        model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False\n    )\nmeasures = run9.fold_evaluations\nprint_compare_runtimes(measures)\n</pre> clf = GaussianNB()  with parallel_backend(\"multiprocessing\", n_jobs=-1):     run9 = openml.runs.run_model_on_task(         model=clf, task=task, upload_flow=False, avoid_duplicate_runs=False     ) measures = run9.fold_evaluations print_compare_runtimes(measures)"},{"location":"examples/30_extended/fetch_runtimes_tutorial/#preparing-tasks-and-scikit-learn-models","title":"Preparing tasks and scikit-learn models\u00b6","text":""},{"location":"examples/30_extended/fetch_runtimes_tutorial/#case-1-running-a-random-forest-model-on-an-openml-task","title":"Case 1: Running a Random Forest model on an OpenML task\u00b6","text":"<p>We'll run a Random Forest model and obtain an OpenML run object. We can see the evaluations recorded per fold for the dataset and the information available for this run.</p>"},{"location":"examples/30_extended/fetch_runtimes_tutorial/#case-2-running-scikit-learn-model-on-an-openml-task-in-parallel","title":"Case 2: Running Scikit-learn model on an OpenML task in parallel\u00b6","text":"<p>Redefining the model to allow parallelism with <code>n_jobs=2</code> (2 cores)</p>"},{"location":"examples/30_extended/fetch_runtimes_tutorial/#case-3-running-and-benchmarking-hpo-algorithms-with-their-runtimes","title":"Case 3: Running and benchmarking HPO algorithms with their runtimes\u00b6","text":"<p>We shall now optimize a similar RandomForest model for the same task using scikit-learn's HPO support by using GridSearchCV to optimize our earlier RandomForest model's hyperparameter <code>n_estimators</code>. Scikit-learn also provides a <code>refit_time_</code> for such HPO models, i.e., the time incurred by training and evaluating the model on the best found parameter setting. This is included in the <code>wall_clock_time_millis_training</code> measure recorded.</p>"},{"location":"examples/30_extended/fetch_runtimes_tutorial/#case-4-running-models-that-scikit-learn-doesnt-parallelize","title":"Case 4: Running models that scikit-learn doesn't parallelize\u00b6","text":"<p>Both scikit-learn and OpenML depend on parallelism implemented through <code>joblib</code>. However, there can be cases where either models cannot be parallelized or don't depend on joblib for its parallelism. 2 such cases are illustrated below.</p> <p>Running a Decision Tree model that doesn't support parallelism implicitly, but using OpenML to parallelize evaluations for the outer-cross validation folds.</p>"},{"location":"examples/30_extended/fetch_runtimes_tutorial/#case-5-running-scikit-learn-models-that-dont-release-gil","title":"Case 5: Running Scikit-learn models that don't release GIL\u00b6","text":"<p>Certain Scikit-learn models do not release the Python GIL and are also not executed in parallel via a BLAS library. In such cases, the CPU times and wallclock times are most likely trustworthy. Note however that only very few models such as naive Bayes models are of this kind.</p>"},{"location":"examples/30_extended/fetch_runtimes_tutorial/#summmary","title":"Summmary\u00b6","text":"<p>The scikit-learn extension for OpenML-Python records model runtimes for the CPU-clock and the wall-clock times. The above examples illustrated how these recorded runtimes can be extracted when using a scikit-learn model and under parallel setups too. To summarize, the scikit-learn extension measures the:</p> <ul> <li><p><code>CPU-time</code> &amp; <code>wallclock-time</code> for the whole run</p> <ul> <li>A run here corresponds to a call to <code>run_model_on_task</code> or <code>run_flow_on_task</code></li> <li>The recorded time is for the model fit for each of the outer-cross validations folds, i.e., the OpenML data splits</li> </ul> </li> <li><p>Python's <code>time</code> module is used to compute the runtimes</p> <ul> <li><code>CPU-time</code> is recorded using the responses of <code>time.process_time()</code></li> <li><code>wallclock-time</code> is recorded using the responses of <code>time.time()</code></li> </ul> </li> <li><p>The timings recorded by OpenML per outer-cross validation fold is agnostic to model parallelisation</p> <ul> <li>The wallclock times reported in Case 2 above highlights the speed-up on using <code>n_jobs=-1</code> in comparison to <code>n_jobs=2</code>, since the timing recorded by OpenML is for the entire <code>fit()</code> procedure, whereas the parallelisation is performed inside <code>fit()</code> by scikit-learn</li> <li>The CPU-time for models that are run in parallel can be difficult to interpret</li> </ul> </li> <li><p><code>CPU-time</code> &amp; <code>wallclock-time</code> for each search per outer fold in an HPO run</p> <ul> <li>Reports the total time for performing search on each of the OpenML data split, subsuming any sort of parallelism that happened as part of the HPO estimator or the underlying base estimator</li> <li>Also allows extraction of the <code>refit_time</code> that scikit-learn measures using <code>time.time()</code> for retraining the model per outer fold, for the best found configuration</li> </ul> </li> <li><p><code>CPU-time</code> &amp; <code>wallclock-time</code> for models that scikit-learn doesn't parallelize</p> <ul> <li>Models like Decision Trees or naive Bayes don't parallelize and thus both the wallclock and CPU times are similar in runtime for the OpenML call</li> <li>However, models implemented in Cython, such as the Decision Trees can release the GIL and still run in parallel if a <code>threading</code> backend is used by joblib.</li> <li>Scikit-learn Neural Networks can undergo parallelization implicitly owing to thread-level parallelism involved in the linear algebraic operations and thus the wallclock-time and CPU-time can differ.</li> </ul> </li> </ul> <p>Because of all the cases mentioned above it is crucial to understand which case is triggered when reporting runtimes for scikit-learn models measured with OpenML-Python! License: BSD 3-Clause</p>"},{"location":"examples/30_extended/flow_id_tutorial/","title":"Obtaining Flow IDs","text":"In\u00a0[\u00a0]: Copied! <pre>import sklearn.tree\n\nimport openml\n</pre> import sklearn.tree  import openml <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\nopenml.config.server = \"https://api.openml.org/api/v1/xml\"\n</pre> openml.config.start_using_configuration_for_example() openml.config.server = \"https://api.openml.org/api/v1/xml\" In\u00a0[\u00a0]: Copied! <pre># Defining a classifier\nclf = sklearn.tree.DecisionTreeClassifier()\n</pre> # Defining a classifier clf = sklearn.tree.DecisionTreeClassifier() In\u00a0[\u00a0]: Copied! <pre>flow = openml.extensions.get_extension_by_model(clf).model_to_flow(clf).publish()\nflow_id = flow.flow_id\nprint(flow_id)\n</pre> flow = openml.extensions.get_extension_by_model(clf).model_to_flow(clf).publish() flow_id = flow.flow_id print(flow_id) <p>This piece of code is rather involved. First, it retrieves a :class:<code>~openml.extensions.Extension</code> which is registered and can handle the given model, in our case it is :class:<code>openml.extensions.sklearn.SklearnExtension</code>. Second, the extension converts the classifier into an instance of :class:<code>openml.OpenMLFlow</code>. Third and finally, the publish method checks whether the current flow is already present on OpenML. If not, it uploads the flow, otherwise, it updates the current instance with all information computed by the server (which is obviously also done when uploading/publishing a flow).</p> <p>To simplify the usage we have created a helper function which automates all these steps:</p> In\u00a0[\u00a0]: Copied! <pre>flow_id = openml.flows.get_flow_id(model=clf)\nprint(flow_id)\n</pre> flow_id = openml.flows.get_flow_id(model=clf) print(flow_id) In\u00a0[\u00a0]: Copied! <pre>print(flow.name, flow.external_version)\n</pre> print(flow.name, flow.external_version) <p>The name and external version are automatically added to a flow when constructing it from a model. We can then use them to retrieve the flow id as follows:</p> In\u00a0[\u00a0]: Copied! <pre>flow_id = openml.flows.flow_exists(name=flow.name, external_version=flow.external_version)\nprint(flow_id)\n</pre> flow_id = openml.flows.flow_exists(name=flow.name, external_version=flow.external_version) print(flow_id) <p>We can also retrieve all flows for a given name:</p> In\u00a0[\u00a0]: Copied! <pre>flow_ids = openml.flows.get_flow_id(name=flow.name)\nprint(flow_ids)\n</pre> flow_ids = openml.flows.get_flow_id(name=flow.name) print(flow_ids) <p>This also works with the actual model (generalizing the first part of this example):</p> In\u00a0[\u00a0]: Copied! <pre>flow_ids = openml.flows.get_flow_id(model=clf, exact_version=False)\nprint(flow_ids)\n</pre> flow_ids = openml.flows.get_flow_id(model=clf, exact_version=False) print(flow_ids) In\u00a0[\u00a0]: Copied! <pre># Deactivating test configuration\nopenml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> # Deactivating test configuration openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/30_extended/flow_id_tutorial/#obtaining-flow-ids","title":"Obtaining Flow IDs\u00b6","text":"<p>This tutorial discusses different ways to obtain the ID of a flow in order to perform further analysis.</p>"},{"location":"examples/30_extended/flow_id_tutorial/#1-obtaining-a-flow-given-a-classifier","title":"1. Obtaining a flow given a classifier\u00b6","text":""},{"location":"examples/30_extended/flow_id_tutorial/#2-obtaining-a-flow-given-its-name","title":"2. Obtaining a flow given its name\u00b6","text":"<p>The schema of a flow is given in XSD ( here).  # noqa E501 Only two fields are required, a unique name, and an external version. While it should be pretty obvious why we need a name, the need for the additional external version information might not be immediately clear. However, this information is very important as it allows to have multiple flows with the same name for different versions of a software. This might be necessary if an algorithm or implementation introduces, renames or drop hyperparameters over time.</p>"},{"location":"examples/30_extended/flows_and_runs_tutorial/","title":"Flows and Runs","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\nfrom sklearn import compose, ensemble, impute, neighbors, preprocessing, pipeline, tree\n\nimport openml\n</pre> import openml from sklearn import compose, ensemble, impute, neighbors, preprocessing, pipeline, tree  import openml <p>We'll use the test server for the rest of this tutorial.</p> <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() In\u00a0[\u00a0]: Copied! <pre># NOTE: We are using dataset 68 from the test server: https://test.openml.org/d/68\ndataset = openml.datasets.get_dataset(dataset_id=\"eeg-eye-state\", version=1)\nX, y, categorical_indicator, attribute_names = dataset.get_data(\n    target=dataset.default_target_attribute\n)\nclf = neighbors.KNeighborsClassifier(n_neighbors=1)\nclf.fit(X, y)\n</pre> # NOTE: We are using dataset 68 from the test server: https://test.openml.org/d/68 dataset = openml.datasets.get_dataset(dataset_id=\"eeg-eye-state\", version=1) X, y, categorical_indicator, attribute_names = dataset.get_data(     target=dataset.default_target_attribute ) clf = neighbors.KNeighborsClassifier(n_neighbors=1) clf.fit(X, y) <p>You can also ask for meta-data to automatically preprocess the data.</p> <ul> <li>e.g. categorical features -&gt; do feature encoding</li> </ul> In\u00a0[\u00a0]: Copied! <pre>dataset = openml.datasets.get_dataset(17)\nX, y, categorical_indicator, attribute_names = dataset.get_data(\n    target=dataset.default_target_attribute\n)\nprint(f\"Categorical features: {categorical_indicator}\")\ntransformer = compose.ColumnTransformer(\n    [(\"one_hot_encoder\", preprocessing.OneHotEncoder(categories=\"auto\"), categorical_indicator)]\n)\nX = transformer.fit_transform(X)\nclf.fit(X, y)\n</pre> dataset = openml.datasets.get_dataset(17) X, y, categorical_indicator, attribute_names = dataset.get_data(     target=dataset.default_target_attribute ) print(f\"Categorical features: {categorical_indicator}\") transformer = compose.ColumnTransformer(     [(\"one_hot_encoder\", preprocessing.OneHotEncoder(categories=\"auto\"), categorical_indicator)] ) X = transformer.fit_transform(X) clf.fit(X, y) In\u00a0[\u00a0]: Copied! <pre># Get a task\ntask = openml.tasks.get_task(403)\n\n# Build any classifier or pipeline\nclf = tree.DecisionTreeClassifier()\n\n# Run the flow\nrun = openml.runs.run_model_on_task(clf, task)\n\nprint(run)\n</pre> # Get a task task = openml.tasks.get_task(403)  # Build any classifier or pipeline clf = tree.DecisionTreeClassifier()  # Run the flow run = openml.runs.run_model_on_task(clf, task)  print(run) <p>Share the run on the OpenML server</p> <p>So far the run is only available locally. By calling the publish function, the run is sent to the OpenML server:</p> In\u00a0[\u00a0]: Copied! <pre>myrun = run.publish()\n# For this tutorial, our configuration publishes to the test server\n# as to not pollute the main server.\nprint(f\"Uploaded to {myrun.openml_url}\")\n</pre> myrun = run.publish() # For this tutorial, our configuration publishes to the test server # as to not pollute the main server. print(f\"Uploaded to {myrun.openml_url}\") <p>We can now also inspect the flow object which was automatically created:</p> In\u00a0[\u00a0]: Copied! <pre>flow = openml.flows.get_flow(run.flow_id)\nprint(flow)\n</pre> flow = openml.flows.get_flow(run.flow_id) print(flow) In\u00a0[\u00a0]: Copied! <pre>task = openml.tasks.get_task(96)\n\n# OpenML helper functions for sklearn can be plugged in directly for complicated pipelines\nfrom openml.extensions.sklearn import cat, cont\n\npipe = pipeline.Pipeline(\n    steps=[\n        (\n            \"Preprocessing\",\n            compose.ColumnTransformer(\n                [\n                    (\n                        \"categorical\",\n                        preprocessing.OneHotEncoder(handle_unknown=\"ignore\"),\n                        cat,  # returns the categorical feature indices\n                    ),\n                    (\n                        \"continuous\",\n                        impute.SimpleImputer(strategy=\"median\"),\n                        cont,\n                    ),  # returns the numeric feature indices\n                ]\n            ),\n        ),\n        (\"Classifier\", ensemble.RandomForestClassifier(n_estimators=10)),\n    ]\n)\n\nrun = openml.runs.run_model_on_task(pipe, task, avoid_duplicate_runs=False)\nmyrun = run.publish()\nprint(f\"Uploaded to {myrun.openml_url}\")\n</pre> task = openml.tasks.get_task(96)  # OpenML helper functions for sklearn can be plugged in directly for complicated pipelines from openml.extensions.sklearn import cat, cont  pipe = pipeline.Pipeline(     steps=[         (             \"Preprocessing\",             compose.ColumnTransformer(                 [                     (                         \"categorical\",                         preprocessing.OneHotEncoder(handle_unknown=\"ignore\"),                         cat,  # returns the categorical feature indices                     ),                     (                         \"continuous\",                         impute.SimpleImputer(strategy=\"median\"),                         cont,                     ),  # returns the numeric feature indices                 ]             ),         ),         (\"Classifier\", ensemble.RandomForestClassifier(n_estimators=10)),     ] )  run = openml.runs.run_model_on_task(pipe, task, avoid_duplicate_runs=False) myrun = run.publish() print(f\"Uploaded to {myrun.openml_url}\") <p>The above pipeline works with the helper functions that internally deal with pandas DataFrame. In the case, pandas is not available, or a NumPy based data processing is the requirement, the above pipeline is presented below to work with NumPy.</p> In\u00a0[\u00a0]: Copied! <pre># Extracting the indices of the categorical columns\nfeatures = task.get_dataset().features\ncategorical_feature_indices = []\nnumeric_feature_indices = []\nfor i in range(len(features)):\n    if features[i].name == task.target_name:\n        continue\n    if features[i].data_type == \"nominal\":\n        categorical_feature_indices.append(i)\n    else:\n        numeric_feature_indices.append(i)\n\npipe = pipeline.Pipeline(\n    steps=[\n        (\n            \"Preprocessing\",\n            compose.ColumnTransformer(\n                [\n                    (\n                        \"categorical\",\n                        preprocessing.OneHotEncoder(handle_unknown=\"ignore\"),\n                        categorical_feature_indices,\n                    ),\n                    (\n                        \"continuous\",\n                        impute.SimpleImputer(strategy=\"median\"),\n                        numeric_feature_indices,\n                    ),\n                ]\n            ),\n        ),\n        (\"Classifier\", ensemble.RandomForestClassifier(n_estimators=10)),\n    ]\n)\n\nrun = openml.runs.run_model_on_task(pipe, task, avoid_duplicate_runs=False)\nmyrun = run.publish()\nprint(f\"Uploaded to {myrun.openml_url}\")\n</pre> # Extracting the indices of the categorical columns features = task.get_dataset().features categorical_feature_indices = [] numeric_feature_indices = [] for i in range(len(features)):     if features[i].name == task.target_name:         continue     if features[i].data_type == \"nominal\":         categorical_feature_indices.append(i)     else:         numeric_feature_indices.append(i)  pipe = pipeline.Pipeline(     steps=[         (             \"Preprocessing\",             compose.ColumnTransformer(                 [                     (                         \"categorical\",                         preprocessing.OneHotEncoder(handle_unknown=\"ignore\"),                         categorical_feature_indices,                     ),                     (                         \"continuous\",                         impute.SimpleImputer(strategy=\"median\"),                         numeric_feature_indices,                     ),                 ]             ),         ),         (\"Classifier\", ensemble.RandomForestClassifier(n_estimators=10)),     ] )  run = openml.runs.run_model_on_task(pipe, task, avoid_duplicate_runs=False) myrun = run.publish() print(f\"Uploaded to {myrun.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>task = openml.tasks.get_task(96)\n\n# The following lines can then be executed offline:\nrun = openml.runs.run_model_on_task(\n    pipe,\n    task,\n    avoid_duplicate_runs=False,\n    upload_flow=False,\n)\n\n# The run may be stored offline, and the flow will be stored along with it:\nrun.to_filesystem(directory=\"myrun\")\n\n# They may be loaded and uploaded at a later time\nrun = openml.runs.OpenMLRun.from_filesystem(directory=\"myrun\")\nrun.publish()\n\n# Publishing the run will automatically upload the related flow if\n# it does not yet exist on the server.\n</pre> task = openml.tasks.get_task(96)  # The following lines can then be executed offline: run = openml.runs.run_model_on_task(     pipe,     task,     avoid_duplicate_runs=False,     upload_flow=False, )  # The run may be stored offline, and the flow will be stored along with it: run.to_filesystem(directory=\"myrun\")  # They may be loaded and uploaded at a later time run = openml.runs.OpenMLRun.from_filesystem(directory=\"myrun\") run.publish()  # Publishing the run will automatically upload the related flow if # it does not yet exist on the server. <p>Alternatively, one can also directly run flows.</p> In\u00a0[\u00a0]: Copied! <pre># Get a task\ntask = openml.tasks.get_task(403)\n\n# Build any classifier or pipeline\nclf = tree.ExtraTreeClassifier()\n\n# Obtain the scikit-learn extension interface to convert the classifier\n# into a flow object.\nextension = openml.extensions.get_extension_by_model(clf)\nflow = extension.model_to_flow(clf)\n\nrun = openml.runs.run_flow_on_task(flow, task)\n</pre> # Get a task task = openml.tasks.get_task(403)  # Build any classifier or pipeline clf = tree.ExtraTreeClassifier()  # Obtain the scikit-learn extension interface to convert the classifier # into a flow object. extension = openml.extensions.get_extension_by_model(clf) flow = extension.model_to_flow(clf)  run = openml.runs.run_flow_on_task(flow, task) In\u00a0[\u00a0]: Copied! <pre># Easy benchmarking:\nfor task_id in [115]:  # Add further tasks. Disclaimer: they might take some time\n    task = openml.tasks.get_task(task_id)\n    data = openml.datasets.get_dataset(task.dataset_id)\n    clf = neighbors.KNeighborsClassifier(n_neighbors=5)\n\n    run = openml.runs.run_model_on_task(clf, task, avoid_duplicate_runs=False)\n    myrun = run.publish()\n    print(f\"kNN on {data.name}: {myrun.openml_url}\")\n</pre> # Easy benchmarking: for task_id in [115]:  # Add further tasks. Disclaimer: they might take some time     task = openml.tasks.get_task(task_id)     data = openml.datasets.get_dataset(task.dataset_id)     clf = neighbors.KNeighborsClassifier(n_neighbors=5)      run = openml.runs.run_model_on_task(clf, task, avoid_duplicate_runs=False)     myrun = run.publish()     print(f\"kNN on {data.name}: {myrun.openml_url}\") In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/30_extended/flows_and_runs_tutorial/#flows-and-runs","title":"Flows and Runs\u00b6","text":"<p>This tutorial covers how to train/run a model and how to upload the results.</p>"},{"location":"examples/30_extended/flows_and_runs_tutorial/#train-machine-learning-models","title":"Train machine learning models\u00b6","text":"<p>Train a scikit-learn model on the data manually.</p>"},{"location":"examples/30_extended/flows_and_runs_tutorial/#runs-easily-explore-models","title":"Runs: Easily explore models\u00b6","text":"<p>We can run (many) scikit-learn algorithms on (many) OpenML tasks.</p>"},{"location":"examples/30_extended/flows_and_runs_tutorial/#it-also-works-with-pipelines","title":"It also works with pipelines\u00b6","text":"<p>When you need to handle 'dirty' data, build pipelines to model then automatically. To demonstrate this using the dataset <code>credit-a &lt;https://test.openml.org/d/16&gt;</code>_ via <code>task &lt;https://test.openml.org/t/96&gt;</code>_ as it contains both numerical and categorical variables and missing values in both.</p>"},{"location":"examples/30_extended/flows_and_runs_tutorial/#running-flows-on-tasks-offline-for-later-upload","title":"Running flows on tasks offline for later upload\u00b6","text":"<p>For those scenarios where there is no access to internet, it is possible to run a model on a task without uploading results or flows to the server immediately.</p> <p>To perform the following line offline, it is required to have been called before such that the task is cached on the local openml cache directory:</p>"},{"location":"examples/30_extended/flows_and_runs_tutorial/#challenge","title":"Challenge\u00b6","text":"<p>Try to build the best possible models on several OpenML tasks, compare your results with the rest of the class and learn from them. Some tasks you could try (or browse openml.org):</p> <ul> <li>EEG eye state: data_id:<code>1471 &lt;https://www.openml.org/d/1471&gt;</code>, task_id:<code>14951 &lt;https://www.openml.org/t/14951&gt;</code></li> <li>Volcanoes on Venus: data_id:<code>1527 &lt;https://www.openml.org/d/1527&gt;</code>, task_id:<code>10103 &lt;https://www.openml.org/t/10103&gt;</code></li> <li>Walking activity: data_id:<code>1509 &lt;https://www.openml.org/d/1509&gt;</code>, task_id:<code>9945 &lt;https://www.openml.org/t/9945&gt;</code>, 150k instances.</li> <li>Covertype (Satellite): data_id:<code>150 &lt;https://www.openml.org/d/150&gt;</code>, task_id:<code>218 &lt;https://www.openml.org/t/218&gt;</code>, 500k instances.</li> <li>Higgs (Physics): data_id:<code>23512 &lt;https://www.openml.org/d/23512&gt;</code>, task_id:<code>52950 &lt;https://www.openml.org/t/52950&gt;</code>, 100k instances, missing values.</li> </ul>"},{"location":"examples/30_extended/plot_svm_hyperparameters_tutorial/","title":"Plotting hyperparameter surfaces","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\nimport numpy as np\n</pre> import openml import numpy as np In\u00a0[\u00a0]: Copied! <pre>df = openml.evaluations.list_evaluations_setups(\n    function=\"predictive_accuracy\",\n    flows=[8353],\n    tasks=[6],\n    # Using this flag incorporates the hyperparameters into the returned dataframe. Otherwise,\n    # the dataframe would contain a field ``paramaters`` containing an unparsed dictionary.\n    parameters_in_separate_columns=True,\n)\nprint(df.head(n=10))\n</pre> df = openml.evaluations.list_evaluations_setups(     function=\"predictive_accuracy\",     flows=[8353],     tasks=[6],     # Using this flag incorporates the hyperparameters into the returned dataframe. Otherwise,     # the dataframe would contain a field ``paramaters`` containing an unparsed dictionary.     parameters_in_separate_columns=True, ) print(df.head(n=10)) <p>We can see all the hyperparameter names in the columns of the dataframe:</p> In\u00a0[\u00a0]: Copied! <pre>for name in df.columns:\n    print(name)\n</pre> for name in df.columns:     print(name) <p>Next, we cast and transform the hyperparameters of interest (<code>C</code> and <code>gamma</code>) so that we can nicely plot them.</p> In\u00a0[\u00a0]: Copied! <pre>hyperparameters = [\"sklearn.svm.classes.SVC(16)_C\", \"sklearn.svm.classes.SVC(16)_gamma\"]\ndf[hyperparameters] = df[hyperparameters].astype(float).apply(np.log10)\n</pre> hyperparameters = [\"sklearn.svm.classes.SVC(16)_C\", \"sklearn.svm.classes.SVC(16)_gamma\"] df[hyperparameters] = df[hyperparameters].astype(float).apply(np.log10) In\u00a0[\u00a0]: Copied! <pre>df.plot.hexbin(\n    x=\"sklearn.svm.classes.SVC(16)_C\",\n    y=\"sklearn.svm.classes.SVC(16)_gamma\",\n    C=\"value\",\n    reduce_C_function=np.mean,\n    gridsize=25,\n    title=\"SVM performance landscape\",\n)\n</pre> df.plot.hexbin(     x=\"sklearn.svm.classes.SVC(16)_C\",     y=\"sklearn.svm.classes.SVC(16)_gamma\",     C=\"value\",     reduce_C_function=np.mean,     gridsize=25,     title=\"SVM performance landscape\", ) In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nC = df[\"sklearn.svm.classes.SVC(16)_C\"]\ngamma = df[\"sklearn.svm.classes.SVC(16)_gamma\"]\nscore = df[\"value\"]\n\n# Plotting all evaluations:\nax.plot(C, gamma, \"ko\", ms=1)\n# Create a contour plot\ncntr = ax.tricontourf(C, gamma, score, levels=12, cmap=\"RdBu_r\")\n# Adjusting the colorbar\nfig.colorbar(cntr, ax=ax, label=\"accuracy\")\n# Adjusting the axis limits\nax.set(\n    xlim=(min(C), max(C)),\n    ylim=(min(gamma), max(gamma)),\n    xlabel=\"C (log10)\",\n    ylabel=\"gamma (log10)\",\n)\nax.set_title(\"SVM performance landscape\")\n# License: BSD 3-Clause\n</pre> import matplotlib.pyplot as plt  fig, ax = plt.subplots()  C = df[\"sklearn.svm.classes.SVC(16)_C\"] gamma = df[\"sklearn.svm.classes.SVC(16)_gamma\"] score = df[\"value\"]  # Plotting all evaluations: ax.plot(C, gamma, \"ko\", ms=1) # Create a contour plot cntr = ax.tricontourf(C, gamma, score, levels=12, cmap=\"RdBu_r\") # Adjusting the colorbar fig.colorbar(cntr, ax=ax, label=\"accuracy\") # Adjusting the axis limits ax.set(     xlim=(min(C), max(C)),     ylim=(min(gamma), max(gamma)),     xlabel=\"C (log10)\",     ylabel=\"gamma (log10)\", ) ax.set_title(\"SVM performance landscape\") # License: BSD 3-Clause"},{"location":"examples/30_extended/plot_svm_hyperparameters_tutorial/#plotting-hyperparameter-surfaces","title":"Plotting hyperparameter surfaces\u00b6","text":""},{"location":"examples/30_extended/plot_svm_hyperparameters_tutorial/#first-step-obtaining-the-data","title":"First step - obtaining the data\u00b6","text":"<p>First, we need to choose an SVM flow, for example 8353, and a task. Finding the IDs of them are not part of this tutorial, this could for example be done via the website.</p> <p>For this we use the function <code>list_evaluations_setup</code> which can automatically join evaluations conducted by the server with the hyperparameter settings extracted from the uploaded runs (called setup).</p>"},{"location":"examples/30_extended/plot_svm_hyperparameters_tutorial/#option-1-plotting-via-the-pandas-helper-functions","title":"Option 1 - plotting via the pandas helper functions\u00b6","text":""},{"location":"examples/30_extended/plot_svm_hyperparameters_tutorial/#option-2-plotting-via-matplotlib","title":"Option 2 - plotting via matplotlib\u00b6","text":""},{"location":"examples/30_extended/run_setup_tutorial/","title":"Run Setup","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport openml\nfrom openml.extensions.sklearn import cat, cont\n\nfrom sklearn.pipeline import make_pipeline, Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder, FunctionTransformer\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.decomposition import TruncatedSVD\n</pre>  import numpy as np import openml from openml.extensions.sklearn import cat, cont  from sklearn.pipeline import make_pipeline, Pipeline from sklearn.compose import ColumnTransformer from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder, FunctionTransformer from sklearn.ensemble import RandomForestClassifier from sklearn.decomposition import TruncatedSVD <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() <ol> <li>Create a flow and use it to solve a task</li> </ol> <p>First, let's download the task that we are interested in</p> In\u00a0[\u00a0]: Copied! <pre>task = openml.tasks.get_task(6)\n</pre> task = openml.tasks.get_task(6) <p>we will create a fairly complex model, with many preprocessing components and many potential hyperparameters. Of course, the model can be as complex and as easy as you want it to be</p> In\u00a0[\u00a0]: Copied! <pre>cat_imp = make_pipeline(\n    OneHotEncoder(handle_unknown=\"ignore\"),\n    TruncatedSVD(),\n)\ncont_imp = SimpleImputer(strategy=\"median\")\nct = ColumnTransformer([(\"cat\", cat_imp, cat), (\"cont\", cont_imp, cont)])\nmodel_original = Pipeline(\n    steps=[\n        (\"transform\", ct),\n        (\"estimator\", RandomForestClassifier()),\n    ]\n)\n</pre> cat_imp = make_pipeline(     OneHotEncoder(handle_unknown=\"ignore\"),     TruncatedSVD(), ) cont_imp = SimpleImputer(strategy=\"median\") ct = ColumnTransformer([(\"cat\", cat_imp, cat), (\"cont\", cont_imp, cont)]) model_original = Pipeline(     steps=[         (\"transform\", ct),         (\"estimator\", RandomForestClassifier()),     ] ) <p>Let's change some hyperparameters. Of course, in any good application we would tune them using, e.g., Random Search or Bayesian Optimization, but for the purpose of this tutorial we set them to some specific values that might or might not be optimal</p> In\u00a0[\u00a0]: Copied! <pre>hyperparameters_original = {\n    \"estimator__criterion\": \"gini\",\n    \"estimator__n_estimators\": 50,\n    \"estimator__max_depth\": 10,\n    \"estimator__min_samples_leaf\": 1,\n}\nmodel_original.set_params(**hyperparameters_original)\n\n# solve the task and upload the result (this implicitly creates the flow)\nrun = openml.runs.run_model_on_task(model_original, task, avoid_duplicate_runs=False)\nrun_original = run.publish()  # this implicitly uploads the flow\n</pre> hyperparameters_original = {     \"estimator__criterion\": \"gini\",     \"estimator__n_estimators\": 50,     \"estimator__max_depth\": 10,     \"estimator__min_samples_leaf\": 1, } model_original.set_params(**hyperparameters_original)  # solve the task and upload the result (this implicitly creates the flow) run = openml.runs.run_model_on_task(model_original, task, avoid_duplicate_runs=False) run_original = run.publish()  # this implicitly uploads the flow In\u00a0[\u00a0]: Copied! <pre># obtain setup id (note that the setup id is assigned by the OpenML server -\n# therefore it was not yet available in our local copy of the run)\nrun_downloaded = openml.runs.get_run(run_original.run_id)\nsetup_id = run_downloaded.setup_id\n\n# after this, we can easily reinstantiate the model\nmodel_duplicate = openml.setups.initialize_model(setup_id)\n# it will automatically have all the hyperparameters set\n\n# and run the task again\nrun_duplicate = openml.runs.run_model_on_task(model_duplicate, task, avoid_duplicate_runs=False)\n</pre> # obtain setup id (note that the setup id is assigned by the OpenML server - # therefore it was not yet available in our local copy of the run) run_downloaded = openml.runs.get_run(run_original.run_id) setup_id = run_downloaded.setup_id  # after this, we can easily reinstantiate the model model_duplicate = openml.setups.initialize_model(setup_id) # it will automatically have all the hyperparameters set  # and run the task again run_duplicate = openml.runs.run_model_on_task(model_duplicate, task, avoid_duplicate_runs=False) In\u00a0[\u00a0]: Copied! <pre># the run has stored all predictions in the field data content\nnp.testing.assert_array_equal(run_original.data_content, run_duplicate.data_content)\n</pre> # the run has stored all predictions in the field data content np.testing.assert_array_equal(run_original.data_content, run_duplicate.data_content) In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n\n# By: Jan N. van Rijn\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example()  # By: Jan N. van Rijn # License: BSD 3-Clause"},{"location":"examples/30_extended/run_setup_tutorial/#run-setup","title":"Run Setup\u00b6","text":"<p>One of the key features of the openml-python library is that is allows to reinstantiate flows with hyperparameter settings that were uploaded before. This tutorial uses the concept of setups. Although setups are not extensively described in the OpenML documentation (because most users will not directly use them), they form a important concept within OpenML distinguishing between hyperparameter configurations. A setup is the combination of a flow with all its hyperparameters set.</p> <p>A key requirement for reinstantiating a flow is to have the same scikit-learn version as the flow that was uploaded. However, this tutorial will upload the flow (that will later be reinstantiated) itself, so it can be ran with any scikit-learn version that is supported by this library. In this case, the requirement of the corresponding scikit-learn versions is automatically met.</p> <p>In this tutorial we will 1) Create a flow and use it to solve a task; 2) Download the flow, reinstantiate the model with same hyperparameters, and solve the same task again; 3) We will verify that the obtained results are exactly the same.</p>"},{"location":"examples/30_extended/run_setup_tutorial/#2-download-the-flow-and-solve-the-same-task-again","title":"2) Download the flow and solve the same task again.\u00b6","text":""},{"location":"examples/30_extended/run_setup_tutorial/#3-we-will-verify-that-the-obtained-results-are-exactly-the-same","title":"3) We will verify that the obtained results are exactly the same.\u00b6","text":""},{"location":"examples/30_extended/study_tutorial/","title":"Benchmark studies","text":"In\u00a0[\u00a0]: Copied! <pre>import uuid\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nimport openml\n</pre> import uuid  from sklearn.ensemble import RandomForestClassifier  import openml In\u00a0[\u00a0]: Copied! <pre>studies = openml.study.list_studies(output_format=\"dataframe\", status=\"all\")\nprint(studies.head(n=10))\n</pre> studies = openml.study.list_studies(output_format=\"dataframe\", status=\"all\") print(studies.head(n=10)) <p>This is done based on the study ID.</p> In\u00a0[\u00a0]: Copied! <pre>study = openml.study.get_study(123)\nprint(study)\n</pre> study = openml.study.get_study(123) print(study) <p>Studies also features a description:</p> In\u00a0[\u00a0]: Copied! <pre>print(study.description)\n</pre> print(study.description) <p>Studies are a container for runs:</p> In\u00a0[\u00a0]: Copied! <pre>print(study.runs)\n</pre> print(study.runs) <p>And we can use the evaluation listing functionality to learn more about the evaluations available for the conducted runs:</p> In\u00a0[\u00a0]: Copied! <pre>evaluations = openml.evaluations.list_evaluations(\n    function=\"predictive_accuracy\",\n    study=study.study_id,\n    output_format=\"dataframe\",\n)\nprint(evaluations.head())\n</pre> evaluations = openml.evaluations.list_evaluations(     function=\"predictive_accuracy\",     study=study.study_id,     output_format=\"dataframe\", ) print(evaluations.head()) <p>We'll use the test server for the rest of this tutorial.</p> <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() In\u00a0[\u00a0]: Copied! <pre># Model to be used\nclf = RandomForestClassifier()\n\n# We'll create a study with one run on 3 datasets present in the suite\ntasks = [115, 259, 307]\n\n# To verify\n# https://test.openml.org/api/v1/study/1\nsuite = openml.study.get_suite(\"OpenML100\")\nprint(all(t_id in suite.tasks for t_id in tasks))\n\nrun_ids = []\nfor task_id in tasks:\n    task = openml.tasks.get_task(task_id)\n    run = openml.runs.run_model_on_task(clf, task)\n    run.publish()\n    run_ids.append(run.run_id)\n\n# The study needs a machine-readable and unique alias. To obtain this,\n# we simply generate a random uuid.\nalias = uuid.uuid4().hex\n\nnew_study = openml.study.create_study(\n    name=\"Test-Study\",\n    description=\"Test study for the Python tutorial on studies\",\n    run_ids=run_ids,\n    alias=alias,\n    benchmark_suite=suite.study_id,\n)\nnew_study.publish()\nprint(new_study)\n</pre> # Model to be used clf = RandomForestClassifier()  # We'll create a study with one run on 3 datasets present in the suite tasks = [115, 259, 307]  # To verify # https://test.openml.org/api/v1/study/1 suite = openml.study.get_suite(\"OpenML100\") print(all(t_id in suite.tasks for t_id in tasks))  run_ids = [] for task_id in tasks:     task = openml.tasks.get_task(task_id)     run = openml.runs.run_model_on_task(clf, task)     run.publish()     run_ids.append(run.run_id)  # The study needs a machine-readable and unique alias. To obtain this, # we simply generate a random uuid. alias = uuid.uuid4().hex  new_study = openml.study.create_study(     name=\"Test-Study\",     description=\"Test study for the Python tutorial on studies\",     run_ids=run_ids,     alias=alias,     benchmark_suite=suite.study_id, ) new_study.publish() print(new_study) In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/30_extended/study_tutorial/#benchmark-studies","title":"Benchmark studies\u00b6","text":"<p>How to list, download and upload benchmark studies. In contrast to benchmark suites which hold a list of tasks, studies hold a list of runs. As runs contain all information on flows and tasks, all required information about a study can be retrieved.</p>"},{"location":"examples/30_extended/study_tutorial/#listing-studies","title":"Listing studies\u00b6","text":"<ul> <li>Use the output_format parameter to select output type</li> <li>Default gives <code>dict</code>, but we'll use <code>dataframe</code> to obtain an easier-to-work-with data structure</li> </ul>"},{"location":"examples/30_extended/study_tutorial/#downloading-studies","title":"Downloading studies\u00b6","text":""},{"location":"examples/30_extended/study_tutorial/#uploading-studies","title":"Uploading studies\u00b6","text":"<p>Creating a study is as simple as creating any kind of other OpenML entity. In this examples we'll create a few runs for the OpenML-100 benchmark suite which is available on the OpenML test server.</p>"},{"location":"examples/30_extended/suites_tutorial/","title":"Benchmark suites","text":"In\u00a0[\u00a0]: Copied! <pre>import uuid\n\nimport numpy as np\n\nimport openml\n</pre> import uuid  import numpy as np  import openml In\u00a0[\u00a0]: Copied! <pre>suites = openml.study.list_suites(output_format=\"dataframe\", status=\"all\")\nprint(suites.head(n=10))\n</pre> suites = openml.study.list_suites(output_format=\"dataframe\", status=\"all\") print(suites.head(n=10)) <p>This is done based on the dataset ID.</p> In\u00a0[\u00a0]: Copied! <pre>suite = openml.study.get_suite(99)\nprint(suite)\n</pre> suite = openml.study.get_suite(99) print(suite) <p>Suites also feature a description:</p> In\u00a0[\u00a0]: Copied! <pre>print(suite.description)\n</pre> print(suite.description) <p>Suites are a container for tasks:</p> In\u00a0[\u00a0]: Copied! <pre>print(suite.tasks)\n</pre> print(suite.tasks) <p>And we can use the task listing functionality to learn more about them:</p> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(output_format=\"dataframe\")\n</pre> tasks = openml.tasks.list_tasks(output_format=\"dataframe\") <p>Using <code>@</code> in pd.DataFrame.query accesses variables outside of the current dataframe.</p> In\u00a0[\u00a0]: Copied! <pre>tasks = tasks.query(\"tid in @suite.tasks\")\nprint(tasks.describe().transpose())\n</pre> tasks = tasks.query(\"tid in @suite.tasks\") print(tasks.describe().transpose()) <p>We'll use the test server for the rest of this tutorial.</p> <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() In\u00a0[\u00a0]: Copied! <pre>all_tasks = list(openml.tasks.list_tasks(output_format=\"dataframe\")[\"tid\"])\ntask_ids_for_suite = sorted(np.random.choice(all_tasks, replace=False, size=20))\n\n# The study needs a machine-readable and unique alias. To obtain this,\n# we simply generate a random uuid.\n\nalias = uuid.uuid4().hex\n\nnew_suite = openml.study.create_benchmark_suite(\n    name=\"Test-Suite\",\n    description=\"Test suite for the Python tutorial on benchmark suites\",\n    task_ids=task_ids_for_suite,\n    alias=alias,\n)\nnew_suite.publish()\nprint(new_suite)\n</pre> all_tasks = list(openml.tasks.list_tasks(output_format=\"dataframe\")[\"tid\"]) task_ids_for_suite = sorted(np.random.choice(all_tasks, replace=False, size=20))  # The study needs a machine-readable and unique alias. To obtain this, # we simply generate a random uuid.  alias = uuid.uuid4().hex  new_suite = openml.study.create_benchmark_suite(     name=\"Test-Suite\",     description=\"Test suite for the Python tutorial on benchmark suites\",     task_ids=task_ids_for_suite,     alias=alias, ) new_suite.publish() print(new_suite) In\u00a0[\u00a0]: Copied! <pre>openml.config.stop_using_configuration_for_example()\n# License: BSD 3-Clause\n</pre> openml.config.stop_using_configuration_for_example() # License: BSD 3-Clause"},{"location":"examples/30_extended/suites_tutorial/#benchmark-suites","title":"Benchmark suites\u00b6","text":"<p>How to list, download and upload benchmark suites.</p> <p>If you want to learn more about benchmark suites, check out our brief introductory tutorial \"Simple suites tutorial\" or the OpenML benchmark docs.</p>"},{"location":"examples/30_extended/suites_tutorial/#listing-suites","title":"Listing suites\u00b6","text":"<ul> <li>Use the output_format parameter to select output type</li> <li>Default gives <code>dict</code>, but we'll use <code>dataframe</code> to obtain an easier-to-work-with data structure</li> </ul>"},{"location":"examples/30_extended/suites_tutorial/#downloading-suites","title":"Downloading suites\u00b6","text":""},{"location":"examples/30_extended/suites_tutorial/#uploading-suites","title":"Uploading suites\u00b6","text":"<p>Uploading suites is as simple as uploading any kind of other OpenML entity - the only reason why we need so much code in this example is because we upload some random data.</p> <p>We'll take a random subset of at least ten tasks of all available tasks on the test server:</p>"},{"location":"examples/30_extended/task_manual_iteration_tutorial/","title":"Tasks: retrieving splits","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\n</pre> import openml <p>For this tutorial we will use the famous King+Rook versus King+Pawn on A7 dataset, which has the dataset ID 3 (dataset on OpenML), and for which there exist tasks with all important estimation procedures. It is small enough (less than 5000 samples) to efficiently use it in an example.</p> <p>We will first start with (task 233), which is a task with a holdout estimation procedure.</p> In\u00a0[\u00a0]: Copied! <pre>task_id = 233\ntask = openml.tasks.get_task(task_id)\n</pre> task_id = 233 task = openml.tasks.get_task(task_id) <p>Now that we have a task object we can obtain the number of repetitions, folds and samples as defined by the task:</p> In\u00a0[\u00a0]: Copied! <pre>n_repeats, n_folds, n_samples = task.get_split_dimensions()\n</pre> n_repeats, n_folds, n_samples = task.get_split_dimensions() <ul> <li><code>n_repeats</code>: Number of times the model quality estimation is performed</li> <li><code>n_folds</code>: Number of folds per repeat</li> <li><code>n_samples</code>: How many data points to use. This is only relevant for learning curve tasks</li> </ul> <p>A list of all available estimation procedures is available here.</p> <p>Task <code>233</code> is a simple task using the holdout estimation procedure and therefore has only a single repeat, a single fold and a single sample size:</p> In\u00a0[\u00a0]: Copied! <pre>print(\n    \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(\n        task_id,\n        n_repeats,\n        n_folds,\n        n_samples,\n    )\n)\n</pre> print(     \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(         task_id,         n_repeats,         n_folds,         n_samples,     ) ) <p>We can now retrieve the train/test split for this combination of repeats, folds and number of samples (indexing is zero-based). Usually, one would loop over all repeats, folds and sample sizes, but we can neglect this here as there is only a single repetition.</p> In\u00a0[\u00a0]: Copied! <pre>train_indices, test_indices = task.get_train_test_split_indices(\n    repeat=0,\n    fold=0,\n    sample=0,\n)\n\nprint(train_indices.shape, train_indices.dtype)\nprint(test_indices.shape, test_indices.dtype)\n</pre> train_indices, test_indices = task.get_train_test_split_indices(     repeat=0,     fold=0,     sample=0, )  print(train_indices.shape, train_indices.dtype) print(test_indices.shape, test_indices.dtype) <p>And then split the data based on this:</p> In\u00a0[\u00a0]: Copied! <pre>X, y = task.get_X_and_y(dataset_format=\"dataframe\")\nX_train = X.iloc[train_indices]\ny_train = y.iloc[train_indices]\nX_test = X.iloc[test_indices]\ny_test = y.iloc[test_indices]\n\nprint(\n    \"X_train.shape: {}, y_train.shape: {}, X_test.shape: {}, y_test.shape: {}\".format(\n        X_train.shape,\n        y_train.shape,\n        X_test.shape,\n        y_test.shape,\n    )\n)\n</pre> X, y = task.get_X_and_y(dataset_format=\"dataframe\") X_train = X.iloc[train_indices] y_train = y.iloc[train_indices] X_test = X.iloc[test_indices] y_test = y.iloc[test_indices]  print(     \"X_train.shape: {}, y_train.shape: {}, X_test.shape: {}, y_test.shape: {}\".format(         X_train.shape,         y_train.shape,         X_test.shape,         y_test.shape,     ) ) <p>Obviously, we can also retrieve cross-validation versions of the dataset used in task <code>233</code>:</p> In\u00a0[\u00a0]: Copied! <pre>task_id = 3\ntask = openml.tasks.get_task(task_id)\nX, y = task.get_X_and_y()\nn_repeats, n_folds, n_samples = task.get_split_dimensions()\nprint(\n    \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(\n        task_id,\n        n_repeats,\n        n_folds,\n        n_samples,\n    )\n)\n</pre> task_id = 3 task = openml.tasks.get_task(task_id) X, y = task.get_X_and_y() n_repeats, n_folds, n_samples = task.get_split_dimensions() print(     \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(         task_id,         n_repeats,         n_folds,         n_samples,     ) ) <p>And then perform the aforementioned iteration over all splits:</p> In\u00a0[\u00a0]: Copied! <pre>for repeat_idx in range(n_repeats):\n    for fold_idx in range(n_folds):\n        for sample_idx in range(n_samples):\n            train_indices, test_indices = task.get_train_test_split_indices(\n                repeat=repeat_idx,\n                fold=fold_idx,\n                sample=sample_idx,\n            )\n            X_train = X.iloc[train_indices]\n            y_train = y.iloc[train_indices]\n            X_test = X.iloc[test_indices]\n            y_test = y.iloc[test_indices]\n\n            print(\n                \"Repeat #{}, fold #{}, samples {}: X_train.shape: {}, \"\n                \"y_train.shape {}, X_test.shape {}, y_test.shape {}\".format(\n                    repeat_idx,\n                    fold_idx,\n                    sample_idx,\n                    X_train.shape,\n                    y_train.shape,\n                    X_test.shape,\n                    y_test.shape,\n                )\n            )\n</pre> for repeat_idx in range(n_repeats):     for fold_idx in range(n_folds):         for sample_idx in range(n_samples):             train_indices, test_indices = task.get_train_test_split_indices(                 repeat=repeat_idx,                 fold=fold_idx,                 sample=sample_idx,             )             X_train = X.iloc[train_indices]             y_train = y.iloc[train_indices]             X_test = X.iloc[test_indices]             y_test = y.iloc[test_indices]              print(                 \"Repeat #{}, fold #{}, samples {}: X_train.shape: {}, \"                 \"y_train.shape {}, X_test.shape {}, y_test.shape {}\".format(                     repeat_idx,                     fold_idx,                     sample_idx,                     X_train.shape,                     y_train.shape,                     X_test.shape,                     y_test.shape,                 )             ) <p>And also versions with multiple repeats:</p> In\u00a0[\u00a0]: Copied! <pre>task_id = 1767\ntask = openml.tasks.get_task(task_id)\nX, y = task.get_X_and_y()\nn_repeats, n_folds, n_samples = task.get_split_dimensions()\nprint(\n    \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(\n        task_id,\n        n_repeats,\n        n_folds,\n        n_samples,\n    )\n)\n</pre> task_id = 1767 task = openml.tasks.get_task(task_id) X, y = task.get_X_and_y() n_repeats, n_folds, n_samples = task.get_split_dimensions() print(     \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(         task_id,         n_repeats,         n_folds,         n_samples,     ) ) <p>And then again perform the aforementioned iteration over all splits:</p> In\u00a0[\u00a0]: Copied! <pre>for repeat_idx in range(n_repeats):\n    for fold_idx in range(n_folds):\n        for sample_idx in range(n_samples):\n            train_indices, test_indices = task.get_train_test_split_indices(\n                repeat=repeat_idx,\n                fold=fold_idx,\n                sample=sample_idx,\n            )\n            X_train = X.iloc[train_indices]\n            y_train = y.iloc[train_indices]\n            X_test = X.iloc[test_indices]\n            y_test = y.iloc[test_indices]\n\n            print(\n                \"Repeat #{}, fold #{}, samples {}: X_train.shape: {}, \"\n                \"y_train.shape {}, X_test.shape {}, y_test.shape {}\".format(\n                    repeat_idx,\n                    fold_idx,\n                    sample_idx,\n                    X_train.shape,\n                    y_train.shape,\n                    X_test.shape,\n                    y_test.shape,\n                )\n            )\n</pre> for repeat_idx in range(n_repeats):     for fold_idx in range(n_folds):         for sample_idx in range(n_samples):             train_indices, test_indices = task.get_train_test_split_indices(                 repeat=repeat_idx,                 fold=fold_idx,                 sample=sample_idx,             )             X_train = X.iloc[train_indices]             y_train = y.iloc[train_indices]             X_test = X.iloc[test_indices]             y_test = y.iloc[test_indices]              print(                 \"Repeat #{}, fold #{}, samples {}: X_train.shape: {}, \"                 \"y_train.shape {}, X_test.shape {}, y_test.shape {}\".format(                     repeat_idx,                     fold_idx,                     sample_idx,                     X_train.shape,                     y_train.shape,                     X_test.shape,                     y_test.shape,                 )             ) <p>And finally a task based on learning curves:</p> In\u00a0[\u00a0]: Copied! <pre>task_id = 1702\ntask = openml.tasks.get_task(task_id)\nX, y = task.get_X_and_y()\nn_repeats, n_folds, n_samples = task.get_split_dimensions()\nprint(\n    \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(\n        task_id,\n        n_repeats,\n        n_folds,\n        n_samples,\n    )\n)\n</pre> task_id = 1702 task = openml.tasks.get_task(task_id) X, y = task.get_X_and_y() n_repeats, n_folds, n_samples = task.get_split_dimensions() print(     \"Task {}: number of repeats: {}, number of folds: {}, number of samples {}.\".format(         task_id,         n_repeats,         n_folds,         n_samples,     ) ) <p>And then again perform the aforementioned iteration over all splits:</p> In\u00a0[\u00a0]: Copied! <pre>for repeat_idx in range(n_repeats):\n    for fold_idx in range(n_folds):\n        for sample_idx in range(n_samples):\n            train_indices, test_indices = task.get_train_test_split_indices(\n                repeat=repeat_idx,\n                fold=fold_idx,\n                sample=sample_idx,\n            )\n            X_train = X.iloc[train_indices]\n            y_train = y.iloc[train_indices]\n            X_test = X.iloc[test_indices]\n            y_test = y.iloc[test_indices]\n\n            print(\n                \"Repeat #{}, fold #{}, samples {}: X_train.shape: {}, \"\n                \"y_train.shape {}, X_test.shape {}, y_test.shape {}\".format(\n                    repeat_idx,\n                    fold_idx,\n                    sample_idx,\n                    X_train.shape,\n                    y_train.shape,\n                    X_test.shape,\n                    y_test.shape,\n                )\n            )\n# License: BSD 3-Clause\n</pre> for repeat_idx in range(n_repeats):     for fold_idx in range(n_folds):         for sample_idx in range(n_samples):             train_indices, test_indices = task.get_train_test_split_indices(                 repeat=repeat_idx,                 fold=fold_idx,                 sample=sample_idx,             )             X_train = X.iloc[train_indices]             y_train = y.iloc[train_indices]             X_test = X.iloc[test_indices]             y_test = y.iloc[test_indices]              print(                 \"Repeat #{}, fold #{}, samples {}: X_train.shape: {}, \"                 \"y_train.shape {}, X_test.shape {}, y_test.shape {}\".format(                     repeat_idx,                     fold_idx,                     sample_idx,                     X_train.shape,                     y_train.shape,                     X_test.shape,                     y_test.shape,                 )             ) # License: BSD 3-Clause"},{"location":"examples/30_extended/task_manual_iteration_tutorial/#tasks-retrieving-splits","title":"Tasks: retrieving splits\u00b6","text":"<p>Tasks define a target and a train/test split. Normally, they are the input to the function <code>openml.runs.run_model_on_task</code> which automatically runs the model on all splits of the task. However, sometimes it is necessary to manually split a dataset to perform experiments outside of the functions provided by OpenML. One such example is in the benchmark library HPOBench which extensively uses data from OpenML, but not OpenML's functionality to conduct runs.</p>"},{"location":"examples/30_extended/tasks_tutorial/","title":"Tasks","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\nfrom openml.tasks import TaskType\n</pre> import openml from openml.tasks import TaskType <p>Tasks are identified by IDs and can be accessed in two different ways:</p> <ol> <li>In a list providing basic information on all tasks available on OpenML. This function will not download the actual tasks, but will instead download meta data that can be used to filter the tasks and retrieve a set of IDs. We can filter this list, for example, we can only list tasks having a special tag or only tasks for a specific target such as supervised classification.</li> <li>A single task by its ID. It contains all meta information, the target metric, the splits and an iterator which can be used to access the splits in a useful manner.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(\n    task_type=TaskType.SUPERVISED_CLASSIFICATION, output_format=\"dataframe\"\n)\nprint(tasks.columns)\nprint(f\"First 5 of {len(tasks)} tasks:\")\nprint(tasks.head())\n</pre> tasks = openml.tasks.list_tasks(     task_type=TaskType.SUPERVISED_CLASSIFICATION, output_format=\"dataframe\" ) print(tasks.columns) print(f\"First 5 of {len(tasks)} tasks:\") print(tasks.head()) <p>We can filter the list of tasks to only contain datasets with more than 500 samples, but less than 1000 samples:</p> In\u00a0[\u00a0]: Copied! <pre>filtered_tasks = tasks.query(\"NumberOfInstances &gt; 500 and NumberOfInstances &lt; 1000\")\nprint(list(filtered_tasks.index))\n</pre> filtered_tasks = tasks.query(\"NumberOfInstances &gt; 500 and NumberOfInstances &lt; 1000\") print(list(filtered_tasks.index)) In\u00a0[\u00a0]: Copied! <pre># Number of tasks\nprint(len(filtered_tasks))\n</pre> # Number of tasks print(len(filtered_tasks)) <p>Then, we can further restrict the tasks to all have the same resampling strategy:</p> In\u00a0[\u00a0]: Copied! <pre>filtered_tasks = filtered_tasks.query('estimation_procedure == \"10-fold Crossvalidation\"')\nprint(list(filtered_tasks.index))\n</pre> filtered_tasks = filtered_tasks.query('estimation_procedure == \"10-fold Crossvalidation\"') print(list(filtered_tasks.index)) In\u00a0[\u00a0]: Copied! <pre># Number of tasks\nprint(len(filtered_tasks))\n</pre> # Number of tasks print(len(filtered_tasks)) <p>Resampling strategies can be found on the OpenML Website.</p> <p>Similar to listing tasks by task type, we can list tasks by tags:</p> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(tag=\"OpenML100\", output_format=\"dataframe\")\nprint(f\"First 5 of {len(tasks)} tasks:\")\nprint(tasks.head())\n</pre> tasks = openml.tasks.list_tasks(tag=\"OpenML100\", output_format=\"dataframe\") print(f\"First 5 of {len(tasks)} tasks:\") print(tasks.head()) <p>Furthermore, we can list tasks based on the dataset id:</p> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(data_id=1471, output_format=\"dataframe\")\nprint(f\"First 5 of {len(tasks)} tasks:\")\nprint(tasks.head())\n</pre> tasks = openml.tasks.list_tasks(data_id=1471, output_format=\"dataframe\") print(f\"First 5 of {len(tasks)} tasks:\") print(tasks.head()) <p>In addition, a size limit and an offset can be applied both separately and simultaneously:</p> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(size=10, offset=50, output_format=\"dataframe\")\nprint(tasks)\n</pre> tasks = openml.tasks.list_tasks(size=10, offset=50, output_format=\"dataframe\") print(tasks) <p>OpenML 100 is a curated list of 100 tasks to start using OpenML. They are all supervised classification tasks with more than 500 instances and less than 50000 instances per task. To make things easier, the tasks do not contain highly unbalanced data and sparse data. However, the tasks include missing values and categorical features. You can find out more about the OpenML 100 on the OpenML benchmarking page.</p> <p>Finally, it is also possible to list all tasks on OpenML with:</p> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(output_format=\"dataframe\")\nprint(len(tasks))\n</pre> tasks = openml.tasks.list_tasks(output_format=\"dataframe\") print(len(tasks)) In\u00a0[\u00a0]: Copied! <pre>tasks.query('name==\"eeg-eye-state\"')\n</pre> tasks.query('name==\"eeg-eye-state\"') In\u00a0[\u00a0]: Copied! <pre>task_id = 31\ntask = openml.tasks.get_task(task_id)\n</pre> task_id = 31 task = openml.tasks.get_task(task_id) In\u00a0[\u00a0]: Copied! <pre># Properties of the task are stored as member variables:\nprint(task)\n</pre> # Properties of the task are stored as member variables: print(task) In\u00a0[\u00a0]: Copied! <pre># And:\n\nids = [2, 1891, 31, 9983]\ntasks = openml.tasks.get_tasks(ids)\nprint(tasks[0])\n</pre> # And:  ids = [2, 1891, 31, 9983] tasks = openml.tasks.get_tasks(ids) print(tasks[0]) <p>We'll use the test server for the rest of this tutorial.</p> <p>.. warning:: .. include:: ../../test_server_usage_warning.txt</p> In\u00a0[\u00a0]: Copied! <pre>openml.config.start_using_configuration_for_example()\n</pre> openml.config.start_using_configuration_for_example() In\u00a0[\u00a0]: Copied! <pre>try:\n    my_task = openml.tasks.create_task(\n        task_type=TaskType.SUPERVISED_CLASSIFICATION,\n        dataset_id=128,\n        target_name=\"class\",\n        evaluation_measure=\"predictive_accuracy\",\n        estimation_procedure_id=1,\n    )\n    my_task.publish()\nexcept openml.exceptions.OpenMLServerException as e:\n    # Error code for 'task already exists'\n    if e.code == 614:\n        # Lookup task\n        tasks = openml.tasks.list_tasks(data_id=128)\n        tasks = tasks.query(\n            'task_type == \"Supervised Classification\" '\n            'and estimation_procedure == \"10-fold Crossvalidation\" '\n            'and evaluation_measures == \"predictive_accuracy\"'\n        )\n        task_id = tasks.loc[:, \"tid\"].values[0]\n        print(\"Task already exists. Task ID is\", task_id)\n</pre> try:     my_task = openml.tasks.create_task(         task_type=TaskType.SUPERVISED_CLASSIFICATION,         dataset_id=128,         target_name=\"class\",         evaluation_measure=\"predictive_accuracy\",         estimation_procedure_id=1,     )     my_task.publish() except openml.exceptions.OpenMLServerException as e:     # Error code for 'task already exists'     if e.code == 614:         # Lookup task         tasks = openml.tasks.list_tasks(data_id=128)         tasks = tasks.query(             'task_type == \"Supervised Classification\" '             'and estimation_procedure == \"10-fold Crossvalidation\" '             'and evaluation_measures == \"predictive_accuracy\"'         )         task_id = tasks.loc[:, \"tid\"].values[0]         print(\"Task already exists. Task ID is\", task_id) In\u00a0[\u00a0]: Copied! <pre># reverting to prod server\nopenml.config.stop_using_configuration_for_example()\n</pre> # reverting to prod server openml.config.stop_using_configuration_for_example() <ul> <li>Complete list of task types.</li> <li>Complete list of model estimation procedures.</li> <li>Complete list of evaluation measures.</li> </ul> <p>License: BSD 3-Clause</p>"},{"location":"examples/30_extended/tasks_tutorial/#tasks","title":"Tasks\u00b6","text":"<p>A tutorial on how to list and download tasks.</p>"},{"location":"examples/30_extended/tasks_tutorial/#listing-tasks","title":"Listing tasks\u00b6","text":"<p>We will start by simply listing only supervised classification tasks.</p> <p>openml.tasks.list_tasks() returns a dictionary of dictionaries by default, but we request a pandas dataframe instead to have better visualization capabilities and easier access:</p>"},{"location":"examples/30_extended/tasks_tutorial/#exercise","title":"Exercise\u00b6","text":"<p>Search for the tasks on the 'eeg-eye-state' dataset.</p>"},{"location":"examples/30_extended/tasks_tutorial/#downloading-tasks","title":"Downloading tasks\u00b6","text":"<p>We provide two functions to download tasks, one which downloads only a single task by its ID, and one which takes a list of IDs and downloads all of these tasks:</p>"},{"location":"examples/30_extended/tasks_tutorial/#creating-tasks","title":"Creating tasks\u00b6","text":"<p>You can also create new tasks. Take the following into account:</p> <ul> <li>You can only create tasks on active datasets</li> <li>For now, only the following tasks are supported: classification, regression, clustering, and learning curve analysis.</li> <li>For now, tasks can only be created on a single dataset.</li> <li>The exact same task must not already exist.</li> </ul> <p>Creating a task requires the following input:</p> <ul> <li>task_type: The task type ID, required (see below). Required.</li> <li>dataset_id: The dataset ID. Required.</li> <li>target_name: The name of the attribute you aim to predict. Optional.</li> <li>estimation_procedure_id : The ID of the estimation procedure used to create train-test splits. Optional.</li> <li>evaluation_measure: The name of the evaluation measure. Optional.</li> <li>Any additional inputs for specific tasks</li> </ul> <p>It is best to leave the evaluation measure open if there is no strong prerequisite for a specific measure. OpenML will always compute all appropriate measures and you can filter or sort results on your favourite measure afterwards. Only add an evaluation measure if necessary (e.g. when other measure make no sense), since it will create a new task, which scatters results across tasks.</p>"},{"location":"examples/30_extended/tasks_tutorial/#example","title":"Example\u00b6","text":"<p>Let's create a classification task on a dataset. In this example we will do this on the Iris dataset (ID=128 (on test server)). We'll use 10-fold cross-validation (ID=1), and predictive accuracy as the predefined measure (this can also be left open). If a task with these parameters exists, we will get an appropriate exception. If such a task doesn't exist, a task will be created and the corresponding task_id will be returned.</p>"},{"location":"examples/40_paper/2015_neurips_feurer_example/","title":"Feurer et al. (2015)","text":"In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n\nimport openml\n</pre> import pandas as pd  import openml <p>List of dataset IDs given in the supplementary material of Feurer et al.: https://papers.nips.cc/paper/5872-efficient-and-robust-automated-machine-learning-supplemental.zip</p> In\u00a0[\u00a0]: Copied! <pre>dataset_ids = [\n    3, 6, 12, 14, 16, 18, 21, 22, 23, 24, 26, 28, 30, 31, 32, 36, 38, 44, 46,\n    57, 60, 179, 180, 181, 182, 184, 185, 273, 293, 300, 351, 354, 357, 389,\n    390, 391, 392, 393, 395, 396, 398, 399, 401, 554, 679, 715, 718, 720, 722,\n    723, 727, 728, 734, 735, 737, 740, 741, 743, 751, 752, 761, 772, 797, 799,\n    803, 806, 807, 813, 816, 819, 821, 822, 823, 833, 837, 843, 845, 846, 847,\n    849, 866, 871, 881, 897, 901, 903, 904, 910, 912, 913, 914, 917, 923, 930,\n    934, 953, 958, 959, 962, 966, 971, 976, 977, 978, 979, 980, 991, 993, 995,\n    1000, 1002, 1018, 1019, 1020, 1021, 1036, 1040, 1041, 1049, 1050, 1053,\n    1056, 1067, 1068, 1069, 1111, 1112, 1114, 1116, 1119, 1120, 1128, 1130,\n    1134, 1138, 1139, 1142, 1146, 1161, 1166,\n]\n</pre> dataset_ids = [     3, 6, 12, 14, 16, 18, 21, 22, 23, 24, 26, 28, 30, 31, 32, 36, 38, 44, 46,     57, 60, 179, 180, 181, 182, 184, 185, 273, 293, 300, 351, 354, 357, 389,     390, 391, 392, 393, 395, 396, 398, 399, 401, 554, 679, 715, 718, 720, 722,     723, 727, 728, 734, 735, 737, 740, 741, 743, 751, 752, 761, 772, 797, 799,     803, 806, 807, 813, 816, 819, 821, 822, 823, 833, 837, 843, 845, 846, 847,     849, 866, 871, 881, 897, 901, 903, 904, 910, 912, 913, 914, 917, 923, 930,     934, 953, 958, 959, 962, 966, 971, 976, 977, 978, 979, 980, 991, 993, 995,     1000, 1002, 1018, 1019, 1020, 1021, 1036, 1040, 1041, 1049, 1050, 1053,     1056, 1067, 1068, 1069, 1111, 1112, 1114, 1116, 1119, 1120, 1128, 1130,     1134, 1138, 1139, 1142, 1146, 1161, 1166, ] <p>The dataset IDs could be used directly to load the dataset and split the data into a training set and a test set. However, to be reproducible, we will first obtain the respective tasks from OpenML, which define both the target feature and the train/test split.</p> <p>.. note:: It is discouraged to work directly on datasets and only provide dataset IDs in a paper as this does not allow reproducibility (unclear splitting). Please do not use datasets but the respective tasks as basis for a paper and publish task IDS. This example is only given to showcase the use of OpenML-Python for a published paper and as a warning on how not to do it. Please check the <code>OpenML documentation of tasks &lt;https://docs.openml.org/concepts/tasks/&gt;</code>_ if you want to learn more about them.</p> <p>This lists both active and inactive tasks (because of <code>status='all'</code>). Unfortunately, this is necessary as some of the datasets contain issues found after the publication and became deactivated, which also deactivated the tasks on them. More information on active or inactive datasets can be found in the online docs.</p> In\u00a0[\u00a0]: Copied! <pre>tasks = openml.tasks.list_tasks(\n    task_type=openml.tasks.TaskType.SUPERVISED_CLASSIFICATION,\n    status=\"all\",\n)\n\n# Query only those with holdout as the resampling startegy.\ntasks = tasks.query('estimation_procedure == \"33% Holdout set\"')\n\ntask_ids = []\nfor did in dataset_ids:\n    tasks_ = list(tasks.query(f\"did == {did}\").tid)\n    if len(tasks_) &gt;= 1:  # if there are multiple task, take the one with lowest ID (oldest).\n        task_id = min(tasks_)\n    else:\n        raise ValueError(did)\n\n    # Optional - Check that the task has the same target attribute as the\n    # dataset default target attribute\n    # (disabled for this example as it needs to run fast to be rendered online)\n    # task = openml.tasks.get_task(task_id)\n    # dataset = task.get_dataset()\n    # if task.target_name != dataset.default_target_attribute:\n    #     raise ValueError(\n    #         (task.target_name, dataset.default_target_attribute)\n    #     )\n\n    task_ids.append(task_id)\n\nassert len(task_ids) == 140\ntask_ids.sort()\n\n# These are the tasks to work with:\nprint(task_ids)\n\n# License: BSD 3-Clause\n</pre> tasks = openml.tasks.list_tasks(     task_type=openml.tasks.TaskType.SUPERVISED_CLASSIFICATION,     status=\"all\", )  # Query only those with holdout as the resampling startegy. tasks = tasks.query('estimation_procedure == \"33% Holdout set\"')  task_ids = [] for did in dataset_ids:     tasks_ = list(tasks.query(f\"did == {did}\").tid)     if len(tasks_) &gt;= 1:  # if there are multiple task, take the one with lowest ID (oldest).         task_id = min(tasks_)     else:         raise ValueError(did)      # Optional - Check that the task has the same target attribute as the     # dataset default target attribute     # (disabled for this example as it needs to run fast to be rendered online)     # task = openml.tasks.get_task(task_id)     # dataset = task.get_dataset()     # if task.target_name != dataset.default_target_attribute:     #     raise ValueError(     #         (task.target_name, dataset.default_target_attribute)     #     )      task_ids.append(task_id)  assert len(task_ids) == 140 task_ids.sort()  # These are the tasks to work with: print(task_ids)  # License: BSD 3-Clause"},{"location":"examples/40_paper/2015_neurips_feurer_example/#feurer-et-al-2015","title":"Feurer et al. (2015)\u00b6","text":"<p>A tutorial on how to get the datasets used in the paper introducing Auto-sklearn by Feurer et al..</p> <p>Auto-sklearn website: https://automl.github.io/auto-sklearn/</p>"},{"location":"examples/40_paper/2015_neurips_feurer_example/#publication","title":"Publication\u00b6","text":"<p>| Efficient and Robust Automated Machine Learning | Matthias Feurer, Aaron Klein, Katharina Eggensperger, Jost Springenberg, Manuel Blum and Frank Hutter | In Advances in Neural Information Processing Systems 28, 2015 | Available at https://papers.nips.cc/paper/5872-efficient-and-robust-automated-machine-learning.pdf</p>"},{"location":"examples/40_paper/2018_ida_strang_example/","title":"Strang et al. (2018)","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nimport openml\n</pre> import matplotlib.pyplot as plt  import openml <p>A basic step for each data-mining or machine learning task is to determine which model to choose based on the problem and the data at hand. In this work we investigate when non-linear classifiers outperform linear classifiers by means of a large scale experiment.</p> <p>The paper is accompanied with a study object, containing all relevant tasks and runs (<code>study_id=123</code>). The paper features three experiment classes: Support Vector Machines (SVM), Neural Networks (NN) and Decision Trees (DT). This example demonstrates how to reproduce the plots, comparing two classifiers given the OpenML flow ids. Note that this allows us to reproduce the SVM and NN experiment, but not the DT experiment, as this requires a bit more effort to distinguish the same flow with different hyperparameter values.</p> In\u00a0[\u00a0]: Copied! <pre>study_id = 123\n# for comparing svms: flow_ids = [7754, 7756]\n# for comparing nns: flow_ids = [7722, 7729]\n# for comparing dts: flow_ids = [7725], differentiate on hyper-parameter value\nclassifier_family = \"SVM\"\nflow_ids = [7754, 7756]\nmeasure = \"predictive_accuracy\"\nmeta_features = [\"NumberOfInstances\", \"NumberOfFeatures\"]\nclass_values = [\"non-linear better\", \"linear better\", \"equal\"]\n\n# Downloads all evaluation records related to this study\nevaluations = openml.evaluations.list_evaluations(\n    measure,\n    size=None,\n    flows=flow_ids,\n    study=study_id,\n    output_format=\"dataframe\",\n)\n# gives us a table with columns data_id, flow1_value, flow2_value\nevaluations = evaluations.pivot(index=\"data_id\", columns=\"flow_id\", values=\"value\").dropna()\n# downloads all data qualities (for scatter plot)\ndata_qualities = openml.datasets.list_datasets(\n    data_id=list(evaluations.index.values),\n)\n# removes irrelevant data qualities\ndata_qualities = data_qualities[meta_features]\n# makes a join between evaluation table and data qualities table,\n# now we have columns data_id, flow1_value, flow2_value, meta_feature_1,\n# meta_feature_2\nevaluations = evaluations.join(data_qualities, how=\"inner\")\n\n# adds column that indicates the difference between the two classifiers\nevaluations[\"diff\"] = evaluations[flow_ids[0]] - evaluations[flow_ids[1]]\n</pre> study_id = 123 # for comparing svms: flow_ids = [7754, 7756] # for comparing nns: flow_ids = [7722, 7729] # for comparing dts: flow_ids = [7725], differentiate on hyper-parameter value classifier_family = \"SVM\" flow_ids = [7754, 7756] measure = \"predictive_accuracy\" meta_features = [\"NumberOfInstances\", \"NumberOfFeatures\"] class_values = [\"non-linear better\", \"linear better\", \"equal\"]  # Downloads all evaluation records related to this study evaluations = openml.evaluations.list_evaluations(     measure,     size=None,     flows=flow_ids,     study=study_id,     output_format=\"dataframe\", ) # gives us a table with columns data_id, flow1_value, flow2_value evaluations = evaluations.pivot(index=\"data_id\", columns=\"flow_id\", values=\"value\").dropna() # downloads all data qualities (for scatter plot) data_qualities = openml.datasets.list_datasets(     data_id=list(evaluations.index.values), ) # removes irrelevant data qualities data_qualities = data_qualities[meta_features] # makes a join between evaluation table and data qualities table, # now we have columns data_id, flow1_value, flow2_value, meta_feature_1, # meta_feature_2 evaluations = evaluations.join(data_qualities, how=\"inner\")  # adds column that indicates the difference between the two classifiers evaluations[\"diff\"] = evaluations[flow_ids[0]] - evaluations[flow_ids[1]] <p>makes the s-plot</p> In\u00a0[\u00a0]: Copied! <pre>fig_splot, ax_splot = plt.subplots()\nax_splot.plot(range(len(evaluations)), sorted(evaluations[\"diff\"]))\nax_splot.set_title(classifier_family)\nax_splot.set_xlabel(\"Dataset (sorted)\")\nax_splot.set_ylabel(\"difference between linear and non-linear classifier\")\nax_splot.grid(linestyle=\"--\", axis=\"y\")\nplt.show()\n</pre> fig_splot, ax_splot = plt.subplots() ax_splot.plot(range(len(evaluations)), sorted(evaluations[\"diff\"])) ax_splot.set_title(classifier_family) ax_splot.set_xlabel(\"Dataset (sorted)\") ax_splot.set_ylabel(\"difference between linear and non-linear classifier\") ax_splot.grid(linestyle=\"--\", axis=\"y\") plt.show() <p>adds column that indicates the difference between the two classifiers, needed for the scatter plot</p> In\u00a0[\u00a0]: Copied! <pre>def determine_class(val_lin, val_nonlin):\n    if val_lin &lt; val_nonlin:\n        return class_values[0]\n    if val_nonlin &lt; val_lin:\n        return class_values[1]\n    return class_values[2]\n\n\nevaluations[\"class\"] = evaluations.apply(\n    lambda row: determine_class(row[flow_ids[0]], row[flow_ids[1]]), axis=1\n)\n\n# does the plotting and formatting\nfig_scatter, ax_scatter = plt.subplots()\nfor class_val in class_values:\n    df_class = evaluations[evaluations[\"class\"] == class_val]\n    plt.scatter(df_class[meta_features[0]], df_class[meta_features[1]], label=class_val)\nax_scatter.set_title(classifier_family)\nax_scatter.set_xlabel(meta_features[0])\nax_scatter.set_ylabel(meta_features[1])\nax_scatter.legend()\nax_scatter.set_xscale(\"log\")\nax_scatter.set_yscale(\"log\")\nplt.show()\n</pre> def determine_class(val_lin, val_nonlin):     if val_lin &lt; val_nonlin:         return class_values[0]     if val_nonlin &lt; val_lin:         return class_values[1]     return class_values[2]   evaluations[\"class\"] = evaluations.apply(     lambda row: determine_class(row[flow_ids[0]], row[flow_ids[1]]), axis=1 )  # does the plotting and formatting fig_scatter, ax_scatter = plt.subplots() for class_val in class_values:     df_class = evaluations[evaluations[\"class\"] == class_val]     plt.scatter(df_class[meta_features[0]], df_class[meta_features[1]], label=class_val) ax_scatter.set_title(classifier_family) ax_scatter.set_xlabel(meta_features[0]) ax_scatter.set_ylabel(meta_features[1]) ax_scatter.legend() ax_scatter.set_xscale(\"log\") ax_scatter.set_yscale(\"log\") plt.show() <p>makes a scatter plot where each data point represents the performance of the two algorithms on various axis (not in the paper)</p> In\u00a0[\u00a0]: Copied! <pre>fig_diagplot, ax_diagplot = plt.subplots()\nax_diagplot.grid(linestyle=\"--\")\nax_diagplot.plot([0, 1], ls=\"-\", color=\"black\")\nax_diagplot.plot([0.2, 1.2], ls=\"--\", color=\"black\")\nax_diagplot.plot([-0.2, 0.8], ls=\"--\", color=\"black\")\nax_diagplot.scatter(evaluations[flow_ids[0]], evaluations[flow_ids[1]])\nax_diagplot.set_xlabel(measure)\nax_diagplot.set_ylabel(measure)\nplt.show()\n# License: BSD 3-Clause\n</pre> fig_diagplot, ax_diagplot = plt.subplots() ax_diagplot.grid(linestyle=\"--\") ax_diagplot.plot([0, 1], ls=\"-\", color=\"black\") ax_diagplot.plot([0.2, 1.2], ls=\"--\", color=\"black\") ax_diagplot.plot([-0.2, 0.8], ls=\"--\", color=\"black\") ax_diagplot.scatter(evaluations[flow_ids[0]], evaluations[flow_ids[1]]) ax_diagplot.set_xlabel(measure) ax_diagplot.set_ylabel(measure) plt.show() # License: BSD 3-Clause"},{"location":"examples/40_paper/2018_ida_strang_example/#strang-et-al-2018","title":"Strang et al. (2018)\u00b6","text":"<p>A tutorial on how to reproduce the analysis conducted for Don't Rule Out Simple Models Prematurely: A Large Scale Benchmark Comparing Linear and Non-linear Classifiers in OpenML.</p>"},{"location":"examples/40_paper/2018_ida_strang_example/#publication","title":"Publication\u00b6","text":"<p>| Don't Rule Out Simple Models Prematurely: A Large Scale Benchmark Comparing Linear and Non-linear Classifiers in OpenML | Benjamin Strang, Peter van der Putten, Jan N. van Rijn and Frank Hutter | In Advances in Intelligent Data Analysis XVII 17th International Symposium, 2018 | Available at https://link.springer.com/chapter/10.1007%2F978-3-030-01768-2_25</p>"},{"location":"examples/40_paper/2018_kdd_rijn_example/","title":"van Rijn and Hutter (2018)","text":"<p>With the advent of automated machine learning, automated hyperparameter optimization methods are by now routinely used in data mining. However, this progress is not yet matched by equal progress on automatic analyses that yield information beyond performance-optimizing hyperparameter settings. In this example, we aim to answer the following two questions: Given an algorithm, what are generally its most important hyperparameters?</p> <p>This work is carried out on the OpenML-100 benchmark suite, which can be obtained by <code>openml.study.get_suite('OpenML100')</code>. In this example, we conduct the experiment on the Support Vector Machine (<code>flow_id=7707</code>) with specific kernel (we will perform a post-process filter operation for this). We should set some other experimental parameters (number of results per task, evaluation measure and the number of trees of the internal functional Anova) before the fun can begin.</p> <p>Note that we simplify the example in several ways:</p> <ol> <li>We only consider numerical hyperparameters</li> <li>We consider all hyperparameters that are numerical (in reality, some hyperparameters might be inactive (e.g., <code>degree</code>) or irrelevant (e.g., <code>random_state</code>)</li> <li>We assume all hyperparameters to be on uniform scale</li> </ol> <p>Any difference in conclusion between the actual paper and the presented results is most likely due to one of these simplifications. For example, the hyperparameter C looks rather insignificant, whereas it is quite important when it is put on a log-scale. All these simplifications can be addressed by defining a ConfigSpace. For a more elaborated example that uses this, please see: https://github.com/janvanrijn/openml-pimp/blob/d0a14f3eb480f2a90008889f00041bdccc7b9265/examples/plot/plot_fanova_aggregates.py # noqa F401</p> In\u00a0[\u00a0]: Copied! <pre>    suite = openml.study.get_suite(\"OpenML100\")\n    flow_id = 7707\n    parameter_filters = {\"sklearn.svm.classes.SVC(17)_kernel\": \"sigmoid\"}\n    evaluation_measure = \"predictive_accuracy\"\n    limit_per_task = 500\n    limit_nr_tasks = 15\n    n_trees = 16\n\n    fanova_results = []\n    # we will obtain all results from OpenML per task. Practice has shown that this places the bottleneck on the\n    # communication with OpenML, and for iterated experimenting it is better to cache the results in a local file.\n    for idx, task_id in enumerate(suite.tasks):\n        if limit_nr_tasks is not None and idx &gt;= limit_nr_tasks:\n            continue\n        print(\n            \"Starting with task %d (%d/%d)\"\n            % (task_id, idx + 1, len(suite.tasks) if limit_nr_tasks is None else limit_nr_tasks)\n        )\n        # note that we explicitly only include tasks from the benchmark suite that was specified (as per the for-loop)\n        evals = openml.evaluations.list_evaluations_setups(\n            evaluation_measure,\n            flows=[flow_id],\n            tasks=[task_id],\n            size=limit_per_task,\n            output_format=\"dataframe\",\n        )\n    except json.decoder.JSONDecodeError as e:\n        print(\"Task %d error: %s\" % (task_id, e))\n        continue\n    # apply our filters, to have only the setups that comply to the hyperparameters we want\n    for filter_key, filter_value in parameter_filters.items():\n        setups_evals = setups_evals[setups_evals[filter_key] == filter_value]\n    # in this simplified example, we only display numerical and float hyperparameters. For categorical hyperparameters,\n    # the fanova library needs to be informed by using a configspace object.\n    setups_evals = setups_evals.select_dtypes(include=[\"int64\", \"float64\"])\n    # drop rows with unique values. These are by definition not an interesting hyperparameter, e.g., ``axis``,\n    # ``verbose``.\n    setups_evals = setups_evals[\n        [\n            c\n            for c in list(setups_evals)\n            if len(setups_evals[c].unique()) &gt; 1 or c == performance_column\n        ]\n    ]\n    # We are done with processing ``setups_evals``. Note that we still might have some irrelevant hyperparameters, e.g.,\n    # ``random_state``. We have dropped some relevant hyperparameters, i.e., several categoricals. Let's check it out:\n\n    # determine x values to pass to fanova library\n    parameter_names = [\n        pname for pname in setups_evals.columns.to_numpy() if pname != performance_column\n    ]\n    evaluator = fanova.fanova.fANOVA(\n        X=setups_evals[parameter_names].to_numpy(),\n        Y=setups_evals[performance_column].to_numpy(),\n        n_trees=n_trees,\n    )\n    for idx, pname in enumerate(parameter_names):\n        try:\n            fanova_results.append(\n                {\n                    \"hyperparameter\": pname.split(\".\")[-1],\n                    \"fanova\": evaluator.quantify_importance([idx])[(idx,)][\n                        \"individual importance\"\n                    ],\n                }\n            )\n        except RuntimeError as e:\n            # functional ANOVA sometimes crashes with a RuntimeError, e.g., on tasks where the performance is constant\n            # for all configurations (there is no variance). We will skip these tasks (like the authors did in the\n            # paper).\n            print(\"Task %d error: %s\" % (task_id, e))\n            continue\n\n    # transform ``fanova_results`` from a list of dicts into a DataFrame\n    fanova_results = pd.DataFrame(fanova_results)\n</pre>     suite = openml.study.get_suite(\"OpenML100\")     flow_id = 7707     parameter_filters = {\"sklearn.svm.classes.SVC(17)_kernel\": \"sigmoid\"}     evaluation_measure = \"predictive_accuracy\"     limit_per_task = 500     limit_nr_tasks = 15     n_trees = 16      fanova_results = []     # we will obtain all results from OpenML per task. Practice has shown that this places the bottleneck on the     # communication with OpenML, and for iterated experimenting it is better to cache the results in a local file.     for idx, task_id in enumerate(suite.tasks):         if limit_nr_tasks is not None and idx &gt;= limit_nr_tasks:             continue         print(             \"Starting with task %d (%d/%d)\"             % (task_id, idx + 1, len(suite.tasks) if limit_nr_tasks is None else limit_nr_tasks)         )         # note that we explicitly only include tasks from the benchmark suite that was specified (as per the for-loop)         evals = openml.evaluations.list_evaluations_setups(             evaluation_measure,             flows=[flow_id],             tasks=[task_id],             size=limit_per_task,             output_format=\"dataframe\",         )     except json.decoder.JSONDecodeError as e:         print(\"Task %d error: %s\" % (task_id, e))         continue     # apply our filters, to have only the setups that comply to the hyperparameters we want     for filter_key, filter_value in parameter_filters.items():         setups_evals = setups_evals[setups_evals[filter_key] == filter_value]     # in this simplified example, we only display numerical and float hyperparameters. For categorical hyperparameters,     # the fanova library needs to be informed by using a configspace object.     setups_evals = setups_evals.select_dtypes(include=[\"int64\", \"float64\"])     # drop rows with unique values. These are by definition not an interesting hyperparameter, e.g., ``axis``,     # ``verbose``.     setups_evals = setups_evals[         [             c             for c in list(setups_evals)             if len(setups_evals[c].unique()) &gt; 1 or c == performance_column         ]     ]     # We are done with processing ``setups_evals``. Note that we still might have some irrelevant hyperparameters, e.g.,     # ``random_state``. We have dropped some relevant hyperparameters, i.e., several categoricals. Let's check it out:      # determine x values to pass to fanova library     parameter_names = [         pname for pname in setups_evals.columns.to_numpy() if pname != performance_column     ]     evaluator = fanova.fanova.fANOVA(         X=setups_evals[parameter_names].to_numpy(),         Y=setups_evals[performance_column].to_numpy(),         n_trees=n_trees,     )     for idx, pname in enumerate(parameter_names):         try:             fanova_results.append(                 {                     \"hyperparameter\": pname.split(\".\")[-1],                     \"fanova\": evaluator.quantify_importance([idx])[(idx,)][                         \"individual importance\"                     ],                 }             )         except RuntimeError as e:             # functional ANOVA sometimes crashes with a RuntimeError, e.g., on tasks where the performance is constant             # for all configurations (there is no variance). We will skip these tasks (like the authors did in the             # paper).             print(\"Task %d error: %s\" % (task_id, e))             continue      # transform ``fanova_results`` from a list of dicts into a DataFrame     fanova_results = pd.DataFrame(fanova_results) <p>make the boxplot of the variance contribution. Obviously, we can also use this data to make the Nemenyi plot, but this relies on the rather complex <code>Orange</code> dependency (<code>pip install Orange3</code>). For the complete example, the reader is referred to the more elaborate script (referred to earlier)</p> In\u00a0[\u00a0]: Copied! <pre>    fig, ax = plt.subplots()\n    sns.boxplot(x=\"hyperparameter\", y=\"fanova\", data=fanova_results, ax=ax)\n    ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\n    ax.set_ylabel(\"Variance Contribution\")\n    ax.set_xlabel(None)\n    plt.tight_layout()\n    plt.show()\n    # License: BSD 3-Clause\n</pre>     fig, ax = plt.subplots()     sns.boxplot(x=\"hyperparameter\", y=\"fanova\", data=fanova_results, ax=ax)     ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")     ax.set_ylabel(\"Variance Contribution\")     ax.set_xlabel(None)     plt.tight_layout()     plt.show()     # License: BSD 3-Clause"},{"location":"examples/40_paper/2018_kdd_rijn_example/#van-rijn-and-hutter-2018","title":"van Rijn and Hutter (2018)\u00b6","text":"<p>A tutorial on how to reproduce the paper Hyperparameter Importance Across Datasets.</p> <p>This is a Unix-only tutorial, as the requirements can not be satisfied on a Windows machine (Untested on other systems).</p>"},{"location":"examples/40_paper/2018_kdd_rijn_example/#publication","title":"Publication\u00b6","text":"<p>| Hyperparameter importance across datasets | Jan N. van Rijn and Frank Hutter | In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining, 2018 | Available at https://dl.acm.org/doi/10.1145/3219819.3220058</p> <p>import sys DEPRECATED EXAMPLE -- Avoid running this code in our CI/CD pipeline print(\"This example is deprecated, remove this code to use it manually.\") if not run_code: print(\"Exiting...\") sys.exit()</p> <p>import json</p> <p>import fanova import matplotlib.pyplot as plt import pandas as pd import seaborn as sns</p> <p>import openml</p> <p>############################################################################# With the advent of automated machine learning, automated hyperparameter optimization methods are by now routinely used in data mining. However, this progress is not yet matched by equal progress on automatic analyses that yield information beyond performance-optimizing hyperparameter settings. In this example, we aim to answer the following two questions: Given an algorithm, what are generally its most important hyperparameters?</p> <p>This work is carried out on the OpenML-100 benchmark suite, which can be obtained by <code>openml.study.get_suite('OpenML100')</code>. In this example, we conduct the experiment on the Support Vector Machine (<code>flow_id=7707</code>) with specific kernel (we will perform a post-process filter operation for this). We should set some other experimental parameters (number of results per task, evaluation measure and the number of trees of the internal functional Anova) before the fun can begin.</p> <p>Note that we simplify the example in several ways:</p> <ol> <li>We only consider numerical hyperparameters</li> <li>We consider all hyperparameters that are numerical (in reality, some hyperparameters might be inactive (e.g., <code>degree</code>) or irrelevant (e.g., <code>random_state</code>)</li> <li>We assume all hyperparameters to be on uniform scale</li> </ol> <p>Any difference in conclusion between the actual paper and the presented results is most likely due to one of these simplifications. For example, the hyperparameter C looks rather insignificant, whereas it is quite important when it is put on a log-scale. All these simplifications can be addressed by defining a ConfigSpace. For a more elaborated example that uses this, please see: https://github.com/janvanrijn/openml-pimp/blob/d0a14f3eb480f2a90008889f00041bdccc7b9265/examples/plot/plot_fanova_aggregates.py</p> <p>suite = openml.study.get_suite(\"OpenML100\") flow_id = 7707 parameter_filters = {\"sklearn.svm.classes.SVC(17)_kernel\": \"sigmoid\"} evaluation_measure = \"predictive_accuracy\" limit_per_task = 500 limit_nr_tasks = 15 n_trees = 16</p> <p>fanova_results = [] we will obtain all results from OpenML per task. Practice has shown that this places the bottleneck on the communication with OpenML, and for iterated experimenting it is better to cache the results in a local file. for idx, task_id in enumerate(suite.tasks): if limit_nr_tasks is not None and idx &gt;= limit_nr_tasks: continue print( \"Starting with task %d (%d/%d)\" % (task_id, idx + 1, len(suite.tasks) if limit_nr_tasks is None else limit_nr_tasks) ) # note that we explicitly only include tasks from the benchmark suite that was specified (as per the for-loop) evals = openml.evaluations.list_evaluations_setups( evaluation_measure, flows=[flow_id], tasks=[task_id], size=limit_per_task, )</p>"},{"location":"examples/40_paper/2018_neurips_perrone_example/","title":"Perrone et al. (2018)","text":"In\u00a0[\u00a0]: Copied! <pre>import openml\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import OneHotEncoder\n\nimport openml\n\nflow_type = \"svm\"  # this example will use the smaller svm flow evaluations\n</pre> import openml import numpy as np import pandas as pd from matplotlib import pyplot as plt from sklearn.compose import ColumnTransformer from sklearn.ensemble import RandomForestRegressor from sklearn.impute import SimpleImputer from sklearn.metrics import mean_squared_error from sklearn.pipeline import Pipeline from sklearn.preprocessing import OneHotEncoder  import openml  flow_type = \"svm\"  # this example will use the smaller svm flow evaluations <p>The subsequent functions are defined to fetch tasks, flows, evaluations and preprocess them into a tabular format that can be used to build models.</p> In\u00a0[\u00a0]: Copied! <pre>def fetch_evaluations(run_full=False, flow_type=\"svm\", metric=\"area_under_roc_curve\"):\n    \"\"\"\n    Fetch a list of evaluations based on the flows and tasks used in the experiments.\n\n    Parameters\n    ----------\n    run_full : boolean\n        If True, use the full list of tasks used in the paper\n        If False, use 5 tasks with the smallest number of evaluations available\n    flow_type : str, {'svm', 'xgboost'}\n        To select whether svm or xgboost experiments are to be run\n    metric : str\n        The evaluation measure that is passed to openml.evaluations.list_evaluations\n\n    Returns\n    -------\n    eval_df : dataframe\n    task_ids : list\n    flow_id : int\n    \"\"\"\n    # Collecting task IDs as used by the experiments from the paper\n    # fmt: off\n    if flow_type == \"svm\" and run_full:\n        task_ids = [\n            10101, 145878, 146064, 14951, 34537, 3485, 3492, 3493, 3494,\n            37, 3889, 3891, 3899, 3902, 3903, 3913, 3918, 3950, 9889,\n            9914, 9946, 9952, 9967, 9971, 9976, 9978, 9980, 9983,\n        ]\n    elif flow_type == \"svm\" and not run_full:\n        task_ids = [9983, 3485, 3902, 3903, 145878]\n    elif flow_type == \"xgboost\" and run_full:\n        task_ids = [\n            10093, 10101, 125923, 145847, 145857, 145862, 145872, 145878,\n            145953, 145972, 145976, 145979, 146064, 14951, 31, 3485,\n            3492, 3493, 37, 3896, 3903, 3913, 3917, 3918, 3, 49, 9914,\n            9946, 9952, 9967,\n        ]\n    else:  # flow_type == 'xgboost' and not run_full:\n        task_ids = [3903, 37, 3485, 49, 3913]\n    # fmt: on\n\n    # Fetching the relevant flow\n    flow_id = 5891 if flow_type == \"svm\" else 6767\n\n    # Fetching evaluations\n    eval_df = openml.evaluations.list_evaluations_setups(\n        function=metric,\n        tasks=task_ids,\n        flows=[flow_id],\n        uploaders=[2702],\n        parameters_in_separate_columns=True,\n    )\n    return eval_df, task_ids, flow_id\n\n\ndef create_table_from_evaluations(\n    eval_df, flow_type=\"svm\", run_count=np.iinfo(np.int64).max, task_ids=None\n):\n    \"\"\"\n    Create a tabular data with its ground truth from a dataframe of evaluations.\n    Optionally, can filter out records based on task ids.\n\n    Parameters\n    ----------\n    eval_df : dataframe\n        Containing list of runs as obtained from list_evaluations()\n    flow_type : str, {'svm', 'xgboost'}\n        To select whether svm or xgboost experiments are to be run\n    run_count : int\n        Maximum size of the table created, or number of runs included in the table\n    task_ids : list, (optional)\n        List of integers specifying the tasks to be retained from the evaluations dataframe\n\n    Returns\n    -------\n    eval_table : dataframe\n    values : list\n    \"\"\"\n    if task_ids is not None:\n        eval_df = eval_df[eval_df[\"task_id\"].isin(task_ids)]\n    if flow_type == \"svm\":\n        colnames = [\"cost\", \"degree\", \"gamma\", \"kernel\"]\n    else:\n        colnames = [\n            \"alpha\",\n            \"booster\",\n            \"colsample_bylevel\",\n            \"colsample_bytree\",\n            \"eta\",\n            \"lambda\",\n            \"max_depth\",\n            \"min_child_weight\",\n            \"nrounds\",\n            \"subsample\",\n        ]\n    eval_df = eval_df.sample(frac=1)  # shuffling rows\n    eval_df = eval_df.iloc[:run_count, :]\n    eval_df.columns = [column.split(\"_\")[-1] for column in eval_df.columns]\n    eval_table = eval_df.loc[:, colnames]\n    value = eval_df.loc[:, \"value\"]\n    return eval_table, value\n\n\ndef list_categorical_attributes(flow_type=\"svm\"):\n    if flow_type == \"svm\":\n        return [\"kernel\"]\n    return [\"booster\"]\n</pre> def fetch_evaluations(run_full=False, flow_type=\"svm\", metric=\"area_under_roc_curve\"):     \"\"\"     Fetch a list of evaluations based on the flows and tasks used in the experiments.      Parameters     ----------     run_full : boolean         If True, use the full list of tasks used in the paper         If False, use 5 tasks with the smallest number of evaluations available     flow_type : str, {'svm', 'xgboost'}         To select whether svm or xgboost experiments are to be run     metric : str         The evaluation measure that is passed to openml.evaluations.list_evaluations      Returns     -------     eval_df : dataframe     task_ids : list     flow_id : int     \"\"\"     # Collecting task IDs as used by the experiments from the paper     # fmt: off     if flow_type == \"svm\" and run_full:         task_ids = [             10101, 145878, 146064, 14951, 34537, 3485, 3492, 3493, 3494,             37, 3889, 3891, 3899, 3902, 3903, 3913, 3918, 3950, 9889,             9914, 9946, 9952, 9967, 9971, 9976, 9978, 9980, 9983,         ]     elif flow_type == \"svm\" and not run_full:         task_ids = [9983, 3485, 3902, 3903, 145878]     elif flow_type == \"xgboost\" and run_full:         task_ids = [             10093, 10101, 125923, 145847, 145857, 145862, 145872, 145878,             145953, 145972, 145976, 145979, 146064, 14951, 31, 3485,             3492, 3493, 37, 3896, 3903, 3913, 3917, 3918, 3, 49, 9914,             9946, 9952, 9967,         ]     else:  # flow_type == 'xgboost' and not run_full:         task_ids = [3903, 37, 3485, 49, 3913]     # fmt: on      # Fetching the relevant flow     flow_id = 5891 if flow_type == \"svm\" else 6767      # Fetching evaluations     eval_df = openml.evaluations.list_evaluations_setups(         function=metric,         tasks=task_ids,         flows=[flow_id],         uploaders=[2702],         parameters_in_separate_columns=True,     )     return eval_df, task_ids, flow_id   def create_table_from_evaluations(     eval_df, flow_type=\"svm\", run_count=np.iinfo(np.int64).max, task_ids=None ):     \"\"\"     Create a tabular data with its ground truth from a dataframe of evaluations.     Optionally, can filter out records based on task ids.      Parameters     ----------     eval_df : dataframe         Containing list of runs as obtained from list_evaluations()     flow_type : str, {'svm', 'xgboost'}         To select whether svm or xgboost experiments are to be run     run_count : int         Maximum size of the table created, or number of runs included in the table     task_ids : list, (optional)         List of integers specifying the tasks to be retained from the evaluations dataframe      Returns     -------     eval_table : dataframe     values : list     \"\"\"     if task_ids is not None:         eval_df = eval_df[eval_df[\"task_id\"].isin(task_ids)]     if flow_type == \"svm\":         colnames = [\"cost\", \"degree\", \"gamma\", \"kernel\"]     else:         colnames = [             \"alpha\",             \"booster\",             \"colsample_bylevel\",             \"colsample_bytree\",             \"eta\",             \"lambda\",             \"max_depth\",             \"min_child_weight\",             \"nrounds\",             \"subsample\",         ]     eval_df = eval_df.sample(frac=1)  # shuffling rows     eval_df = eval_df.iloc[:run_count, :]     eval_df.columns = [column.split(\"_\")[-1] for column in eval_df.columns]     eval_table = eval_df.loc[:, colnames]     value = eval_df.loc[:, \"value\"]     return eval_table, value   def list_categorical_attributes(flow_type=\"svm\"):     if flow_type == \"svm\":         return [\"kernel\"]     return [\"booster\"] <p>Fetching the data from OpenML</p> <p>Now, we read all the tasks and evaluations for them and collate into a table. Here, we are reading all the tasks and evaluations for the SVM flow and pre-processing all retrieved evaluations.</p> In\u00a0[\u00a0]: Copied! <pre>eval_df, task_ids, flow_id = fetch_evaluations(run_full=False, flow_type=flow_type)\nX, y = create_table_from_evaluations(eval_df, flow_type=flow_type)\nprint(X.head())\nprint(\"Y : \", y[:5])\n</pre> eval_df, task_ids, flow_id = fetch_evaluations(run_full=False, flow_type=flow_type) X, y = create_table_from_evaluations(eval_df, flow_type=flow_type) print(X.head()) print(\"Y : \", y[:5]) In\u00a0[\u00a0]: Copied! <pre># Separating data into categorical and non-categorical (numeric for this example) columns\ncat_cols = list_categorical_attributes(flow_type=flow_type)\nnum_cols = list(set(X.columns) - set(cat_cols))\n\n# Missing value imputers for numeric columns\nnum_imputer = SimpleImputer(missing_values=np.nan, strategy=\"constant\", fill_value=-1)\n\n# Creating the one-hot encoder for numerical representation of categorical columns\nenc = Pipeline(\n    [\n        (\n            \"cat_si\",\n            SimpleImputer(\n                strategy=\"constant\",\n                fill_value=\"missing\",\n            ),\n        ),\n        (\"cat_ohe\", OneHotEncoder(handle_unknown=\"ignore\")),\n    ],\n)\n# Combining column transformers\nct = ColumnTransformer([(\"cat\", enc, cat_cols), (\"num\", num_imputer, num_cols)])\n\n# Creating the full pipeline with the surrogate model\nclf = RandomForestRegressor(n_estimators=50)\nmodel = Pipeline(steps=[(\"preprocess\", ct), (\"surrogate\", clf)])\n</pre> # Separating data into categorical and non-categorical (numeric for this example) columns cat_cols = list_categorical_attributes(flow_type=flow_type) num_cols = list(set(X.columns) - set(cat_cols))  # Missing value imputers for numeric columns num_imputer = SimpleImputer(missing_values=np.nan, strategy=\"constant\", fill_value=-1)  # Creating the one-hot encoder for numerical representation of categorical columns enc = Pipeline(     [         (             \"cat_si\",             SimpleImputer(                 strategy=\"constant\",                 fill_value=\"missing\",             ),         ),         (\"cat_ohe\", OneHotEncoder(handle_unknown=\"ignore\")),     ], ) # Combining column transformers ct = ColumnTransformer([(\"cat\", enc, cat_cols), (\"num\", num_imputer, num_cols)])  # Creating the full pipeline with the surrogate model clf = RandomForestRegressor(n_estimators=50) model = Pipeline(steps=[(\"preprocess\", ct), (\"surrogate\", clf)]) In\u00a0[\u00a0]: Copied! <pre># Selecting a task for the surrogate\ntask_id = task_ids[-1]\nprint(\"Task ID : \", task_id)\nX, y = create_table_from_evaluations(eval_df, task_ids=[task_id], flow_type=\"svm\")\n\nmodel.fit(X, y)\ny_pred = model.predict(X)\n\nprint(f\"Training RMSE : {mean_squared_error(y, y_pred):.5}\")\n</pre> # Selecting a task for the surrogate task_id = task_ids[-1] print(\"Task ID : \", task_id) X, y = create_table_from_evaluations(eval_df, task_ids=[task_id], flow_type=\"svm\")  model.fit(X, y) y_pred = model.predict(X)  print(f\"Training RMSE : {mean_squared_error(y, y_pred):.5}\") In\u00a0[\u00a0]: Copied! <pre># Sampling random configurations\ndef random_sample_configurations(num_samples=100):\n    colnames = [\"cost\", \"degree\", \"gamma\", \"kernel\"]\n    ranges = [\n        (0.000986, 998.492437),\n        (2.0, 5.0),\n        (0.000988, 913.373845),\n        ([\"linear\", \"polynomial\", \"radial\", \"sigmoid\"]),\n    ]\n    X = pd.DataFrame(np.nan, index=range(num_samples), columns=colnames)\n    for i in range(len(colnames)):\n        if len(ranges[i]) == 2:\n            col_val = np.random.uniform(low=ranges[i][0], high=ranges[i][1], size=num_samples)\n        else:\n            col_val = np.random.choice(ranges[i], size=num_samples)\n        X.iloc[:, i] = col_val\n    return X\n\n\nconfigs = random_sample_configurations(num_samples=1000)\nprint(configs)\n</pre> # Sampling random configurations def random_sample_configurations(num_samples=100):     colnames = [\"cost\", \"degree\", \"gamma\", \"kernel\"]     ranges = [         (0.000986, 998.492437),         (2.0, 5.0),         (0.000988, 913.373845),         ([\"linear\", \"polynomial\", \"radial\", \"sigmoid\"]),     ]     X = pd.DataFrame(np.nan, index=range(num_samples), columns=colnames)     for i in range(len(colnames)):         if len(ranges[i]) == 2:             col_val = np.random.uniform(low=ranges[i][0], high=ranges[i][1], size=num_samples)         else:             col_val = np.random.choice(ranges[i], size=num_samples)         X.iloc[:, i] = col_val     return X   configs = random_sample_configurations(num_samples=1000) print(configs) In\u00a0[\u00a0]: Copied! <pre>preds = model.predict(configs)\n\n# tracking the maximum AUC obtained over the functions evaluations\npreds = np.maximum.accumulate(preds)\n# computing regret (1 - predicted_auc)\nregret = 1 - preds\n\n# plotting the regret curve\nplt.plot(regret)\nplt.title(\"AUC regret for Random Search on surrogate\")\nplt.xlabel(\"Numbe of function evaluations\")\nplt.ylabel(\"Regret\")\n# License: BSD 3-Clause\n</pre> preds = model.predict(configs)  # tracking the maximum AUC obtained over the functions evaluations preds = np.maximum.accumulate(preds) # computing regret (1 - predicted_auc) regret = 1 - preds  # plotting the regret curve plt.plot(regret) plt.title(\"AUC regret for Random Search on surrogate\") plt.xlabel(\"Numbe of function evaluations\") plt.ylabel(\"Regret\") # License: BSD 3-Clause"},{"location":"examples/40_paper/2018_neurips_perrone_example/#perrone-et-al-2018","title":"Perrone et al. (2018)\u00b6","text":"<p>A tutorial on how to build a surrogate model based on OpenML data as done for Scalable Hyperparameter Transfer Learning by Perrone et al..</p>"},{"location":"examples/40_paper/2018_neurips_perrone_example/#publication","title":"Publication\u00b6","text":"<p>| Scalable Hyperparameter Transfer Learning | Valerio Perrone and Rodolphe Jenatton and Matthias Seeger and Cedric Archambeau | In Advances in Neural Information Processing Systems 31, 2018 | Available at https://papers.nips.cc/paper/7917-scalable-hyperparameter-transfer-learning.pdf</p> <p>This example demonstrates how OpenML runs can be used to construct a surrogate model.</p> <p>In the following section, we shall do the following:</p> <ul> <li>Retrieve tasks and flows as used in the experiments by Perrone et al. (2018).</li> <li>Build a tabular data by fetching the evaluations uploaded to OpenML.</li> <li>Impute missing values and handle categorical data before building a Random Forest model that maps hyperparameter values to the area under curve score.</li> </ul>"},{"location":"examples/40_paper/2018_neurips_perrone_example/#creating-pre-processing-and-modelling-pipelines","title":"Creating pre-processing and modelling pipelines\u00b6","text":"<p>The two primary tasks are to impute the missing values, that is, account for the hyperparameters that are not available with the runs from OpenML. And secondly, to handle categorical variables using One-hot encoding prior to modelling.</p>"},{"location":"examples/40_paper/2018_neurips_perrone_example/#building-a-surrogate-model-on-a-tasks-evaluation","title":"Building a surrogate model on a task's evaluation\u00b6","text":"<p>The same set of functions can be used for a single task to retrieve a singular table which can be used for the surrogate model construction. We shall use the SVM flow here to keep execution time simple and quick.</p>"},{"location":"examples/40_paper/2018_neurips_perrone_example/#evaluating-the-surrogate-model","title":"Evaluating the surrogate model\u00b6","text":"<p>The surrogate model built from a task's evaluations fetched from OpenML will be put into trivial action here, where we shall randomly sample configurations and observe the trajectory of the area under curve (auc) we can obtain from the surrogate we've built.</p> <p>NOTE: This section is written exclusively for the SVM flow</p>"},{"location":"reference/","title":"openml","text":"<p>The OpenML module implements a python interface to <code>OpenML &lt;https://www.openml.org&gt;</code>_, a collaborative platform for machine learning. OpenML can be used to</p> <ul> <li>store, download and analyze datasets</li> <li>make experiments and their results (e.g. models, predictions)   accesible and reproducible for everybody</li> <li>analyze experiments (uploaded by you and other collaborators) and conduct   meta studies</li> </ul> <p>In particular, this module implements a python interface for the <code>OpenML REST API &lt;https://www.openml.org/guide#!rest_services&gt;</code> (<code>REST on wikipedia &lt;https://en.wikipedia.org/wiki/Representational_state_transfer&gt;</code>).</p>"},{"location":"reference/#openml.OpenMLBenchmarkSuite","title":"<code>OpenMLBenchmarkSuite</code>","text":"<p>               Bases: <code>BaseStudy</code></p> <p>An OpenMLBenchmarkSuite represents the OpenML concept of a suite (a collection of tasks).</p> <p>It contains the following information: name, id, description, creation date, creator id and the task ids.</p> <p>According to this list of task ids, the suite object receives a list of OpenML object ids (datasets).</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>main_entity_type</code> <code>str</code> <p>the entity type (e.g., task, run) that is core in this study. only entities of this type can be added explicitly</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class OpenMLBenchmarkSuite(BaseStudy):\n    \"\"\"\n    An OpenMLBenchmarkSuite represents the OpenML concept of a suite (a collection of tasks).\n\n    It contains the following information: name, id, description, creation date,\n    creator id and the task ids.\n\n    According to this list of task ids, the suite object receives a list of\n    OpenML object ids (datasets).\n\n    Parameters\n    ----------\n    suite_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    main_entity_type : str\n        the entity type (e.g., task, run) that is core in this study.\n        only entities of this type can be added explicitly\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        suite_id: int | None,\n        alias: str | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n    ):\n        super().__init__(\n            study_id=suite_id,\n            alias=alias,\n            main_entity_type=\"task\",\n            benchmark_suite=None,\n            name=name,\n            description=description,\n            status=status,\n            creation_date=creation_date,\n            creator=creator,\n            tags=tags,\n            data=data,\n            tasks=tasks,\n            flows=None,\n            runs=None,\n            setups=None,\n        )\n</code></pre>"},{"location":"reference/#openml.OpenMLClassificationTask","title":"<code>OpenMLClassificationTask</code>","text":"<p>               Bases: <code>OpenMLSupervisedTask</code></p> <p>OpenML Classification object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the Classification task type.</p> required <code>task_type</code> <code>str</code> <p>Name of the Classification task type.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset associated with the Classification task.</p> required <code>target_name</code> <code>str</code> <p>Name of the target variable.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure for the Classification task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Estimation parameters for the Classification task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the data splits for the Classification task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the Classification task (if it already exists on OpenML).</p> <code>None</code> <code>class_labels</code> <code>List of str</code> <p>A list of class labels (for classification tasks).</p> <code>None</code> <code>cost_matrix</code> <code>array</code> <p>A cost matrix (for classification tasks).</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLClassificationTask(OpenMLSupervisedTask):\n    \"\"\"OpenML Classification object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the Classification task type.\n    task_type : str\n        Name of the Classification task type.\n    data_set_id : int\n        ID of the OpenML dataset associated with the Classification task.\n    target_name : str\n        Name of the target variable.\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure for the Classification task.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure.\n    estimation_parameters : dict, default=None\n        Estimation parameters for the Classification task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure.\n    data_splits_url : str, default=None\n        URL of the data splits for the Classification task.\n    task_id : Union[int, None]\n        ID of the Classification task (if it already exists on OpenML).\n    class_labels : List of str, default=None\n        A list of class labels (for classification tasks).\n    cost_matrix : array, default=None\n        A cost matrix (for classification tasks).\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        class_labels: list[str] | None = None,\n        cost_matrix: np.ndarray | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n        )\n        self.class_labels = class_labels\n        self.cost_matrix = cost_matrix\n\n        if cost_matrix is not None:\n            raise NotImplementedError(\"Costmatrix\")\n</code></pre>"},{"location":"reference/#openml.OpenMLClusteringTask","title":"<code>OpenMLClusteringTask</code>","text":"<p>               Bases: <code>OpenMLTask</code></p> <p>OpenML Clustering object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>Task type ID of the OpenML clustering task.</p> required <code>task_type</code> <code>str</code> <p>Task type of the OpenML clustering task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset used in clustering the task.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the OpenML estimation procedure.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the OpenML clustering task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the OpenML estimation procedure used in the clustering task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Parameters used by the OpenML estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the OpenML data splits for the clustering task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Evaluation measure used in the clustering task.</p> <code>None</code> <code>target_name</code> <code>str</code> <p>Name of the target feature (class) that is not part of the feature set for the clustering task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLClusteringTask(OpenMLTask):\n    \"\"\"OpenML Clustering object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        Task type ID of the OpenML clustering task.\n    task_type : str\n        Task type of the OpenML clustering task.\n    data_set_id : int\n        ID of the OpenML dataset used in clustering the task.\n    estimation_procedure_id : int, default=None\n        ID of the OpenML estimation procedure.\n    task_id : Union[int, None]\n        ID of the OpenML clustering task.\n    estimation_procedure_type : str, default=None\n        Type of the OpenML estimation procedure used in the clustering task.\n    estimation_parameters : dict, default=None\n        Parameters used by the OpenML estimation procedure.\n    data_splits_url : str, default=None\n        URL of the OpenML data splits for the clustering task.\n    evaluation_measure : str, default=None\n        Evaluation measure used in the clustering task.\n    target_name : str, default=None\n        Name of the target feature (class) that is not part of the\n        feature set for the clustering task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        estimation_procedure_id: int = 17,\n        task_id: int | None = None,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        evaluation_measure: str | None = None,\n        target_name: str | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            evaluation_measure=evaluation_measure,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            data_splits_url=data_splits_url,\n        )\n\n        self.target_name = target_name\n\n    def get_X(self) -&gt; pd.DataFrame:\n        \"\"\"Get data associated with the current task.\n\n        Returns\n        -------\n        The X data as a dataframe\n        \"\"\"\n        dataset = self.get_dataset()\n        data, *_ = dataset.get_data(target=None)\n        return data\n\n    def _to_dict(self) -&gt; dict[str, dict[str, int | str | list[dict[str, Any]]]]:\n        # Right now, it is not supported as a feature.\n        # Uncomment if it is supported on the server\n        # in the future.\n        # https://github.com/openml/OpenML/issues/925\n        \"\"\"\n        task_dict = task_container['oml:task_inputs']\n        if self.target_name is not None:\n            task_dict['oml:input'].append(\n                OrderedDict([\n                    ('@name', 'target_feature'),\n                    ('#text', self.target_name)\n                ])\n            )\n        \"\"\"\n        return super()._to_dict()\n</code></pre>"},{"location":"reference/#openml.OpenMLClusteringTask.get_X","title":"<code>get_X()</code>","text":"<p>Get data associated with the current task.</p> <p>Returns:</p> Type Description <code>The X data as a dataframe</code> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_X(self) -&gt; pd.DataFrame:\n    \"\"\"Get data associated with the current task.\n\n    Returns\n    -------\n    The X data as a dataframe\n    \"\"\"\n    dataset = self.get_dataset()\n    data, *_ = dataset.get_data(target=None)\n    return data\n</code></pre>"},{"location":"reference/#openml.OpenMLDataFeature","title":"<code>OpenMLDataFeature</code>","text":"<p>Data Feature (a.k.a. Attribute) object.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of this feature</p> required <code>name</code> <code>str</code> <p>Name of the feature</p> required <code>data_type</code> <code>str</code> <p>can be nominal, numeric, string, date (corresponds to arff)</p> required <code>nominal_values</code> <code>list(str)</code> <p>list of the possible values, in case of nominal attribute</p> required <code>number_missing_values</code> <code>int</code> <p>Number of rows that have a missing value for this feature.</p> required <code>ontologies</code> <code>list(str)</code> <p>list of ontologies attached to this feature. An ontology describes the concept that are described in a feature. An ontology is defined by an URL where the information is provided.</p> <code>None</code> Source code in <code>openml/datasets/data_feature.py</code> <pre><code>class OpenMLDataFeature:\n    \"\"\"\n    Data Feature (a.k.a. Attribute) object.\n\n    Parameters\n    ----------\n    index : int\n        The index of this feature\n    name : str\n        Name of the feature\n    data_type : str\n        can be nominal, numeric, string, date (corresponds to arff)\n    nominal_values : list(str)\n        list of the possible values, in case of nominal attribute\n    number_missing_values : int\n        Number of rows that have a missing value for this feature.\n    ontologies : list(str)\n        list of ontologies attached to this feature. An ontology describes the\n        concept that are described in a feature. An ontology is defined by an\n        URL where the information is provided.\n    \"\"\"\n\n    LEGAL_DATA_TYPES: ClassVar[Sequence[str]] = [\"nominal\", \"numeric\", \"string\", \"date\"]\n\n    def __init__(  # noqa: PLR0913\n        self,\n        index: int,\n        name: str,\n        data_type: str,\n        nominal_values: list[str],\n        number_missing_values: int,\n        ontologies: list[str] | None = None,\n    ):\n        if not isinstance(index, int):\n            raise TypeError(f\"Index must be `int` but is {type(index)}\")\n\n        if data_type not in self.LEGAL_DATA_TYPES:\n            raise ValueError(\n                f\"data type should be in {self.LEGAL_DATA_TYPES!s}, found: {data_type}\",\n            )\n\n        if data_type == \"nominal\":\n            if nominal_values is None:\n                raise TypeError(\n                    \"Dataset features require attribute `nominal_values` for nominal \"\n                    \"feature type.\",\n                )\n\n            if not isinstance(nominal_values, list):\n                raise TypeError(\n                    \"Argument `nominal_values` is of wrong datatype, should be list, \"\n                    f\"but is {type(nominal_values)}\",\n                )\n        elif nominal_values is not None:\n            raise TypeError(\"Argument `nominal_values` must be None for non-nominal feature.\")\n\n        if not isinstance(number_missing_values, int):\n            msg = f\"number_missing_values must be int but is {type(number_missing_values)}\"\n            raise TypeError(msg)\n\n        self.index = index\n        self.name = str(name)\n        self.data_type = str(data_type)\n        self.nominal_values = nominal_values\n        self.number_missing_values = number_missing_values\n        self.ontologies = ontologies\n\n    def __repr__(self) -&gt; str:\n        return \"[%d - %s (%s)]\" % (self.index, self.name, self.data_type)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, OpenMLDataFeature) and self.__dict__ == other.__dict__\n\n    def _repr_pretty_(self, pp: pretty.PrettyPrinter, cycle: bool) -&gt; None:  # noqa: FBT001, ARG002\n        pp.text(str(self))\n</code></pre>"},{"location":"reference/#openml.OpenMLDataset","title":"<code>OpenMLDataset</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>Dataset object.</p> <p>Allows fetching and uploading datasets to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> required <code>data_format</code> <code>str</code> <p>Format of the dataset which can be either 'arff' or 'sparse_arff'.</p> <code>'arff'</code> <code>cache_format</code> <code>str</code> <p>Format for caching the dataset which can be either 'feather' or 'pickle'.</p> <code>'pickle'</code> <code>dataset_id</code> <code>int</code> <p>Id autogenerated by the server.</p> <code>None</code> <code>version</code> <code>int</code> <p>Version of this dataset. '1' for original version. Auto-incremented by server.</p> <code>None</code> <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> <code>None</code> <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> <code>None</code> <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> <code>None</code> <code>upload_date</code> <code>str</code> <p>The date-time when the dataset was uploaded, generated by server.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> <code>None</code> <code>licence</code> <code>str</code> <p>License of the data.</p> <code>None</code> <code>url</code> <code>str</code> <p>Valid URL, points to actual data file. The file can be on the OpenML server or another dataset repository.</p> <code>None</code> <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset.</p> <code>None</code> <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes.</p> <code>None</code> <code>version_label</code> <code>str</code> <p>Version label provided by user. Can be a date, hash, or some other type of id.</p> <code>None</code> <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> <code>None</code> <code>tag</code> <code>str</code> <p>Tags, describing the algorithms.</p> <code>None</code> <code>visibility</code> <code>str</code> <p>Who can see the dataset. Typical values: 'Everyone','All my friends','Only me'. Can also be any of the user's circles.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <code>update_comment</code> <code>str</code> <p>An explanation for when the dataset is uploaded.</p> <code>None</code> <code>md5_checksum</code> <code>str</code> <p>MD5 checksum to check if the dataset is downloaded without corruption.</p> <code>None</code> <code>data_file</code> <code>str</code> <p>Path to where the dataset is located.</p> <code>None</code> <code>features_file</code> <code>dict</code> <p>A dictionary of dataset features, which maps a feature index to a OpenMLDataFeature.</p> <code>None</code> <code>qualities_file</code> <code>dict</code> <p>A dictionary of dataset qualities, which maps a quality name to a quality value.</p> <code>None</code> <code>dataset</code> <code>str | None</code> <p>Serialized arff dataset string.</p> <code>None</code> <code>parquet_url</code> <code>str | None</code> <p>This is the URL to the storage location where the dataset files are hosted. This can be a MinIO bucket URL. If specified, the data will be accessed from this URL when reading the files.</p> <code>None</code> <code>parquet_file</code> <code>str | None</code> <p>Path to the local file.</p> <code>None</code> Source code in <code>openml/datasets/dataset.py</code> <pre><code>class OpenMLDataset(OpenMLBase):\n    \"\"\"Dataset object.\n\n    Allows fetching and uploading datasets to OpenML.\n\n    Parameters\n    ----------\n    name : str\n        Name of the dataset.\n    description : str\n        Description of the dataset.\n    data_format : str\n        Format of the dataset which can be either 'arff' or 'sparse_arff'.\n    cache_format : str\n        Format for caching the dataset which can be either 'feather' or 'pickle'.\n    dataset_id : int, optional\n        Id autogenerated by the server.\n    version : int, optional\n        Version of this dataset. '1' for original version.\n        Auto-incremented by server.\n    creator : str, optional\n        The person who created the dataset.\n    contributor : str, optional\n        People who contributed to the current version of the dataset.\n    collection_date : str, optional\n        The date the data was originally collected, given by the uploader.\n    upload_date : str, optional\n        The date-time when the dataset was uploaded, generated by server.\n    language : str, optional\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    licence : str, optional\n        License of the data.\n    url : str, optional\n        Valid URL, points to actual data file.\n        The file can be on the OpenML server or another dataset repository.\n    default_target_attribute : str, optional\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column,\n        if present in the dataset.\n    ignore_attribute : str | list, optional\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n    version_label : str, optional\n        Version label provided by user.\n        Can be a date, hash, or some other type of id.\n    citation : str, optional\n        Reference(s) that should be cited when building on this data.\n    tag : str, optional\n        Tags, describing the algorithms.\n    visibility : str, optional\n        Who can see the dataset.\n        Typical values: 'Everyone','All my friends','Only me'.\n        Can also be any of the user's circles.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n    update_comment : str, optional\n        An explanation for when the dataset is uploaded.\n    md5_checksum : str, optional\n        MD5 checksum to check if the dataset is downloaded without corruption.\n    data_file : str, optional\n        Path to where the dataset is located.\n    features_file : dict, optional\n        A dictionary of dataset features,\n        which maps a feature index to a OpenMLDataFeature.\n    qualities_file : dict, optional\n        A dictionary of dataset qualities,\n        which maps a quality name to a quality value.\n    dataset: string, optional\n        Serialized arff dataset string.\n    parquet_url: string, optional\n        This is the URL to the storage location where the dataset files are hosted.\n        This can be a MinIO bucket URL. If specified, the data will be accessed\n        from this URL when reading the files.\n    parquet_file: string, optional\n        Path to the local file.\n    \"\"\"\n\n    def __init__(  # noqa: C901, PLR0912, PLR0913, PLR0915\n        self,\n        name: str,\n        description: str | None,\n        data_format: Literal[\"arff\", \"sparse_arff\"] = \"arff\",\n        cache_format: Literal[\"feather\", \"pickle\"] = \"pickle\",\n        dataset_id: int | None = None,\n        version: int | None = None,\n        creator: str | None = None,\n        contributor: str | None = None,\n        collection_date: str | None = None,\n        upload_date: str | None = None,\n        language: str | None = None,\n        licence: str | None = None,\n        url: str | None = None,\n        default_target_attribute: str | None = None,\n        row_id_attribute: str | None = None,\n        ignore_attribute: str | list[str] | None = None,\n        version_label: str | None = None,\n        citation: str | None = None,\n        tag: str | None = None,\n        visibility: str | None = None,\n        original_data_url: str | None = None,\n        paper_url: str | None = None,\n        update_comment: str | None = None,\n        md5_checksum: str | None = None,\n        data_file: str | None = None,\n        features_file: str | None = None,\n        qualities_file: str | None = None,\n        dataset: str | None = None,\n        parquet_url: str | None = None,\n        parquet_file: str | None = None,\n    ):\n        if cache_format not in [\"feather\", \"pickle\"]:\n            raise ValueError(\n                \"cache_format must be one of 'feather' or 'pickle. \"\n                f\"Invalid format specified: {cache_format}\",\n            )\n\n        def find_invalid_characters(string: str, pattern: str) -&gt; str:\n            invalid_chars = set()\n            regex = re.compile(pattern)\n            for char in string:\n                if not regex.match(char):\n                    invalid_chars.add(char)\n            return \",\".join(\n                [f\"'{char}'\" if char != \"'\" else f'\"{char}\"' for char in invalid_chars],\n            )\n\n        if dataset_id is None:\n            pattern = \"^[\\x00-\\x7f]*$\"\n            if description and not re.match(pattern, description):\n                # not basiclatin (XSD complains)\n                invalid_characters = find_invalid_characters(description, pattern)\n                raise ValueError(\n                    f\"Invalid symbols {invalid_characters} in description: {description}\",\n                )\n            pattern = \"^[\\x00-\\x7f]*$\"\n            if citation and not re.match(pattern, citation):\n                # not basiclatin (XSD complains)\n                invalid_characters = find_invalid_characters(citation, pattern)\n                raise ValueError(\n                    f\"Invalid symbols {invalid_characters} in citation: {citation}\",\n                )\n            pattern = \"^[a-zA-Z0-9_\\\\-\\\\.\\\\(\\\\),]+$\"\n            if not re.match(pattern, name):\n                # regex given by server in error message\n                invalid_characters = find_invalid_characters(name, pattern)\n                raise ValueError(f\"Invalid symbols {invalid_characters} in name: {name}\")\n\n        self.ignore_attribute: list[str] | None = None\n        if isinstance(ignore_attribute, str):\n            self.ignore_attribute = [ignore_attribute]\n        elif isinstance(ignore_attribute, list) or ignore_attribute is None:\n            self.ignore_attribute = ignore_attribute\n        else:\n            raise ValueError(\"Wrong data type for ignore_attribute. Should be list.\")\n\n        # TODO add function to check if the name is casual_string128\n        # Attributes received by querying the RESTful API\n        self.dataset_id = int(dataset_id) if dataset_id is not None else None\n        self.name = name\n        self.version = int(version) if version is not None else None\n        self.description = description\n        self.cache_format = cache_format\n        # Has to be called format, otherwise there will be an XML upload error\n        self.format = data_format\n        self.creator = creator\n        self.contributor = contributor\n        self.collection_date = collection_date\n        self.upload_date = upload_date\n        self.language = language\n        self.licence = licence\n        self.url = url\n        self.default_target_attribute = default_target_attribute\n        self.row_id_attribute = row_id_attribute\n\n        self.version_label = version_label\n        self.citation = citation\n        self.tag = tag\n        self.visibility = visibility\n        self.original_data_url = original_data_url\n        self.paper_url = paper_url\n        self.update_comment = update_comment\n        self.md5_checksum = md5_checksum\n        self.data_file = data_file\n        self.parquet_file = parquet_file\n        self._dataset = dataset\n        self._parquet_url = parquet_url\n\n        self._features: dict[int, OpenMLDataFeature] | None = None\n        self._qualities: dict[str, float] | None = None\n        self._no_qualities_found = False\n\n        if features_file is not None:\n            self._features = _read_features(Path(features_file))\n\n        # \"\" was the old default value by `get_dataset` and maybe still used by some\n        if qualities_file == \"\":\n            # TODO(0.15): to switch to \"qualities_file is not None\" below and remove warning\n            warnings.warn(\n                \"Starting from Version 0.15 `qualities_file` must be None and not an empty string \"\n                \"to avoid reading the qualities from file. Set `qualities_file` to None to avoid \"\n                \"this warning.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n            qualities_file = None\n\n        if qualities_file is not None:\n            self._qualities = _read_qualities(Path(qualities_file))\n\n        if data_file is not None:\n            data_pickle, data_feather, feather_attribute = self._compressed_cache_file_paths(\n                Path(data_file)\n            )\n            self.data_pickle_file = data_pickle if Path(data_pickle).exists() else None\n            self.data_feather_file = data_feather if Path(data_feather).exists() else None\n            self.feather_attribute_file = feather_attribute if Path(feather_attribute) else None\n        else:\n            self.data_pickle_file = None\n            self.data_feather_file = None\n            self.feather_attribute_file = None\n\n    @property\n    def features(self) -&gt; dict[int, OpenMLDataFeature]:\n        \"\"\"Get the features of this dataset.\"\"\"\n        if self._features is None:\n            # TODO(eddiebergman): These should return a value so we can set it to be not None\n            self._load_features()\n\n        assert self._features is not None\n        return self._features\n\n    @property\n    def qualities(self) -&gt; dict[str, float] | None:\n        \"\"\"Get the qualities of this dataset.\"\"\"\n        # TODO(eddiebergman): Better docstring, I don't know what qualities means\n\n        # We have to check `_no_qualities_found` as there might not be qualities for a dataset\n        if self._qualities is None and (not self._no_qualities_found):\n            self._load_qualities()\n\n        return self._qualities\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Get the dataset numeric id.\"\"\"\n        return self.dataset_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | None]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        # Obtain number of features in accordance with lazy loading.\n        n_features: int | None = None\n        if self._qualities is not None and self._qualities[\"NumberOfFeatures\"] is not None:\n            n_features = int(self._qualities[\"NumberOfFeatures\"])\n        elif self._features is not None:\n            n_features = len(self._features)\n\n        fields: dict[str, int | str | None] = {\n            \"Name\": self.name,\n            \"Version\": self.version,\n            \"Format\": self.format,\n            \"Licence\": self.licence,\n            \"Download URL\": self.url,\n            \"Data file\": str(self.data_file) if self.data_file is not None else None,\n            \"Pickle file\": (\n                str(self.data_pickle_file) if self.data_pickle_file is not None else None\n            ),\n            \"# of features\": n_features,\n        }\n        if self.upload_date is not None:\n            fields[\"Upload Date\"] = self.upload_date.replace(\"T\", \" \")\n        if self.dataset_id is not None:\n            fields[\"OpenML URL\"] = self.openml_url\n        if self._qualities is not None and self._qualities[\"NumberOfInstances\"] is not None:\n            fields[\"# of instances\"] = int(self._qualities[\"NumberOfInstances\"])\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Name\",\n            \"Version\",\n            \"Format\",\n            \"Upload Date\",\n            \"Licence\",\n            \"Download URL\",\n            \"OpenML URL\",\n            \"Data File\",\n            \"Pickle File\",\n            \"# of features\",\n            \"# of instances\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, OpenMLDataset):\n            return False\n\n        server_fields = {\n            \"dataset_id\",\n            \"version\",\n            \"upload_date\",\n            \"url\",\n            \"_parquet_url\",\n            \"dataset\",\n            \"data_file\",\n            \"format\",\n            \"cache_format\",\n        }\n\n        cache_fields = {\n            \"_dataset\",\n            \"data_file\",\n            \"data_pickle_file\",\n            \"data_feather_file\",\n            \"feather_attribute_file\",\n            \"parquet_file\",\n        }\n\n        # check that common keys and values are identical\n        ignore_fields = server_fields | cache_fields\n        self_keys = set(self.__dict__.keys()) - ignore_fields\n        other_keys = set(other.__dict__.keys()) - ignore_fields\n        return self_keys == other_keys and all(\n            self.__dict__[key] == other.__dict__[key] for key in self_keys\n        )\n\n    def _download_data(self) -&gt; None:\n        \"\"\"Download ARFF data file to standard cache directory. Set `self.data_file`.\"\"\"\n        # import required here to avoid circular import.\n        from .functions import _get_dataset_arff, _get_dataset_parquet\n\n        skip_parquet = os.environ.get(OPENML_SKIP_PARQUET_ENV_VAR, \"false\").casefold() == \"true\"\n        if self._parquet_url is not None and not skip_parquet:\n            parquet_file = _get_dataset_parquet(self)\n            self.parquet_file = None if parquet_file is None else str(parquet_file)\n        if self.parquet_file is None:\n            self.data_file = str(_get_dataset_arff(self))\n\n    def _get_arff(self, format: str) -&gt; dict:  # noqa: A002\n        \"\"\"Read ARFF file and return decoded arff.\n\n        Reads the file referenced in self.data_file.\n\n        Parameters\n        ----------\n        format : str\n            Format of the ARFF file.\n            Must be one of 'arff' or 'sparse_arff' or a string that will be either of those\n            when converted to lower case.\n\n\n\n        Returns\n        -------\n        dict\n            Decoded arff.\n\n        \"\"\"\n        # TODO: add a partial read method which only returns the attribute\n        # headers of the corresponding .arff file!\n        import struct\n\n        filename = self.data_file\n        assert filename is not None\n        filepath = Path(filename)\n\n        bits = 8 * struct.calcsize(\"P\")\n\n        # Files can be considered too large on a 32-bit system,\n        # if it exceeds 120mb (slightly more than covtype dataset size)\n        # This number is somewhat arbitrary.\n        if bits != 64:\n            MB_120 = 120_000_000\n            file_size = filepath.stat().st_size\n            if file_size &gt; MB_120:\n                raise NotImplementedError(\n                    f\"File {filename} too big for {file_size}-bit system ({bits} bytes).\",\n                )\n\n        if format.lower() == \"arff\":\n            return_type = arff.DENSE\n        elif format.lower() == \"sparse_arff\":\n            return_type = arff.COO\n        else:\n            raise ValueError(f\"Unknown data format {format}\")\n\n        def decode_arff(fh: Any) -&gt; dict:\n            decoder = arff.ArffDecoder()\n            return decoder.decode(fh, encode_nominal=True, return_type=return_type)  # type: ignore\n\n        if filepath.suffix.endswith(\".gz\"):\n            with gzip.open(filename) as zipfile:\n                return decode_arff(zipfile)\n        else:\n            with filepath.open(encoding=\"utf8\") as fh:\n                return decode_arff(fh)\n\n    def _parse_data_from_arff(  # noqa: C901, PLR0912, PLR0915\n        self,\n        arff_file_path: Path,\n    ) -&gt; tuple[pd.DataFrame | scipy.sparse.csr_matrix, list[bool], list[str]]:\n        \"\"\"Parse all required data from arff file.\n\n        Parameters\n        ----------\n        arff_file_path : str\n            Path to the file on disk.\n\n        Returns\n        -------\n        Tuple[Union[pd.DataFrame, scipy.sparse.csr_matrix], List[bool], List[str]]\n            DataFrame or csr_matrix: dataset\n            List[bool]: List indicating which columns contain categorical variables.\n            List[str]: List of column names.\n        \"\"\"\n        try:\n            data = self._get_arff(self.format)\n        except OSError as e:\n            logger.critical(\n                f\"Please check that the data file {arff_file_path} is there and can be read.\",\n            )\n            raise e\n\n        ARFF_DTYPES_TO_PD_DTYPE = {\n            \"INTEGER\": \"integer\",\n            \"REAL\": \"floating\",\n            \"NUMERIC\": \"floating\",\n            \"STRING\": \"string\",\n        }\n        attribute_dtype = {}\n        attribute_names = []\n        categories_names = {}\n        categorical = []\n        for name, type_ in data[\"attributes\"]:\n            # if the feature is nominal and a sparse matrix is\n            # requested, the categories need to be numeric\n            if isinstance(type_, list) and self.format.lower() == \"sparse_arff\":\n                try:\n                    # checks if the strings which should be the class labels\n                    # can be encoded into integers\n                    pd.factorize(type_)[0]\n                except ValueError as e:\n                    raise ValueError(\n                        \"Categorical data needs to be numeric when using sparse ARFF.\"\n                    ) from e\n\n            # string can only be supported with pandas DataFrame\n            elif type_ == \"STRING\" and self.format.lower() == \"sparse_arff\":\n                raise ValueError(\"Dataset containing strings is not supported with sparse ARFF.\")\n\n            # infer the dtype from the ARFF header\n            if isinstance(type_, list):\n                categorical.append(True)\n                categories_names[name] = type_\n                if len(type_) == 2:\n                    type_norm = [cat.lower().capitalize() for cat in type_]\n                    if {\"True\", \"False\"} == set(type_norm):\n                        categories_names[name] = [cat == \"True\" for cat in type_norm]\n                        attribute_dtype[name] = \"boolean\"\n                    else:\n                        attribute_dtype[name] = \"categorical\"\n                else:\n                    attribute_dtype[name] = \"categorical\"\n            else:\n                categorical.append(False)\n                attribute_dtype[name] = ARFF_DTYPES_TO_PD_DTYPE[type_]\n            attribute_names.append(name)\n\n        if self.format.lower() == \"sparse_arff\":\n            X = data[\"data\"]\n            X_shape = (max(X[1]) + 1, max(X[2]) + 1)\n            X = scipy.sparse.coo_matrix((X[0], (X[1], X[2])), shape=X_shape, dtype=np.float32)\n            X = X.tocsr()\n        elif self.format.lower() == \"arff\":\n            X = pd.DataFrame(data[\"data\"], columns=attribute_names)\n\n            col = []\n            for column_name in X.columns:\n                if attribute_dtype[column_name] in (\"categorical\", \"boolean\"):\n                    categories = self._unpack_categories(\n                        X[column_name],  # type: ignore\n                        categories_names[column_name],\n                    )\n                    col.append(categories)\n                elif attribute_dtype[column_name] in (\"floating\", \"integer\"):\n                    X_col = X[column_name]\n                    if X_col.min() &gt;= 0 and X_col.max() &lt;= 255:\n                        try:\n                            X_col_uint = X_col.astype(\"uint8\")\n                            if (X_col == X_col_uint).all():\n                                col.append(X_col_uint)\n                                continue\n                        except ValueError:\n                            pass\n                    col.append(X[column_name])\n                else:\n                    col.append(X[column_name])\n            X = pd.concat(col, axis=1)\n        else:\n            raise ValueError(f\"Dataset format '{self.format}' is not a valid format.\")\n\n        return X, categorical, attribute_names  # type: ignore\n\n    def _compressed_cache_file_paths(self, data_file: Path) -&gt; tuple[Path, Path, Path]:\n        data_pickle_file = data_file.with_suffix(\".pkl.py3\")\n        data_feather_file = data_file.with_suffix(\".feather\")\n        feather_attribute_file = data_file.with_suffix(\".feather.attributes.pkl.py3\")\n        return data_pickle_file, data_feather_file, feather_attribute_file\n\n    def _cache_compressed_file_from_file(\n        self,\n        data_file: Path,\n    ) -&gt; tuple[pd.DataFrame | scipy.sparse.csr_matrix, list[bool], list[str]]:\n        \"\"\"Store data from the local file in compressed format.\n\n        If a local parquet file is present it will be used instead of the arff file.\n        Sets cache_format to 'pickle' if data is sparse.\n        \"\"\"\n        (\n            data_pickle_file,\n            data_feather_file,\n            feather_attribute_file,\n        ) = self._compressed_cache_file_paths(data_file)\n\n        attribute_names, categorical, data = self._parse_data_from_file(data_file)\n\n        # Feather format does not work for sparse datasets, so we use pickle for sparse datasets\n        if scipy.sparse.issparse(data):\n            self.cache_format = \"pickle\"\n\n        logger.info(f\"{self.cache_format} write {self.name}\")\n        if self.cache_format == \"feather\":\n            assert isinstance(data, pd.DataFrame)\n\n            data.to_feather(data_feather_file)\n            with open(feather_attribute_file, \"wb\") as fh:  # noqa: PTH123\n                pickle.dump((categorical, attribute_names), fh, pickle.HIGHEST_PROTOCOL)\n            self.data_feather_file = data_feather_file\n            self.feather_attribute_file = feather_attribute_file\n\n        else:\n            with open(data_pickle_file, \"wb\") as fh:  # noqa: PTH123\n                pickle.dump((data, categorical, attribute_names), fh, pickle.HIGHEST_PROTOCOL)\n            self.data_pickle_file = data_pickle_file\n\n        data_file = data_pickle_file if self.cache_format == \"pickle\" else data_feather_file\n        logger.debug(f\"Saved dataset {int(self.dataset_id or -1)}: {self.name} to file {data_file}\")\n\n        return data, categorical, attribute_names\n\n    def _parse_data_from_file(\n        self,\n        data_file: Path,\n    ) -&gt; tuple[list[str], list[bool], pd.DataFrame | scipy.sparse.csr_matrix]:\n        if data_file.suffix == \".arff\":\n            data, categorical, attribute_names = self._parse_data_from_arff(data_file)\n        elif data_file.suffix == \".pq\":\n            attribute_names, categorical, data = self._parse_data_from_pq(data_file)\n        else:\n            raise ValueError(f\"Unknown file type for file '{data_file}'.\")\n\n        return attribute_names, categorical, data\n\n    def _parse_data_from_pq(self, data_file: Path) -&gt; tuple[list[str], list[bool], pd.DataFrame]:\n        try:\n            data = pd.read_parquet(data_file)\n        except Exception as e:\n            raise Exception(f\"File: {data_file}\") from e\n        categorical = [data[c].dtype.name == \"category\" for c in data.columns]\n        attribute_names = list(data.columns)\n        return attribute_names, categorical, data\n\n    def _load_data(self) -&gt; tuple[pd.DataFrame, list[bool], list[str]]:  # noqa: PLR0912, C901, PLR0915\n        \"\"\"Load data from compressed format or arff. Download data if not present on disk.\"\"\"\n        need_to_create_pickle = self.cache_format == \"pickle\" and self.data_pickle_file is None\n        need_to_create_feather = self.cache_format == \"feather\" and self.data_feather_file is None\n\n        if need_to_create_pickle or need_to_create_feather:\n            if self.data_file is None:\n                self._download_data()\n\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n            data, cats, attrs = self._cache_compressed_file_from_file(Path(file_to_load))\n            return _ensure_dataframe(data, attrs), cats, attrs\n\n        # helper variable to help identify where errors occur\n        fpath = self.data_feather_file if self.cache_format == \"feather\" else self.data_pickle_file\n        logger.info(f\"{self.cache_format} load data {self.name}\")\n        try:\n            if self.cache_format == \"feather\":\n                assert self.data_feather_file is not None\n                assert self.feather_attribute_file is not None\n\n                data = pd.read_feather(self.data_feather_file)\n                fpath = self.feather_attribute_file\n                with self.feather_attribute_file.open(\"rb\") as fh:\n                    categorical, attribute_names = pickle.load(fh)  # noqa: S301\n            else:\n                assert self.data_pickle_file is not None\n                with self.data_pickle_file.open(\"rb\") as fh:\n                    data, categorical, attribute_names = pickle.load(fh)  # noqa: S301\n\n        except FileNotFoundError as e:\n            raise ValueError(\n                f\"Cannot find file for dataset {self.name} at location '{fpath}'.\"\n            ) from e\n        except (EOFError, ModuleNotFoundError, ValueError, AttributeError) as e:\n            error_message = getattr(e, \"message\", e.args[0])\n            hint = \"\"\n\n            if isinstance(e, EOFError):\n                readable_error = \"Detected a corrupt cache file\"\n            elif isinstance(e, (ModuleNotFoundError, AttributeError)):\n                readable_error = \"Detected likely dependency issues\"\n                hint = (\n                    \"This can happen if the cache was constructed with a different pandas version \"\n                    \"than the one that is used to load the data. See also \"\n                )\n                if isinstance(e, ModuleNotFoundError):\n                    hint += \"https://github.com/openml/openml-python/issues/918. \"\n                elif isinstance(e, AttributeError):\n                    hint += \"https://github.com/openml/openml-python/pull/1121. \"\n\n            elif isinstance(e, ValueError) and \"unsupported pickle protocol\" in e.args[0]:\n                readable_error = \"Encountered unsupported pickle protocol\"\n            else:\n                raise e\n\n            logger.warning(\n                f\"{readable_error} when loading dataset {self.id} from '{fpath}'. \"\n                f\"{hint}\"\n                f\"Error message was: {error_message}. \"\n                \"We will continue loading data from the arff-file, \"\n                \"but this will be much slower for big datasets. \"\n                \"Please manually delete the cache file if you want OpenML-Python \"\n                \"to attempt to reconstruct it.\",\n            )\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n            attr, cat, df = self._parse_data_from_file(Path(file_to_load))\n            return _ensure_dataframe(df), cat, attr\n\n        data_up_to_date = isinstance(data, pd.DataFrame) or scipy.sparse.issparse(data)\n        if self.cache_format == \"pickle\" and not data_up_to_date:\n            logger.info(\"Updating outdated pickle file.\")\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n\n            data, cats, attrs = self._cache_compressed_file_from_file(Path(file_to_load))\n\n        return _ensure_dataframe(data, attribute_names), categorical, attribute_names\n\n    @staticmethod\n    def _unpack_categories(series: pd.Series, categories: list) -&gt; pd.Series:\n        # nan-likes can not be explicitly specified as a category\n        def valid_category(cat: Any) -&gt; bool:\n            return isinstance(cat, str) or (cat is not None and not np.isnan(cat))\n\n        filtered_categories = [c for c in categories if valid_category(c)]\n        col = []\n        for x in series:\n            try:\n                col.append(categories[int(x)])\n            except (TypeError, ValueError):\n                col.append(np.nan)\n\n        # We require two lines to create a series of categories as detailed here:\n        # https://pandas.pydata.org/pandas-docs/version/0.24/user_guide/categorical.html#series-creation\n        raw_cat = pd.Categorical(col, ordered=True, categories=filtered_categories)\n        return pd.Series(raw_cat, index=series.index, name=series.name)\n\n    def get_data(  # noqa: C901\n        self,\n        target: list[str] | str | None = None,\n        include_row_id: bool = False,  # noqa: FBT001, FBT002\n        include_ignore_attribute: bool = False,  # noqa: FBT001, FBT002\n    ) -&gt; tuple[pd.DataFrame, pd.Series | None, list[bool], list[str]]:\n        \"\"\"Returns dataset content as dataframes.\n\n        Parameters\n        ----------\n        target : string, List[str] or None (default=None)\n            Name of target column to separate from the data.\n            Splitting multiple columns is currently not supported.\n        include_row_id : boolean (default=False)\n            Whether to include row ids in the returned dataset.\n        include_ignore_attribute : boolean (default=False)\n            Whether to include columns that are marked as \"ignore\"\n            on the server in the dataset.\n\n\n        Returns\n        -------\n        X : dataframe, shape (n_samples, n_columns)\n            Dataset, may have sparse dtypes in the columns if required.\n        y : pd.Series, shape (n_samples, ) or None\n            Target column\n        categorical_indicator : list[bool]\n            Mask that indicate categorical features.\n        attribute_names : list[str]\n            List of attribute names.\n        \"\"\"\n        data, categorical_mask, attribute_names = self._load_data()\n\n        to_exclude = []\n        if not include_row_id and self.row_id_attribute is not None:\n            if isinstance(self.row_id_attribute, str):\n                to_exclude.append(self.row_id_attribute)\n            elif isinstance(self.row_id_attribute, Iterable):\n                to_exclude.extend(self.row_id_attribute)\n\n        if not include_ignore_attribute and self.ignore_attribute is not None:\n            if isinstance(self.ignore_attribute, str):\n                to_exclude.append(self.ignore_attribute)\n            elif isinstance(self.ignore_attribute, Iterable):\n                to_exclude.extend(self.ignore_attribute)\n\n        if len(to_exclude) &gt; 0:\n            logger.info(f\"Going to remove the following attributes: {to_exclude}\")\n            keep = np.array([column not in to_exclude for column in attribute_names])\n            data = data.drop(columns=to_exclude)\n            categorical_mask = [cat for cat, k in zip(categorical_mask, keep) if k]\n            attribute_names = [att for att, k in zip(attribute_names, keep) if k]\n\n        if target is None:\n            return data, None, categorical_mask, attribute_names\n\n        if isinstance(target, str):\n            target_names = target.split(\",\") if \",\" in target else [target]\n        else:\n            target_names = target\n\n        # All the assumptions below for the target are dependant on the number of targets being 1\n        n_targets = len(target_names)\n        if n_targets &gt; 1:\n            raise NotImplementedError(f\"Number of targets {n_targets} not implemented.\")\n\n        target_name = target_names[0]\n        x = data.drop(columns=[target_name])\n        y = data[target_name].squeeze()\n\n        # Finally, remove the target from the list of attributes and categorical mask\n        target_index = attribute_names.index(target_name)\n        categorical_mask.pop(target_index)\n        attribute_names.remove(target_name)\n\n        assert isinstance(y, pd.Series)\n        return x, y, categorical_mask, attribute_names\n\n    def _load_features(self) -&gt; None:\n        \"\"\"Load the features metadata from the server and store it in the dataset object.\"\"\"\n        # Delayed Import to avoid circular imports or having to import all of dataset.functions to\n        # import OpenMLDataset.\n        from openml.datasets.functions import _get_dataset_features_file\n\n        if self.dataset_id is None:\n            raise ValueError(\n                \"No dataset id specified. Please set the dataset id. Otherwise we cannot load \"\n                \"metadata.\",\n            )\n\n        features_file = _get_dataset_features_file(None, self.dataset_id)\n        self._features = _read_features(features_file)\n\n    def _load_qualities(self) -&gt; None:\n        \"\"\"Load qualities information from the server and store it in the dataset object.\"\"\"\n        # same reason as above for _load_features\n        from openml.datasets.functions import _get_dataset_qualities_file\n\n        if self.dataset_id is None:\n            raise ValueError(\n                \"No dataset id specified. Please set the dataset id. Otherwise we cannot load \"\n                \"metadata.\",\n            )\n\n        qualities_file = _get_dataset_qualities_file(None, self.dataset_id)\n\n        if qualities_file is None:\n            self._no_qualities_found = True\n        else:\n            self._qualities = _read_qualities(qualities_file)\n\n    def retrieve_class_labels(self, target_name: str = \"class\") -&gt; None | list[str]:\n        \"\"\"Reads the datasets arff to determine the class-labels.\n\n        If the task has no class labels (for example a regression problem)\n        it returns None. Necessary because the data returned by get_data\n        only contains the indices of the classes, while OpenML needs the real\n        classname when uploading the results of a run.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target attribute\n\n        Returns\n        -------\n        list\n        \"\"\"\n        for feature in self.features.values():\n            if feature.name == target_name:\n                if feature.data_type == \"nominal\":\n                    return feature.nominal_values\n\n                if feature.data_type == \"string\":\n                    # Rel.: #1311\n                    # The target is invalid for a classification task if the feature type is string\n                    # and not nominal. For such miss-configured tasks, we silently fix it here as\n                    # we can safely interpreter string as nominal.\n                    df, *_ = self.get_data()\n                    return list(df[feature.name].unique())\n\n        return None\n\n    def get_features_by_type(  # noqa: C901\n        self,\n        data_type: str,\n        exclude: list[str] | None = None,\n        exclude_ignore_attribute: bool = True,  # noqa: FBT002, FBT001\n        exclude_row_id_attribute: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; list[int]:\n        \"\"\"\n        Return indices of features of a given type, e.g. all nominal features.\n        Optional parameters to exclude various features by index or ontology.\n\n        Parameters\n        ----------\n        data_type : str\n            The data type to return (e.g., nominal, numeric, date, string)\n        exclude : list(int)\n            List of columns to exclude from the return value\n        exclude_ignore_attribute : bool\n            Whether to exclude the defined ignore attributes (and adapt the\n            return values as if these indices are not present)\n        exclude_row_id_attribute : bool\n            Whether to exclude the defined row id attributes (and adapt the\n            return values as if these indices are not present)\n\n        Returns\n        -------\n        result : list\n            a list of indices that have the specified data type\n        \"\"\"\n        if data_type not in OpenMLDataFeature.LEGAL_DATA_TYPES:\n            raise TypeError(\"Illegal feature type requested\")\n        if self.ignore_attribute is not None and not isinstance(self.ignore_attribute, list):\n            raise TypeError(\"ignore_attribute should be a list\")\n        if self.row_id_attribute is not None and not isinstance(self.row_id_attribute, str):\n            raise TypeError(\"row id attribute should be a str\")\n        if exclude is not None and not isinstance(exclude, list):\n            raise TypeError(\"Exclude should be a list\")\n            # assert all(isinstance(elem, str) for elem in exclude),\n            #            \"Exclude should be a list of strings\"\n        to_exclude = []\n        if exclude is not None:\n            to_exclude.extend(exclude)\n        if exclude_ignore_attribute and self.ignore_attribute is not None:\n            to_exclude.extend(self.ignore_attribute)\n        if exclude_row_id_attribute and self.row_id_attribute is not None:\n            to_exclude.append(self.row_id_attribute)\n\n        result = []\n        offset = 0\n        # this function assumes that everything in to_exclude will\n        # be 'excluded' from the dataset (hence the offset)\n        for idx in self.features:\n            name = self.features[idx].name\n            if name in to_exclude:\n                offset += 1\n            elif self.features[idx].data_type == data_type:\n                result.append(idx - offset)\n        return result\n\n    def _get_file_elements(self) -&gt; dict:\n        \"\"\"Adds the 'dataset' to file elements.\"\"\"\n        file_elements: dict = {}\n        path = None if self.data_file is None else Path(self.data_file).absolute()\n\n        if self._dataset is not None:\n            file_elements[\"dataset\"] = self._dataset\n        elif path is not None and path.exists():\n            with path.open(\"rb\") as fp:\n                file_elements[\"dataset\"] = fp.read()\n\n            try:\n                dataset_utf8 = str(file_elements[\"dataset\"], encoding=\"utf8\")\n                arff.ArffDecoder().decode(dataset_utf8, encode_nominal=True)\n            except arff.ArffException as e:\n                raise ValueError(\"The file you have provided is not a valid arff file.\") from e\n\n        elif self.url is None:\n            raise ValueError(\"No valid url/path to the data file was given.\")\n        return file_elements\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.dataset_id = int(xml_response[\"oml:upload_data_set\"][\"oml:id\"])\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        props = [\n            \"id\",\n            \"name\",\n            \"version\",\n            \"description\",\n            \"format\",\n            \"creator\",\n            \"contributor\",\n            \"collection_date\",\n            \"upload_date\",\n            \"language\",\n            \"licence\",\n            \"url\",\n            \"default_target_attribute\",\n            \"row_id_attribute\",\n            \"ignore_attribute\",\n            \"version_label\",\n            \"citation\",\n            \"tag\",\n            \"visibility\",\n            \"original_data_url\",\n            \"paper_url\",\n            \"update_comment\",\n            \"md5_checksum\",\n        ]\n\n        prop_values = {}\n        for prop in props:\n            content = getattr(self, prop, None)\n            if content is not None:\n                prop_values[\"oml:\" + prop] = content\n\n        return {\n            \"oml:data_set_description\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                **prop_values,\n            }\n        }\n</code></pre>"},{"location":"reference/#openml.OpenMLDataset.features","title":"<code>features: dict[int, OpenMLDataFeature]</code>  <code>property</code>","text":"<p>Get the features of this dataset.</p>"},{"location":"reference/#openml.OpenMLDataset.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Get the dataset numeric id.</p>"},{"location":"reference/#openml.OpenMLDataset.qualities","title":"<code>qualities: dict[str, float] | None</code>  <code>property</code>","text":"<p>Get the qualities of this dataset.</p>"},{"location":"reference/#openml.OpenMLDataset.get_data","title":"<code>get_data(target=None, include_row_id=False, include_ignore_attribute=False)</code>","text":"<p>Returns dataset content as dataframes.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>(string, List[str] or None(default=None))</code> <p>Name of target column to separate from the data. Splitting multiple columns is currently not supported.</p> <code>None</code> <code>include_row_id</code> <code>boolean(default=False)</code> <p>Whether to include row ids in the returned dataset.</p> <code>False</code> <code>include_ignore_attribute</code> <code>boolean(default=False)</code> <p>Whether to include columns that are marked as \"ignore\" on the server in the dataset.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>X</code> <code>(dataframe, shape(n_samples, n_columns))</code> <p>Dataset, may have sparse dtypes in the columns if required.</p> <code>y</code> <code>(Series, shape(n_samples) or None)</code> <p>Target column</p> <code>categorical_indicator</code> <code>list[bool]</code> <p>Mask that indicate categorical features.</p> <code>attribute_names</code> <code>list[str]</code> <p>List of attribute names.</p> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def get_data(  # noqa: C901\n    self,\n    target: list[str] | str | None = None,\n    include_row_id: bool = False,  # noqa: FBT001, FBT002\n    include_ignore_attribute: bool = False,  # noqa: FBT001, FBT002\n) -&gt; tuple[pd.DataFrame, pd.Series | None, list[bool], list[str]]:\n    \"\"\"Returns dataset content as dataframes.\n\n    Parameters\n    ----------\n    target : string, List[str] or None (default=None)\n        Name of target column to separate from the data.\n        Splitting multiple columns is currently not supported.\n    include_row_id : boolean (default=False)\n        Whether to include row ids in the returned dataset.\n    include_ignore_attribute : boolean (default=False)\n        Whether to include columns that are marked as \"ignore\"\n        on the server in the dataset.\n\n\n    Returns\n    -------\n    X : dataframe, shape (n_samples, n_columns)\n        Dataset, may have sparse dtypes in the columns if required.\n    y : pd.Series, shape (n_samples, ) or None\n        Target column\n    categorical_indicator : list[bool]\n        Mask that indicate categorical features.\n    attribute_names : list[str]\n        List of attribute names.\n    \"\"\"\n    data, categorical_mask, attribute_names = self._load_data()\n\n    to_exclude = []\n    if not include_row_id and self.row_id_attribute is not None:\n        if isinstance(self.row_id_attribute, str):\n            to_exclude.append(self.row_id_attribute)\n        elif isinstance(self.row_id_attribute, Iterable):\n            to_exclude.extend(self.row_id_attribute)\n\n    if not include_ignore_attribute and self.ignore_attribute is not None:\n        if isinstance(self.ignore_attribute, str):\n            to_exclude.append(self.ignore_attribute)\n        elif isinstance(self.ignore_attribute, Iterable):\n            to_exclude.extend(self.ignore_attribute)\n\n    if len(to_exclude) &gt; 0:\n        logger.info(f\"Going to remove the following attributes: {to_exclude}\")\n        keep = np.array([column not in to_exclude for column in attribute_names])\n        data = data.drop(columns=to_exclude)\n        categorical_mask = [cat for cat, k in zip(categorical_mask, keep) if k]\n        attribute_names = [att for att, k in zip(attribute_names, keep) if k]\n\n    if target is None:\n        return data, None, categorical_mask, attribute_names\n\n    if isinstance(target, str):\n        target_names = target.split(\",\") if \",\" in target else [target]\n    else:\n        target_names = target\n\n    # All the assumptions below for the target are dependant on the number of targets being 1\n    n_targets = len(target_names)\n    if n_targets &gt; 1:\n        raise NotImplementedError(f\"Number of targets {n_targets} not implemented.\")\n\n    target_name = target_names[0]\n    x = data.drop(columns=[target_name])\n    y = data[target_name].squeeze()\n\n    # Finally, remove the target from the list of attributes and categorical mask\n    target_index = attribute_names.index(target_name)\n    categorical_mask.pop(target_index)\n    attribute_names.remove(target_name)\n\n    assert isinstance(y, pd.Series)\n    return x, y, categorical_mask, attribute_names\n</code></pre>"},{"location":"reference/#openml.OpenMLDataset.get_features_by_type","title":"<code>get_features_by_type(data_type, exclude=None, exclude_ignore_attribute=True, exclude_row_id_attribute=True)</code>","text":"<p>Return indices of features of a given type, e.g. all nominal features. Optional parameters to exclude various features by index or ontology.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>The data type to return (e.g., nominal, numeric, date, string)</p> required <code>exclude</code> <code>list(int)</code> <p>List of columns to exclude from the return value</p> <code>None</code> <code>exclude_ignore_attribute</code> <code>bool</code> <p>Whether to exclude the defined ignore attributes (and adapt the return values as if these indices are not present)</p> <code>True</code> <code>exclude_row_id_attribute</code> <code>bool</code> <p>Whether to exclude the defined row id attributes (and adapt the return values as if these indices are not present)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>result</code> <code>list</code> <p>a list of indices that have the specified data type</p> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def get_features_by_type(  # noqa: C901\n    self,\n    data_type: str,\n    exclude: list[str] | None = None,\n    exclude_ignore_attribute: bool = True,  # noqa: FBT002, FBT001\n    exclude_row_id_attribute: bool = True,  # noqa: FBT002, FBT001\n) -&gt; list[int]:\n    \"\"\"\n    Return indices of features of a given type, e.g. all nominal features.\n    Optional parameters to exclude various features by index or ontology.\n\n    Parameters\n    ----------\n    data_type : str\n        The data type to return (e.g., nominal, numeric, date, string)\n    exclude : list(int)\n        List of columns to exclude from the return value\n    exclude_ignore_attribute : bool\n        Whether to exclude the defined ignore attributes (and adapt the\n        return values as if these indices are not present)\n    exclude_row_id_attribute : bool\n        Whether to exclude the defined row id attributes (and adapt the\n        return values as if these indices are not present)\n\n    Returns\n    -------\n    result : list\n        a list of indices that have the specified data type\n    \"\"\"\n    if data_type not in OpenMLDataFeature.LEGAL_DATA_TYPES:\n        raise TypeError(\"Illegal feature type requested\")\n    if self.ignore_attribute is not None and not isinstance(self.ignore_attribute, list):\n        raise TypeError(\"ignore_attribute should be a list\")\n    if self.row_id_attribute is not None and not isinstance(self.row_id_attribute, str):\n        raise TypeError(\"row id attribute should be a str\")\n    if exclude is not None and not isinstance(exclude, list):\n        raise TypeError(\"Exclude should be a list\")\n        # assert all(isinstance(elem, str) for elem in exclude),\n        #            \"Exclude should be a list of strings\"\n    to_exclude = []\n    if exclude is not None:\n        to_exclude.extend(exclude)\n    if exclude_ignore_attribute and self.ignore_attribute is not None:\n        to_exclude.extend(self.ignore_attribute)\n    if exclude_row_id_attribute and self.row_id_attribute is not None:\n        to_exclude.append(self.row_id_attribute)\n\n    result = []\n    offset = 0\n    # this function assumes that everything in to_exclude will\n    # be 'excluded' from the dataset (hence the offset)\n    for idx in self.features:\n        name = self.features[idx].name\n        if name in to_exclude:\n            offset += 1\n        elif self.features[idx].data_type == data_type:\n            result.append(idx - offset)\n    return result\n</code></pre>"},{"location":"reference/#openml.OpenMLDataset.retrieve_class_labels","title":"<code>retrieve_class_labels(target_name='class')</code>","text":"<p>Reads the datasets arff to determine the class-labels.</p> <p>If the task has no class labels (for example a regression problem) it returns None. Necessary because the data returned by get_data only contains the indices of the classes, while OpenML needs the real classname when uploading the results of a run.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>Name of the target attribute</p> <code>'class'</code> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def retrieve_class_labels(self, target_name: str = \"class\") -&gt; None | list[str]:\n    \"\"\"Reads the datasets arff to determine the class-labels.\n\n    If the task has no class labels (for example a regression problem)\n    it returns None. Necessary because the data returned by get_data\n    only contains the indices of the classes, while OpenML needs the real\n    classname when uploading the results of a run.\n\n    Parameters\n    ----------\n    target_name : str\n        Name of the target attribute\n\n    Returns\n    -------\n    list\n    \"\"\"\n    for feature in self.features.values():\n        if feature.name == target_name:\n            if feature.data_type == \"nominal\":\n                return feature.nominal_values\n\n            if feature.data_type == \"string\":\n                # Rel.: #1311\n                # The target is invalid for a classification task if the feature type is string\n                # and not nominal. For such miss-configured tasks, we silently fix it here as\n                # we can safely interpreter string as nominal.\n                df, *_ = self.get_data()\n                return list(df[feature.name].unique())\n\n    return None\n</code></pre>"},{"location":"reference/#openml.OpenMLEvaluation","title":"<code>OpenMLEvaluation</code>","text":"<p>Contains all meta-information about a run / evaluation combination, according to the evaluation/list function</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>Refers to the run.</p> required <code>task_id</code> <code>int</code> <p>Refers to the task.</p> required <code>setup_id</code> <code>int</code> <p>Refers to the setup.</p> required <code>flow_id</code> <code>int</code> <p>Refers to the flow.</p> required <code>flow_name</code> <code>str</code> <p>Name of the referred flow.</p> required <code>data_id</code> <code>int</code> <p>Refers to the dataset.</p> required <code>data_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>function</code> <code>str</code> <p>The evaluation metric of this item (e.g., accuracy).</p> required <code>upload_time</code> <code>str</code> <p>The time of evaluation.</p> required <code>uploader</code> <code>int</code> <p>Uploader ID (user ID)</p> required <code>upload_name</code> <code>str</code> <p>Name of the uploader of this evaluation</p> required <code>value</code> <code>float</code> <p>The value (score) of this evaluation.</p> required <code>values</code> <code>List[float]</code> <p>The values (scores) per repeat and fold (if requested)</p> required <code>array_data</code> <code>str</code> <p>list of information per class. (e.g., in case of precision, auroc, recall)</p> <code>None</code> Source code in <code>openml/evaluations/evaluation.py</code> <pre><code>class OpenMLEvaluation:\n    \"\"\"\n    Contains all meta-information about a run / evaluation combination,\n    according to the evaluation/list function\n\n    Parameters\n    ----------\n    run_id : int\n        Refers to the run.\n    task_id : int\n        Refers to the task.\n    setup_id : int\n        Refers to the setup.\n    flow_id : int\n        Refers to the flow.\n    flow_name : str\n        Name of the referred flow.\n    data_id : int\n        Refers to the dataset.\n    data_name : str\n        The name of the dataset.\n    function : str\n        The evaluation metric of this item (e.g., accuracy).\n    upload_time : str\n        The time of evaluation.\n    uploader: int\n        Uploader ID (user ID)\n    upload_name : str\n        Name of the uploader of this evaluation\n    value : float\n        The value (score) of this evaluation.\n    values : List[float]\n        The values (scores) per repeat and fold (if requested)\n    array_data : str\n        list of information per class.\n        (e.g., in case of precision, auroc, recall)\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        run_id: int,\n        task_id: int,\n        setup_id: int,\n        flow_id: int,\n        flow_name: str,\n        data_id: int,\n        data_name: str,\n        function: str,\n        upload_time: str,\n        uploader: int,\n        uploader_name: str,\n        value: float | None,\n        values: list[float] | None,\n        array_data: str | None = None,\n    ):\n        self.run_id = run_id\n        self.task_id = task_id\n        self.setup_id = setup_id\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.data_id = data_id\n        self.data_name = data_name\n        self.function = function\n        self.upload_time = upload_time\n        self.uploader = uploader\n        self.uploader_name = uploader_name\n        self.value = value\n        self.values = values\n        self.array_data = array_data\n\n    def _to_dict(self) -&gt; dict:\n        return {\n            \"run_id\": self.run_id,\n            \"task_id\": self.task_id,\n            \"setup_id\": self.setup_id,\n            \"flow_id\": self.flow_id,\n            \"flow_name\": self.flow_name,\n            \"data_id\": self.data_id,\n            \"data_name\": self.data_name,\n            \"function\": self.function,\n            \"upload_time\": self.upload_time,\n            \"uploader\": self.uploader,\n            \"uploader_name\": self.uploader_name,\n            \"value\": self.value,\n            \"values\": self.values,\n            \"array_data\": self.array_data,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Evaluation\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"Upload Date\": self.upload_time,\n            \"Run ID\": self.run_id,\n            \"OpenML Run URL\": openml.runs.OpenMLRun.url_for_id(self.run_id),\n            \"Task ID\": self.task_id,\n            \"OpenML Task URL\": openml.tasks.OpenMLTask.url_for_id(self.task_id),\n            \"Flow ID\": self.flow_id,\n            \"OpenML Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"Setup ID\": self.setup_id,\n            \"Data ID\": self.data_id,\n            \"Data Name\": self.data_name,\n            \"OpenML Data URL\": openml.datasets.OpenMLDataset.url_for_id(self.data_id),\n            \"Metric Used\": self.function,\n            \"Result\": self.value,\n        }\n\n        order = [\n            \"Uploader Date\",\n            \"Run ID\",\n            \"OpenML Run URL\",\n            \"Task ID\",\n            \"OpenML Task URL\" \"Flow ID\",\n            \"OpenML Flow URL\",\n            \"Setup ID\",\n            \"Data ID\",\n            \"Data Name\",\n            \"OpenML Data URL\",\n            \"Metric Used\",\n            \"Result\",\n        ]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/#openml.OpenMLFlow","title":"<code>OpenMLFlow</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Flow. Stores machine learning models.</p> <p>Flows should not be generated manually, but by the function :meth:<code>openml.flows.create_flow_from_model</code>. Using this helper function ensures that all relevant fields are filled in.</p> <p>Implements <code>openml.implementation.upload.xsd &lt;https://github.com/openml/openml/blob/master/openml_OS/views/pages/api_new/v1/xsd/ openml.implementation.upload.xsd&gt;</code>_.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the flow. Is used together with the attribute <code>external_version</code> as a unique identifier of the flow.</p> required <code>description</code> <code>str</code> <p>Human-readable description of the flow (free text).</p> required <code>model</code> <code>object</code> <p>ML model which is described by this flow.</p> required <code>components</code> <code>OrderedDict</code> <p>Mapping from component identifier to an OpenMLFlow object. Components are usually subfunctions of an algorithm (e.g. kernels), base learners in ensemble algorithms (decision tree in adaboost) or building blocks of a machine learning pipeline. Components are modeled as independent flows and can be shared between flows (different pipelines can use the same components).</p> required <code>parameters</code> <code>OrderedDict</code> <p>Mapping from parameter name to the parameter default value. The parameter default value must be of type <code>str</code>, so that the respective toolbox plugin can take care of casting the parameter default value to the correct type.</p> required <code>parameters_meta_info</code> <code>OrderedDict</code> <p>Mapping from parameter name to <code>dict</code>. Stores additional information for each parameter. Required keys are <code>data_type</code> and <code>description</code>.</p> required <code>external_version</code> <code>str</code> <p>Version number of the software the flow is implemented in. Is used together with the attribute <code>name</code> as a uniquer identifier of the flow.</p> required <code>tags</code> <code>list</code> <p>List of tags. Created on the server by other API calls.</p> required <code>language</code> <code>str</code> <p>Natural language the flow is described in (not the programming language).</p> required <code>dependencies</code> <code>str</code> <p>A list of dependencies necessary to run the flow. This field should contain all libraries the flow depends on. To allow reproducibility it should also specify the exact version numbers.</p> required <code>class_name</code> <code>str</code> <p>The development language name of the class which is described by this flow.</p> <code>None</code> <code>custom_name</code> <code>str</code> <p>Custom name of the flow given by the owner.</p> <code>None</code> <code>binary_url</code> <code>str</code> <p>Url from which the binary can be downloaded. Added by the server. Ignored when uploaded manually. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>binary_format</code> <code>str</code> <p>Format in which the binary code was uploaded. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>binary_md5</code> <code>str</code> <p>MD5 checksum to check if the binary code was correctly downloaded. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>uploader</code> <code>str</code> <p>OpenML user ID of the uploader. Filled in by the server.</p> <code>None</code> <code>upload_date</code> <code>str</code> <p>Date the flow was uploaded. Filled in by the server.</p> <code>None</code> <code>flow_id</code> <code>int</code> <p>Flow ID. Assigned by the server.</p> <code>None</code> <code>extension</code> <code>Extension</code> <p>The extension for a flow (e.g., sklearn).</p> <code>None</code> <code>version</code> <code>str</code> <p>OpenML version of the flow. Assigned by the server.</p> <code>None</code> Source code in <code>openml/flows/flow.py</code> <pre><code>class OpenMLFlow(OpenMLBase):\n    \"\"\"OpenML Flow. Stores machine learning models.\n\n    Flows should not be generated manually, but by the function\n    :meth:`openml.flows.create_flow_from_model`. Using this helper function\n    ensures that all relevant fields are filled in.\n\n    Implements `openml.implementation.upload.xsd\n    &lt;https://github.com/openml/openml/blob/master/openml_OS/views/pages/api_new/v1/xsd/\n    openml.implementation.upload.xsd&gt;`_.\n\n    Parameters\n    ----------\n    name : str\n        Name of the flow. Is used together with the attribute\n        `external_version` as a unique identifier of the flow.\n    description : str\n        Human-readable description of the flow (free text).\n    model : object\n        ML model which is described by this flow.\n    components : OrderedDict\n        Mapping from component identifier to an OpenMLFlow object. Components\n        are usually subfunctions of an algorithm (e.g. kernels), base learners\n        in ensemble algorithms (decision tree in adaboost) or building blocks\n        of a machine learning pipeline. Components are modeled as independent\n        flows and can be shared between flows (different pipelines can use\n        the same components).\n    parameters : OrderedDict\n        Mapping from parameter name to the parameter default value. The\n        parameter default value must be of type `str`, so that the respective\n        toolbox plugin can take care of casting the parameter default value to\n        the correct type.\n    parameters_meta_info : OrderedDict\n        Mapping from parameter name to `dict`. Stores additional information\n        for each parameter. Required keys are `data_type` and `description`.\n    external_version : str\n        Version number of the software the flow is implemented in. Is used\n        together with the attribute `name` as a uniquer identifier of the flow.\n    tags : list\n        List of tags. Created on the server by other API calls.\n    language : str\n        Natural language the flow is described in (not the programming\n        language).\n    dependencies : str\n        A list of dependencies necessary to run the flow. This field should\n        contain all libraries the flow depends on. To allow reproducibility\n        it should also specify the exact version numbers.\n    class_name : str, optional\n        The development language name of the class which is described by this\n        flow.\n    custom_name : str, optional\n        Custom name of the flow given by the owner.\n    binary_url : str, optional\n        Url from which the binary can be downloaded. Added by the server.\n        Ignored when uploaded manually. Will not be used by the python API\n        because binaries aren't compatible across machines.\n    binary_format : str, optional\n        Format in which the binary code was uploaded. Will not be used by the\n        python API because binaries aren't compatible across machines.\n    binary_md5 : str, optional\n        MD5 checksum to check if the binary code was correctly downloaded. Will\n        not be used by the python API because binaries aren't compatible across\n        machines.\n    uploader : str, optional\n        OpenML user ID of the uploader. Filled in by the server.\n    upload_date : str, optional\n        Date the flow was uploaded. Filled in by the server.\n    flow_id : int, optional\n        Flow ID. Assigned by the server.\n    extension : Extension, optional\n        The extension for a flow (e.g., sklearn).\n    version : str, optional\n        OpenML version of the flow. Assigned by the server.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        name: str,\n        description: str,\n        model: object,\n        components: dict,\n        parameters: dict,\n        parameters_meta_info: dict,\n        external_version: str,\n        tags: list,\n        language: str,\n        dependencies: str,\n        class_name: str | None = None,\n        custom_name: str | None = None,\n        binary_url: str | None = None,\n        binary_format: str | None = None,\n        binary_md5: str | None = None,\n        uploader: str | None = None,\n        upload_date: str | None = None,\n        flow_id: int | None = None,\n        extension: Extension | None = None,\n        version: str | None = None,\n    ):\n        self.name = name\n        self.description = description\n        self.model = model\n\n        for variable, variable_name in [\n            [components, \"components\"],\n            [parameters, \"parameters\"],\n            [parameters_meta_info, \"parameters_meta_info\"],\n        ]:\n            if not isinstance(variable, (OrderedDict, dict)):\n                raise TypeError(\n                    f\"{variable_name} must be of type OrderedDict or dict, \"\n                    f\"but is {type(variable)}.\",\n                )\n\n        self.components = components\n        self.parameters = parameters\n        self.parameters_meta_info = parameters_meta_info\n        self.class_name = class_name\n\n        keys_parameters = set(parameters.keys())\n        keys_parameters_meta_info = set(parameters_meta_info.keys())\n        if len(keys_parameters.difference(keys_parameters_meta_info)) &gt; 0:\n            raise ValueError(\n                f\"Parameter {keys_parameters.difference(keys_parameters_meta_info)!s} only in \"\n                \"parameters, but not in parameters_meta_info.\",\n            )\n        if len(keys_parameters_meta_info.difference(keys_parameters)) &gt; 0:\n            raise ValueError(\n                f\"Parameter {keys_parameters_meta_info.difference(keys_parameters)!s} only in \"\n                \" parameters_meta_info, but not in parameters.\",\n            )\n\n        self.external_version = external_version\n        self.uploader = uploader\n\n        self.custom_name = custom_name\n        self.tags = tags if tags is not None else []\n        self.binary_url = binary_url\n        self.binary_format = binary_format\n        self.binary_md5 = binary_md5\n        self.version = version\n        self.upload_date = upload_date\n        self.language = language\n        self.dependencies = dependencies\n        self.flow_id = flow_id\n        if extension is None:\n            self._extension = get_extension_by_flow(self)\n        else:\n            self._extension = extension\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"The ID of the flow.\"\"\"\n        return self.flow_id\n\n    @property\n    def extension(self) -&gt; Extension:\n        \"\"\"The extension of the flow (e.g., sklearn).\"\"\"\n        if self._extension is not None:\n            return self._extension\n\n        raise RuntimeError(\n            f\"No extension could be found for flow {self.flow_id}: {self.name}\",\n        )\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        fields = {\n            \"Flow Name\": self.name,\n            \"Flow Description\": self.description,\n            \"Dependencies\": self.dependencies,\n        }\n        if self.flow_id is not None:\n            fields[\"Flow URL\"] = self.openml_url if self.openml_url is not None else \"None\"\n            fields[\"Flow ID\"] = str(self.flow_id)\n            if self.version is not None:\n                fields[\"Flow ID\"] += f\" (version {self.version})\"\n        if self.upload_date is not None:\n            fields[\"Upload Date\"] = self.upload_date.replace(\"T\", \" \")\n        if self.binary_url is not None:\n            fields[\"Binary URL\"] = self.binary_url\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Flow ID\",\n            \"Flow URL\",\n            \"Flow Name\",\n            \"Flow Description\",\n            \"Binary URL\",\n            \"Upload Date\",\n            \"Dependencies\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def _to_dict(self) -&gt; dict[str, dict]:  # noqa: C901, PLR0912\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        flow_container = OrderedDict()  # type: 'dict[str, dict]'\n        flow_dict = OrderedDict(\n            [(\"@xmlns:oml\", \"http://openml.org/openml\")],\n        )  # type: 'dict[str, list | str]'  # E501\n        flow_container[\"oml:flow\"] = flow_dict\n        _add_if_nonempty(flow_dict, \"oml:id\", self.flow_id)\n\n        for required in [\"name\", \"external_version\"]:\n            if getattr(self, required) is None:\n                raise ValueError(f\"self.{required} is required but None\")\n        for attribute in [\n            \"uploader\",\n            \"name\",\n            \"custom_name\",\n            \"class_name\",\n            \"version\",\n            \"external_version\",\n            \"description\",\n            \"upload_date\",\n            \"language\",\n            \"dependencies\",\n        ]:\n            _add_if_nonempty(flow_dict, f\"oml:{attribute}\", getattr(self, attribute))\n\n        if not self.description:\n            logger = logging.getLogger(__name__)\n            logger.warning(\"Flow % has empty description\", self.name)\n\n        flow_parameters = []\n        for key in self.parameters:\n            param_dict = OrderedDict()  # type: 'OrderedDict[str, str]'\n            param_dict[\"oml:name\"] = key\n            meta_info = self.parameters_meta_info[key]\n\n            _add_if_nonempty(param_dict, \"oml:data_type\", meta_info[\"data_type\"])\n            param_dict[\"oml:default_value\"] = self.parameters[key]\n            _add_if_nonempty(param_dict, \"oml:description\", meta_info[\"description\"])\n\n            for key_, value in param_dict.items():\n                if key_ is not None and not isinstance(key_, str):\n                    raise ValueError(\n                        f\"Parameter name {key_} cannot be serialized \"\n                        f\"because it is of type {type(key_)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n                if value is not None and not isinstance(value, str):\n                    raise ValueError(\n                        f\"Parameter value {value} cannot be serialized \"\n                        f\"because it is of type {type(value)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n\n            flow_parameters.append(param_dict)\n\n        flow_dict[\"oml:parameter\"] = flow_parameters\n\n        components = []\n        for key in self.components:\n            component_dict = OrderedDict()  # type: 'OrderedDict[str, dict]'\n            component_dict[\"oml:identifier\"] = key\n            if self.components[key] in [\"passthrough\", \"drop\"]:\n                component_dict[\"oml:flow\"] = {\n                    \"oml-python:serialized_object\": \"component_reference\",\n                    \"value\": {\"key\": self.components[key], \"step_name\": self.components[key]},\n                }\n            else:\n                component_dict[\"oml:flow\"] = self.components[key]._to_dict()[\"oml:flow\"]\n\n            for key_ in component_dict:\n                # We only need to check if the key is a string, because the\n                # value is a flow. The flow itself is valid by recursion\n                if key_ is not None and not isinstance(key_, str):\n                    raise ValueError(\n                        f\"Parameter name {key_} cannot be serialized \"\n                        f\"because it is of type {type(key_)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n\n            components.append(component_dict)\n\n        flow_dict[\"oml:component\"] = components\n        flow_dict[\"oml:tag\"] = self.tags\n        for attribute in [\"binary_url\", \"binary_format\", \"binary_md5\"]:\n            _add_if_nonempty(flow_dict, f\"oml:{attribute}\", getattr(self, attribute))\n\n        return flow_container\n\n    @classmethod\n    def _from_dict(cls, xml_dict: dict) -&gt; OpenMLFlow:\n        \"\"\"Create a flow from an xml description.\n\n        Calls itself recursively to create :class:`OpenMLFlow` objects of\n        subflows (components).\n\n        XML definition of a flow is available at\n        https://github.com/openml/OpenML/blob/master/openml_OS/views/pages/api_new/v1/xsd/openml.implementation.upload.xsd\n\n        Parameters\n        ----------\n        xml_dict : dict\n            Dictionary representation of the flow as created by _to_dict()\n\n        Returns\n        -------\n            OpenMLFlow\n\n        \"\"\"  # E501\n        arguments = OrderedDict()\n        dic = xml_dict[\"oml:flow\"]\n\n        # Mandatory parts in the xml file\n        for key in [\"name\"]:\n            arguments[key] = dic[\"oml:\" + key]\n\n        # non-mandatory parts in the xml file\n        for key in [\n            \"external_version\",\n            \"uploader\",\n            \"description\",\n            \"upload_date\",\n            \"language\",\n            \"dependencies\",\n            \"version\",\n            \"binary_url\",\n            \"binary_format\",\n            \"binary_md5\",\n            \"class_name\",\n            \"custom_name\",\n        ]:\n            arguments[key] = dic.get(\"oml:\" + key)\n\n        # has to be converted to an int if present and cannot parsed in the\n        # two loops above\n        arguments[\"flow_id\"] = int(dic[\"oml:id\"]) if dic.get(\"oml:id\") is not None else None\n\n        # Now parse parts of a flow which can occur multiple times like\n        # parameters, components (subflows) and tags. These can't be tackled\n        # in the loops above because xmltodict returns a dict if such an\n        # entity occurs once, and a list if it occurs multiple times.\n        # Furthermore, they must be treated differently, for example\n        # for components this method is called recursively and\n        # for parameters the actual information is split into two dictionaries\n        # for easier access in python.\n\n        parameters = OrderedDict()\n        parameters_meta_info = OrderedDict()\n        if \"oml:parameter\" in dic:\n            # In case of a single parameter, xmltodict returns a dictionary,\n            # otherwise a list.\n            oml_parameters = extract_xml_tags(\"oml:parameter\", dic, allow_none=False)\n\n            for oml_parameter in oml_parameters:\n                parameter_name = oml_parameter[\"oml:name\"]\n                default_value = oml_parameter[\"oml:default_value\"]\n                parameters[parameter_name] = default_value\n\n                meta_info = OrderedDict()\n                meta_info[\"description\"] = oml_parameter.get(\"oml:description\")\n                meta_info[\"data_type\"] = oml_parameter.get(\"oml:data_type\")\n                parameters_meta_info[parameter_name] = meta_info\n        arguments[\"parameters\"] = parameters\n        arguments[\"parameters_meta_info\"] = parameters_meta_info\n\n        components = OrderedDict()\n        if \"oml:component\" in dic:\n            # In case of a single component xmltodict returns a dict,\n            # otherwise a list.\n            oml_components = extract_xml_tags(\"oml:component\", dic, allow_none=False)\n\n            for component in oml_components:\n                flow = OpenMLFlow._from_dict(component)\n                components[component[\"oml:identifier\"]] = flow\n        arguments[\"components\"] = components\n        arguments[\"tags\"] = extract_xml_tags(\"oml:tag\", dic)\n\n        arguments[\"model\"] = None\n        return cls(**arguments)\n\n    def to_filesystem(self, output_directory: str | Path) -&gt; None:\n        \"\"\"Write a flow to the filesystem as XML to output_directory.\"\"\"\n        output_directory = Path(output_directory)\n        output_directory.mkdir(parents=True, exist_ok=True)\n\n        output_path = output_directory / \"flow.xml\"\n        if output_path.exists():\n            raise ValueError(\"Output directory already contains a flow.xml file.\")\n\n        run_xml = self._to_xml()\n        with output_path.open(\"w\") as f:\n            f.write(run_xml)\n\n    @classmethod\n    def from_filesystem(cls, input_directory: str | Path) -&gt; OpenMLFlow:\n        \"\"\"Read a flow from an XML in input_directory on the filesystem.\"\"\"\n        input_directory = Path(input_directory) / \"flow.xml\"\n        with input_directory.open() as f:\n            xml_string = f.read()\n        return OpenMLFlow._from_dict(xmltodict.parse(xml_string))\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.flow_id = int(xml_response[\"oml:upload_flow\"][\"oml:id\"])\n\n    def publish(self, raise_error_if_exists: bool = False) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n        \"\"\"Publish this flow to OpenML server.\n\n        Raises a PyOpenMLError if the flow exists on the server, but\n        `self.flow_id` does not match the server known flow id.\n\n        Parameters\n        ----------\n        raise_error_if_exists : bool, optional (default=False)\n            If True, raise PyOpenMLError if the flow exists on the server.\n            If False, update the local flow to match the server flow.\n\n        Returns\n        -------\n        self : OpenMLFlow\n\n        \"\"\"\n        # Import at top not possible because of cyclic dependencies. In\n        # particular, flow.py tries to import functions.py in order to call\n        # get_flow(), while functions.py tries to import flow.py in order to\n        # instantiate an OpenMLFlow.\n        import openml.flows.functions\n\n        flow_id = openml.flows.functions.flow_exists(self.name, self.external_version)\n        if not flow_id:\n            if self.flow_id:\n                raise openml.exceptions.PyOpenMLError(\n                    \"Flow does not exist on the server, \" \"but 'flow.flow_id' is not None.\",\n                )\n            super().publish()\n            assert self.flow_id is not None  # for mypy\n            flow_id = self.flow_id\n        elif raise_error_if_exists:\n            error_message = f\"This OpenMLFlow already exists with id: {flow_id}.\"\n            raise openml.exceptions.PyOpenMLError(error_message)\n        elif self.flow_id is not None and self.flow_id != flow_id:\n            raise openml.exceptions.PyOpenMLError(\n                \"Local flow_id does not match server flow_id: \" f\"'{self.flow_id}' vs '{flow_id}'\",\n            )\n\n        flow = openml.flows.functions.get_flow(flow_id)\n        _copy_server_fields(flow, self)\n        try:\n            openml.flows.functions.assert_flows_equal(\n                self,\n                flow,\n                flow.upload_date,\n                ignore_parameter_values=True,\n                ignore_custom_name_if_none=True,\n            )\n        except ValueError as e:\n            message = e.args[0]\n            raise ValueError(\n                \"The flow on the server is inconsistent with the local flow. \"\n                f\"The server flow ID is {flow_id}. Please check manually and remove \"\n                f\"the flow if necessary! Error is:\\n'{message}'\",\n            ) from e\n        return self\n\n    def get_structure(self, key_item: str) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Returns for each sub-component of the flow the path of identifiers\n        that should be traversed to reach this component. The resulting dict\n        maps a key (identifying a flow by either its id, name or fullname) to\n        the parameter prefix.\n\n        Parameters\n        ----------\n        key_item: str\n            The flow attribute that will be used to identify flows in the\n            structure. Allowed values {flow_id, name}\n\n        Returns\n        -------\n        dict[str, List[str]]\n            The flow structure\n        \"\"\"\n        if key_item not in [\"flow_id\", \"name\"]:\n            raise ValueError(\"key_item should be in {flow_id, name}\")\n        structure = {}\n        for key, sub_flow in self.components.items():\n            sub_structure = sub_flow.get_structure(key_item)\n            for flow_name, flow_sub_structure in sub_structure.items():\n                structure[flow_name] = [key, *flow_sub_structure]\n        structure[getattr(self, key_item)] = []\n        return structure\n\n    def get_subflow(self, structure: list[str]) -&gt; OpenMLFlow:\n        \"\"\"\n        Returns a subflow from the tree of dependencies.\n\n        Parameters\n        ----------\n        structure: list[str]\n            A list of strings, indicating the location of the subflow\n\n        Returns\n        -------\n        OpenMLFlow\n            The OpenMLFlow that corresponds to the structure\n        \"\"\"\n        # make a copy of structure, as we don't want to change it in the\n        # outer scope\n        structure = list(structure)\n        if len(structure) &lt; 1:\n            raise ValueError(\"Please provide a structure list of size &gt;= 1\")\n        sub_identifier = structure[0]\n        if sub_identifier not in self.components:\n            raise ValueError(\n                f\"Flow {self.name} does not contain component with \" f\"identifier {sub_identifier}\",\n            )\n        if len(structure) == 1:\n            return self.components[sub_identifier]  # type: ignore\n\n        structure.pop(0)\n        return self.components[sub_identifier].get_subflow(structure)  # type: ignore\n</code></pre>"},{"location":"reference/#openml.OpenMLFlow.extension","title":"<code>extension: Extension</code>  <code>property</code>","text":"<p>The extension of the flow (e.g., sklearn).</p>"},{"location":"reference/#openml.OpenMLFlow.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>The ID of the flow.</p>"},{"location":"reference/#openml.OpenMLFlow.from_filesystem","title":"<code>from_filesystem(input_directory)</code>  <code>classmethod</code>","text":"<p>Read a flow from an XML in input_directory on the filesystem.</p> Source code in <code>openml/flows/flow.py</code> <pre><code>@classmethod\ndef from_filesystem(cls, input_directory: str | Path) -&gt; OpenMLFlow:\n    \"\"\"Read a flow from an XML in input_directory on the filesystem.\"\"\"\n    input_directory = Path(input_directory) / \"flow.xml\"\n    with input_directory.open() as f:\n        xml_string = f.read()\n    return OpenMLFlow._from_dict(xmltodict.parse(xml_string))\n</code></pre>"},{"location":"reference/#openml.OpenMLFlow.get_structure","title":"<code>get_structure(key_item)</code>","text":"<p>Returns for each sub-component of the flow the path of identifiers that should be traversed to reach this component. The resulting dict maps a key (identifying a flow by either its id, name or fullname) to the parameter prefix.</p> <p>Parameters:</p> Name Type Description Default <code>key_item</code> <code>str</code> <p>The flow attribute that will be used to identify flows in the structure. Allowed values {flow_id, name}</p> required <p>Returns:</p> Type Description <code>dict[str, List[str]]</code> <p>The flow structure</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def get_structure(self, key_item: str) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Returns for each sub-component of the flow the path of identifiers\n    that should be traversed to reach this component. The resulting dict\n    maps a key (identifying a flow by either its id, name or fullname) to\n    the parameter prefix.\n\n    Parameters\n    ----------\n    key_item: str\n        The flow attribute that will be used to identify flows in the\n        structure. Allowed values {flow_id, name}\n\n    Returns\n    -------\n    dict[str, List[str]]\n        The flow structure\n    \"\"\"\n    if key_item not in [\"flow_id\", \"name\"]:\n        raise ValueError(\"key_item should be in {flow_id, name}\")\n    structure = {}\n    for key, sub_flow in self.components.items():\n        sub_structure = sub_flow.get_structure(key_item)\n        for flow_name, flow_sub_structure in sub_structure.items():\n            structure[flow_name] = [key, *flow_sub_structure]\n    structure[getattr(self, key_item)] = []\n    return structure\n</code></pre>"},{"location":"reference/#openml.OpenMLFlow.get_subflow","title":"<code>get_subflow(structure)</code>","text":"<p>Returns a subflow from the tree of dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>list[str]</code> <p>A list of strings, indicating the location of the subflow</p> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> <p>The OpenMLFlow that corresponds to the structure</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def get_subflow(self, structure: list[str]) -&gt; OpenMLFlow:\n    \"\"\"\n    Returns a subflow from the tree of dependencies.\n\n    Parameters\n    ----------\n    structure: list[str]\n        A list of strings, indicating the location of the subflow\n\n    Returns\n    -------\n    OpenMLFlow\n        The OpenMLFlow that corresponds to the structure\n    \"\"\"\n    # make a copy of structure, as we don't want to change it in the\n    # outer scope\n    structure = list(structure)\n    if len(structure) &lt; 1:\n        raise ValueError(\"Please provide a structure list of size &gt;= 1\")\n    sub_identifier = structure[0]\n    if sub_identifier not in self.components:\n        raise ValueError(\n            f\"Flow {self.name} does not contain component with \" f\"identifier {sub_identifier}\",\n        )\n    if len(structure) == 1:\n        return self.components[sub_identifier]  # type: ignore\n\n    structure.pop(0)\n    return self.components[sub_identifier].get_subflow(structure)  # type: ignore\n</code></pre>"},{"location":"reference/#openml.OpenMLFlow.publish","title":"<code>publish(raise_error_if_exists=False)</code>","text":"<p>Publish this flow to OpenML server.</p> <p>Raises a PyOpenMLError if the flow exists on the server, but <code>self.flow_id</code> does not match the server known flow id.</p> <p>Parameters:</p> Name Type Description Default <code>raise_error_if_exists</code> <code>(bool, optional(default=False))</code> <p>If True, raise PyOpenMLError if the flow exists on the server. If False, update the local flow to match the server flow.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>self</code> <code>OpenMLFlow</code> Source code in <code>openml/flows/flow.py</code> <pre><code>def publish(self, raise_error_if_exists: bool = False) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n    \"\"\"Publish this flow to OpenML server.\n\n    Raises a PyOpenMLError if the flow exists on the server, but\n    `self.flow_id` does not match the server known flow id.\n\n    Parameters\n    ----------\n    raise_error_if_exists : bool, optional (default=False)\n        If True, raise PyOpenMLError if the flow exists on the server.\n        If False, update the local flow to match the server flow.\n\n    Returns\n    -------\n    self : OpenMLFlow\n\n    \"\"\"\n    # Import at top not possible because of cyclic dependencies. In\n    # particular, flow.py tries to import functions.py in order to call\n    # get_flow(), while functions.py tries to import flow.py in order to\n    # instantiate an OpenMLFlow.\n    import openml.flows.functions\n\n    flow_id = openml.flows.functions.flow_exists(self.name, self.external_version)\n    if not flow_id:\n        if self.flow_id:\n            raise openml.exceptions.PyOpenMLError(\n                \"Flow does not exist on the server, \" \"but 'flow.flow_id' is not None.\",\n            )\n        super().publish()\n        assert self.flow_id is not None  # for mypy\n        flow_id = self.flow_id\n    elif raise_error_if_exists:\n        error_message = f\"This OpenMLFlow already exists with id: {flow_id}.\"\n        raise openml.exceptions.PyOpenMLError(error_message)\n    elif self.flow_id is not None and self.flow_id != flow_id:\n        raise openml.exceptions.PyOpenMLError(\n            \"Local flow_id does not match server flow_id: \" f\"'{self.flow_id}' vs '{flow_id}'\",\n        )\n\n    flow = openml.flows.functions.get_flow(flow_id)\n    _copy_server_fields(flow, self)\n    try:\n        openml.flows.functions.assert_flows_equal(\n            self,\n            flow,\n            flow.upload_date,\n            ignore_parameter_values=True,\n            ignore_custom_name_if_none=True,\n        )\n    except ValueError as e:\n        message = e.args[0]\n        raise ValueError(\n            \"The flow on the server is inconsistent with the local flow. \"\n            f\"The server flow ID is {flow_id}. Please check manually and remove \"\n            f\"the flow if necessary! Error is:\\n'{message}'\",\n        ) from e\n    return self\n</code></pre>"},{"location":"reference/#openml.OpenMLFlow.to_filesystem","title":"<code>to_filesystem(output_directory)</code>","text":"<p>Write a flow to the filesystem as XML to output_directory.</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def to_filesystem(self, output_directory: str | Path) -&gt; None:\n    \"\"\"Write a flow to the filesystem as XML to output_directory.\"\"\"\n    output_directory = Path(output_directory)\n    output_directory.mkdir(parents=True, exist_ok=True)\n\n    output_path = output_directory / \"flow.xml\"\n    if output_path.exists():\n        raise ValueError(\"Output directory already contains a flow.xml file.\")\n\n    run_xml = self._to_xml()\n    with output_path.open(\"w\") as f:\n        f.write(run_xml)\n</code></pre>"},{"location":"reference/#openml.OpenMLLearningCurveTask","title":"<code>OpenMLLearningCurveTask</code>","text":"<p>               Bases: <code>OpenMLClassificationTask</code></p> <p>OpenML Learning Curve object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the Learning Curve task.</p> required <code>task_type</code> <code>str</code> <p>Name of the Learning Curve task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the dataset that this task is associated with.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature in the dataset.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure to use for evaluating models.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Additional parameters for the estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the file containing the data splits for Learning Curve task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the Learning Curve task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure to use for evaluating models.</p> <code>None</code> <code>class_labels</code> <code>list of str</code> <p>Class labels for Learning Curve tasks.</p> <code>None</code> <code>cost_matrix</code> <code>numpy array</code> <p>Cost matrix for Learning Curve tasks.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLLearningCurveTask(OpenMLClassificationTask):\n    \"\"\"OpenML Learning Curve object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the Learning Curve task.\n    task_type : str\n        Name of the Learning Curve task.\n    data_set_id : int\n        ID of the dataset that this task is associated with.\n    target_name : str\n        Name of the target feature in the dataset.\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure to use for evaluating models.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure.\n    estimation_parameters : dict, default=None\n        Additional parameters for the estimation procedure.\n    data_splits_url : str, default=None\n        URL of the file containing the data splits for Learning Curve task.\n    task_id : Union[int, None]\n        ID of the Learning Curve task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure to use for evaluating models.\n    class_labels : list of str, default=None\n        Class labels for Learning Curve tasks.\n    cost_matrix : numpy array, default=None\n        Cost matrix for Learning Curve tasks.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 13,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        evaluation_measure: str | None = None,\n        class_labels: list[str] | None = None,\n        cost_matrix: np.ndarray | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n            class_labels=class_labels,\n            cost_matrix=cost_matrix,\n        )\n</code></pre>"},{"location":"reference/#openml.OpenMLParameter","title":"<code>OpenMLParameter</code>","text":"<p>Parameter object (used in setup).</p> <p>Parameters:</p> Name Type Description Default <code>input_id</code> <code>int</code> <p>The input id from the openml database</p> required <code>flow</code> <p>The flow to which this parameter is associated</p> required <code>flow</code> <p>The name of the flow (no version number) to which this parameter is associated</p> required <code>full_name</code> <code>str</code> <p>The name of the flow and parameter combined</p> required <code>parameter_name</code> <code>str</code> <p>The name of the parameter</p> required <code>data_type</code> <code>str</code> <p>The datatype of the parameter. generally unused for sklearn flows</p> required <code>default_value</code> <code>str</code> <p>The default value. For sklearn parameters, this is unknown and a default value is selected arbitrarily</p> required <code>value</code> <code>str</code> <p>If the parameter was set, the value that it was set to.</p> required Source code in <code>openml/setups/setup.py</code> <pre><code>class OpenMLParameter:\n    \"\"\"Parameter object (used in setup).\n\n    Parameters\n    ----------\n    input_id : int\n        The input id from the openml database\n    flow id : int\n        The flow to which this parameter is associated\n    flow name : str\n        The name of the flow (no version number) to which this parameter\n        is associated\n    full_name : str\n        The name of the flow and parameter combined\n    parameter_name : str\n        The name of the parameter\n    data_type : str\n        The datatype of the parameter. generally unused for sklearn flows\n    default_value : str\n        The default value. For sklearn parameters, this is unknown and a\n        default value is selected arbitrarily\n    value : str\n        If the parameter was set, the value that it was set to.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        input_id: int,\n        flow_id: int,\n        flow_name: str,\n        full_name: str,\n        parameter_name: str,\n        data_type: str,\n        default_value: str,\n        value: str,\n    ):\n        self.id = input_id\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.full_name = full_name\n        self.parameter_name = parameter_name\n        self.data_type = data_type\n        self.default_value = default_value\n        self.value = value\n\n    def _to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"flow_id\": self.flow_id,\n            \"flow_name\": self.flow_name,\n            \"full_name\": self.full_name,\n            \"parameter_name\": self.parameter_name,\n            \"data_type\": self.data_type,\n            \"default_value\": self.default_value,\n            \"value\": self.value,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Parameter\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"ID\": self.id,\n            \"Flow ID\": self.flow_id,\n            # \"Flow Name\": self.flow_name,\n            \"Flow Name\": self.full_name,\n            \"Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"Parameter Name\": self.parameter_name,\n        }\n        # indented prints for parameter attributes\n        # indention = 2 spaces + 1 | + 2 underscores\n        indent = f\"{' ' * 2}|{'_' * 2}\"\n        parameter_data_type = f\"{indent}Data Type\"\n        fields[parameter_data_type] = self.data_type\n        parameter_default = f\"{indent}Default\"\n        fields[parameter_default] = self.default_value\n        parameter_value = f\"{indent}Value\"\n        fields[parameter_value] = self.value\n\n        # determines the order in which the information will be printed\n        order = [\n            \"ID\",\n            \"Flow ID\",\n            \"Flow Name\",\n            \"Flow URL\",\n            \"Parameter Name\",\n            parameter_data_type,\n            parameter_default,\n            parameter_value,\n        ]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/#openml.OpenMLRegressionTask","title":"<code>OpenMLRegressionTask</code>","text":"<p>               Bases: <code>OpenMLSupervisedTask</code></p> <p>OpenML Regression object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>Task type ID of the OpenML Regression task.</p> required <code>task_type</code> <code>str</code> <p>Task type of the OpenML Regression task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature used in the Regression task.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the OpenML estimation procedure.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the OpenML estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Parameters used by the OpenML estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the OpenML data splits for the Regression task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the OpenML Regression task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Evaluation measure used in the Regression task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLRegressionTask(OpenMLSupervisedTask):\n    \"\"\"OpenML Regression object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        Task type ID of the OpenML Regression task.\n    task_type : str\n        Task type of the OpenML Regression task.\n    data_set_id : int\n        ID of the OpenML dataset.\n    target_name : str\n        Name of the target feature used in the Regression task.\n    estimation_procedure_id : int, default=None\n        ID of the OpenML estimation procedure.\n    estimation_procedure_type : str, default=None\n        Type of the OpenML estimation procedure.\n    estimation_parameters : dict, default=None\n        Parameters used by the OpenML estimation procedure.\n    data_splits_url : str, default=None\n        URL of the OpenML data splits for the Regression task.\n    task_id : Union[int, None]\n        ID of the OpenML Regression task.\n    evaluation_measure : str, default=None\n        Evaluation measure used in the Regression task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 7,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        evaluation_measure: str | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n        )\n</code></pre>"},{"location":"reference/#openml.OpenMLRun","title":"<code>OpenMLRun</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Run: result of running a model on an OpenML dataset.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The ID of the OpenML task associated with the run.</p> required <code>flow_id</code> <code>int | None</code> <p>The ID of the OpenML flow associated with the run.</p> required <code>dataset_id</code> <code>int | None</code> <p>The ID of the OpenML dataset used for the run.</p> required <code>setup_string</code> <code>str | None</code> <p>The setup string of the run.</p> <code>None</code> <code>output_files</code> <code>dict[str, int] | None</code> <p>Specifies where each related file can be found.</p> <code>None</code> <code>setup_id</code> <code>int | None</code> <p>An integer representing the ID of the setup used for the run.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Representing the tags associated with the run.</p> <code>None</code> <code>uploader</code> <code>int | None</code> <p>User ID of the uploader.</p> <code>None</code> <code>uploader_name</code> <code>str | None</code> <p>The name of the person who uploaded the run.</p> <code>None</code> <code>evaluations</code> <code>dict | None</code> <p>Representing the evaluations of the run.</p> <code>None</code> <code>fold_evaluations</code> <code>dict | None</code> <p>The evaluations of the run for each fold.</p> <code>None</code> <code>sample_evaluations</code> <code>dict | None</code> <p>The evaluations of the run for each sample.</p> <code>None</code> <code>data_content</code> <code>list[list] | None</code> <p>The predictions generated from executing this run.</p> <code>None</code> <code>trace</code> <code>OpenMLRunTrace | None</code> <p>The trace containing information on internal model evaluations of this run.</p> <code>None</code> <code>model</code> <code>object | None</code> <p>The untrained model that was evaluated in the run.</p> <code>None</code> <code>task_type</code> <code>str | None</code> <p>The type of the OpenML task associated with the run.</p> <code>None</code> <code>task_evaluation_measure</code> <code>str | None</code> <p>The evaluation measure used for the task.</p> <code>None</code> <code>flow_name</code> <code>str | None</code> <p>The name of the OpenML flow associated with the run.</p> <code>None</code> <code>parameter_settings</code> <code>list[dict[str, Any]] | None</code> <p>Representing the parameter settings used for the run.</p> <code>None</code> <code>predictions_url</code> <code>str | None</code> <p>The URL of the predictions file.</p> <code>None</code> <code>task</code> <code>OpenMLTask | None</code> <p>An instance of the OpenMLTask class, representing the OpenML task associated with the run.</p> <code>None</code> <code>flow</code> <code>OpenMLFlow | None</code> <p>An instance of the OpenMLFlow class, representing the OpenML flow associated with the run.</p> <code>None</code> <code>run_id</code> <code>int | None</code> <p>The ID of the run.</p> <code>None</code> <code>description_text</code> <code>str | None</code> <p>Description text to add to the predictions file. If left None, is set to the time the arff file is generated.</p> <code>None</code> <code>run_details</code> <code>str | None</code> <p>Description of the run stored in the run meta-data.</p> <code>None</code> Source code in <code>openml/runs/run.py</code> <pre><code>class OpenMLRun(OpenMLBase):\n    \"\"\"OpenML Run: result of running a model on an OpenML dataset.\n\n    Parameters\n    ----------\n    task_id: int\n        The ID of the OpenML task associated with the run.\n    flow_id: int\n        The ID of the OpenML flow associated with the run.\n    dataset_id: int\n        The ID of the OpenML dataset used for the run.\n    setup_string: str\n        The setup string of the run.\n    output_files: Dict[str, int]\n        Specifies where each related file can be found.\n    setup_id: int\n        An integer representing the ID of the setup used for the run.\n    tags: List[str]\n        Representing the tags associated with the run.\n    uploader: int\n        User ID of the uploader.\n    uploader_name: str\n        The name of the person who uploaded the run.\n    evaluations: Dict\n        Representing the evaluations of the run.\n    fold_evaluations: Dict\n        The evaluations of the run for each fold.\n    sample_evaluations: Dict\n        The evaluations of the run for each sample.\n    data_content: List[List]\n        The predictions generated from executing this run.\n    trace: OpenMLRunTrace\n        The trace containing information on internal model evaluations of this run.\n    model: object\n        The untrained model that was evaluated in the run.\n    task_type: str\n        The type of the OpenML task associated with the run.\n    task_evaluation_measure: str\n        The evaluation measure used for the task.\n    flow_name: str\n        The name of the OpenML flow associated with the run.\n    parameter_settings: list[OrderedDict]\n        Representing the parameter settings used for the run.\n    predictions_url: str\n        The URL of the predictions file.\n    task: OpenMLTask\n        An instance of the OpenMLTask class, representing the OpenML task associated\n        with the run.\n    flow: OpenMLFlow\n        An instance of the OpenMLFlow class, representing the OpenML flow associated\n        with the run.\n    run_id: int\n        The ID of the run.\n    description_text: str, optional\n        Description text to add to the predictions file. If left None, is set to the\n        time the arff file is generated.\n    run_details: str, optional (default=None)\n        Description of the run stored in the run meta-data.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_id: int,\n        flow_id: int | None,\n        dataset_id: int | None,\n        setup_string: str | None = None,\n        output_files: dict[str, int] | None = None,\n        setup_id: int | None = None,\n        tags: list[str] | None = None,\n        uploader: int | None = None,\n        uploader_name: str | None = None,\n        evaluations: dict | None = None,\n        fold_evaluations: dict | None = None,\n        sample_evaluations: dict | None = None,\n        data_content: list[list] | None = None,\n        trace: OpenMLRunTrace | None = None,\n        model: object | None = None,\n        task_type: str | None = None,\n        task_evaluation_measure: str | None = None,\n        flow_name: str | None = None,\n        parameter_settings: list[dict[str, Any]] | None = None,\n        predictions_url: str | None = None,\n        task: OpenMLTask | None = None,\n        flow: OpenMLFlow | None = None,\n        run_id: int | None = None,\n        description_text: str | None = None,\n        run_details: str | None = None,\n    ):\n        self.uploader = uploader\n        self.uploader_name = uploader_name\n        self.task_id = task_id\n        self.task_type = task_type\n        self.task_evaluation_measure = task_evaluation_measure\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.setup_id = setup_id\n        self.setup_string = setup_string\n        self.parameter_settings = parameter_settings\n        self.dataset_id = dataset_id\n        self.evaluations = evaluations\n        self.fold_evaluations = fold_evaluations\n        self.sample_evaluations = sample_evaluations\n        self.data_content = data_content\n        self.output_files = output_files\n        self.trace = trace\n        self.error_message = None\n        self.task = task\n        self.flow = flow\n        self.run_id = run_id\n        self.model = model\n        self.tags = tags\n        self.predictions_url = predictions_url\n        self.description_text = description_text\n        self.run_details = run_details\n        self._predictions = None\n\n    @property\n    def predictions(self) -&gt; pd.DataFrame:\n        \"\"\"Return a DataFrame with predictions for this run\"\"\"\n        if self._predictions is None:\n            if self.data_content:\n                arff_dict = self._generate_arff_dict()\n            elif self.predictions_url:\n                arff_text = openml._api_calls._download_text_file(self.predictions_url)\n                arff_dict = arff.loads(arff_text)\n            else:\n                raise RuntimeError(\"Run has no predictions.\")\n            self._predictions = pd.DataFrame(\n                arff_dict[\"data\"],\n                columns=[name for name, _ in arff_dict[\"attributes\"]],\n            )\n        return self._predictions\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"The ID of the run, None if not uploaded to the server yet.\"\"\"\n        return self.run_id\n\n    def _evaluation_summary(self, metric: str) -&gt; str:\n        \"\"\"Summarizes the evaluation of a metric over all folds.\n\n        The fold scores for the metric must exist already. During run creation,\n        by default, the MAE for OpenMLRegressionTask and the accuracy for\n        OpenMLClassificationTask/OpenMLLearningCurveTasktasks are computed.\n\n        If repetition exist, we take the mean over all repetitions.\n\n        Parameters\n        ----------\n        metric: str\n            Name of an evaluation metric that was used to compute fold scores.\n\n        Returns\n        -------\n        metric_summary: str\n            A formatted string that displays the metric's evaluation summary.\n            The summary consists of the mean and std.\n        \"\"\"\n        if self.fold_evaluations is None:\n            raise ValueError(\"No fold evaluations available.\")\n        fold_score_lists = self.fold_evaluations[metric].values()\n\n        # Get the mean and std over all repetitions\n        rep_means = [np.mean(list(x.values())) for x in fold_score_lists]\n        rep_stds = [np.std(list(x.values())) for x in fold_score_lists]\n\n        return f\"{np.mean(rep_means):.4f} +- {np.mean(rep_stds):.4f}\"\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        # Set up fields\n        fields = {\n            \"Uploader Name\": self.uploader_name,\n            \"Metric\": self.task_evaluation_measure,\n            \"Run ID\": self.run_id,\n            \"Task ID\": self.task_id,\n            \"Task Type\": self.task_type,\n            \"Task URL\": openml.tasks.OpenMLTask.url_for_id(self.task_id),\n            \"Flow ID\": self.flow_id,\n            \"Flow Name\": self.flow_name,\n            \"Flow URL\": (\n                openml.flows.OpenMLFlow.url_for_id(self.flow_id)\n                if self.flow_id is not None\n                else None\n            ),\n            \"Setup ID\": self.setup_id,\n            \"Setup String\": self.setup_string,\n            \"Dataset ID\": self.dataset_id,\n            \"Dataset URL\": (\n                openml.datasets.OpenMLDataset.url_for_id(self.dataset_id)\n                if self.dataset_id is not None\n                else None\n            ),\n        }\n\n        # determines the order of the initial fields in which the information will be printed\n        order = [\"Uploader Name\", \"Uploader Profile\", \"Metric\", \"Result\"]\n\n        if self.uploader is not None:\n            fields[\"Uploader Profile\"] = f\"{openml.config.get_server_base_url()}/u/{self.uploader}\"\n        if self.run_id is not None:\n            fields[\"Run URL\"] = self.openml_url\n        if self.evaluations is not None and self.task_evaluation_measure in self.evaluations:\n            fields[\"Result\"] = self.evaluations[self.task_evaluation_measure]\n        elif self.fold_evaluations is not None:\n            # -- Add locally computed summary values if possible\n            if \"predictive_accuracy\" in self.fold_evaluations:\n                # OpenMLClassificationTask; OpenMLLearningCurveTask\n                result_field = \"Local Result - Accuracy (+- STD)\"\n                fields[result_field] = self._evaluation_summary(\"predictive_accuracy\")\n                order.append(result_field)\n            elif \"mean_absolute_error\" in self.fold_evaluations:\n                # OpenMLRegressionTask\n                result_field = \"Local Result - MAE (+- STD)\"\n                fields[result_field] = self._evaluation_summary(\"mean_absolute_error\")\n                order.append(result_field)\n\n            if \"usercpu_time_millis\" in self.fold_evaluations:\n                # Runtime should be available for most tasks types\n                rt_field = \"Local Runtime - ms (+- STD)\"\n                fields[rt_field] = self._evaluation_summary(\"usercpu_time_millis\")\n                order.append(rt_field)\n\n        # determines the remaining order\n        order += [\n            \"Run ID\",\n            \"Run URL\",\n            \"Task ID\",\n            \"Task Type\",\n            \"Task URL\",\n            \"Flow ID\",\n            \"Flow Name\",\n            \"Flow URL\",\n            \"Setup ID\",\n            \"Setup String\",\n            \"Dataset ID\",\n            \"Dataset URL\",\n        ]\n        return [\n            (key, \"None\" if fields[key] is None else fields[key])  # type: ignore\n            for key in order\n            if key in fields\n        ]\n\n    @classmethod\n    def from_filesystem(cls, directory: str | Path, expect_model: bool = True) -&gt; OpenMLRun:  # noqa: FBT001, FBT002\n        \"\"\"\n        The inverse of the to_filesystem method. Instantiates an OpenMLRun\n        object based on files stored on the file system.\n\n        Parameters\n        ----------\n        directory : str\n            a path leading to the folder where the results\n            are stored\n\n        expect_model : bool\n            if True, it requires the model pickle to be present, and an error\n            will be thrown if not. Otherwise, the model might or might not\n            be present.\n\n        Returns\n        -------\n        run : OpenMLRun\n            the re-instantiated run object\n        \"\"\"\n        # Avoiding cyclic imports\n        import openml.runs.functions\n\n        directory = Path(directory)\n        if not directory.is_dir():\n            raise ValueError(\"Could not find folder\")\n\n        description_path = directory / \"description.xml\"\n        predictions_path = directory / \"predictions.arff\"\n        trace_path = directory / \"trace.arff\"\n        model_path = directory / \"model.pkl\"\n\n        if not description_path.is_file():\n            raise ValueError(\"Could not find description.xml\")\n        if not predictions_path.is_file():\n            raise ValueError(\"Could not find predictions.arff\")\n        if (not model_path.is_file()) and expect_model:\n            raise ValueError(\"Could not find model.pkl\")\n\n        with description_path.open() as fht:\n            xml_string = fht.read()\n        run = openml.runs.functions._create_run_from_xml(xml_string, from_server=False)\n\n        if run.flow_id is None:\n            flow = openml.flows.OpenMLFlow.from_filesystem(directory)\n            run.flow = flow\n            run.flow_name = flow.name\n\n        with predictions_path.open() as fht:\n            predictions = arff.load(fht)\n            run.data_content = predictions[\"data\"]\n\n        if model_path.is_file():\n            # note that it will load the model if the file exists, even if\n            # expect_model is False\n            with model_path.open(\"rb\") as fhb:\n                run.model = pickle.load(fhb)  # noqa: S301\n\n        if trace_path.is_file():\n            run.trace = openml.runs.OpenMLRunTrace._from_filesystem(trace_path)\n\n        return run\n\n    def to_filesystem(\n        self,\n        directory: str | Path,\n        store_model: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; None:\n        \"\"\"\n        The inverse of the from_filesystem method. Serializes a run\n        on the filesystem, to be uploaded later.\n\n        Parameters\n        ----------\n        directory : str\n            a path leading to the folder where the results\n            will be stored. Should be empty\n\n        store_model : bool, optional (default=True)\n            if True, a model will be pickled as well. As this is the most\n            storage expensive part, it is often desirable to not store the\n            model.\n        \"\"\"\n        if self.data_content is None or self.model is None:\n            raise ValueError(\"Run should have been executed (and contain \" \"model / predictions)\")\n        directory = Path(directory)\n        directory.mkdir(exist_ok=True, parents=True)\n\n        if any(directory.iterdir()):\n            raise ValueError(f\"Output directory {directory.expanduser().resolve()} should be empty\")\n\n        run_xml = self._to_xml()\n        predictions_arff = arff.dumps(self._generate_arff_dict())\n\n        # It seems like typing does not allow to define the same variable multiple times\n        with (directory / \"description.xml\").open(\"w\") as fh:\n            fh.write(run_xml)\n        with (directory / \"predictions.arff\").open(\"w\") as fh:\n            fh.write(predictions_arff)\n        if store_model:\n            with (directory / \"model.pkl\").open(\"wb\") as fh_b:\n                pickle.dump(self.model, fh_b)\n\n        if self.flow_id is None and self.flow is not None:\n            self.flow.to_filesystem(directory)\n\n        if self.trace is not None:\n            self.trace._to_filesystem(directory)\n\n    def _generate_arff_dict(self) -&gt; OrderedDict[str, Any]:\n        \"\"\"Generates the arff dictionary for uploading predictions to the\n        server.\n\n        Assumes that the run has been executed.\n\n        The order of the attributes follows the order defined by the Client API for R.\n\n        Returns\n        -------\n        arf_dict : dict\n            Dictionary representation of the ARFF file that will be uploaded.\n            Contains predictions and information about the run environment.\n        \"\"\"\n        if self.data_content is None:\n            raise ValueError(\"Run has not been executed.\")\n        if self.flow is None:\n            assert self.flow_id is not None, \"Run has no associated flow id!\"\n            self.flow = get_flow(self.flow_id)\n\n        if self.description_text is None:\n            self.description_text = time.strftime(\"%c\")\n        task = get_task(self.task_id)\n\n        arff_dict = OrderedDict()  # type: 'OrderedDict[str, Any]'\n        arff_dict[\"data\"] = self.data_content\n        arff_dict[\"description\"] = self.description_text\n        arff_dict[\"relation\"] = f\"openml_task_{task.task_id}_predictions\"\n\n        if isinstance(task, OpenMLLearningCurveTask):\n            class_labels = task.class_labels\n            instance_specifications = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"sample\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n            ]\n\n            arff_dict[\"attributes\"] = instance_specifications\n            if class_labels is not None:\n                arff_dict[\"attributes\"] = (\n                    arff_dict[\"attributes\"]\n                    + [(\"prediction\", class_labels), (\"correct\", class_labels)]\n                    + [\n                        (\"confidence.\" + class_labels[i], \"NUMERIC\")\n                        for i in range(len(class_labels))\n                    ]\n                )\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n        elif isinstance(task, OpenMLClassificationTask):\n            class_labels = task.class_labels\n            instance_specifications = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"sample\", \"NUMERIC\"),  # Legacy\n                (\"row_id\", \"NUMERIC\"),\n            ]\n\n            arff_dict[\"attributes\"] = instance_specifications\n            if class_labels is not None:\n                prediction_confidences = [\n                    (\"confidence.\" + class_labels[i], \"NUMERIC\") for i in range(len(class_labels))\n                ]\n                prediction_and_true = [(\"prediction\", class_labels), (\"correct\", class_labels)]\n                arff_dict[\"attributes\"] = (\n                    arff_dict[\"attributes\"] + prediction_and_true + prediction_confidences\n                )\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n        elif isinstance(task, OpenMLRegressionTask):\n            arff_dict[\"attributes\"] = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n                (\"prediction\", \"NUMERIC\"),\n                (\"truth\", \"NUMERIC\"),\n            ]\n\n        elif isinstance(task, OpenMLClusteringTask):\n            arff_dict[\"attributes\"] = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n                (\"cluster\", \"NUMERIC\"),\n            ]\n\n        else:\n            raise NotImplementedError(f\"Task type {task.task_type!s} is not yet supported.\")\n\n        return arff_dict\n\n    def get_metric_fn(self, sklearn_fn: Callable, kwargs: dict | None = None) -&gt; np.ndarray:  # noqa: PLR0915, PLR0912, C901\n        \"\"\"Calculates metric scores based on predicted values. Assumes the\n        run has been executed locally (and contains run_data). Furthermore,\n        it assumes that the 'correct' or 'truth' attribute is specified in\n        the arff (which is an optional field, but always the case for\n        openml-python runs)\n\n        Parameters\n        ----------\n        sklearn_fn : function\n            a function pointer to a sklearn function that\n            accepts ``y_true``, ``y_pred`` and ``**kwargs``\n        kwargs : dict\n            kwargs for the function\n\n        Returns\n        -------\n        scores : ndarray of scores of length num_folds * num_repeats\n            metric results\n        \"\"\"\n        kwargs = kwargs if kwargs else {}\n        if self.data_content is not None and self.task_id is not None:\n            predictions_arff = self._generate_arff_dict()\n        elif (self.output_files is not None) and (\"predictions\" in self.output_files):\n            predictions_file_url = openml._api_calls._file_id_to_url(\n                self.output_files[\"predictions\"],\n                \"predictions.arff\",\n            )\n            response = openml._api_calls._download_text_file(predictions_file_url)\n            predictions_arff = arff.loads(response)\n            # TODO: make this a stream reader\n        else:\n            raise ValueError(\n                \"Run should have been locally executed or \" \"contain outputfile reference.\",\n            )\n\n        # Need to know more about the task to compute scores correctly\n        task = get_task(self.task_id)\n\n        attribute_names = [att[0] for att in predictions_arff[\"attributes\"]]\n        if (\n            task.task_type_id in [TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE]\n            and \"correct\" not in attribute_names\n        ):\n            raise ValueError('Attribute \"correct\" should be set for ' \"classification task runs\")\n        if task.task_type_id == TaskType.SUPERVISED_REGRESSION and \"truth\" not in attribute_names:\n            raise ValueError('Attribute \"truth\" should be set for ' \"regression task runs\")\n        if task.task_type_id != TaskType.CLUSTERING and \"prediction\" not in attribute_names:\n            raise ValueError('Attribute \"predict\" should be set for ' \"supervised task runs\")\n\n        def _attribute_list_to_dict(attribute_list):  # type: ignore\n            # convenience function: Creates a mapping to map from the name of\n            # attributes present in the arff prediction file to their index.\n            # This is necessary because the number of classes can be different\n            # for different tasks.\n            res = OrderedDict()\n            for idx in range(len(attribute_list)):\n                res[attribute_list[idx][0]] = idx\n            return res\n\n        attribute_dict = _attribute_list_to_dict(predictions_arff[\"attributes\"])\n\n        repeat_idx = attribute_dict[\"repeat\"]\n        fold_idx = attribute_dict[\"fold\"]\n        predicted_idx = attribute_dict[\"prediction\"]  # Assume supervised task\n\n        if task.task_type_id in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n            correct_idx = attribute_dict[\"correct\"]\n        elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n            correct_idx = attribute_dict[\"truth\"]\n        has_samples = False\n        if \"sample\" in attribute_dict:\n            sample_idx = attribute_dict[\"sample\"]\n            has_samples = True\n\n        if (\n            predictions_arff[\"attributes\"][predicted_idx][1]\n            != predictions_arff[\"attributes\"][correct_idx][1]\n        ):\n            pred = predictions_arff[\"attributes\"][predicted_idx][1]\n            corr = predictions_arff[\"attributes\"][correct_idx][1]\n            raise ValueError(\n                \"Predicted and Correct do not have equal values:\" f\" {pred!s} Vs. {corr!s}\",\n            )\n\n        # TODO: these could be cached\n        values_predict: dict[int, dict[int, dict[int, list[float]]]] = {}\n        values_correct: dict[int, dict[int, dict[int, list[float]]]] = {}\n        for _line_idx, line in enumerate(predictions_arff[\"data\"]):\n            rep = line[repeat_idx]\n            fold = line[fold_idx]\n            samp = line[sample_idx] if has_samples else 0\n\n            if task.task_type_id in [\n                TaskType.SUPERVISED_CLASSIFICATION,\n                TaskType.LEARNING_CURVE,\n            ]:\n                prediction = predictions_arff[\"attributes\"][predicted_idx][1].index(\n                    line[predicted_idx],\n                )\n                correct = predictions_arff[\"attributes\"][predicted_idx][1].index(line[correct_idx])\n            elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n                prediction = line[predicted_idx]\n                correct = line[correct_idx]\n            if rep not in values_predict:\n                values_predict[rep] = OrderedDict()\n                values_correct[rep] = OrderedDict()\n            if fold not in values_predict[rep]:\n                values_predict[rep][fold] = OrderedDict()\n                values_correct[rep][fold] = OrderedDict()\n            if samp not in values_predict[rep][fold]:\n                values_predict[rep][fold][samp] = []\n                values_correct[rep][fold][samp] = []\n\n            values_predict[rep][fold][samp].append(prediction)\n            values_correct[rep][fold][samp].append(correct)\n\n        scores = []\n        for rep in values_predict:\n            for fold in values_predict[rep]:\n                last_sample = len(values_predict[rep][fold]) - 1\n                y_pred = values_predict[rep][fold][last_sample]\n                y_true = values_correct[rep][fold][last_sample]\n                scores.append(sklearn_fn(y_true, y_pred, **kwargs))\n        return np.array(scores)\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.run_id = int(xml_response[\"oml:upload_run\"][\"oml:run_id\"])\n\n    def _get_file_elements(self) -&gt; dict:\n        \"\"\"Get file_elements to upload to the server.\n\n        Derived child classes should overwrite this method as necessary.\n        The description field will be populated automatically if not provided.\n        \"\"\"\n        if self.parameter_settings is None and self.model is None:\n            raise PyOpenMLError(\n                \"OpenMLRun must contain a model or be initialized with parameter_settings.\",\n            )\n        if self.flow_id is None:\n            if self.flow is None:\n                raise PyOpenMLError(\n                    \"OpenMLRun object does not contain a flow id or reference to OpenMLFlow \"\n                    \"(these should have been added while executing the task). \",\n                )\n\n            # publish the linked Flow before publishing the run.\n            self.flow.publish()\n            self.flow_id = self.flow.flow_id\n\n        if self.parameter_settings is None:\n            if self.flow is None:\n                assert self.flow_id is not None  # for mypy\n                self.flow = openml.flows.get_flow(self.flow_id)\n            self.parameter_settings = self.flow.extension.obtain_parameter_values(\n                self.flow,\n                self.model,\n            )\n\n        file_elements = {\"description\": (\"description.xml\", self._to_xml())}\n\n        if self.error_message is None:\n            predictions = arff.dumps(self._generate_arff_dict())\n            file_elements[\"predictions\"] = (\"predictions.arff\", predictions)\n\n        if self.trace is not None:\n            trace_arff = arff.dumps(self.trace.trace_to_arff())\n            file_elements[\"trace\"] = (\"trace.arff\", trace_arff)\n        return file_elements\n\n    def _to_dict(self) -&gt; dict[str, dict]:  # noqa: PLR0912, C901\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        description = OrderedDict()  # type: 'OrderedDict'\n        description[\"oml:run\"] = OrderedDict()\n        description[\"oml:run\"][\"@xmlns:oml\"] = \"http://openml.org/openml\"\n        description[\"oml:run\"][\"oml:task_id\"] = self.task_id\n        description[\"oml:run\"][\"oml:flow_id\"] = self.flow_id\n        if self.setup_string is not None:\n            description[\"oml:run\"][\"oml:setup_string\"] = self.setup_string\n        if self.error_message is not None:\n            description[\"oml:run\"][\"oml:error_message\"] = self.error_message\n        if self.run_details is not None:\n            description[\"oml:run\"][\"oml:run_details\"] = self.run_details\n        description[\"oml:run\"][\"oml:parameter_setting\"] = self.parameter_settings\n        if self.tags is not None:\n            description[\"oml:run\"][\"oml:tag\"] = self.tags\n        if (self.fold_evaluations is not None and len(self.fold_evaluations) &gt; 0) or (\n            self.sample_evaluations is not None and len(self.sample_evaluations) &gt; 0\n        ):\n            description[\"oml:run\"][\"oml:output_data\"] = OrderedDict()\n            description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"] = []\n        if self.fold_evaluations is not None:\n            for measure in self.fold_evaluations:\n                for repeat in self.fold_evaluations[measure]:\n                    for fold, value in self.fold_evaluations[measure][repeat].items():\n                        current = OrderedDict(\n                            [\n                                (\"@repeat\", str(repeat)),\n                                (\"@fold\", str(fold)),\n                                (\"oml:name\", measure),\n                                (\"oml:value\", str(value)),\n                            ],\n                        )\n                        description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"].append(current)\n        if self.sample_evaluations is not None:\n            for measure in self.sample_evaluations:\n                for repeat in self.sample_evaluations[measure]:\n                    for fold in self.sample_evaluations[measure][repeat]:\n                        for sample, value in self.sample_evaluations[measure][repeat][fold].items():\n                            current = OrderedDict(\n                                [\n                                    (\"@repeat\", str(repeat)),\n                                    (\"@fold\", str(fold)),\n                                    (\"@sample\", str(sample)),\n                                    (\"oml:name\", measure),\n                                    (\"oml:value\", str(value)),\n                                ],\n                            )\n                            description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"].append(\n                                current,\n                            )\n        return description\n</code></pre>"},{"location":"reference/#openml.OpenMLRun.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>The ID of the run, None if not uploaded to the server yet.</p>"},{"location":"reference/#openml.OpenMLRun.predictions","title":"<code>predictions: pd.DataFrame</code>  <code>property</code>","text":"<p>Return a DataFrame with predictions for this run</p>"},{"location":"reference/#openml.OpenMLRun.from_filesystem","title":"<code>from_filesystem(directory, expect_model=True)</code>  <code>classmethod</code>","text":"<p>The inverse of the to_filesystem method. Instantiates an OpenMLRun object based on files stored on the file system.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>a path leading to the folder where the results are stored</p> required <code>expect_model</code> <code>bool</code> <p>if True, it requires the model pickle to be present, and an error will be thrown if not. Otherwise, the model might or might not be present.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>the re-instantiated run object</p> Source code in <code>openml/runs/run.py</code> <pre><code>@classmethod\ndef from_filesystem(cls, directory: str | Path, expect_model: bool = True) -&gt; OpenMLRun:  # noqa: FBT001, FBT002\n    \"\"\"\n    The inverse of the to_filesystem method. Instantiates an OpenMLRun\n    object based on files stored on the file system.\n\n    Parameters\n    ----------\n    directory : str\n        a path leading to the folder where the results\n        are stored\n\n    expect_model : bool\n        if True, it requires the model pickle to be present, and an error\n        will be thrown if not. Otherwise, the model might or might not\n        be present.\n\n    Returns\n    -------\n    run : OpenMLRun\n        the re-instantiated run object\n    \"\"\"\n    # Avoiding cyclic imports\n    import openml.runs.functions\n\n    directory = Path(directory)\n    if not directory.is_dir():\n        raise ValueError(\"Could not find folder\")\n\n    description_path = directory / \"description.xml\"\n    predictions_path = directory / \"predictions.arff\"\n    trace_path = directory / \"trace.arff\"\n    model_path = directory / \"model.pkl\"\n\n    if not description_path.is_file():\n        raise ValueError(\"Could not find description.xml\")\n    if not predictions_path.is_file():\n        raise ValueError(\"Could not find predictions.arff\")\n    if (not model_path.is_file()) and expect_model:\n        raise ValueError(\"Could not find model.pkl\")\n\n    with description_path.open() as fht:\n        xml_string = fht.read()\n    run = openml.runs.functions._create_run_from_xml(xml_string, from_server=False)\n\n    if run.flow_id is None:\n        flow = openml.flows.OpenMLFlow.from_filesystem(directory)\n        run.flow = flow\n        run.flow_name = flow.name\n\n    with predictions_path.open() as fht:\n        predictions = arff.load(fht)\n        run.data_content = predictions[\"data\"]\n\n    if model_path.is_file():\n        # note that it will load the model if the file exists, even if\n        # expect_model is False\n        with model_path.open(\"rb\") as fhb:\n            run.model = pickle.load(fhb)  # noqa: S301\n\n    if trace_path.is_file():\n        run.trace = openml.runs.OpenMLRunTrace._from_filesystem(trace_path)\n\n    return run\n</code></pre>"},{"location":"reference/#openml.OpenMLRun.get_metric_fn","title":"<code>get_metric_fn(sklearn_fn, kwargs=None)</code>","text":"<p>Calculates metric scores based on predicted values. Assumes the run has been executed locally (and contains run_data). Furthermore, it assumes that the 'correct' or 'truth' attribute is specified in the arff (which is an optional field, but always the case for openml-python runs)</p> <p>Parameters:</p> Name Type Description Default <code>sklearn_fn</code> <code>function</code> <p>a function pointer to a sklearn function that accepts <code>y_true</code>, <code>y_pred</code> and <code>**kwargs</code></p> required <code>kwargs</code> <code>dict</code> <p>kwargs for the function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>scores</code> <code>ndarray of scores of length num_folds * num_repeats</code> <p>metric results</p> Source code in <code>openml/runs/run.py</code> <pre><code>def get_metric_fn(self, sklearn_fn: Callable, kwargs: dict | None = None) -&gt; np.ndarray:  # noqa: PLR0915, PLR0912, C901\n    \"\"\"Calculates metric scores based on predicted values. Assumes the\n    run has been executed locally (and contains run_data). Furthermore,\n    it assumes that the 'correct' or 'truth' attribute is specified in\n    the arff (which is an optional field, but always the case for\n    openml-python runs)\n\n    Parameters\n    ----------\n    sklearn_fn : function\n        a function pointer to a sklearn function that\n        accepts ``y_true``, ``y_pred`` and ``**kwargs``\n    kwargs : dict\n        kwargs for the function\n\n    Returns\n    -------\n    scores : ndarray of scores of length num_folds * num_repeats\n        metric results\n    \"\"\"\n    kwargs = kwargs if kwargs else {}\n    if self.data_content is not None and self.task_id is not None:\n        predictions_arff = self._generate_arff_dict()\n    elif (self.output_files is not None) and (\"predictions\" in self.output_files):\n        predictions_file_url = openml._api_calls._file_id_to_url(\n            self.output_files[\"predictions\"],\n            \"predictions.arff\",\n        )\n        response = openml._api_calls._download_text_file(predictions_file_url)\n        predictions_arff = arff.loads(response)\n        # TODO: make this a stream reader\n    else:\n        raise ValueError(\n            \"Run should have been locally executed or \" \"contain outputfile reference.\",\n        )\n\n    # Need to know more about the task to compute scores correctly\n    task = get_task(self.task_id)\n\n    attribute_names = [att[0] for att in predictions_arff[\"attributes\"]]\n    if (\n        task.task_type_id in [TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE]\n        and \"correct\" not in attribute_names\n    ):\n        raise ValueError('Attribute \"correct\" should be set for ' \"classification task runs\")\n    if task.task_type_id == TaskType.SUPERVISED_REGRESSION and \"truth\" not in attribute_names:\n        raise ValueError('Attribute \"truth\" should be set for ' \"regression task runs\")\n    if task.task_type_id != TaskType.CLUSTERING and \"prediction\" not in attribute_names:\n        raise ValueError('Attribute \"predict\" should be set for ' \"supervised task runs\")\n\n    def _attribute_list_to_dict(attribute_list):  # type: ignore\n        # convenience function: Creates a mapping to map from the name of\n        # attributes present in the arff prediction file to their index.\n        # This is necessary because the number of classes can be different\n        # for different tasks.\n        res = OrderedDict()\n        for idx in range(len(attribute_list)):\n            res[attribute_list[idx][0]] = idx\n        return res\n\n    attribute_dict = _attribute_list_to_dict(predictions_arff[\"attributes\"])\n\n    repeat_idx = attribute_dict[\"repeat\"]\n    fold_idx = attribute_dict[\"fold\"]\n    predicted_idx = attribute_dict[\"prediction\"]  # Assume supervised task\n\n    if task.task_type_id in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n        correct_idx = attribute_dict[\"correct\"]\n    elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n        correct_idx = attribute_dict[\"truth\"]\n    has_samples = False\n    if \"sample\" in attribute_dict:\n        sample_idx = attribute_dict[\"sample\"]\n        has_samples = True\n\n    if (\n        predictions_arff[\"attributes\"][predicted_idx][1]\n        != predictions_arff[\"attributes\"][correct_idx][1]\n    ):\n        pred = predictions_arff[\"attributes\"][predicted_idx][1]\n        corr = predictions_arff[\"attributes\"][correct_idx][1]\n        raise ValueError(\n            \"Predicted and Correct do not have equal values:\" f\" {pred!s} Vs. {corr!s}\",\n        )\n\n    # TODO: these could be cached\n    values_predict: dict[int, dict[int, dict[int, list[float]]]] = {}\n    values_correct: dict[int, dict[int, dict[int, list[float]]]] = {}\n    for _line_idx, line in enumerate(predictions_arff[\"data\"]):\n        rep = line[repeat_idx]\n        fold = line[fold_idx]\n        samp = line[sample_idx] if has_samples else 0\n\n        if task.task_type_id in [\n            TaskType.SUPERVISED_CLASSIFICATION,\n            TaskType.LEARNING_CURVE,\n        ]:\n            prediction = predictions_arff[\"attributes\"][predicted_idx][1].index(\n                line[predicted_idx],\n            )\n            correct = predictions_arff[\"attributes\"][predicted_idx][1].index(line[correct_idx])\n        elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n            prediction = line[predicted_idx]\n            correct = line[correct_idx]\n        if rep not in values_predict:\n            values_predict[rep] = OrderedDict()\n            values_correct[rep] = OrderedDict()\n        if fold not in values_predict[rep]:\n            values_predict[rep][fold] = OrderedDict()\n            values_correct[rep][fold] = OrderedDict()\n        if samp not in values_predict[rep][fold]:\n            values_predict[rep][fold][samp] = []\n            values_correct[rep][fold][samp] = []\n\n        values_predict[rep][fold][samp].append(prediction)\n        values_correct[rep][fold][samp].append(correct)\n\n    scores = []\n    for rep in values_predict:\n        for fold in values_predict[rep]:\n            last_sample = len(values_predict[rep][fold]) - 1\n            y_pred = values_predict[rep][fold][last_sample]\n            y_true = values_correct[rep][fold][last_sample]\n            scores.append(sklearn_fn(y_true, y_pred, **kwargs))\n    return np.array(scores)\n</code></pre>"},{"location":"reference/#openml.OpenMLRun.to_filesystem","title":"<code>to_filesystem(directory, store_model=True)</code>","text":"<p>The inverse of the from_filesystem method. Serializes a run on the filesystem, to be uploaded later.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>a path leading to the folder where the results will be stored. Should be empty</p> required <code>store_model</code> <code>(bool, optional(default=True))</code> <p>if True, a model will be pickled as well. As this is the most storage expensive part, it is often desirable to not store the model.</p> <code>True</code> Source code in <code>openml/runs/run.py</code> <pre><code>def to_filesystem(\n    self,\n    directory: str | Path,\n    store_model: bool = True,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    The inverse of the from_filesystem method. Serializes a run\n    on the filesystem, to be uploaded later.\n\n    Parameters\n    ----------\n    directory : str\n        a path leading to the folder where the results\n        will be stored. Should be empty\n\n    store_model : bool, optional (default=True)\n        if True, a model will be pickled as well. As this is the most\n        storage expensive part, it is often desirable to not store the\n        model.\n    \"\"\"\n    if self.data_content is None or self.model is None:\n        raise ValueError(\"Run should have been executed (and contain \" \"model / predictions)\")\n    directory = Path(directory)\n    directory.mkdir(exist_ok=True, parents=True)\n\n    if any(directory.iterdir()):\n        raise ValueError(f\"Output directory {directory.expanduser().resolve()} should be empty\")\n\n    run_xml = self._to_xml()\n    predictions_arff = arff.dumps(self._generate_arff_dict())\n\n    # It seems like typing does not allow to define the same variable multiple times\n    with (directory / \"description.xml\").open(\"w\") as fh:\n        fh.write(run_xml)\n    with (directory / \"predictions.arff\").open(\"w\") as fh:\n        fh.write(predictions_arff)\n    if store_model:\n        with (directory / \"model.pkl\").open(\"wb\") as fh_b:\n            pickle.dump(self.model, fh_b)\n\n    if self.flow_id is None and self.flow is not None:\n        self.flow.to_filesystem(directory)\n\n    if self.trace is not None:\n        self.trace._to_filesystem(directory)\n</code></pre>"},{"location":"reference/#openml.OpenMLSetup","title":"<code>OpenMLSetup</code>","text":"<p>Setup object (a.k.a. Configuration).</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The OpenML setup id</p> required <code>flow_id</code> <code>int</code> <p>The flow that it is build upon</p> required <code>parameters</code> <code>dict</code> <p>The setting of the parameters</p> required Source code in <code>openml/setups/setup.py</code> <pre><code>class OpenMLSetup:\n    \"\"\"Setup object (a.k.a. Configuration).\n\n    Parameters\n    ----------\n    setup_id : int\n        The OpenML setup id\n    flow_id : int\n        The flow that it is build upon\n    parameters : dict\n        The setting of the parameters\n    \"\"\"\n\n    def __init__(self, setup_id: int, flow_id: int, parameters: dict[int, Any] | None):\n        if not isinstance(setup_id, int):\n            raise ValueError(\"setup id should be int\")\n\n        if not isinstance(flow_id, int):\n            raise ValueError(\"flow id should be int\")\n\n        if parameters is not None and not isinstance(parameters, dict):\n            raise ValueError(\"parameters should be dict\")\n\n        self.setup_id = setup_id\n        self.flow_id = flow_id\n        self.parameters = parameters\n\n    def _to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"setup_id\": self.setup_id,\n            \"flow_id\": self.flow_id,\n            \"parameters\": {p.id: p._to_dict() for p in self.parameters.values()}\n            if self.parameters is not None\n            else None,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Setup\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"Setup ID\": self.setup_id,\n            \"Flow ID\": self.flow_id,\n            \"Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"# of Parameters\": (\n                len(self.parameters) if self.parameters is not None else float(\"nan\")\n            ),\n        }\n\n        # determines the order in which the information will be printed\n        order = [\"Setup ID\", \"Flow ID\", \"Flow URL\", \"# of Parameters\"]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/#openml.OpenMLSplit","title":"<code>OpenMLSplit</code>","text":"<p>OpenML Split object.</p> <p>This class manages train-test splits for a dataset across multiple repetitions, folds, and samples.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>int or str</code> <p>The name or ID of the split.</p> required <code>description</code> <code>str</code> <p>A description of the split.</p> required <code>split</code> <code>dict</code> <p>A dictionary containing the splits organized by repetition, fold, and sample.</p> required Source code in <code>openml/tasks/split.py</code> <pre><code>class OpenMLSplit:\n    \"\"\"OpenML Split object.\n\n    This class manages train-test splits for a dataset across multiple\n    repetitions, folds, and samples.\n\n    Parameters\n    ----------\n    name : int or str\n        The name or ID of the split.\n    description : str\n        A description of the split.\n    split : dict\n        A dictionary containing the splits organized by repetition, fold,\n        and sample.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: int | str,\n        description: str,\n        split: dict[int, dict[int, dict[int, tuple[np.ndarray, np.ndarray]]]],\n    ):\n        self.description = description\n        self.name = name\n        self.split: dict[int, dict[int, dict[int, tuple[np.ndarray, np.ndarray]]]] = {}\n\n        # Add splits according to repetition\n        for repetition in split:\n            _rep = int(repetition)\n            self.split[_rep] = OrderedDict()\n            for fold in split[_rep]:\n                self.split[_rep][fold] = OrderedDict()\n                for sample in split[_rep][fold]:\n                    self.split[_rep][fold][sample] = split[_rep][fold][sample]\n\n        self.repeats = len(self.split)\n\n        # TODO(eddiebergman): Better error message\n        if any(len(self.split[0]) != len(self.split[i]) for i in range(self.repeats)):\n            raise ValueError(\"\")\n\n        self.folds = len(self.split[0])\n        self.samples = len(self.split[0][0])\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if (\n            (not isinstance(self, type(other)))\n            or self.name != other.name\n            or self.description != other.description\n            or self.split.keys() != other.split.keys()\n            or any(\n                self.split[repetition].keys() != other.split[repetition].keys()\n                for repetition in self.split\n            )\n        ):\n            return False\n\n        samples = [\n            (repetition, fold, sample)\n            for repetition in self.split\n            for fold in self.split[repetition]\n            for sample in self.split[repetition][fold]\n        ]\n\n        for repetition, fold, sample in samples:\n            self_train, self_test = self.split[repetition][fold][sample]\n            other_train, other_test = other.split[repetition][fold][sample]\n            if not (np.all(self_train == other_train) and np.all(self_test == other_test)):\n                return False\n        return True\n\n    @classmethod\n    def _from_arff_file(cls, filename: Path) -&gt; OpenMLSplit:  # noqa: C901, PLR0912\n        repetitions = None\n        name = None\n\n        pkl_filename = filename.with_suffix(\".pkl.py3\")\n\n        if pkl_filename.exists():\n            with pkl_filename.open(\"rb\") as fh:\n                # TODO(eddiebergman): Would be good to figure out what _split is and assert it is\n                _split = pickle.load(fh)  # noqa: S301\n            repetitions = _split[\"repetitions\"]\n            name = _split[\"name\"]\n\n        # Cache miss\n        if repetitions is None:\n            # Faster than liac-arff and sufficient in this situation!\n            if not filename.exists():\n                raise FileNotFoundError(f\"Split arff {filename} does not exist!\")\n\n            file_data = arff.load(filename.open(\"r\"), return_type=arff.DENSE_GEN)\n            splits = file_data[\"data\"]\n            name = file_data[\"relation\"]\n            attrnames = [attr[0] for attr in file_data[\"attributes\"]]\n\n            repetitions = OrderedDict()\n\n            type_idx = attrnames.index(\"type\")\n            rowid_idx = attrnames.index(\"rowid\")\n            repeat_idx = attrnames.index(\"repeat\")\n            fold_idx = attrnames.index(\"fold\")\n            sample_idx = attrnames.index(\"sample\") if \"sample\" in attrnames else None\n\n            for line in splits:\n                # A line looks like type, rowid, repeat, fold\n                repetition = int(line[repeat_idx])\n                fold = int(line[fold_idx])\n                sample = 0\n                if sample_idx is not None:\n                    sample = int(line[sample_idx])\n\n                if repetition not in repetitions:\n                    repetitions[repetition] = OrderedDict()\n                if fold not in repetitions[repetition]:\n                    repetitions[repetition][fold] = OrderedDict()\n                if sample not in repetitions[repetition][fold]:\n                    repetitions[repetition][fold][sample] = ([], [])\n                split = repetitions[repetition][fold][sample]\n\n                type_ = line[type_idx]\n                if type_ == \"TRAIN\":\n                    split[0].append(line[rowid_idx])\n                elif type_ == \"TEST\":\n                    split[1].append(line[rowid_idx])\n                else:\n                    raise ValueError(type_)\n\n            for repetition in repetitions:\n                for fold in repetitions[repetition]:\n                    for sample in repetitions[repetition][fold]:\n                        repetitions[repetition][fold][sample] = Split(\n                            np.array(repetitions[repetition][fold][sample][0], dtype=np.int32),\n                            np.array(repetitions[repetition][fold][sample][1], dtype=np.int32),\n                        )\n\n            with pkl_filename.open(\"wb\") as fh:\n                pickle.dump({\"name\": name, \"repetitions\": repetitions}, fh, protocol=2)\n\n        assert name is not None\n        return cls(name, \"\", repetitions)\n\n    def get(self, repeat: int = 0, fold: int = 0, sample: int = 0) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Returns the specified data split from the CrossValidationSplit object.\n\n        Parameters\n        ----------\n        repeat : int\n            Index of the repeat to retrieve.\n        fold : int\n            Index of the fold to retrieve.\n        sample : int\n            Index of the sample to retrieve.\n\n        Returns\n        -------\n        numpy.ndarray\n            The data split for the specified repeat, fold, and sample.\n\n        Raises\n        ------\n        ValueError\n            If the specified repeat, fold, or sample is not known.\n        \"\"\"\n        if repeat not in self.split:\n            raise ValueError(f\"Repeat {repeat!s} not known\")\n        if fold not in self.split[repeat]:\n            raise ValueError(f\"Fold {fold!s} not known\")\n        if sample not in self.split[repeat][fold]:\n            raise ValueError(f\"Sample {sample!s} not known\")\n        return self.split[repeat][fold][sample]\n</code></pre>"},{"location":"reference/#openml.OpenMLSplit.get","title":"<code>get(repeat=0, fold=0, sample=0)</code>","text":"<p>Returns the specified data split from the CrossValidationSplit object.</p> <p>Parameters:</p> Name Type Description Default <code>repeat</code> <code>int</code> <p>Index of the repeat to retrieve.</p> <code>0</code> <code>fold</code> <code>int</code> <p>Index of the fold to retrieve.</p> <code>0</code> <code>sample</code> <code>int</code> <p>Index of the sample to retrieve.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data split for the specified repeat, fold, and sample.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified repeat, fold, or sample is not known.</p> Source code in <code>openml/tasks/split.py</code> <pre><code>def get(self, repeat: int = 0, fold: int = 0, sample: int = 0) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Returns the specified data split from the CrossValidationSplit object.\n\n    Parameters\n    ----------\n    repeat : int\n        Index of the repeat to retrieve.\n    fold : int\n        Index of the fold to retrieve.\n    sample : int\n        Index of the sample to retrieve.\n\n    Returns\n    -------\n    numpy.ndarray\n        The data split for the specified repeat, fold, and sample.\n\n    Raises\n    ------\n    ValueError\n        If the specified repeat, fold, or sample is not known.\n    \"\"\"\n    if repeat not in self.split:\n        raise ValueError(f\"Repeat {repeat!s} not known\")\n    if fold not in self.split[repeat]:\n        raise ValueError(f\"Fold {fold!s} not known\")\n    if sample not in self.split[repeat][fold]:\n        raise ValueError(f\"Sample {sample!s} not known\")\n    return self.split[repeat][fold][sample]\n</code></pre>"},{"location":"reference/#openml.OpenMLStudy","title":"<code>OpenMLStudy</code>","text":"<p>               Bases: <code>BaseStudy</code></p> <p>An OpenMLStudy represents the OpenML concept of a study (a collection of runs).</p> <p>It contains the following information: name, id, description, creation date, creator id and a list of run ids.</p> <p>According to this list of run ids, the study object receives a list of OpenML object ids (datasets, flows, tasks and setups).</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>benchmark_suite</code> <code>int(optional)</code> <p>the benchmark suite (another study) upon which this study is ran. can only be active if main entity type is runs.</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required <code>flows</code> <code>list</code> <p>a list of flow ids associated with this study</p> required <code>runs</code> <code>list</code> <p>a list of run ids associated with this study</p> required <code>setups</code> <code>list</code> <p>a list of setup ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class OpenMLStudy(BaseStudy):\n    \"\"\"\n    An OpenMLStudy represents the OpenML concept of a study (a collection of runs).\n\n    It contains the following information: name, id, description, creation date,\n    creator id and a list of run ids.\n\n    According to this list of run ids, the study object receives a list of\n    OpenML object ids (datasets, flows, tasks and setups).\n\n    Parameters\n    ----------\n    study_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    benchmark_suite : int (optional)\n        the benchmark suite (another study) upon which this study is ran.\n        can only be active if main entity type is runs.\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    flows : list\n        a list of flow ids associated with this study\n    runs : list\n        a list of run ids associated with this study\n    setups : list\n        a list of setup ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        study_id: int | None,\n        alias: str | None,\n        benchmark_suite: int | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n        flows: list[int] | None,\n        runs: list[int] | None,\n        setups: list[int] | None,\n    ):\n        super().__init__(\n            study_id=study_id,\n            alias=alias,\n            main_entity_type=\"run\",\n            benchmark_suite=benchmark_suite,\n            name=name,\n            description=description,\n            status=status,\n            creation_date=creation_date,\n            creator=creator,\n            tags=tags,\n            data=data,\n            tasks=tasks,\n            flows=flows,\n            runs=runs,\n            setups=setups,\n        )\n</code></pre>"},{"location":"reference/#openml.OpenMLSupervisedTask","title":"<code>OpenMLSupervisedTask</code>","text":"<p>               Bases: <code>OpenMLTask</code>, <code>ABC</code></p> <p>OpenML Supervised Classification object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the task type.</p> required <code>task_type</code> <code>str</code> <p>Name of the task type.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset associated with the task.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature (the class variable).</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure for the task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure for the task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Estimation parameters for the task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure for the task.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the data splits for the task.</p> <code>None</code> <code>task_id</code> <code>int | None</code> <p>Refers to the unique identifier of task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLSupervisedTask(OpenMLTask, ABC):\n    \"\"\"OpenML Supervised Classification object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the task type.\n    task_type : str\n        Name of the task type.\n    data_set_id : int\n        ID of the OpenML dataset associated with the task.\n    target_name : str\n        Name of the target feature (the class variable).\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure for the task.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure for the task.\n    estimation_parameters : dict, default=None\n        Estimation parameters for the task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure for the task.\n    data_splits_url : str, default=None\n        URL of the data splits for the task.\n    task_id: Union[int, None]\n        Refers to the unique identifier of task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            data_splits_url=data_splits_url,\n        )\n\n        self.target_name = target_name\n\n    def get_X_and_y(self) -&gt; tuple[pd.DataFrame, pd.Series | pd.DataFrame | None]:\n        \"\"\"Get data associated with the current task.\n\n        Returns\n        -------\n        tuple - X and y\n\n        \"\"\"\n        dataset = self.get_dataset()\n        if self.task_type_id not in (\n            TaskType.SUPERVISED_CLASSIFICATION,\n            TaskType.SUPERVISED_REGRESSION,\n            TaskType.LEARNING_CURVE,\n        ):\n            raise NotImplementedError(self.task_type)\n\n        X, y, _, _ = dataset.get_data(target=self.target_name)\n        return X, y\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        task_container = super()._to_dict()\n        oml_input = task_container[\"oml:task_inputs\"][\"oml:input\"]  # type: ignore\n        assert isinstance(oml_input, list)\n\n        oml_input.append({\"@name\": \"target_feature\", \"#text\": self.target_name})\n        return task_container\n\n    @property\n    def estimation_parameters(self) -&gt; dict[str, str] | None:\n        \"\"\"Return the estimation parameters for the task.\"\"\"\n        warnings.warn(\n            \"The estimation_parameters attribute will be \"\n            \"deprecated in the future, please use \"\n            \"estimation_procedure['parameters'] instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.estimation_procedure[\"parameters\"]\n\n    @estimation_parameters.setter\n    def estimation_parameters(self, est_parameters: dict[str, str] | None) -&gt; None:\n        self.estimation_procedure[\"parameters\"] = est_parameters\n</code></pre>"},{"location":"reference/#openml.OpenMLSupervisedTask.estimation_parameters","title":"<code>estimation_parameters: dict[str, str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the estimation parameters for the task.</p>"},{"location":"reference/#openml.OpenMLSupervisedTask.get_X_and_y","title":"<code>get_X_and_y()</code>","text":"<p>Get data associated with the current task.</p> <p>Returns:</p> Type Description <code>tuple - X and y</code> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_X_and_y(self) -&gt; tuple[pd.DataFrame, pd.Series | pd.DataFrame | None]:\n    \"\"\"Get data associated with the current task.\n\n    Returns\n    -------\n    tuple - X and y\n\n    \"\"\"\n    dataset = self.get_dataset()\n    if self.task_type_id not in (\n        TaskType.SUPERVISED_CLASSIFICATION,\n        TaskType.SUPERVISED_REGRESSION,\n        TaskType.LEARNING_CURVE,\n    ):\n        raise NotImplementedError(self.task_type)\n\n    X, y, _, _ = dataset.get_data(target=self.target_name)\n    return X, y\n</code></pre>"},{"location":"reference/#openml.OpenMLTask","title":"<code>OpenMLTask</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Task object.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int | None</code> <p>Refers to the unique identifier of OpenML task.</p> required <code>task_type_id</code> <code>TaskType</code> <p>Refers to the type of OpenML task.</p> required <code>task_type</code> <code>str</code> <p>Refers to the OpenML task.</p> required <code>data_set_id</code> <code>int</code> <p>Refers to the data.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>Refers to the type of estimates used.</p> <code>1</code> <code>estimation_procedure_type</code> <code>str | None</code> <p>Refers to the type of estimation procedure used for the OpenML task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict[str, str] | None</code> <p>Estimation parameters used for the OpenML task.</p> <code>None</code> <code>evaluation_measure</code> <code>str | None</code> <p>Refers to the evaluation measure.</p> <code>None</code> <code>data_splits_url</code> <code>str | None</code> <p>Refers to the URL of the data splits used for the OpenML task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLTask(OpenMLBase):\n    \"\"\"OpenML Task object.\n\n    Parameters\n    ----------\n    task_id: Union[int, None]\n        Refers to the unique identifier of OpenML task.\n    task_type_id: TaskType\n        Refers to the type of OpenML task.\n    task_type: str\n        Refers to the OpenML task.\n    data_set_id: int\n        Refers to the data.\n    estimation_procedure_id: int\n        Refers to the type of estimates used.\n    estimation_procedure_type: str, default=None\n        Refers to the type of estimation procedure used for the OpenML task.\n    estimation_parameters: [Dict[str, str]], default=None\n        Estimation parameters used for the OpenML task.\n    evaluation_measure: str, default=None\n        Refers to the evaluation measure.\n    data_splits_url: str, default=None\n        Refers to the URL of the data splits used for the OpenML task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_id: int | None,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n    ):\n        self.task_id = int(task_id) if task_id is not None else None\n        self.task_type_id = task_type_id\n        self.task_type = task_type\n        self.dataset_id = int(data_set_id)\n        self.evaluation_measure = evaluation_measure\n        self.estimation_procedure: _EstimationProcedure = {\n            \"type\": estimation_procedure_type,\n            \"parameters\": estimation_parameters,\n            \"data_splits_url\": data_splits_url,\n        }\n        self.estimation_procedure_id = estimation_procedure_id\n        self.split: OpenMLSplit | None = None\n\n    @classmethod\n    def _entity_letter(cls) -&gt; str:\n        return \"t\"\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Return the OpenML ID of this task.\"\"\"\n        return self.task_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        base_server_url = openml.config.get_server_base_url()\n        fields: dict[str, Any] = {\n            \"Task Type Description\": f\"{base_server_url}/tt/{self.task_type_id}\"\n        }\n        if self.task_id is not None:\n            fields[\"Task ID\"] = self.task_id\n            fields[\"Task URL\"] = self.openml_url\n        if self.evaluation_measure is not None:\n            fields[\"Evaluation Measure\"] = self.evaluation_measure\n        if self.estimation_procedure is not None:\n            fields[\"Estimation Procedure\"] = self.estimation_procedure[\"type\"]\n\n        # TODO(eddiebergman): Subclasses could advertise/provide this, instead of having to\n        # have the base class know about it's subclasses.\n        target_name = getattr(self, \"target_name\", None)\n        if target_name is not None:\n            fields[\"Target Feature\"] = target_name\n\n            class_labels = getattr(self, \"class_labels\", None)\n            if class_labels is not None:\n                fields[\"# of Classes\"] = len(class_labels)\n\n            if hasattr(self, \"cost_matrix\"):\n                fields[\"Cost Matrix\"] = \"Available\"\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Task Type Description\",\n            \"Task ID\",\n            \"Task URL\",\n            \"Estimation Procedure\",\n            \"Evaluation Measure\",\n            \"Target Feature\",\n            \"# of Classes\",\n            \"Cost Matrix\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def get_dataset(self, **kwargs: Any) -&gt; datasets.OpenMLDataset:\n        \"\"\"Download dataset associated with task.\n\n        Accepts the same keyword arguments as the `openml.datasets.get_dataset`.\n        \"\"\"\n        return datasets.get_dataset(self.dataset_id, **kwargs)\n\n    def get_train_test_split_indices(\n        self,\n        fold: int = 0,\n        repeat: int = 0,\n        sample: int = 0,\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Get the indices of the train and test splits for a given task.\"\"\"\n        # Replace with retrieve from cache\n        if self.split is None:\n            self.split = self.download_split()\n\n        return self.split.get(repeat=repeat, fold=fold, sample=sample)\n\n    def _download_split(self, cache_file: Path) -&gt; None:\n        # TODO(eddiebergman): Not sure about this try to read and error approach\n        try:\n            with cache_file.open(encoding=\"utf8\"):\n                pass\n        except OSError:\n            split_url = self.estimation_procedure[\"data_splits_url\"]\n            openml._api_calls._download_text_file(\n                source=str(split_url),\n                output_path=str(cache_file),\n            )\n\n    def download_split(self) -&gt; OpenMLSplit:\n        \"\"\"Download the OpenML split for a given task.\"\"\"\n        # TODO(eddiebergman): Can this every be `None`?\n        assert self.task_id is not None\n        cache_dir = _create_cache_directory_for_id(\"tasks\", self.task_id)\n        cached_split_file = cache_dir / \"datasplits.arff\"\n\n        try:\n            split = OpenMLSplit._from_arff_file(cached_split_file)\n        except OSError:\n            # Next, download and cache the associated split file\n            self._download_split(cached_split_file)\n            split = OpenMLSplit._from_arff_file(cached_split_file)\n\n        return split\n\n    def get_split_dimensions(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get the (repeats, folds, samples) of the split for a given task.\"\"\"\n        if self.split is None:\n            self.split = self.download_split()\n\n        return self.split.repeats, self.split.folds, self.split.samples\n\n    # TODO(eddiebergman): Really need some better typing on all this\n    def _to_dict(self) -&gt; dict[str, dict[str, int | str | list[dict[str, Any]]]]:\n        \"\"\"Creates a dictionary representation of self in a string format (for XML parsing).\"\"\"\n        oml_input = [\n            {\"@name\": \"source_data\", \"#text\": str(self.dataset_id)},\n            {\"@name\": \"estimation_procedure\", \"#text\": str(self.estimation_procedure_id)},\n        ]\n        if self.evaluation_measure is not None:\n            oml_input.append({\"@name\": \"evaluation_measures\", \"#text\": self.evaluation_measure})\n\n        return {\n            \"oml:task_inputs\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                \"oml:task_type_id\": self.task_type_id.value,  # This is an int from the enum?\n                \"oml:input\": oml_input,\n            }\n        }\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.task_id = int(xml_response[\"oml:upload_task\"][\"oml:id\"])\n</code></pre>"},{"location":"reference/#openml.OpenMLTask.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Return the OpenML ID of this task.</p>"},{"location":"reference/#openml.OpenMLTask.download_split","title":"<code>download_split()</code>","text":"<p>Download the OpenML split for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def download_split(self) -&gt; OpenMLSplit:\n    \"\"\"Download the OpenML split for a given task.\"\"\"\n    # TODO(eddiebergman): Can this every be `None`?\n    assert self.task_id is not None\n    cache_dir = _create_cache_directory_for_id(\"tasks\", self.task_id)\n    cached_split_file = cache_dir / \"datasplits.arff\"\n\n    try:\n        split = OpenMLSplit._from_arff_file(cached_split_file)\n    except OSError:\n        # Next, download and cache the associated split file\n        self._download_split(cached_split_file)\n        split = OpenMLSplit._from_arff_file(cached_split_file)\n\n    return split\n</code></pre>"},{"location":"reference/#openml.OpenMLTask.get_dataset","title":"<code>get_dataset(**kwargs)</code>","text":"<p>Download dataset associated with task.</p> <p>Accepts the same keyword arguments as the <code>openml.datasets.get_dataset</code>.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_dataset(self, **kwargs: Any) -&gt; datasets.OpenMLDataset:\n    \"\"\"Download dataset associated with task.\n\n    Accepts the same keyword arguments as the `openml.datasets.get_dataset`.\n    \"\"\"\n    return datasets.get_dataset(self.dataset_id, **kwargs)\n</code></pre>"},{"location":"reference/#openml.OpenMLTask.get_split_dimensions","title":"<code>get_split_dimensions()</code>","text":"<p>Get the (repeats, folds, samples) of the split for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_split_dimensions(self) -&gt; tuple[int, int, int]:\n    \"\"\"Get the (repeats, folds, samples) of the split for a given task.\"\"\"\n    if self.split is None:\n        self.split = self.download_split()\n\n    return self.split.repeats, self.split.folds, self.split.samples\n</code></pre>"},{"location":"reference/#openml.OpenMLTask.get_train_test_split_indices","title":"<code>get_train_test_split_indices(fold=0, repeat=0, sample=0)</code>","text":"<p>Get the indices of the train and test splits for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_train_test_split_indices(\n    self,\n    fold: int = 0,\n    repeat: int = 0,\n    sample: int = 0,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Get the indices of the train and test splits for a given task.\"\"\"\n    # Replace with retrieve from cache\n    if self.split is None:\n        self.split = self.download_split()\n\n    return self.split.get(repeat=repeat, fold=fold, sample=sample)\n</code></pre>"},{"location":"reference/#openml.populate_cache","title":"<code>populate_cache(task_ids=None, dataset_ids=None, flow_ids=None, run_ids=None)</code>","text":"<p>Populate a cache for offline and parallel usage of the OpenML connector.</p> <p>Parameters:</p> Name Type Description Default <code>task_ids</code> <code>iterable</code> <code>None</code> <code>dataset_ids</code> <code>iterable</code> <code>None</code> <code>flow_ids</code> <code>iterable</code> <code>None</code> <code>run_ids</code> <code>iterable</code> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>openml/__init__.py</code> <pre><code>def populate_cache(\n    task_ids: list[int] | None = None,\n    dataset_ids: list[int | str] | None = None,\n    flow_ids: list[int] | None = None,\n    run_ids: list[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Populate a cache for offline and parallel usage of the OpenML connector.\n\n    Parameters\n    ----------\n    task_ids : iterable\n\n    dataset_ids : iterable\n\n    flow_ids : iterable\n\n    run_ids : iterable\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if task_ids is not None:\n        for task_id in task_ids:\n            tasks.functions.get_task(task_id)\n\n    if dataset_ids is not None:\n        for dataset_id in dataset_ids:\n            datasets.functions.get_dataset(dataset_id)\n\n    if flow_ids is not None:\n        for flow_id in flow_ids:\n            flows.functions.get_flow(flow_id)\n\n    if run_ids is not None:\n        for run_id in run_ids:\n            runs.functions.get_run(run_id)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>openml<ul> <li>__version__</li> <li>_api_calls</li> <li>base</li> <li>cli</li> <li>config</li> <li>datasets<ul> <li>data_feature</li> <li>dataset</li> <li>functions</li> </ul> </li> <li>evaluations<ul> <li>evaluation</li> <li>functions</li> </ul> </li> <li>exceptions</li> <li>extensions<ul> <li>extension_interface</li> <li>functions</li> <li>sklearn<ul> <li>extension</li> </ul> </li> </ul> </li> <li>flows<ul> <li>flow</li> <li>functions</li> </ul> </li> <li>runs<ul> <li>functions</li> <li>run</li> <li>trace</li> </ul> </li> <li>setups<ul> <li>functions</li> <li>setup</li> </ul> </li> <li>study<ul> <li>functions</li> <li>study</li> </ul> </li> <li>tasks<ul> <li>functions</li> <li>split</li> <li>task</li> </ul> </li> <li>testing</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/__version__/","title":"__version__","text":"<p>Version information.</p>"},{"location":"reference/_api_calls/","title":"_api_calls","text":""},{"location":"reference/_api_calls/#openml._api_calls.resolve_env_proxies","title":"<code>resolve_env_proxies(url)</code>","text":"<p>Attempt to find a suitable proxy for this url.</p> <p>Relies on <code>requests</code> internals to remain consistent. To disable this from the environment, please set the enviornment varialbe <code>no_proxy=\"*\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url endpoint</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The proxy url if found, else None</p> Source code in <code>openml/_api_calls.py</code> <pre><code>def resolve_env_proxies(url: str) -&gt; str | None:\n    \"\"\"Attempt to find a suitable proxy for this url.\n\n    Relies on ``requests`` internals to remain consistent. To disable this from the\n    environment, please set the enviornment varialbe ``no_proxy=\"*\"``.\n\n    Parameters\n    ----------\n    url : str\n        The url endpoint\n\n    Returns\n    -------\n    Optional[str]\n        The proxy url if found, else None\n    \"\"\"\n    resolved_proxies = requests.utils.get_environ_proxies(url)\n    return requests.utils.select_proxy(url, resolved_proxies)  # type: ignore\n</code></pre>"},{"location":"reference/base/","title":"base","text":""},{"location":"reference/base/#openml.base.OpenMLBase","title":"<code>OpenMLBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base object for functionality that is shared across entities.</p> Source code in <code>openml/base.py</code> <pre><code>class OpenMLBase(ABC):\n    \"\"\"Base object for functionality that is shared across entities.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        body_fields = self._get_repr_body_fields()\n        return self._apply_repr_template(body_fields)\n\n    @property\n    @abstractmethod\n    def id(self) -&gt; int | None:\n        \"\"\"The id of the entity, it is unique for its entity type.\"\"\"\n\n    @property\n    def openml_url(self) -&gt; str | None:\n        \"\"\"The URL of the object on the server, if it was uploaded, else None.\"\"\"\n        if self.id is None:\n            return None\n        return self.__class__.url_for_id(self.id)\n\n    @classmethod\n    def url_for_id(cls, id_: int) -&gt; str:\n        \"\"\"Return the OpenML URL for the object of the class entity with the given id.\"\"\"\n        # Sample url for a flow: openml.org/f/123\n        return f\"{openml.config.get_server_base_url()}/{cls._entity_letter()}/{id_}\"\n\n    @classmethod\n    def _entity_letter(cls) -&gt; str:\n        \"\"\"Return the letter which represents the entity type in urls, e.g. 'f' for flow.\"\"\"\n        # We take advantage of the class naming convention (OpenMLX),\n        # which holds for all entities except studies and tasks, which overwrite this method.\n        return cls.__name__.lower()[len(\"OpenML\") :][0]\n\n    # TODO(eddiebergman): This would be much cleaner as an iterator...\n    @abstractmethod\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str] | None]]:\n        \"\"\"Collect all information to display in the __repr__ body.\n\n        Returns\n        -------\n        body_fields : List[Tuple[str, Union[str, int, List[str]]]]\n            A list of (name, value) pairs to display in the body of the __repr__.\n            E.g.: [('metric', 'accuracy'), ('dataset', 'iris')]\n            If value is a List of str, then each item of the list will appear in a separate row.\n        \"\"\"\n        # Should be implemented in the base class.\n\n    def _apply_repr_template(\n        self,\n        body_fields: Iterable[tuple[str, str | int | list[str] | None]],\n    ) -&gt; str:\n        \"\"\"Generates the header and formats the body for string representation of the object.\n\n        Parameters\n        ----------\n        body_fields: List[Tuple[str, str]]\n           A list of (name, value) pairs to display in the body of the __repr__.\n        \"\"\"\n        # We add spaces between capitals, e.g. ClassificationTask -&gt; Classification Task\n        name_with_spaces = re.sub(\n            r\"(\\w)([A-Z])\",\n            r\"\\1 \\2\",\n            self.__class__.__name__[len(\"OpenML\") :],\n        )\n        header_text = f\"OpenML {name_with_spaces}\"\n        header = f\"{header_text}\\n{'=' * len(header_text)}\\n\"\n\n        _body_fields: list[tuple[str, str | int | list[str]]] = [\n            (k, \"None\" if v is None else v) for k, v in body_fields\n        ]\n        longest_field_name_length = max(len(name) for name, _ in _body_fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _body_fields)\n        return header + body\n\n    @abstractmethod\n    def _to_dict(self) -&gt; dict[str, dict]:\n        \"\"\"Creates a dictionary representation of self.\n\n        The return value will be used to create the upload xml file.\n        The xml file must have the tags in exactly the order of the object's xsd.\n        (see https://github.com/openml/OpenML/blob/master/openml_OS/views/pages/api_new/v1/xsd/).\n\n        Returns\n        -------\n            Thing represented as dict.\n        \"\"\"\n        # Should be implemented in the base class.\n\n    def _to_xml(self) -&gt; str:\n        \"\"\"Generate xml representation of self for upload to server.\"\"\"\n        dict_representation = self._to_dict()\n        xml_representation = xmltodict.unparse(dict_representation, pretty=True)\n\n        # A task may not be uploaded with the xml encoding specification:\n        # &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n        _encoding_specification, xml_body = xml_representation.split(\"\\n\", 1)\n        return str(xml_body)\n\n    def _get_file_elements(self) -&gt; openml._api_calls.FILE_ELEMENTS_TYPE:\n        \"\"\"Get file_elements to upload to the server, called during Publish.\n\n        Derived child classes should overwrite this method as necessary.\n        The description field will be populated automatically if not provided.\n        \"\"\"\n        return {}\n\n    @abstractmethod\n    def _parse_publish_response(self, xml_response: dict[str, str]) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n\n    def publish(self) -&gt; OpenMLBase:\n        \"\"\"Publish the object on the OpenML server.\"\"\"\n        file_elements = self._get_file_elements()\n\n        if \"description\" not in file_elements:\n            file_elements[\"description\"] = self._to_xml()\n\n        call = f\"{_get_rest_api_type_alias(self)}/\"\n        response_text = openml._api_calls._perform_api_call(\n            call,\n            \"post\",\n            file_elements=file_elements,\n        )\n        xml_response = xmltodict.parse(response_text)\n\n        self._parse_publish_response(xml_response)\n        return self\n\n    def open_in_browser(self) -&gt; None:\n        \"\"\"Opens the OpenML web page corresponding to this object in your default browser.\"\"\"\n        if self.openml_url is None:\n            raise ValueError(\n                \"Cannot open element on OpenML.org when attribute `openml_url` is `None`\",\n            )\n\n        webbrowser.open(self.openml_url)\n\n    def push_tag(self, tag: str) -&gt; None:\n        \"\"\"Annotates this entity with a tag on the server.\n\n        Parameters\n        ----------\n        tag : str\n            Tag to attach to the flow.\n        \"\"\"\n        _tag_openml_base(self, tag)\n\n    def remove_tag(self, tag: str) -&gt; None:\n        \"\"\"Removes a tag from this entity on the server.\n\n        Parameters\n        ----------\n        tag : str\n            Tag to attach to the flow.\n        \"\"\"\n        _tag_openml_base(self, tag, untag=True)\n</code></pre>"},{"location":"reference/base/#openml.base.OpenMLBase.id","title":"<code>id: int | None</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The id of the entity, it is unique for its entity type.</p>"},{"location":"reference/base/#openml.base.OpenMLBase.openml_url","title":"<code>openml_url: str | None</code>  <code>property</code>","text":"<p>The URL of the object on the server, if it was uploaded, else None.</p>"},{"location":"reference/base/#openml.base.OpenMLBase.open_in_browser","title":"<code>open_in_browser()</code>","text":"<p>Opens the OpenML web page corresponding to this object in your default browser.</p> Source code in <code>openml/base.py</code> <pre><code>def open_in_browser(self) -&gt; None:\n    \"\"\"Opens the OpenML web page corresponding to this object in your default browser.\"\"\"\n    if self.openml_url is None:\n        raise ValueError(\n            \"Cannot open element on OpenML.org when attribute `openml_url` is `None`\",\n        )\n\n    webbrowser.open(self.openml_url)\n</code></pre>"},{"location":"reference/base/#openml.base.OpenMLBase.publish","title":"<code>publish()</code>","text":"<p>Publish the object on the OpenML server.</p> Source code in <code>openml/base.py</code> <pre><code>def publish(self) -&gt; OpenMLBase:\n    \"\"\"Publish the object on the OpenML server.\"\"\"\n    file_elements = self._get_file_elements()\n\n    if \"description\" not in file_elements:\n        file_elements[\"description\"] = self._to_xml()\n\n    call = f\"{_get_rest_api_type_alias(self)}/\"\n    response_text = openml._api_calls._perform_api_call(\n        call,\n        \"post\",\n        file_elements=file_elements,\n    )\n    xml_response = xmltodict.parse(response_text)\n\n    self._parse_publish_response(xml_response)\n    return self\n</code></pre>"},{"location":"reference/base/#openml.base.OpenMLBase.push_tag","title":"<code>push_tag(tag)</code>","text":"<p>Annotates this entity with a tag on the server.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag to attach to the flow.</p> required Source code in <code>openml/base.py</code> <pre><code>def push_tag(self, tag: str) -&gt; None:\n    \"\"\"Annotates this entity with a tag on the server.\n\n    Parameters\n    ----------\n    tag : str\n        Tag to attach to the flow.\n    \"\"\"\n    _tag_openml_base(self, tag)\n</code></pre>"},{"location":"reference/base/#openml.base.OpenMLBase.remove_tag","title":"<code>remove_tag(tag)</code>","text":"<p>Removes a tag from this entity on the server.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag to attach to the flow.</p> required Source code in <code>openml/base.py</code> <pre><code>def remove_tag(self, tag: str) -&gt; None:\n    \"\"\"Removes a tag from this entity on the server.\n\n    Parameters\n    ----------\n    tag : str\n        Tag to attach to the flow.\n    \"\"\"\n    _tag_openml_base(self, tag, untag=True)\n</code></pre>"},{"location":"reference/base/#openml.base.OpenMLBase.url_for_id","title":"<code>url_for_id(id_)</code>  <code>classmethod</code>","text":"<p>Return the OpenML URL for the object of the class entity with the given id.</p> Source code in <code>openml/base.py</code> <pre><code>@classmethod\ndef url_for_id(cls, id_: int) -&gt; str:\n    \"\"\"Return the OpenML URL for the object of the class entity with the given id.\"\"\"\n    # Sample url for a flow: openml.org/f/123\n    return f\"{openml.config.get_server_base_url()}/{cls._entity_letter()}/{id_}\"\n</code></pre>"},{"location":"reference/cli/","title":"cli","text":"<p>Command Line Interface for <code>openml</code> to configure its settings.</p>"},{"location":"reference/cli/#openml.cli.configure","title":"<code>configure(args)</code>","text":"<p>Calls the right submenu(s) to edit <code>args.field</code> in the configuration file.</p> Source code in <code>openml/cli.py</code> <pre><code>def configure(args: argparse.Namespace) -&gt; None:\n    \"\"\"Calls the right submenu(s) to edit `args.field` in the configuration file.\"\"\"\n    set_functions = {\n        \"apikey\": configure_apikey,\n        \"server\": configure_server,\n        \"cachedir\": configure_cachedir,\n        \"retry_policy\": configure_retry_policy,\n        \"connection_n_retries\": configure_connection_n_retries,\n        \"avoid_duplicate_runs\": configure_avoid_duplicate_runs,\n        \"verbosity\": configure_verbosity,\n    }\n\n    def not_supported_yet(_: str) -&gt; None:\n        print(f\"Setting '{args.field}' is not supported yet.\")\n\n    if args.field not in [\"all\", \"none\"]:\n        set_functions.get(args.field, not_supported_yet)(args.value)\n    else:\n        if args.value is not None:\n            print(f\"Can not set value ('{args.value}') when field is specified as '{args.field}'.\")\n            sys.exit()\n        print_configuration()\n\n    if args.field == \"all\":\n        for set_field_function in set_functions.values():\n            set_field_function(args.value)\n</code></pre>"},{"location":"reference/cli/#openml.cli.configure_field","title":"<code>configure_field(field, value, check_with_message, intro_message, input_message, sanitize=None)</code>","text":"<p>Configure <code>field</code> with <code>value</code>. If <code>value</code> is None ask the user for input.</p> <p><code>value</code> and user input are first corrected/auto-completed with <code>convert_value</code> if provided, then validated with <code>check_with_message</code> function. If the user input a wrong value in interactive mode, the user gets to input a new value. The new valid value is saved in the openml configuration file. In case an invalid <code>value</code> is supplied directly (non-interactive), no changes are made.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Field to set.</p> required <code>value</code> <code>None | str</code> <p>Value to field to. If <code>None</code> will ask user for input.</p> required <code>check_with_message</code> <code>Callable[[str], str]</code> <p>Function which validates <code>value</code> or user input, and returns either an error message if it is invalid, or a False-like value if <code>value</code> is valid.</p> required <code>intro_message</code> <code>str</code> <p>Message that is printed once if user input is requested (e.g. instructions).</p> required <code>input_message</code> <code>str</code> <p>Message that comes with the input prompt.</p> required <code>sanitize</code> <code>Callable[[str], str] | None</code> <p>A function to convert user input to 'more acceptable' input, e.g. for auto-complete. If no correction of user input is possible, return the original value. If no function is provided, don't attempt to correct/auto-complete input.</p> <code>None</code> Source code in <code>openml/cli.py</code> <pre><code>def configure_field(  # noqa: PLR0913\n    field: str,\n    value: None | str,\n    check_with_message: Callable[[str], str],\n    intro_message: str,\n    input_message: str,\n    sanitize: Callable[[str], str] | None = None,\n) -&gt; None:\n    \"\"\"Configure `field` with `value`. If `value` is None ask the user for input.\n\n    `value` and user input are first corrected/auto-completed with `convert_value` if provided,\n    then validated with `check_with_message` function.\n    If the user input a wrong value in interactive mode, the user gets to input a new value.\n    The new valid value is saved in the openml configuration file.\n    In case an invalid `value` is supplied directly (non-interactive), no changes are made.\n\n    Parameters\n    ----------\n    field: str\n        Field to set.\n    value: str, None\n        Value to field to. If `None` will ask user for input.\n    check_with_message: Callable[[str], str]\n        Function which validates `value` or user input, and returns either an error message if it\n        is invalid, or a False-like value if `value` is valid.\n    intro_message: str\n        Message that is printed once if user input is requested (e.g. instructions).\n    input_message: str\n        Message that comes with the input prompt.\n    sanitize: Union[Callable[[str], str], None]\n        A function to convert user input to 'more acceptable' input, e.g. for auto-complete.\n        If no correction of user input is possible, return the original value.\n        If no function is provided, don't attempt to correct/auto-complete input.\n    \"\"\"\n    if value is not None:\n        if sanitize:\n            value = sanitize(value)\n        malformed_input = check_with_message(value)\n        if malformed_input:\n            print(malformed_input)\n            sys.exit()\n    else:\n        print(intro_message)\n        value = wait_until_valid_input(\n            prompt=input_message,\n            check=check_with_message,\n            sanitize=sanitize,\n        )\n    verbose_set(field, value)\n</code></pre>"},{"location":"reference/cli/#openml.cli.wait_until_valid_input","title":"<code>wait_until_valid_input(prompt, check, sanitize)</code>","text":"<p>Asks <code>prompt</code> until an input is received which returns True for <code>check</code>.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>message to display</p> required <code>check</code> <code>Callable[[str], str]</code> <p>function to call with the given input, that provides an error message if the input is not valid otherwise, and False-like otherwise.</p> required <code>sanitize</code> <code>Callable[[str], str] | None</code> <p>A function which attempts to sanitize the user input (e.g. auto-complete).</p> required <p>Returns:</p> Type Description <code>valid input</code> Source code in <code>openml/cli.py</code> <pre><code>def wait_until_valid_input(\n    prompt: str,\n    check: Callable[[str], str],\n    sanitize: Callable[[str], str] | None,\n) -&gt; str:\n    \"\"\"Asks `prompt` until an input is received which returns True for `check`.\n\n    Parameters\n    ----------\n    prompt: str\n        message to display\n    check: Callable[[str], str]\n        function to call with the given input, that provides an error message if the input is not\n        valid otherwise, and False-like otherwise.\n    sanitize: Callable[[str], str], optional\n        A function which attempts to sanitize the user input (e.g. auto-complete).\n\n    Returns\n    -------\n    valid input\n\n    \"\"\"\n    while True:\n        response = input(prompt)\n        if sanitize:\n            response = sanitize(response)\n        error_message = check(response)\n        if error_message:\n            print(error_message, end=\"\\n\\n\")\n        else:\n            return response\n</code></pre>"},{"location":"reference/config/","title":"config","text":"<p>Store module level information like the API key, cache directory and the server</p>"},{"location":"reference/config/#openml.config.ConfigurationForExamples","title":"<code>ConfigurationForExamples</code>","text":"<p>Allows easy switching to and from a test configuration, used for examples.</p> Source code in <code>openml/config.py</code> <pre><code>class ConfigurationForExamples:\n    \"\"\"Allows easy switching to and from a test configuration, used for examples.\"\"\"\n\n    _last_used_server = None\n    _last_used_key = None\n    _start_last_called = False\n    _test_server = \"https://test.openml.org/api/v1/xml\"\n    _test_apikey = \"c0c42819af31e706efe1f4b88c23c6c1\"\n\n    @classmethod\n    def start_using_configuration_for_example(cls) -&gt; None:\n        \"\"\"Sets the configuration to connect to the test server with valid apikey.\n\n        To configuration as was before this call is stored, and can be recovered\n        by using the `stop_use_example_configuration` method.\n        \"\"\"\n        global server  # noqa: PLW0603\n        global apikey  # noqa: PLW0603\n\n        if cls._start_last_called and server == cls._test_server and apikey == cls._test_apikey:\n            # Method is called more than once in a row without modifying the server or apikey.\n            # We don't want to save the current test configuration as a last used configuration.\n            return\n\n        cls._last_used_server = server\n        cls._last_used_key = apikey\n        cls._start_last_called = True\n\n        # Test server key for examples\n        server = cls._test_server\n        apikey = cls._test_apikey\n        warnings.warn(\n            f\"Switching to the test server {server} to not upload results to the live server. \"\n            \"Using the test server may result in reduced performance of the API!\",\n            stacklevel=2,\n        )\n\n    @classmethod\n    def stop_using_configuration_for_example(cls) -&gt; None:\n        \"\"\"Return to configuration as it was before `start_use_example_configuration`.\"\"\"\n        if not cls._start_last_called:\n            # We don't want to allow this because it will (likely) result in the `server` and\n            # `apikey` variables being set to None.\n            raise RuntimeError(\n                \"`stop_use_example_configuration` called without a saved config.\"\n                \"`start_use_example_configuration` must be called first.\",\n            )\n\n        global server  # noqa: PLW0603\n        global apikey  # noqa: PLW0603\n\n        server = cast(str, cls._last_used_server)\n        apikey = cast(str, cls._last_used_key)\n        cls._start_last_called = False\n</code></pre>"},{"location":"reference/config/#openml.config.ConfigurationForExamples.start_using_configuration_for_example","title":"<code>start_using_configuration_for_example()</code>  <code>classmethod</code>","text":"<p>Sets the configuration to connect to the test server with valid apikey.</p> <p>To configuration as was before this call is stored, and can be recovered by using the <code>stop_use_example_configuration</code> method.</p> Source code in <code>openml/config.py</code> <pre><code>@classmethod\ndef start_using_configuration_for_example(cls) -&gt; None:\n    \"\"\"Sets the configuration to connect to the test server with valid apikey.\n\n    To configuration as was before this call is stored, and can be recovered\n    by using the `stop_use_example_configuration` method.\n    \"\"\"\n    global server  # noqa: PLW0603\n    global apikey  # noqa: PLW0603\n\n    if cls._start_last_called and server == cls._test_server and apikey == cls._test_apikey:\n        # Method is called more than once in a row without modifying the server or apikey.\n        # We don't want to save the current test configuration as a last used configuration.\n        return\n\n    cls._last_used_server = server\n    cls._last_used_key = apikey\n    cls._start_last_called = True\n\n    # Test server key for examples\n    server = cls._test_server\n    apikey = cls._test_apikey\n    warnings.warn(\n        f\"Switching to the test server {server} to not upload results to the live server. \"\n        \"Using the test server may result in reduced performance of the API!\",\n        stacklevel=2,\n    )\n</code></pre>"},{"location":"reference/config/#openml.config.ConfigurationForExamples.stop_using_configuration_for_example","title":"<code>stop_using_configuration_for_example()</code>  <code>classmethod</code>","text":"<p>Return to configuration as it was before <code>start_use_example_configuration</code>.</p> Source code in <code>openml/config.py</code> <pre><code>@classmethod\ndef stop_using_configuration_for_example(cls) -&gt; None:\n    \"\"\"Return to configuration as it was before `start_use_example_configuration`.\"\"\"\n    if not cls._start_last_called:\n        # We don't want to allow this because it will (likely) result in the `server` and\n        # `apikey` variables being set to None.\n        raise RuntimeError(\n            \"`stop_use_example_configuration` called without a saved config.\"\n            \"`start_use_example_configuration` must be called first.\",\n        )\n\n    global server  # noqa: PLW0603\n    global apikey  # noqa: PLW0603\n\n    server = cast(str, cls._last_used_server)\n    apikey = cast(str, cls._last_used_key)\n    cls._start_last_called = False\n</code></pre>"},{"location":"reference/config/#openml.config.get_cache_directory","title":"<code>get_cache_directory()</code>","text":"<p>Get the current cache directory.</p> <p>This gets the cache directory for the current server relative to the root cache directory that can be set via <code>set_root_cache_directory()</code>. The cache directory is the <code>root_cache_directory</code> with additional information on which subdirectory to use based on the server name. By default it is <code>root_cache_directory / org / openml / www</code> for the standard OpenML.org server and is defined as <code>root_cache_directory / top-level domain / second-level domain / hostname</code> ```</p>"},{"location":"reference/config/#openml.config.get_cache_directory--returns","title":"Returns","text":"<p>cachedir : string     The current cache directory.</p> Source code in <code>openml/config.py</code> <pre><code>def get_cache_directory() -&gt; str:\n    \"\"\"Get the current cache directory.\n\n    This gets the cache directory for the current server relative\n    to the root cache directory that can be set via\n    ``set_root_cache_directory()``. The cache directory is the\n    ``root_cache_directory`` with additional information on which\n    subdirectory to use based on the server name. By default it is\n    ``root_cache_directory / org / openml / www`` for the standard\n    OpenML.org server and is defined as\n    ``root_cache_directory / top-level domain / second-level domain /\n    hostname``\n    ```\n\n    Returns\n    -------\n    cachedir : string\n        The current cache directory.\n\n    \"\"\"\n    url_suffix = urlparse(server).netloc\n    reversed_url_suffix = os.sep.join(url_suffix.split(\".\")[::-1])  # noqa: PTH118\n    return os.path.join(_root_cache_directory, reversed_url_suffix)  # noqa: PTH118\n</code></pre>"},{"location":"reference/config/#openml.config.get_server_base_url","title":"<code>get_server_base_url()</code>","text":"<p>Return the base URL of the currently configured server.</p> <p>Turns <code>\"https://api.openml.org/api/v1/xml\"</code> in <code>\"https://www.openml.org/\"</code> and <code>\"https://test.openml.org/api/v1/xml\"</code> in <code>\"https://test.openml.org/\"</code></p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/config.py</code> <pre><code>def get_server_base_url() -&gt; str:\n    \"\"\"Return the base URL of the currently configured server.\n\n    Turns ``\"https://api.openml.org/api/v1/xml\"`` in ``\"https://www.openml.org/\"``\n    and ``\"https://test.openml.org/api/v1/xml\"`` in ``\"https://test.openml.org/\"``\n\n    Returns\n    -------\n    str\n    \"\"\"\n    domain, path = server.split(\"/api\", maxsplit=1)\n    return domain.replace(\"api\", \"www\")\n</code></pre>"},{"location":"reference/config/#openml.config.overwrite_config_context","title":"<code>overwrite_config_context(config)</code>","text":"<p>A context manager to temporarily override variables in the configuration.</p> Source code in <code>openml/config.py</code> <pre><code>@contextmanager\ndef overwrite_config_context(config: dict[str, Any]) -&gt; Iterator[_Config]:\n    \"\"\"A context manager to temporarily override variables in the configuration.\"\"\"\n    existing_config = get_config_as_dict()\n    merged_config = {**existing_config, **config}\n\n    _setup(merged_config)  # type: ignore\n    yield merged_config  # type: ignore\n\n    _setup(existing_config)\n</code></pre>"},{"location":"reference/config/#openml.config.set_console_log_level","title":"<code>set_console_log_level(console_output_level)</code>","text":"<p>Set console output to the desired level and register it with openml logger if needed.</p> Source code in <code>openml/config.py</code> <pre><code>def set_console_log_level(console_output_level: int) -&gt; None:\n    \"\"\"Set console output to the desired level and register it with openml logger if needed.\"\"\"\n    global console_handler  # noqa: PLW0602\n    assert console_handler is not None\n    _set_level_register_and_store(console_handler, console_output_level)\n</code></pre>"},{"location":"reference/config/#openml.config.set_field_in_config_file","title":"<code>set_field_in_config_file(field, value)</code>","text":"<p>Overwrites the <code>field</code> in the configuration file with the new <code>value</code>.</p> Source code in <code>openml/config.py</code> <pre><code>def set_field_in_config_file(field: str, value: Any) -&gt; None:\n    \"\"\"Overwrites the `field` in the configuration file with the new `value`.\"\"\"\n    if field not in _defaults:\n        raise ValueError(f\"Field '{field}' is not valid and must be one of '{_defaults.keys()}'.\")\n\n    # TODO(eddiebergman): This use of globals has gone too far\n    globals()[field] = value\n    config_file = determine_config_file_path()\n    config = _parse_config(config_file)\n    with config_file.open(\"w\") as fh:\n        for f in _defaults:\n            # We can't blindly set all values based on globals() because when the user\n            # sets it through config.FIELD it should not be stored to file.\n            # There doesn't seem to be a way to avoid writing defaults to file with configparser,\n            # because it is impossible to distinguish from an explicitly set value that matches\n            # the default value, to one that was set to its default because it was omitted.\n            value = globals()[f] if f == field else config.get(f)  # type: ignore\n            if value is not None:\n                fh.write(f\"{f} = {value}\\n\")\n</code></pre>"},{"location":"reference/config/#openml.config.set_file_log_level","title":"<code>set_file_log_level(file_output_level)</code>","text":"<p>Set file output to the desired level and register it with openml logger if needed.</p> Source code in <code>openml/config.py</code> <pre><code>def set_file_log_level(file_output_level: int) -&gt; None:\n    \"\"\"Set file output to the desired level and register it with openml logger if needed.\"\"\"\n    global file_handler  # noqa: PLW0602\n    assert file_handler is not None\n    _set_level_register_and_store(file_handler, file_output_level)\n</code></pre>"},{"location":"reference/config/#openml.config.set_root_cache_directory","title":"<code>set_root_cache_directory(root_cache_directory)</code>","text":"<p>Set module-wide base cache directory.</p> <p>Sets the root cache directory, wherin the cache directories are created to store content from different OpenML servers. For example, by default, cached data for the standard OpenML.org server is stored at <code>root_cache_directory / org / openml / www</code>, and the general pattern is <code>root_cache_directory / top-level domain / second-level domain / hostname</code>.</p> <p>Parameters:</p> Name Type Description Default <code>root_cache_directory</code> <code>string</code> <p>Path to use as cache directory.</p> required See Also <p>get_cache_directory</p> Source code in <code>openml/config.py</code> <pre><code>def set_root_cache_directory(root_cache_directory: str | Path) -&gt; None:\n    \"\"\"Set module-wide base cache directory.\n\n    Sets the root cache directory, wherin the cache directories are\n    created to store content from different OpenML servers. For example,\n    by default, cached data for the standard OpenML.org server is stored\n    at ``root_cache_directory / org / openml / www``, and the general\n    pattern is ``root_cache_directory / top-level domain / second-level\n    domain / hostname``.\n\n    Parameters\n    ----------\n    root_cache_directory : string\n         Path to use as cache directory.\n\n    See Also\n    --------\n    get_cache_directory\n    \"\"\"\n    global _root_cache_directory  # noqa: PLW0603\n    _root_cache_directory = Path(root_cache_directory)\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":""},{"location":"reference/exceptions/#openml.exceptions.ObjectNotPublishedError","title":"<code>ObjectNotPublishedError</code>","text":"<p>               Bases: <code>PyOpenMLError</code></p> <p>Indicates an object has not been published yet.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class ObjectNotPublishedError(PyOpenMLError):\n    \"\"\"Indicates an object has not been published yet.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLCacheException","title":"<code>OpenMLCacheException</code>","text":"<p>               Bases: <code>PyOpenMLError</code></p> <p>Dataset / task etc not found in cache</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLCacheException(PyOpenMLError):  # noqa: N818\n    \"\"\"Dataset / task etc not found in cache\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLHashException","title":"<code>OpenMLHashException</code>","text":"<p>               Bases: <code>PyOpenMLError</code></p> <p>Locally computed hash is different than hash announced by the server.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLHashException(PyOpenMLError):  # noqa: N818\n    \"\"\"Locally computed hash is different than hash announced by the server.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLNotAuthorizedError","title":"<code>OpenMLNotAuthorizedError</code>","text":"<p>               Bases: <code>OpenMLServerError</code></p> <p>Indicates an authenticated user is not authorized to execute the requested action.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLNotAuthorizedError(OpenMLServerError):\n    \"\"\"Indicates an authenticated user is not authorized to execute the requested action.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLPrivateDatasetError","title":"<code>OpenMLPrivateDatasetError</code>","text":"<p>               Bases: <code>PyOpenMLError</code></p> <p>Exception thrown when the user has no rights to access the dataset.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLPrivateDatasetError(PyOpenMLError):\n    \"\"\"Exception thrown when the user has no rights to access the dataset.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLRunsExistError","title":"<code>OpenMLRunsExistError</code>","text":"<p>               Bases: <code>PyOpenMLError</code></p> <p>Indicates run(s) already exists on the server when they should not be duplicated.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLRunsExistError(PyOpenMLError):\n    \"\"\"Indicates run(s) already exists on the server when they should not be duplicated.\"\"\"\n\n    def __init__(self, run_ids: set[int], message: str) -&gt; None:\n        if len(run_ids) &lt; 1:\n            raise ValueError(\"Set of run ids must be non-empty.\")\n        self.run_ids = run_ids\n        super().__init__(message)\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLServerError","title":"<code>OpenMLServerError</code>","text":"<p>               Bases: <code>PyOpenMLError</code></p> <p>class for when something is really wrong on the server (result did not parse to dict), contains unparsed error.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLServerError(PyOpenMLError):\n    \"\"\"class for when something is really wrong on the server\n    (result did not parse to dict), contains unparsed error.\n    \"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLServerException","title":"<code>OpenMLServerException</code>","text":"<p>               Bases: <code>OpenMLServerError</code></p> <p>exception for when the result of the server was not 200 (e.g., listing call w/o results).</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLServerException(OpenMLServerError):  # noqa: N818\n    \"\"\"exception for when the result of the server was\n    not 200 (e.g., listing call w/o results).\n    \"\"\"\n\n    # Code needs to be optional to allow the exception to be picklable:\n    # https://stackoverflow.com/questions/16244923/how-to-make-a-custom-exception-class-with-multiple-init-args-pickleable  # noqa: E501\n    def __init__(self, message: str, code: int | None = None, url: str | None = None):\n        self.message = message\n        self.code = code\n        self.url = url\n        super().__init__(message)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.url} returned code {self.code}: {self.message}\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.OpenMLServerNoResult","title":"<code>OpenMLServerNoResult</code>","text":"<p>               Bases: <code>OpenMLServerException</code></p> <p>Exception for when the result of the server is empty.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class OpenMLServerNoResult(OpenMLServerException):\n    \"\"\"Exception for when the result of the server is empty.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#openml.exceptions.PyOpenMLError","title":"<code>PyOpenMLError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions in OpenML-Python.</p> Source code in <code>openml/exceptions.py</code> <pre><code>class PyOpenMLError(Exception):\n    \"\"\"Base class for all exceptions in OpenML-Python.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/testing/","title":"testing","text":""},{"location":"reference/testing/#openml.testing.CustomImputer","title":"<code>CustomImputer</code>","text":"<p>               Bases: <code>Imputer</code></p> <p>Duplicate class alias for sklearn's SimpleImputer</p> <p>Helps bypass the sklearn extension duplicate operation check</p> Source code in <code>openml/testing.py</code> <pre><code>class CustomImputer(SimpleImputer):\n    \"\"\"Duplicate class alias for sklearn's SimpleImputer\n\n    Helps bypass the sklearn extension duplicate operation check\n    \"\"\"\n</code></pre>"},{"location":"reference/testing/#openml.testing.TestBase","title":"<code>TestBase</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>Base class for tests</p> Note <p>Currently hard-codes a read-write key. Hopefully soon allows using a test server, not the production server.</p> Source code in <code>openml/testing.py</code> <pre><code>class TestBase(unittest.TestCase):\n    \"\"\"Base class for tests\n\n    Note\n    ----\n    Currently hard-codes a read-write key.\n    Hopefully soon allows using a test server, not the production server.\n    \"\"\"\n\n    # TODO: This could be made more explcit with a TypedDict instead of list[str | int]\n    publish_tracker: ClassVar[dict[str, list[str | int]]] = {\n        \"run\": [],\n        \"data\": [],\n        \"flow\": [],\n        \"task\": [],\n        \"study\": [],\n        \"user\": [],\n    }\n    flow_name_tracker: ClassVar[list[str]] = []\n    test_server = \"https://test.openml.org/api/v1/xml\"\n    # amueller's read/write key that he will throw away later\n    apikey = \"610344db6388d9ba34f6db45a3cf71de\"\n\n    # creating logger for tracking files uploaded to test server\n    logger = logging.getLogger(\"unit_tests_published_entities\")\n    logger.setLevel(logging.DEBUG)\n\n    def setUp(self, n_levels: int = 1, tmpdir_suffix: str = \"\") -&gt; None:\n        \"\"\"Setup variables and temporary directories.\n\n        In particular, this methods:\n\n        * creates a temporary working directory\n        * figures out a path to a few static test files\n        * set the default server to be the test server\n        * set a static API key for the test server\n        * increases the maximal number of retries\n\n        Parameters\n        ----------\n        n_levels : int\n            Number of nested directories the test is in. Necessary to resolve the path to the\n            ``files`` directory, which is located directly under the ``tests`` directory.\n        \"\"\"\n        # This cache directory is checked in to git to simulate a populated\n        # cache\n        self.maxDiff = None\n        abspath_this_file = Path(inspect.getfile(self.__class__)).absolute()\n        static_cache_dir = abspath_this_file.parent\n        for _ in range(n_levels):\n            static_cache_dir = static_cache_dir.parent.absolute()\n\n        content = os.listdir(static_cache_dir)\n        if \"files\" in content:\n            static_cache_dir = static_cache_dir / \"files\"\n        else:\n            raise ValueError(\n                f\"Cannot find test cache dir, expected it to be {static_cache_dir}!\",\n            )\n\n        self.static_cache_dir = static_cache_dir\n        self.cwd = Path.cwd()\n        workdir = Path(__file__).parent.absolute()\n        tmp_dir_name = self.id() + tmpdir_suffix\n        self.workdir = workdir / tmp_dir_name\n        shutil.rmtree(self.workdir, ignore_errors=True)\n\n        self.workdir.mkdir(exist_ok=True)\n        os.chdir(self.workdir)\n\n        self.cached = True\n        openml.config.apikey = TestBase.apikey\n        self.production_server = \"https://www.openml.org/api/v1/xml\"\n        openml.config.avoid_duplicate_runs = False\n        openml.config.set_root_cache_directory(str(self.workdir))\n\n        # Increase the number of retries to avoid spurious server failures\n        self.retry_policy = openml.config.retry_policy\n        self.connection_n_retries = openml.config.connection_n_retries\n        openml.config.set_retry_policy(\"robot\", n_retries=20)\n\n    def tearDown(self) -&gt; None:\n        \"\"\"Tear down the test\"\"\"\n        os.chdir(self.cwd)\n        try:\n            shutil.rmtree(self.workdir)\n        except PermissionError as e:\n            if os.name != \"nt\":\n                # one of the files may still be used by another process\n                raise e\n\n        openml.config.connection_n_retries = self.connection_n_retries\n        openml.config.retry_policy = self.retry_policy\n\n    @classmethod\n    def _mark_entity_for_removal(\n        cls,\n        entity_type: str,\n        entity_id: int,\n        entity_name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Static record of entities uploaded to test server\n\n        Dictionary of lists where the keys are 'entity_type'.\n        Each such dictionary is a list of integer IDs.\n        For entity_type='flow', each list element is a tuple\n        of the form (Flow ID, Flow Name).\n        \"\"\"\n        if entity_type not in TestBase.publish_tracker:\n            TestBase.publish_tracker[entity_type] = [entity_id]\n        else:\n            TestBase.publish_tracker[entity_type].append(entity_id)\n        if isinstance(entity_type, openml.flows.OpenMLFlow):\n            assert entity_name is not None\n            cls.flow_name_tracker.append(entity_name)\n\n    @classmethod\n    def _delete_entity_from_tracker(cls, entity_type: str, entity: int) -&gt; None:\n        \"\"\"Deletes entity records from the static file_tracker\n\n        Given an entity type and corresponding ID, deletes all entries, including\n        duplicate entries of the ID for the entity type.\n        \"\"\"\n        if entity_type in TestBase.publish_tracker:\n            # removes duplicate entries\n            TestBase.publish_tracker[entity_type] = list(set(TestBase.publish_tracker[entity_type]))\n            if entity_type == \"flow\":\n                delete_index = next(\n                    i\n                    for i, (id_, _) in enumerate(\n                        zip(TestBase.publish_tracker[entity_type], TestBase.flow_name_tracker),\n                    )\n                    if id_ == entity\n                )\n            else:\n                delete_index = next(\n                    i\n                    for i, id_ in enumerate(TestBase.publish_tracker[entity_type])\n                    if id_ == entity\n                )\n            TestBase.publish_tracker[entity_type].pop(delete_index)\n\n    def _get_sentinel(self, sentinel: str | None = None) -&gt; str:\n        if sentinel is None:\n            # Create a unique prefix for the flow. Necessary because the flow\n            # is identified by its name and external version online. Having a\n            # unique name allows us to publish the same flow in each test run.\n            md5 = hashlib.md5()  # noqa: S324\n            md5.update(str(time.time()).encode(\"utf-8\"))\n            md5.update(str(os.getpid()).encode(\"utf-8\"))\n            sentinel = md5.hexdigest()[:10]\n            sentinel = f\"TEST{sentinel}\"\n        return sentinel\n\n    def _add_sentinel_to_flow_name(\n        self,\n        flow: openml.flows.OpenMLFlow,\n        sentinel: str | None = None,\n    ) -&gt; tuple[openml.flows.OpenMLFlow, str]:\n        sentinel = self._get_sentinel(sentinel=sentinel)\n        flows_to_visit = []\n        flows_to_visit.append(flow)\n        while len(flows_to_visit) &gt; 0:\n            current_flow = flows_to_visit.pop()\n            current_flow.name = f\"{sentinel}{current_flow.name}\"\n            for subflow in current_flow.components.values():\n                flows_to_visit.append(subflow)\n\n        return flow, sentinel\n\n    def _check_dataset(self, dataset: dict[str, str | int]) -&gt; None:\n        _check_dataset(dataset)\n        assert isinstance(dataset, dict)\n        assert len(dataset) &gt;= 2\n        assert \"did\" in dataset\n        assert isinstance(dataset[\"did\"], int)\n        assert \"status\" in dataset\n        assert isinstance(dataset[\"status\"], str)\n        assert dataset[\"status\"] in [\"in_preparation\", \"active\", \"deactivated\"]\n\n    def _check_fold_timing_evaluations(  # noqa: PLR0913\n        self,\n        fold_evaluations: dict[str, dict[int, dict[int, float]]],\n        num_repeats: int,\n        num_folds: int,\n        *,\n        max_time_allowed: float = 60000.0,\n        task_type: TaskType = TaskType.SUPERVISED_CLASSIFICATION,\n        check_scores: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Checks whether the right timing measures are attached to the run\n        (before upload). Test is only performed for versions &gt;= Python3.3\n\n        In case of check_n_jobs(clf) == false, please do not perform this\n        check (check this condition outside of this function. )\n        default max_time_allowed (per fold, in milli seconds) = 1 minute,\n        quite pessimistic\n        \"\"\"\n        # a dict mapping from openml measure to a tuple with the minimum and\n        # maximum allowed value\n        check_measures = {\n            # should take at least one millisecond (?)\n            \"usercpu_time_millis_testing\": (0, max_time_allowed),\n            \"usercpu_time_millis_training\": (0, max_time_allowed),\n            \"usercpu_time_millis\": (0, max_time_allowed),\n            \"wall_clock_time_millis_training\": (0, max_time_allowed),\n            \"wall_clock_time_millis_testing\": (0, max_time_allowed),\n            \"wall_clock_time_millis\": (0, max_time_allowed),\n        }\n\n        if check_scores:\n            if task_type in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n                check_measures[\"predictive_accuracy\"] = (0, 1.0)\n            elif task_type == TaskType.SUPERVISED_REGRESSION:\n                check_measures[\"mean_absolute_error\"] = (0, float(\"inf\"))\n\n        assert isinstance(fold_evaluations, dict)\n        assert set(fold_evaluations.keys()) == set(check_measures.keys())\n\n        for measure in check_measures:\n            if measure in fold_evaluations:\n                num_rep_entrees = len(fold_evaluations[measure])\n                assert num_rep_entrees == num_repeats\n                min_val = check_measures[measure][0]\n                max_val = check_measures[measure][1]\n                for rep in range(num_rep_entrees):\n                    num_fold_entrees = len(fold_evaluations[measure][rep])\n                    assert num_fold_entrees == num_folds\n                    for fold in range(num_fold_entrees):\n                        evaluation = fold_evaluations[measure][rep][fold]\n                        assert isinstance(evaluation, float)\n                        assert evaluation &gt;= min_val\n                        assert evaluation &lt;= max_val\n</code></pre>"},{"location":"reference/testing/#openml.testing.TestBase.setUp","title":"<code>setUp(n_levels=1, tmpdir_suffix='')</code>","text":"<p>Setup variables and temporary directories.</p> <p>In particular, this methods:</p> <ul> <li>creates a temporary working directory</li> <li>figures out a path to a few static test files</li> <li>set the default server to be the test server</li> <li>set a static API key for the test server</li> <li>increases the maximal number of retries</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n_levels</code> <code>int</code> <p>Number of nested directories the test is in. Necessary to resolve the path to the <code>files</code> directory, which is located directly under the <code>tests</code> directory.</p> <code>1</code> Source code in <code>openml/testing.py</code> <pre><code>def setUp(self, n_levels: int = 1, tmpdir_suffix: str = \"\") -&gt; None:\n    \"\"\"Setup variables and temporary directories.\n\n    In particular, this methods:\n\n    * creates a temporary working directory\n    * figures out a path to a few static test files\n    * set the default server to be the test server\n    * set a static API key for the test server\n    * increases the maximal number of retries\n\n    Parameters\n    ----------\n    n_levels : int\n        Number of nested directories the test is in. Necessary to resolve the path to the\n        ``files`` directory, which is located directly under the ``tests`` directory.\n    \"\"\"\n    # This cache directory is checked in to git to simulate a populated\n    # cache\n    self.maxDiff = None\n    abspath_this_file = Path(inspect.getfile(self.__class__)).absolute()\n    static_cache_dir = abspath_this_file.parent\n    for _ in range(n_levels):\n        static_cache_dir = static_cache_dir.parent.absolute()\n\n    content = os.listdir(static_cache_dir)\n    if \"files\" in content:\n        static_cache_dir = static_cache_dir / \"files\"\n    else:\n        raise ValueError(\n            f\"Cannot find test cache dir, expected it to be {static_cache_dir}!\",\n        )\n\n    self.static_cache_dir = static_cache_dir\n    self.cwd = Path.cwd()\n    workdir = Path(__file__).parent.absolute()\n    tmp_dir_name = self.id() + tmpdir_suffix\n    self.workdir = workdir / tmp_dir_name\n    shutil.rmtree(self.workdir, ignore_errors=True)\n\n    self.workdir.mkdir(exist_ok=True)\n    os.chdir(self.workdir)\n\n    self.cached = True\n    openml.config.apikey = TestBase.apikey\n    self.production_server = \"https://www.openml.org/api/v1/xml\"\n    openml.config.avoid_duplicate_runs = False\n    openml.config.set_root_cache_directory(str(self.workdir))\n\n    # Increase the number of retries to avoid spurious server failures\n    self.retry_policy = openml.config.retry_policy\n    self.connection_n_retries = openml.config.connection_n_retries\n    openml.config.set_retry_policy(\"robot\", n_retries=20)\n</code></pre>"},{"location":"reference/testing/#openml.testing.TestBase.tearDown","title":"<code>tearDown()</code>","text":"<p>Tear down the test</p> Source code in <code>openml/testing.py</code> <pre><code>def tearDown(self) -&gt; None:\n    \"\"\"Tear down the test\"\"\"\n    os.chdir(self.cwd)\n    try:\n        shutil.rmtree(self.workdir)\n    except PermissionError as e:\n        if os.name != \"nt\":\n            # one of the files may still be used by another process\n            raise e\n\n    openml.config.connection_n_retries = self.connection_n_retries\n    openml.config.retry_policy = self.retry_policy\n</code></pre>"},{"location":"reference/testing/#openml.testing.check_task_existence","title":"<code>check_task_existence(task_type, dataset_id, target_name, **kwargs)</code>","text":"<p>Checks if any task with exists on test server that matches the meta data.</p> Parameter <p>task_type : openml.tasks.TaskType dataset_id : int target_name : str</p> Return <p>int, None</p> Source code in <code>openml/testing.py</code> <pre><code>def check_task_existence(\n    task_type: TaskType,\n    dataset_id: int,\n    target_name: str,\n    **kwargs: dict[str, str | int | dict[str, str | int | openml.tasks.TaskType]],\n) -&gt; int | None:\n    \"\"\"Checks if any task with exists on test server that matches the meta data.\n\n    Parameter\n    ---------\n    task_type : openml.tasks.TaskType\n    dataset_id : int\n    target_name : str\n\n    Return\n    ------\n    int, None\n    \"\"\"\n    return_val = None\n    tasks = openml.tasks.list_tasks(task_type=task_type)\n    if len(tasks) == 0:\n        return None\n    tasks = tasks.loc[tasks[\"did\"] == dataset_id]\n    if len(tasks) == 0:\n        return None\n    tasks = tasks.loc[tasks[\"target_feature\"] == target_name]\n    if len(tasks) == 0:\n        return None\n    task_match = []\n    for task_id in tasks[\"tid\"].to_list():\n        task_match.append(task_id)\n        try:\n            task = openml.tasks.get_task(task_id)\n        except OpenMLServerException:\n            # can fail if task_id deleted by another parallely run unit test\n            task_match.pop(-1)\n            return_val = None\n            continue\n        for k, v in kwargs.items():\n            if getattr(task, k) != v:\n                # even if one of the meta-data key mismatches, then task_id is not a match\n                task_match.pop(-1)\n                break\n        # if task_id is retained in the task_match list, it passed all meta key-value matches\n        if len(task_match) == 1:\n            return_val = task_id\n            break\n    if len(task_match) == 0:\n        return_val = None\n    return return_val\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#openml.utils.ProgressBar","title":"<code>ProgressBar</code>","text":"<p>               Bases: <code>ProgressType</code></p> <p>Progressbar for MinIO function's <code>progress</code> parameter.</p> Source code in <code>openml/utils.py</code> <pre><code>class ProgressBar(ProgressType):\n    \"\"\"Progressbar for MinIO function's `progress` parameter.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._object_name = \"\"\n        self._progress_bar: tqdm | None = None\n\n    def set_meta(self, object_name: str, total_length: int) -&gt; None:\n        \"\"\"Initializes the progress bar.\n\n        Parameters\n        ----------\n        object_name: str\n          Not used.\n\n        total_length: int\n          File size of the object in bytes.\n        \"\"\"\n        self._object_name = object_name\n        self._progress_bar = tqdm(total=total_length, unit_scale=True, unit=\"B\")\n\n    def update(self, length: int) -&gt; None:\n        \"\"\"Updates the progress bar.\n\n        Parameters\n        ----------\n        length: int\n          Number of bytes downloaded since last `update` call.\n        \"\"\"\n        if not self._progress_bar:\n            raise RuntimeError(\"Call `set_meta` before calling `update`.\")\n        self._progress_bar.update(length)\n        if self._progress_bar.total &lt;= self._progress_bar.n:\n            self._progress_bar.close()\n</code></pre>"},{"location":"reference/utils/#openml.utils.ProgressBar.set_meta","title":"<code>set_meta(object_name, total_length)</code>","text":"<p>Initializes the progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>Not used.</p> required <code>total_length</code> <code>int</code> <p>File size of the object in bytes.</p> required Source code in <code>openml/utils.py</code> <pre><code>def set_meta(self, object_name: str, total_length: int) -&gt; None:\n    \"\"\"Initializes the progress bar.\n\n    Parameters\n    ----------\n    object_name: str\n      Not used.\n\n    total_length: int\n      File size of the object in bytes.\n    \"\"\"\n    self._object_name = object_name\n    self._progress_bar = tqdm(total=total_length, unit_scale=True, unit=\"B\")\n</code></pre>"},{"location":"reference/utils/#openml.utils.ProgressBar.update","title":"<code>update(length)</code>","text":"<p>Updates the progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Number of bytes downloaded since last <code>update</code> call.</p> required Source code in <code>openml/utils.py</code> <pre><code>def update(self, length: int) -&gt; None:\n    \"\"\"Updates the progress bar.\n\n    Parameters\n    ----------\n    length: int\n      Number of bytes downloaded since last `update` call.\n    \"\"\"\n    if not self._progress_bar:\n        raise RuntimeError(\"Call `set_meta` before calling `update`.\")\n    self._progress_bar.update(length)\n    if self._progress_bar.total &lt;= self._progress_bar.n:\n        self._progress_bar.close()\n</code></pre>"},{"location":"reference/utils/#openml.utils.extract_xml_tags","title":"<code>extract_xml_tags(xml_tag_name, node, *, allow_none=True)</code>","text":"<p>Helper to extract xml tags from xmltodict.</p> <p>Parameters:</p> Name Type Description Default <code>xml_tag_name</code> <code>str</code> <p>Name of the xml tag to extract from the node.</p> required <code>node</code> <code>Mapping[str, Any]</code> <p>Node object returned by <code>xmltodict</code> from which <code>xml_tag_name</code> should be extracted.</p> required <code>allow_none</code> <code>bool</code> <p>If <code>False</code>, the tag needs to exist in the node. Will raise a <code>ValueError</code> if it does not.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> Source code in <code>openml/utils.py</code> <pre><code>def extract_xml_tags(\n    xml_tag_name: str,\n    node: Mapping[str, Any],\n    *,\n    allow_none: bool = True,\n) -&gt; Any | None:\n    \"\"\"Helper to extract xml tags from xmltodict.\n\n    Parameters\n    ----------\n    xml_tag_name : str\n        Name of the xml tag to extract from the node.\n\n    node : Mapping[str, Any]\n        Node object returned by ``xmltodict`` from which ``xml_tag_name``\n        should be extracted.\n\n    allow_none : bool\n        If ``False``, the tag needs to exist in the node. Will raise a\n        ``ValueError`` if it does not.\n\n    Returns\n    -------\n    object\n    \"\"\"\n    if xml_tag_name in node and node[xml_tag_name] is not None:\n        if isinstance(node[xml_tag_name], (dict, str)):\n            return [node[xml_tag_name]]\n        if isinstance(node[xml_tag_name], list):\n            return node[xml_tag_name]\n\n        raise ValueError(\"Received not string and non list as tag item\")\n\n    if allow_none:\n        return None\n\n    raise ValueError(f\"Could not find tag '{xml_tag_name}' in node '{node!s}'\")\n</code></pre>"},{"location":"reference/datasets/","title":"datasets","text":""},{"location":"reference/datasets/#openml.datasets.OpenMLDataFeature","title":"<code>OpenMLDataFeature</code>","text":"<p>Data Feature (a.k.a. Attribute) object.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of this feature</p> required <code>name</code> <code>str</code> <p>Name of the feature</p> required <code>data_type</code> <code>str</code> <p>can be nominal, numeric, string, date (corresponds to arff)</p> required <code>nominal_values</code> <code>list(str)</code> <p>list of the possible values, in case of nominal attribute</p> required <code>number_missing_values</code> <code>int</code> <p>Number of rows that have a missing value for this feature.</p> required <code>ontologies</code> <code>list(str)</code> <p>list of ontologies attached to this feature. An ontology describes the concept that are described in a feature. An ontology is defined by an URL where the information is provided.</p> <code>None</code> Source code in <code>openml/datasets/data_feature.py</code> <pre><code>class OpenMLDataFeature:\n    \"\"\"\n    Data Feature (a.k.a. Attribute) object.\n\n    Parameters\n    ----------\n    index : int\n        The index of this feature\n    name : str\n        Name of the feature\n    data_type : str\n        can be nominal, numeric, string, date (corresponds to arff)\n    nominal_values : list(str)\n        list of the possible values, in case of nominal attribute\n    number_missing_values : int\n        Number of rows that have a missing value for this feature.\n    ontologies : list(str)\n        list of ontologies attached to this feature. An ontology describes the\n        concept that are described in a feature. An ontology is defined by an\n        URL where the information is provided.\n    \"\"\"\n\n    LEGAL_DATA_TYPES: ClassVar[Sequence[str]] = [\"nominal\", \"numeric\", \"string\", \"date\"]\n\n    def __init__(  # noqa: PLR0913\n        self,\n        index: int,\n        name: str,\n        data_type: str,\n        nominal_values: list[str],\n        number_missing_values: int,\n        ontologies: list[str] | None = None,\n    ):\n        if not isinstance(index, int):\n            raise TypeError(f\"Index must be `int` but is {type(index)}\")\n\n        if data_type not in self.LEGAL_DATA_TYPES:\n            raise ValueError(\n                f\"data type should be in {self.LEGAL_DATA_TYPES!s}, found: {data_type}\",\n            )\n\n        if data_type == \"nominal\":\n            if nominal_values is None:\n                raise TypeError(\n                    \"Dataset features require attribute `nominal_values` for nominal \"\n                    \"feature type.\",\n                )\n\n            if not isinstance(nominal_values, list):\n                raise TypeError(\n                    \"Argument `nominal_values` is of wrong datatype, should be list, \"\n                    f\"but is {type(nominal_values)}\",\n                )\n        elif nominal_values is not None:\n            raise TypeError(\"Argument `nominal_values` must be None for non-nominal feature.\")\n\n        if not isinstance(number_missing_values, int):\n            msg = f\"number_missing_values must be int but is {type(number_missing_values)}\"\n            raise TypeError(msg)\n\n        self.index = index\n        self.name = str(name)\n        self.data_type = str(data_type)\n        self.nominal_values = nominal_values\n        self.number_missing_values = number_missing_values\n        self.ontologies = ontologies\n\n    def __repr__(self) -&gt; str:\n        return \"[%d - %s (%s)]\" % (self.index, self.name, self.data_type)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, OpenMLDataFeature) and self.__dict__ == other.__dict__\n\n    def _repr_pretty_(self, pp: pretty.PrettyPrinter, cycle: bool) -&gt; None:  # noqa: FBT001, ARG002\n        pp.text(str(self))\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset","title":"<code>OpenMLDataset</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>Dataset object.</p> <p>Allows fetching and uploading datasets to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> required <code>data_format</code> <code>str</code> <p>Format of the dataset which can be either 'arff' or 'sparse_arff'.</p> <code>'arff'</code> <code>cache_format</code> <code>str</code> <p>Format for caching the dataset which can be either 'feather' or 'pickle'.</p> <code>'pickle'</code> <code>dataset_id</code> <code>int</code> <p>Id autogenerated by the server.</p> <code>None</code> <code>version</code> <code>int</code> <p>Version of this dataset. '1' for original version. Auto-incremented by server.</p> <code>None</code> <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> <code>None</code> <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> <code>None</code> <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> <code>None</code> <code>upload_date</code> <code>str</code> <p>The date-time when the dataset was uploaded, generated by server.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> <code>None</code> <code>licence</code> <code>str</code> <p>License of the data.</p> <code>None</code> <code>url</code> <code>str</code> <p>Valid URL, points to actual data file. The file can be on the OpenML server or another dataset repository.</p> <code>None</code> <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset.</p> <code>None</code> <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes.</p> <code>None</code> <code>version_label</code> <code>str</code> <p>Version label provided by user. Can be a date, hash, or some other type of id.</p> <code>None</code> <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> <code>None</code> <code>tag</code> <code>str</code> <p>Tags, describing the algorithms.</p> <code>None</code> <code>visibility</code> <code>str</code> <p>Who can see the dataset. Typical values: 'Everyone','All my friends','Only me'. Can also be any of the user's circles.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <code>update_comment</code> <code>str</code> <p>An explanation for when the dataset is uploaded.</p> <code>None</code> <code>md5_checksum</code> <code>str</code> <p>MD5 checksum to check if the dataset is downloaded without corruption.</p> <code>None</code> <code>data_file</code> <code>str</code> <p>Path to where the dataset is located.</p> <code>None</code> <code>features_file</code> <code>dict</code> <p>A dictionary of dataset features, which maps a feature index to a OpenMLDataFeature.</p> <code>None</code> <code>qualities_file</code> <code>dict</code> <p>A dictionary of dataset qualities, which maps a quality name to a quality value.</p> <code>None</code> <code>dataset</code> <code>str | None</code> <p>Serialized arff dataset string.</p> <code>None</code> <code>parquet_url</code> <code>str | None</code> <p>This is the URL to the storage location where the dataset files are hosted. This can be a MinIO bucket URL. If specified, the data will be accessed from this URL when reading the files.</p> <code>None</code> <code>parquet_file</code> <code>str | None</code> <p>Path to the local file.</p> <code>None</code> Source code in <code>openml/datasets/dataset.py</code> <pre><code>class OpenMLDataset(OpenMLBase):\n    \"\"\"Dataset object.\n\n    Allows fetching and uploading datasets to OpenML.\n\n    Parameters\n    ----------\n    name : str\n        Name of the dataset.\n    description : str\n        Description of the dataset.\n    data_format : str\n        Format of the dataset which can be either 'arff' or 'sparse_arff'.\n    cache_format : str\n        Format for caching the dataset which can be either 'feather' or 'pickle'.\n    dataset_id : int, optional\n        Id autogenerated by the server.\n    version : int, optional\n        Version of this dataset. '1' for original version.\n        Auto-incremented by server.\n    creator : str, optional\n        The person who created the dataset.\n    contributor : str, optional\n        People who contributed to the current version of the dataset.\n    collection_date : str, optional\n        The date the data was originally collected, given by the uploader.\n    upload_date : str, optional\n        The date-time when the dataset was uploaded, generated by server.\n    language : str, optional\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    licence : str, optional\n        License of the data.\n    url : str, optional\n        Valid URL, points to actual data file.\n        The file can be on the OpenML server or another dataset repository.\n    default_target_attribute : str, optional\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column,\n        if present in the dataset.\n    ignore_attribute : str | list, optional\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n    version_label : str, optional\n        Version label provided by user.\n        Can be a date, hash, or some other type of id.\n    citation : str, optional\n        Reference(s) that should be cited when building on this data.\n    tag : str, optional\n        Tags, describing the algorithms.\n    visibility : str, optional\n        Who can see the dataset.\n        Typical values: 'Everyone','All my friends','Only me'.\n        Can also be any of the user's circles.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n    update_comment : str, optional\n        An explanation for when the dataset is uploaded.\n    md5_checksum : str, optional\n        MD5 checksum to check if the dataset is downloaded without corruption.\n    data_file : str, optional\n        Path to where the dataset is located.\n    features_file : dict, optional\n        A dictionary of dataset features,\n        which maps a feature index to a OpenMLDataFeature.\n    qualities_file : dict, optional\n        A dictionary of dataset qualities,\n        which maps a quality name to a quality value.\n    dataset: string, optional\n        Serialized arff dataset string.\n    parquet_url: string, optional\n        This is the URL to the storage location where the dataset files are hosted.\n        This can be a MinIO bucket URL. If specified, the data will be accessed\n        from this URL when reading the files.\n    parquet_file: string, optional\n        Path to the local file.\n    \"\"\"\n\n    def __init__(  # noqa: C901, PLR0912, PLR0913, PLR0915\n        self,\n        name: str,\n        description: str | None,\n        data_format: Literal[\"arff\", \"sparse_arff\"] = \"arff\",\n        cache_format: Literal[\"feather\", \"pickle\"] = \"pickle\",\n        dataset_id: int | None = None,\n        version: int | None = None,\n        creator: str | None = None,\n        contributor: str | None = None,\n        collection_date: str | None = None,\n        upload_date: str | None = None,\n        language: str | None = None,\n        licence: str | None = None,\n        url: str | None = None,\n        default_target_attribute: str | None = None,\n        row_id_attribute: str | None = None,\n        ignore_attribute: str | list[str] | None = None,\n        version_label: str | None = None,\n        citation: str | None = None,\n        tag: str | None = None,\n        visibility: str | None = None,\n        original_data_url: str | None = None,\n        paper_url: str | None = None,\n        update_comment: str | None = None,\n        md5_checksum: str | None = None,\n        data_file: str | None = None,\n        features_file: str | None = None,\n        qualities_file: str | None = None,\n        dataset: str | None = None,\n        parquet_url: str | None = None,\n        parquet_file: str | None = None,\n    ):\n        if cache_format not in [\"feather\", \"pickle\"]:\n            raise ValueError(\n                \"cache_format must be one of 'feather' or 'pickle. \"\n                f\"Invalid format specified: {cache_format}\",\n            )\n\n        def find_invalid_characters(string: str, pattern: str) -&gt; str:\n            invalid_chars = set()\n            regex = re.compile(pattern)\n            for char in string:\n                if not regex.match(char):\n                    invalid_chars.add(char)\n            return \",\".join(\n                [f\"'{char}'\" if char != \"'\" else f'\"{char}\"' for char in invalid_chars],\n            )\n\n        if dataset_id is None:\n            pattern = \"^[\\x00-\\x7f]*$\"\n            if description and not re.match(pattern, description):\n                # not basiclatin (XSD complains)\n                invalid_characters = find_invalid_characters(description, pattern)\n                raise ValueError(\n                    f\"Invalid symbols {invalid_characters} in description: {description}\",\n                )\n            pattern = \"^[\\x00-\\x7f]*$\"\n            if citation and not re.match(pattern, citation):\n                # not basiclatin (XSD complains)\n                invalid_characters = find_invalid_characters(citation, pattern)\n                raise ValueError(\n                    f\"Invalid symbols {invalid_characters} in citation: {citation}\",\n                )\n            pattern = \"^[a-zA-Z0-9_\\\\-\\\\.\\\\(\\\\),]+$\"\n            if not re.match(pattern, name):\n                # regex given by server in error message\n                invalid_characters = find_invalid_characters(name, pattern)\n                raise ValueError(f\"Invalid symbols {invalid_characters} in name: {name}\")\n\n        self.ignore_attribute: list[str] | None = None\n        if isinstance(ignore_attribute, str):\n            self.ignore_attribute = [ignore_attribute]\n        elif isinstance(ignore_attribute, list) or ignore_attribute is None:\n            self.ignore_attribute = ignore_attribute\n        else:\n            raise ValueError(\"Wrong data type for ignore_attribute. Should be list.\")\n\n        # TODO add function to check if the name is casual_string128\n        # Attributes received by querying the RESTful API\n        self.dataset_id = int(dataset_id) if dataset_id is not None else None\n        self.name = name\n        self.version = int(version) if version is not None else None\n        self.description = description\n        self.cache_format = cache_format\n        # Has to be called format, otherwise there will be an XML upload error\n        self.format = data_format\n        self.creator = creator\n        self.contributor = contributor\n        self.collection_date = collection_date\n        self.upload_date = upload_date\n        self.language = language\n        self.licence = licence\n        self.url = url\n        self.default_target_attribute = default_target_attribute\n        self.row_id_attribute = row_id_attribute\n\n        self.version_label = version_label\n        self.citation = citation\n        self.tag = tag\n        self.visibility = visibility\n        self.original_data_url = original_data_url\n        self.paper_url = paper_url\n        self.update_comment = update_comment\n        self.md5_checksum = md5_checksum\n        self.data_file = data_file\n        self.parquet_file = parquet_file\n        self._dataset = dataset\n        self._parquet_url = parquet_url\n\n        self._features: dict[int, OpenMLDataFeature] | None = None\n        self._qualities: dict[str, float] | None = None\n        self._no_qualities_found = False\n\n        if features_file is not None:\n            self._features = _read_features(Path(features_file))\n\n        # \"\" was the old default value by `get_dataset` and maybe still used by some\n        if qualities_file == \"\":\n            # TODO(0.15): to switch to \"qualities_file is not None\" below and remove warning\n            warnings.warn(\n                \"Starting from Version 0.15 `qualities_file` must be None and not an empty string \"\n                \"to avoid reading the qualities from file. Set `qualities_file` to None to avoid \"\n                \"this warning.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n            qualities_file = None\n\n        if qualities_file is not None:\n            self._qualities = _read_qualities(Path(qualities_file))\n\n        if data_file is not None:\n            data_pickle, data_feather, feather_attribute = self._compressed_cache_file_paths(\n                Path(data_file)\n            )\n            self.data_pickle_file = data_pickle if Path(data_pickle).exists() else None\n            self.data_feather_file = data_feather if Path(data_feather).exists() else None\n            self.feather_attribute_file = feather_attribute if Path(feather_attribute) else None\n        else:\n            self.data_pickle_file = None\n            self.data_feather_file = None\n            self.feather_attribute_file = None\n\n    @property\n    def features(self) -&gt; dict[int, OpenMLDataFeature]:\n        \"\"\"Get the features of this dataset.\"\"\"\n        if self._features is None:\n            # TODO(eddiebergman): These should return a value so we can set it to be not None\n            self._load_features()\n\n        assert self._features is not None\n        return self._features\n\n    @property\n    def qualities(self) -&gt; dict[str, float] | None:\n        \"\"\"Get the qualities of this dataset.\"\"\"\n        # TODO(eddiebergman): Better docstring, I don't know what qualities means\n\n        # We have to check `_no_qualities_found` as there might not be qualities for a dataset\n        if self._qualities is None and (not self._no_qualities_found):\n            self._load_qualities()\n\n        return self._qualities\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Get the dataset numeric id.\"\"\"\n        return self.dataset_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | None]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        # Obtain number of features in accordance with lazy loading.\n        n_features: int | None = None\n        if self._qualities is not None and self._qualities[\"NumberOfFeatures\"] is not None:\n            n_features = int(self._qualities[\"NumberOfFeatures\"])\n        elif self._features is not None:\n            n_features = len(self._features)\n\n        fields: dict[str, int | str | None] = {\n            \"Name\": self.name,\n            \"Version\": self.version,\n            \"Format\": self.format,\n            \"Licence\": self.licence,\n            \"Download URL\": self.url,\n            \"Data file\": str(self.data_file) if self.data_file is not None else None,\n            \"Pickle file\": (\n                str(self.data_pickle_file) if self.data_pickle_file is not None else None\n            ),\n            \"# of features\": n_features,\n        }\n        if self.upload_date is not None:\n            fields[\"Upload Date\"] = self.upload_date.replace(\"T\", \" \")\n        if self.dataset_id is not None:\n            fields[\"OpenML URL\"] = self.openml_url\n        if self._qualities is not None and self._qualities[\"NumberOfInstances\"] is not None:\n            fields[\"# of instances\"] = int(self._qualities[\"NumberOfInstances\"])\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Name\",\n            \"Version\",\n            \"Format\",\n            \"Upload Date\",\n            \"Licence\",\n            \"Download URL\",\n            \"OpenML URL\",\n            \"Data File\",\n            \"Pickle File\",\n            \"# of features\",\n            \"# of instances\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, OpenMLDataset):\n            return False\n\n        server_fields = {\n            \"dataset_id\",\n            \"version\",\n            \"upload_date\",\n            \"url\",\n            \"_parquet_url\",\n            \"dataset\",\n            \"data_file\",\n            \"format\",\n            \"cache_format\",\n        }\n\n        cache_fields = {\n            \"_dataset\",\n            \"data_file\",\n            \"data_pickle_file\",\n            \"data_feather_file\",\n            \"feather_attribute_file\",\n            \"parquet_file\",\n        }\n\n        # check that common keys and values are identical\n        ignore_fields = server_fields | cache_fields\n        self_keys = set(self.__dict__.keys()) - ignore_fields\n        other_keys = set(other.__dict__.keys()) - ignore_fields\n        return self_keys == other_keys and all(\n            self.__dict__[key] == other.__dict__[key] for key in self_keys\n        )\n\n    def _download_data(self) -&gt; None:\n        \"\"\"Download ARFF data file to standard cache directory. Set `self.data_file`.\"\"\"\n        # import required here to avoid circular import.\n        from .functions import _get_dataset_arff, _get_dataset_parquet\n\n        skip_parquet = os.environ.get(OPENML_SKIP_PARQUET_ENV_VAR, \"false\").casefold() == \"true\"\n        if self._parquet_url is not None and not skip_parquet:\n            parquet_file = _get_dataset_parquet(self)\n            self.parquet_file = None if parquet_file is None else str(parquet_file)\n        if self.parquet_file is None:\n            self.data_file = str(_get_dataset_arff(self))\n\n    def _get_arff(self, format: str) -&gt; dict:  # noqa: A002\n        \"\"\"Read ARFF file and return decoded arff.\n\n        Reads the file referenced in self.data_file.\n\n        Parameters\n        ----------\n        format : str\n            Format of the ARFF file.\n            Must be one of 'arff' or 'sparse_arff' or a string that will be either of those\n            when converted to lower case.\n\n\n\n        Returns\n        -------\n        dict\n            Decoded arff.\n\n        \"\"\"\n        # TODO: add a partial read method which only returns the attribute\n        # headers of the corresponding .arff file!\n        import struct\n\n        filename = self.data_file\n        assert filename is not None\n        filepath = Path(filename)\n\n        bits = 8 * struct.calcsize(\"P\")\n\n        # Files can be considered too large on a 32-bit system,\n        # if it exceeds 120mb (slightly more than covtype dataset size)\n        # This number is somewhat arbitrary.\n        if bits != 64:\n            MB_120 = 120_000_000\n            file_size = filepath.stat().st_size\n            if file_size &gt; MB_120:\n                raise NotImplementedError(\n                    f\"File {filename} too big for {file_size}-bit system ({bits} bytes).\",\n                )\n\n        if format.lower() == \"arff\":\n            return_type = arff.DENSE\n        elif format.lower() == \"sparse_arff\":\n            return_type = arff.COO\n        else:\n            raise ValueError(f\"Unknown data format {format}\")\n\n        def decode_arff(fh: Any) -&gt; dict:\n            decoder = arff.ArffDecoder()\n            return decoder.decode(fh, encode_nominal=True, return_type=return_type)  # type: ignore\n\n        if filepath.suffix.endswith(\".gz\"):\n            with gzip.open(filename) as zipfile:\n                return decode_arff(zipfile)\n        else:\n            with filepath.open(encoding=\"utf8\") as fh:\n                return decode_arff(fh)\n\n    def _parse_data_from_arff(  # noqa: C901, PLR0912, PLR0915\n        self,\n        arff_file_path: Path,\n    ) -&gt; tuple[pd.DataFrame | scipy.sparse.csr_matrix, list[bool], list[str]]:\n        \"\"\"Parse all required data from arff file.\n\n        Parameters\n        ----------\n        arff_file_path : str\n            Path to the file on disk.\n\n        Returns\n        -------\n        Tuple[Union[pd.DataFrame, scipy.sparse.csr_matrix], List[bool], List[str]]\n            DataFrame or csr_matrix: dataset\n            List[bool]: List indicating which columns contain categorical variables.\n            List[str]: List of column names.\n        \"\"\"\n        try:\n            data = self._get_arff(self.format)\n        except OSError as e:\n            logger.critical(\n                f\"Please check that the data file {arff_file_path} is there and can be read.\",\n            )\n            raise e\n\n        ARFF_DTYPES_TO_PD_DTYPE = {\n            \"INTEGER\": \"integer\",\n            \"REAL\": \"floating\",\n            \"NUMERIC\": \"floating\",\n            \"STRING\": \"string\",\n        }\n        attribute_dtype = {}\n        attribute_names = []\n        categories_names = {}\n        categorical = []\n        for name, type_ in data[\"attributes\"]:\n            # if the feature is nominal and a sparse matrix is\n            # requested, the categories need to be numeric\n            if isinstance(type_, list) and self.format.lower() == \"sparse_arff\":\n                try:\n                    # checks if the strings which should be the class labels\n                    # can be encoded into integers\n                    pd.factorize(type_)[0]\n                except ValueError as e:\n                    raise ValueError(\n                        \"Categorical data needs to be numeric when using sparse ARFF.\"\n                    ) from e\n\n            # string can only be supported with pandas DataFrame\n            elif type_ == \"STRING\" and self.format.lower() == \"sparse_arff\":\n                raise ValueError(\"Dataset containing strings is not supported with sparse ARFF.\")\n\n            # infer the dtype from the ARFF header\n            if isinstance(type_, list):\n                categorical.append(True)\n                categories_names[name] = type_\n                if len(type_) == 2:\n                    type_norm = [cat.lower().capitalize() for cat in type_]\n                    if {\"True\", \"False\"} == set(type_norm):\n                        categories_names[name] = [cat == \"True\" for cat in type_norm]\n                        attribute_dtype[name] = \"boolean\"\n                    else:\n                        attribute_dtype[name] = \"categorical\"\n                else:\n                    attribute_dtype[name] = \"categorical\"\n            else:\n                categorical.append(False)\n                attribute_dtype[name] = ARFF_DTYPES_TO_PD_DTYPE[type_]\n            attribute_names.append(name)\n\n        if self.format.lower() == \"sparse_arff\":\n            X = data[\"data\"]\n            X_shape = (max(X[1]) + 1, max(X[2]) + 1)\n            X = scipy.sparse.coo_matrix((X[0], (X[1], X[2])), shape=X_shape, dtype=np.float32)\n            X = X.tocsr()\n        elif self.format.lower() == \"arff\":\n            X = pd.DataFrame(data[\"data\"], columns=attribute_names)\n\n            col = []\n            for column_name in X.columns:\n                if attribute_dtype[column_name] in (\"categorical\", \"boolean\"):\n                    categories = self._unpack_categories(\n                        X[column_name],  # type: ignore\n                        categories_names[column_name],\n                    )\n                    col.append(categories)\n                elif attribute_dtype[column_name] in (\"floating\", \"integer\"):\n                    X_col = X[column_name]\n                    if X_col.min() &gt;= 0 and X_col.max() &lt;= 255:\n                        try:\n                            X_col_uint = X_col.astype(\"uint8\")\n                            if (X_col == X_col_uint).all():\n                                col.append(X_col_uint)\n                                continue\n                        except ValueError:\n                            pass\n                    col.append(X[column_name])\n                else:\n                    col.append(X[column_name])\n            X = pd.concat(col, axis=1)\n        else:\n            raise ValueError(f\"Dataset format '{self.format}' is not a valid format.\")\n\n        return X, categorical, attribute_names  # type: ignore\n\n    def _compressed_cache_file_paths(self, data_file: Path) -&gt; tuple[Path, Path, Path]:\n        data_pickle_file = data_file.with_suffix(\".pkl.py3\")\n        data_feather_file = data_file.with_suffix(\".feather\")\n        feather_attribute_file = data_file.with_suffix(\".feather.attributes.pkl.py3\")\n        return data_pickle_file, data_feather_file, feather_attribute_file\n\n    def _cache_compressed_file_from_file(\n        self,\n        data_file: Path,\n    ) -&gt; tuple[pd.DataFrame | scipy.sparse.csr_matrix, list[bool], list[str]]:\n        \"\"\"Store data from the local file in compressed format.\n\n        If a local parquet file is present it will be used instead of the arff file.\n        Sets cache_format to 'pickle' if data is sparse.\n        \"\"\"\n        (\n            data_pickle_file,\n            data_feather_file,\n            feather_attribute_file,\n        ) = self._compressed_cache_file_paths(data_file)\n\n        attribute_names, categorical, data = self._parse_data_from_file(data_file)\n\n        # Feather format does not work for sparse datasets, so we use pickle for sparse datasets\n        if scipy.sparse.issparse(data):\n            self.cache_format = \"pickle\"\n\n        logger.info(f\"{self.cache_format} write {self.name}\")\n        if self.cache_format == \"feather\":\n            assert isinstance(data, pd.DataFrame)\n\n            data.to_feather(data_feather_file)\n            with open(feather_attribute_file, \"wb\") as fh:  # noqa: PTH123\n                pickle.dump((categorical, attribute_names), fh, pickle.HIGHEST_PROTOCOL)\n            self.data_feather_file = data_feather_file\n            self.feather_attribute_file = feather_attribute_file\n\n        else:\n            with open(data_pickle_file, \"wb\") as fh:  # noqa: PTH123\n                pickle.dump((data, categorical, attribute_names), fh, pickle.HIGHEST_PROTOCOL)\n            self.data_pickle_file = data_pickle_file\n\n        data_file = data_pickle_file if self.cache_format == \"pickle\" else data_feather_file\n        logger.debug(f\"Saved dataset {int(self.dataset_id or -1)}: {self.name} to file {data_file}\")\n\n        return data, categorical, attribute_names\n\n    def _parse_data_from_file(\n        self,\n        data_file: Path,\n    ) -&gt; tuple[list[str], list[bool], pd.DataFrame | scipy.sparse.csr_matrix]:\n        if data_file.suffix == \".arff\":\n            data, categorical, attribute_names = self._parse_data_from_arff(data_file)\n        elif data_file.suffix == \".pq\":\n            attribute_names, categorical, data = self._parse_data_from_pq(data_file)\n        else:\n            raise ValueError(f\"Unknown file type for file '{data_file}'.\")\n\n        return attribute_names, categorical, data\n\n    def _parse_data_from_pq(self, data_file: Path) -&gt; tuple[list[str], list[bool], pd.DataFrame]:\n        try:\n            data = pd.read_parquet(data_file)\n        except Exception as e:\n            raise Exception(f\"File: {data_file}\") from e\n        categorical = [data[c].dtype.name == \"category\" for c in data.columns]\n        attribute_names = list(data.columns)\n        return attribute_names, categorical, data\n\n    def _load_data(self) -&gt; tuple[pd.DataFrame, list[bool], list[str]]:  # noqa: PLR0912, C901, PLR0915\n        \"\"\"Load data from compressed format or arff. Download data if not present on disk.\"\"\"\n        need_to_create_pickle = self.cache_format == \"pickle\" and self.data_pickle_file is None\n        need_to_create_feather = self.cache_format == \"feather\" and self.data_feather_file is None\n\n        if need_to_create_pickle or need_to_create_feather:\n            if self.data_file is None:\n                self._download_data()\n\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n            data, cats, attrs = self._cache_compressed_file_from_file(Path(file_to_load))\n            return _ensure_dataframe(data, attrs), cats, attrs\n\n        # helper variable to help identify where errors occur\n        fpath = self.data_feather_file if self.cache_format == \"feather\" else self.data_pickle_file\n        logger.info(f\"{self.cache_format} load data {self.name}\")\n        try:\n            if self.cache_format == \"feather\":\n                assert self.data_feather_file is not None\n                assert self.feather_attribute_file is not None\n\n                data = pd.read_feather(self.data_feather_file)\n                fpath = self.feather_attribute_file\n                with self.feather_attribute_file.open(\"rb\") as fh:\n                    categorical, attribute_names = pickle.load(fh)  # noqa: S301\n            else:\n                assert self.data_pickle_file is not None\n                with self.data_pickle_file.open(\"rb\") as fh:\n                    data, categorical, attribute_names = pickle.load(fh)  # noqa: S301\n\n        except FileNotFoundError as e:\n            raise ValueError(\n                f\"Cannot find file for dataset {self.name} at location '{fpath}'.\"\n            ) from e\n        except (EOFError, ModuleNotFoundError, ValueError, AttributeError) as e:\n            error_message = getattr(e, \"message\", e.args[0])\n            hint = \"\"\n\n            if isinstance(e, EOFError):\n                readable_error = \"Detected a corrupt cache file\"\n            elif isinstance(e, (ModuleNotFoundError, AttributeError)):\n                readable_error = \"Detected likely dependency issues\"\n                hint = (\n                    \"This can happen if the cache was constructed with a different pandas version \"\n                    \"than the one that is used to load the data. See also \"\n                )\n                if isinstance(e, ModuleNotFoundError):\n                    hint += \"https://github.com/openml/openml-python/issues/918. \"\n                elif isinstance(e, AttributeError):\n                    hint += \"https://github.com/openml/openml-python/pull/1121. \"\n\n            elif isinstance(e, ValueError) and \"unsupported pickle protocol\" in e.args[0]:\n                readable_error = \"Encountered unsupported pickle protocol\"\n            else:\n                raise e\n\n            logger.warning(\n                f\"{readable_error} when loading dataset {self.id} from '{fpath}'. \"\n                f\"{hint}\"\n                f\"Error message was: {error_message}. \"\n                \"We will continue loading data from the arff-file, \"\n                \"but this will be much slower for big datasets. \"\n                \"Please manually delete the cache file if you want OpenML-Python \"\n                \"to attempt to reconstruct it.\",\n            )\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n            attr, cat, df = self._parse_data_from_file(Path(file_to_load))\n            return _ensure_dataframe(df), cat, attr\n\n        data_up_to_date = isinstance(data, pd.DataFrame) or scipy.sparse.issparse(data)\n        if self.cache_format == \"pickle\" and not data_up_to_date:\n            logger.info(\"Updating outdated pickle file.\")\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n\n            data, cats, attrs = self._cache_compressed_file_from_file(Path(file_to_load))\n\n        return _ensure_dataframe(data, attribute_names), categorical, attribute_names\n\n    @staticmethod\n    def _unpack_categories(series: pd.Series, categories: list) -&gt; pd.Series:\n        # nan-likes can not be explicitly specified as a category\n        def valid_category(cat: Any) -&gt; bool:\n            return isinstance(cat, str) or (cat is not None and not np.isnan(cat))\n\n        filtered_categories = [c for c in categories if valid_category(c)]\n        col = []\n        for x in series:\n            try:\n                col.append(categories[int(x)])\n            except (TypeError, ValueError):\n                col.append(np.nan)\n\n        # We require two lines to create a series of categories as detailed here:\n        # https://pandas.pydata.org/pandas-docs/version/0.24/user_guide/categorical.html#series-creation\n        raw_cat = pd.Categorical(col, ordered=True, categories=filtered_categories)\n        return pd.Series(raw_cat, index=series.index, name=series.name)\n\n    def get_data(  # noqa: C901\n        self,\n        target: list[str] | str | None = None,\n        include_row_id: bool = False,  # noqa: FBT001, FBT002\n        include_ignore_attribute: bool = False,  # noqa: FBT001, FBT002\n    ) -&gt; tuple[pd.DataFrame, pd.Series | None, list[bool], list[str]]:\n        \"\"\"Returns dataset content as dataframes.\n\n        Parameters\n        ----------\n        target : string, List[str] or None (default=None)\n            Name of target column to separate from the data.\n            Splitting multiple columns is currently not supported.\n        include_row_id : boolean (default=False)\n            Whether to include row ids in the returned dataset.\n        include_ignore_attribute : boolean (default=False)\n            Whether to include columns that are marked as \"ignore\"\n            on the server in the dataset.\n\n\n        Returns\n        -------\n        X : dataframe, shape (n_samples, n_columns)\n            Dataset, may have sparse dtypes in the columns if required.\n        y : pd.Series, shape (n_samples, ) or None\n            Target column\n        categorical_indicator : list[bool]\n            Mask that indicate categorical features.\n        attribute_names : list[str]\n            List of attribute names.\n        \"\"\"\n        data, categorical_mask, attribute_names = self._load_data()\n\n        to_exclude = []\n        if not include_row_id and self.row_id_attribute is not None:\n            if isinstance(self.row_id_attribute, str):\n                to_exclude.append(self.row_id_attribute)\n            elif isinstance(self.row_id_attribute, Iterable):\n                to_exclude.extend(self.row_id_attribute)\n\n        if not include_ignore_attribute and self.ignore_attribute is not None:\n            if isinstance(self.ignore_attribute, str):\n                to_exclude.append(self.ignore_attribute)\n            elif isinstance(self.ignore_attribute, Iterable):\n                to_exclude.extend(self.ignore_attribute)\n\n        if len(to_exclude) &gt; 0:\n            logger.info(f\"Going to remove the following attributes: {to_exclude}\")\n            keep = np.array([column not in to_exclude for column in attribute_names])\n            data = data.drop(columns=to_exclude)\n            categorical_mask = [cat for cat, k in zip(categorical_mask, keep) if k]\n            attribute_names = [att for att, k in zip(attribute_names, keep) if k]\n\n        if target is None:\n            return data, None, categorical_mask, attribute_names\n\n        if isinstance(target, str):\n            target_names = target.split(\",\") if \",\" in target else [target]\n        else:\n            target_names = target\n\n        # All the assumptions below for the target are dependant on the number of targets being 1\n        n_targets = len(target_names)\n        if n_targets &gt; 1:\n            raise NotImplementedError(f\"Number of targets {n_targets} not implemented.\")\n\n        target_name = target_names[0]\n        x = data.drop(columns=[target_name])\n        y = data[target_name].squeeze()\n\n        # Finally, remove the target from the list of attributes and categorical mask\n        target_index = attribute_names.index(target_name)\n        categorical_mask.pop(target_index)\n        attribute_names.remove(target_name)\n\n        assert isinstance(y, pd.Series)\n        return x, y, categorical_mask, attribute_names\n\n    def _load_features(self) -&gt; None:\n        \"\"\"Load the features metadata from the server and store it in the dataset object.\"\"\"\n        # Delayed Import to avoid circular imports or having to import all of dataset.functions to\n        # import OpenMLDataset.\n        from openml.datasets.functions import _get_dataset_features_file\n\n        if self.dataset_id is None:\n            raise ValueError(\n                \"No dataset id specified. Please set the dataset id. Otherwise we cannot load \"\n                \"metadata.\",\n            )\n\n        features_file = _get_dataset_features_file(None, self.dataset_id)\n        self._features = _read_features(features_file)\n\n    def _load_qualities(self) -&gt; None:\n        \"\"\"Load qualities information from the server and store it in the dataset object.\"\"\"\n        # same reason as above for _load_features\n        from openml.datasets.functions import _get_dataset_qualities_file\n\n        if self.dataset_id is None:\n            raise ValueError(\n                \"No dataset id specified. Please set the dataset id. Otherwise we cannot load \"\n                \"metadata.\",\n            )\n\n        qualities_file = _get_dataset_qualities_file(None, self.dataset_id)\n\n        if qualities_file is None:\n            self._no_qualities_found = True\n        else:\n            self._qualities = _read_qualities(qualities_file)\n\n    def retrieve_class_labels(self, target_name: str = \"class\") -&gt; None | list[str]:\n        \"\"\"Reads the datasets arff to determine the class-labels.\n\n        If the task has no class labels (for example a regression problem)\n        it returns None. Necessary because the data returned by get_data\n        only contains the indices of the classes, while OpenML needs the real\n        classname when uploading the results of a run.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target attribute\n\n        Returns\n        -------\n        list\n        \"\"\"\n        for feature in self.features.values():\n            if feature.name == target_name:\n                if feature.data_type == \"nominal\":\n                    return feature.nominal_values\n\n                if feature.data_type == \"string\":\n                    # Rel.: #1311\n                    # The target is invalid for a classification task if the feature type is string\n                    # and not nominal. For such miss-configured tasks, we silently fix it here as\n                    # we can safely interpreter string as nominal.\n                    df, *_ = self.get_data()\n                    return list(df[feature.name].unique())\n\n        return None\n\n    def get_features_by_type(  # noqa: C901\n        self,\n        data_type: str,\n        exclude: list[str] | None = None,\n        exclude_ignore_attribute: bool = True,  # noqa: FBT002, FBT001\n        exclude_row_id_attribute: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; list[int]:\n        \"\"\"\n        Return indices of features of a given type, e.g. all nominal features.\n        Optional parameters to exclude various features by index or ontology.\n\n        Parameters\n        ----------\n        data_type : str\n            The data type to return (e.g., nominal, numeric, date, string)\n        exclude : list(int)\n            List of columns to exclude from the return value\n        exclude_ignore_attribute : bool\n            Whether to exclude the defined ignore attributes (and adapt the\n            return values as if these indices are not present)\n        exclude_row_id_attribute : bool\n            Whether to exclude the defined row id attributes (and adapt the\n            return values as if these indices are not present)\n\n        Returns\n        -------\n        result : list\n            a list of indices that have the specified data type\n        \"\"\"\n        if data_type not in OpenMLDataFeature.LEGAL_DATA_TYPES:\n            raise TypeError(\"Illegal feature type requested\")\n        if self.ignore_attribute is not None and not isinstance(self.ignore_attribute, list):\n            raise TypeError(\"ignore_attribute should be a list\")\n        if self.row_id_attribute is not None and not isinstance(self.row_id_attribute, str):\n            raise TypeError(\"row id attribute should be a str\")\n        if exclude is not None and not isinstance(exclude, list):\n            raise TypeError(\"Exclude should be a list\")\n            # assert all(isinstance(elem, str) for elem in exclude),\n            #            \"Exclude should be a list of strings\"\n        to_exclude = []\n        if exclude is not None:\n            to_exclude.extend(exclude)\n        if exclude_ignore_attribute and self.ignore_attribute is not None:\n            to_exclude.extend(self.ignore_attribute)\n        if exclude_row_id_attribute and self.row_id_attribute is not None:\n            to_exclude.append(self.row_id_attribute)\n\n        result = []\n        offset = 0\n        # this function assumes that everything in to_exclude will\n        # be 'excluded' from the dataset (hence the offset)\n        for idx in self.features:\n            name = self.features[idx].name\n            if name in to_exclude:\n                offset += 1\n            elif self.features[idx].data_type == data_type:\n                result.append(idx - offset)\n        return result\n\n    def _get_file_elements(self) -&gt; dict:\n        \"\"\"Adds the 'dataset' to file elements.\"\"\"\n        file_elements: dict = {}\n        path = None if self.data_file is None else Path(self.data_file).absolute()\n\n        if self._dataset is not None:\n            file_elements[\"dataset\"] = self._dataset\n        elif path is not None and path.exists():\n            with path.open(\"rb\") as fp:\n                file_elements[\"dataset\"] = fp.read()\n\n            try:\n                dataset_utf8 = str(file_elements[\"dataset\"], encoding=\"utf8\")\n                arff.ArffDecoder().decode(dataset_utf8, encode_nominal=True)\n            except arff.ArffException as e:\n                raise ValueError(\"The file you have provided is not a valid arff file.\") from e\n\n        elif self.url is None:\n            raise ValueError(\"No valid url/path to the data file was given.\")\n        return file_elements\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.dataset_id = int(xml_response[\"oml:upload_data_set\"][\"oml:id\"])\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        props = [\n            \"id\",\n            \"name\",\n            \"version\",\n            \"description\",\n            \"format\",\n            \"creator\",\n            \"contributor\",\n            \"collection_date\",\n            \"upload_date\",\n            \"language\",\n            \"licence\",\n            \"url\",\n            \"default_target_attribute\",\n            \"row_id_attribute\",\n            \"ignore_attribute\",\n            \"version_label\",\n            \"citation\",\n            \"tag\",\n            \"visibility\",\n            \"original_data_url\",\n            \"paper_url\",\n            \"update_comment\",\n            \"md5_checksum\",\n        ]\n\n        prop_values = {}\n        for prop in props:\n            content = getattr(self, prop, None)\n            if content is not None:\n                prop_values[\"oml:\" + prop] = content\n\n        return {\n            \"oml:data_set_description\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                **prop_values,\n            }\n        }\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset.features","title":"<code>features: dict[int, OpenMLDataFeature]</code>  <code>property</code>","text":"<p>Get the features of this dataset.</p>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Get the dataset numeric id.</p>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset.qualities","title":"<code>qualities: dict[str, float] | None</code>  <code>property</code>","text":"<p>Get the qualities of this dataset.</p>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset.get_data","title":"<code>get_data(target=None, include_row_id=False, include_ignore_attribute=False)</code>","text":"<p>Returns dataset content as dataframes.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>(string, List[str] or None(default=None))</code> <p>Name of target column to separate from the data. Splitting multiple columns is currently not supported.</p> <code>None</code> <code>include_row_id</code> <code>boolean(default=False)</code> <p>Whether to include row ids in the returned dataset.</p> <code>False</code> <code>include_ignore_attribute</code> <code>boolean(default=False)</code> <p>Whether to include columns that are marked as \"ignore\" on the server in the dataset.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>X</code> <code>(dataframe, shape(n_samples, n_columns))</code> <p>Dataset, may have sparse dtypes in the columns if required.</p> <code>y</code> <code>(Series, shape(n_samples) or None)</code> <p>Target column</p> <code>categorical_indicator</code> <code>list[bool]</code> <p>Mask that indicate categorical features.</p> <code>attribute_names</code> <code>list[str]</code> <p>List of attribute names.</p> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def get_data(  # noqa: C901\n    self,\n    target: list[str] | str | None = None,\n    include_row_id: bool = False,  # noqa: FBT001, FBT002\n    include_ignore_attribute: bool = False,  # noqa: FBT001, FBT002\n) -&gt; tuple[pd.DataFrame, pd.Series | None, list[bool], list[str]]:\n    \"\"\"Returns dataset content as dataframes.\n\n    Parameters\n    ----------\n    target : string, List[str] or None (default=None)\n        Name of target column to separate from the data.\n        Splitting multiple columns is currently not supported.\n    include_row_id : boolean (default=False)\n        Whether to include row ids in the returned dataset.\n    include_ignore_attribute : boolean (default=False)\n        Whether to include columns that are marked as \"ignore\"\n        on the server in the dataset.\n\n\n    Returns\n    -------\n    X : dataframe, shape (n_samples, n_columns)\n        Dataset, may have sparse dtypes in the columns if required.\n    y : pd.Series, shape (n_samples, ) or None\n        Target column\n    categorical_indicator : list[bool]\n        Mask that indicate categorical features.\n    attribute_names : list[str]\n        List of attribute names.\n    \"\"\"\n    data, categorical_mask, attribute_names = self._load_data()\n\n    to_exclude = []\n    if not include_row_id and self.row_id_attribute is not None:\n        if isinstance(self.row_id_attribute, str):\n            to_exclude.append(self.row_id_attribute)\n        elif isinstance(self.row_id_attribute, Iterable):\n            to_exclude.extend(self.row_id_attribute)\n\n    if not include_ignore_attribute and self.ignore_attribute is not None:\n        if isinstance(self.ignore_attribute, str):\n            to_exclude.append(self.ignore_attribute)\n        elif isinstance(self.ignore_attribute, Iterable):\n            to_exclude.extend(self.ignore_attribute)\n\n    if len(to_exclude) &gt; 0:\n        logger.info(f\"Going to remove the following attributes: {to_exclude}\")\n        keep = np.array([column not in to_exclude for column in attribute_names])\n        data = data.drop(columns=to_exclude)\n        categorical_mask = [cat for cat, k in zip(categorical_mask, keep) if k]\n        attribute_names = [att for att, k in zip(attribute_names, keep) if k]\n\n    if target is None:\n        return data, None, categorical_mask, attribute_names\n\n    if isinstance(target, str):\n        target_names = target.split(\",\") if \",\" in target else [target]\n    else:\n        target_names = target\n\n    # All the assumptions below for the target are dependant on the number of targets being 1\n    n_targets = len(target_names)\n    if n_targets &gt; 1:\n        raise NotImplementedError(f\"Number of targets {n_targets} not implemented.\")\n\n    target_name = target_names[0]\n    x = data.drop(columns=[target_name])\n    y = data[target_name].squeeze()\n\n    # Finally, remove the target from the list of attributes and categorical mask\n    target_index = attribute_names.index(target_name)\n    categorical_mask.pop(target_index)\n    attribute_names.remove(target_name)\n\n    assert isinstance(y, pd.Series)\n    return x, y, categorical_mask, attribute_names\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset.get_features_by_type","title":"<code>get_features_by_type(data_type, exclude=None, exclude_ignore_attribute=True, exclude_row_id_attribute=True)</code>","text":"<p>Return indices of features of a given type, e.g. all nominal features. Optional parameters to exclude various features by index or ontology.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>The data type to return (e.g., nominal, numeric, date, string)</p> required <code>exclude</code> <code>list(int)</code> <p>List of columns to exclude from the return value</p> <code>None</code> <code>exclude_ignore_attribute</code> <code>bool</code> <p>Whether to exclude the defined ignore attributes (and adapt the return values as if these indices are not present)</p> <code>True</code> <code>exclude_row_id_attribute</code> <code>bool</code> <p>Whether to exclude the defined row id attributes (and adapt the return values as if these indices are not present)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>result</code> <code>list</code> <p>a list of indices that have the specified data type</p> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def get_features_by_type(  # noqa: C901\n    self,\n    data_type: str,\n    exclude: list[str] | None = None,\n    exclude_ignore_attribute: bool = True,  # noqa: FBT002, FBT001\n    exclude_row_id_attribute: bool = True,  # noqa: FBT002, FBT001\n) -&gt; list[int]:\n    \"\"\"\n    Return indices of features of a given type, e.g. all nominal features.\n    Optional parameters to exclude various features by index or ontology.\n\n    Parameters\n    ----------\n    data_type : str\n        The data type to return (e.g., nominal, numeric, date, string)\n    exclude : list(int)\n        List of columns to exclude from the return value\n    exclude_ignore_attribute : bool\n        Whether to exclude the defined ignore attributes (and adapt the\n        return values as if these indices are not present)\n    exclude_row_id_attribute : bool\n        Whether to exclude the defined row id attributes (and adapt the\n        return values as if these indices are not present)\n\n    Returns\n    -------\n    result : list\n        a list of indices that have the specified data type\n    \"\"\"\n    if data_type not in OpenMLDataFeature.LEGAL_DATA_TYPES:\n        raise TypeError(\"Illegal feature type requested\")\n    if self.ignore_attribute is not None and not isinstance(self.ignore_attribute, list):\n        raise TypeError(\"ignore_attribute should be a list\")\n    if self.row_id_attribute is not None and not isinstance(self.row_id_attribute, str):\n        raise TypeError(\"row id attribute should be a str\")\n    if exclude is not None and not isinstance(exclude, list):\n        raise TypeError(\"Exclude should be a list\")\n        # assert all(isinstance(elem, str) for elem in exclude),\n        #            \"Exclude should be a list of strings\"\n    to_exclude = []\n    if exclude is not None:\n        to_exclude.extend(exclude)\n    if exclude_ignore_attribute and self.ignore_attribute is not None:\n        to_exclude.extend(self.ignore_attribute)\n    if exclude_row_id_attribute and self.row_id_attribute is not None:\n        to_exclude.append(self.row_id_attribute)\n\n    result = []\n    offset = 0\n    # this function assumes that everything in to_exclude will\n    # be 'excluded' from the dataset (hence the offset)\n    for idx in self.features:\n        name = self.features[idx].name\n        if name in to_exclude:\n            offset += 1\n        elif self.features[idx].data_type == data_type:\n            result.append(idx - offset)\n    return result\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.OpenMLDataset.retrieve_class_labels","title":"<code>retrieve_class_labels(target_name='class')</code>","text":"<p>Reads the datasets arff to determine the class-labels.</p> <p>If the task has no class labels (for example a regression problem) it returns None. Necessary because the data returned by get_data only contains the indices of the classes, while OpenML needs the real classname when uploading the results of a run.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>Name of the target attribute</p> <code>'class'</code> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def retrieve_class_labels(self, target_name: str = \"class\") -&gt; None | list[str]:\n    \"\"\"Reads the datasets arff to determine the class-labels.\n\n    If the task has no class labels (for example a regression problem)\n    it returns None. Necessary because the data returned by get_data\n    only contains the indices of the classes, while OpenML needs the real\n    classname when uploading the results of a run.\n\n    Parameters\n    ----------\n    target_name : str\n        Name of the target attribute\n\n    Returns\n    -------\n    list\n    \"\"\"\n    for feature in self.features.values():\n        if feature.name == target_name:\n            if feature.data_type == \"nominal\":\n                return feature.nominal_values\n\n            if feature.data_type == \"string\":\n                # Rel.: #1311\n                # The target is invalid for a classification task if the feature type is string\n                # and not nominal. For such miss-configured tasks, we silently fix it here as\n                # we can safely interpreter string as nominal.\n                df, *_ = self.get_data()\n                return list(df[feature.name].unique())\n\n    return None\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.attributes_arff_from_df","title":"<code>attributes_arff_from_df(df)</code>","text":"<p>Describe attributes of the dataframe according to ARFF specification.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, shape(n_samples, n_features))</code> <p>The dataframe containing the data set.</p> required <p>Returns:</p> Name Type Description <code>attributes_arff</code> <code>list[str]</code> <p>The data set attributes as required by the ARFF format.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def attributes_arff_from_df(df: pd.DataFrame) -&gt; list[tuple[str, list[str] | str]]:\n    \"\"\"Describe attributes of the dataframe according to ARFF specification.\n\n    Parameters\n    ----------\n    df : DataFrame, shape (n_samples, n_features)\n        The dataframe containing the data set.\n\n    Returns\n    -------\n    attributes_arff : list[str]\n        The data set attributes as required by the ARFF format.\n    \"\"\"\n    PD_DTYPES_TO_ARFF_DTYPE = {\"integer\": \"INTEGER\", \"floating\": \"REAL\", \"string\": \"STRING\"}\n    attributes_arff: list[tuple[str, list[str] | str]] = []\n\n    if not all(isinstance(column_name, str) for column_name in df.columns):\n        logger.warning(\"Converting non-str column names to str.\")\n        df.columns = [str(column_name) for column_name in df.columns]\n\n    for column_name in df:\n        # skipna=True does not infer properly the dtype. The NA values are\n        # dropped before the inference instead.\n        column_dtype = pd.api.types.infer_dtype(df[column_name].dropna(), skipna=False)\n\n        if column_dtype == \"categorical\":\n            # for categorical feature, arff expects a list string. However, a\n            # categorical column can contain mixed type and should therefore\n            # raise an error asking to convert all entries to string.\n            categories = df[column_name].cat.categories\n            categories_dtype = pd.api.types.infer_dtype(categories)\n            if categories_dtype not in (\"string\", \"unicode\"):\n                raise ValueError(\n                    f\"The column '{column_name}' of the dataframe is of \"\n                    \"'category' dtype. Therefore, all values in \"\n                    \"this columns should be string. Please \"\n                    \"convert the entries which are not string. \"\n                    f\"Got {categories_dtype} dtype in this column.\",\n                )\n            attributes_arff.append((column_name, categories.tolist()))\n        elif column_dtype == \"boolean\":\n            # boolean are encoded as categorical.\n            attributes_arff.append((column_name, [\"True\", \"False\"]))\n        elif column_dtype in PD_DTYPES_TO_ARFF_DTYPE:\n            attributes_arff.append((column_name, PD_DTYPES_TO_ARFF_DTYPE[column_dtype]))\n        else:\n            raise ValueError(\n                f\"The dtype '{column_dtype}' of the column '{column_name}' is not \"\n                \"currently supported by liac-arff. Supported \"\n                \"dtypes are categorical, string, integer, \"\n                \"floating, and boolean.\",\n            )\n    return attributes_arff\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.check_datasets_active","title":"<code>check_datasets_active(dataset_ids, raise_error_if_not_exist=True)</code>","text":"<p>Check if the dataset ids provided are active.</p> <p>Raises an error if a dataset_id in the given list of dataset_ids does not exist on the server and <code>raise_error_if_not_exist</code> is set to True (default).</p> <p>Parameters:</p> Name Type Description Default <code>dataset_ids</code> <code>List[int]</code> <p>A list of integers representing dataset ids.</p> required <code>raise_error_if_not_exist</code> <code>bool(default=True)</code> <p>Flag that if activated can raise an error, if one or more of the given dataset ids do not exist on the server.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with items {did: bool}</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def check_datasets_active(\n    dataset_ids: list[int],\n    raise_error_if_not_exist: bool = True,  # noqa: FBT001, FBT002\n) -&gt; dict[int, bool]:\n    \"\"\"\n    Check if the dataset ids provided are active.\n\n    Raises an error if a dataset_id in the given list\n    of dataset_ids does not exist on the server and\n    `raise_error_if_not_exist` is set to True (default).\n\n    Parameters\n    ----------\n    dataset_ids : List[int]\n        A list of integers representing dataset ids.\n    raise_error_if_not_exist : bool (default=True)\n        Flag that if activated can raise an error, if one or more of the\n        given dataset ids do not exist on the server.\n\n    Returns\n    -------\n    dict\n        A dictionary with items {did: bool}\n    \"\"\"\n    datasets = list_datasets(status=\"all\", data_id=dataset_ids)\n    missing = set(dataset_ids) - set(datasets.index)\n    if raise_error_if_not_exist and missing:\n        missing_str = \", \".join(str(did) for did in missing)\n        raise ValueError(f\"Could not find dataset(s) {missing_str} in OpenML dataset list.\")\n    mask = datasets[\"status\"] == \"active\"\n    return dict(mask)\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.create_dataset","title":"<code>create_dataset(name, description, creator, contributor, collection_date, language, licence, attributes, data, default_target_attribute, ignore_attribute, citation, row_id_attribute=None, original_data_url=None, paper_url=None, update_comment=None, version_label=None)</code>","text":"<p>Create a dataset.</p> <p>This function creates an OpenMLDataset object. The OpenMLDataset object contains information related to the dataset and the actual data file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> required <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> required <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> required <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> required <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> required <code>licence</code> <code>str</code> <p>License of the data.</p> required <code>attributes</code> <code>list, dict, or 'auto'</code> <p>A list of tuples. Each tuple consists of the attribute name and type. If passing a pandas DataFrame, the attributes can be automatically inferred by passing <code>'auto'</code>. Specific attributes can be manually specified by a passing a dictionary where the key is the name of the attribute and the value is the data type of the attribute.</p> required <code>data</code> <code>(ndarray, list, dataframe, coo_matrix, shape(n_samples, n_features))</code> <p>An array that contains both the attributes and the targets. When providing a dataframe, the attribute names and type can be inferred by passing <code>attributes='auto'</code>. The target feature is indicated as meta-data of the dataset.</p> required <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> required <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes. Can have multiple values, comma separated.</p> required <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> required <code>version_label</code> <code>str</code> <p>Version label provided by user.  Can be a date, hash, or some other type of id.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset. If <code>data</code> is a dataframe and <code>row_id_attribute</code> is not specified, the index of the dataframe will be used as the <code>row_id_attribute</code>. If the name of the index is <code>None</code>, it will be discarded.</p> <p>.. versionadded: 0.8     Inference of <code>row_id_attribute</code> from a dataframe.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <code>update_comment</code> <code>str</code> <p>An explanation for when the dataset is uploaded.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>class</code> <code>`openml.OpenMLDataset`</code> <code>Dataset description.</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def create_dataset(  # noqa: C901, PLR0912, PLR0915\n    name: str,\n    description: str | None,\n    creator: str | None,\n    contributor: str | None,\n    collection_date: str | None,\n    language: str | None,\n    licence: str | None,\n    # TODO(eddiebergman): Docstring says `type` but I don't know what this is other than strings\n    # Edit: Found it could also be like [\"True\", \"False\"]\n    attributes: list[tuple[str, str | list[str]]] | dict[str, str | list[str]] | Literal[\"auto\"],\n    data: pd.DataFrame | np.ndarray | scipy.sparse.coo_matrix,\n    # TODO(eddiebergman): Function requires `default_target_attribute` exist but API allows None\n    default_target_attribute: str,\n    ignore_attribute: str | list[str] | None,\n    citation: str,\n    row_id_attribute: str | None = None,\n    original_data_url: str | None = None,\n    paper_url: str | None = None,\n    update_comment: str | None = None,\n    version_label: str | None = None,\n) -&gt; OpenMLDataset:\n    \"\"\"Create a dataset.\n\n    This function creates an OpenMLDataset object.\n    The OpenMLDataset object contains information related to the dataset\n    and the actual data file.\n\n    Parameters\n    ----------\n    name : str\n        Name of the dataset.\n    description : str\n        Description of the dataset.\n    creator : str\n        The person who created the dataset.\n    contributor : str\n        People who contributed to the current version of the dataset.\n    collection_date : str\n        The date the data was originally collected, given by the uploader.\n    language : str\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    licence : str\n        License of the data.\n    attributes : list, dict, or 'auto'\n        A list of tuples. Each tuple consists of the attribute name and type.\n        If passing a pandas DataFrame, the attributes can be automatically\n        inferred by passing ``'auto'``. Specific attributes can be manually\n        specified by a passing a dictionary where the key is the name of the\n        attribute and the value is the data type of the attribute.\n    data : ndarray, list, dataframe, coo_matrix, shape (n_samples, n_features)\n        An array that contains both the attributes and the targets. When\n        providing a dataframe, the attribute names and type can be inferred by\n        passing ``attributes='auto'``.\n        The target feature is indicated as meta-data of the dataset.\n    default_target_attribute : str\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    ignore_attribute : str | list\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n        Can have multiple values, comma separated.\n    citation : str\n        Reference(s) that should be cited when building on this data.\n    version_label : str, optional\n        Version label provided by user.\n         Can be a date, hash, or some other type of id.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column, if present in the\n        dataset. If ``data`` is a dataframe and ``row_id_attribute`` is not\n        specified, the index of the dataframe will be used as the\n        ``row_id_attribute``. If the name of the index is ``None``, it will\n        be discarded.\n\n        .. versionadded: 0.8\n            Inference of ``row_id_attribute`` from a dataframe.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n    update_comment : str, optional\n        An explanation for when the dataset is uploaded.\n\n    Returns\n    -------\n    class:`openml.OpenMLDataset`\n    Dataset description.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # infer the row id from the index of the dataset\n        if row_id_attribute is None:\n            row_id_attribute = data.index.name\n        # When calling data.values, the index will be skipped.\n        # We need to reset the index such that it is part of the data.\n        if data.index.name is not None:\n            data = data.reset_index()\n\n    if attributes == \"auto\" or isinstance(attributes, dict):\n        if not isinstance(data, pd.DataFrame):\n            raise ValueError(\n                \"Automatically inferring attributes requires \"\n                f\"a pandas DataFrame. A {data!r} was given instead.\",\n            )\n        # infer the type of data for each column of the DataFrame\n        attributes_ = attributes_arff_from_df(data)\n        if isinstance(attributes, dict):\n            # override the attributes which was specified by the user\n            for attr_idx in range(len(attributes_)):\n                attr_name = attributes_[attr_idx][0]\n                if attr_name in attributes:\n                    attributes_[attr_idx] = (attr_name, attributes[attr_name])\n    else:\n        attributes_ = attributes\n    ignore_attributes = _expand_parameter(ignore_attribute)\n    _validated_data_attributes(ignore_attributes, attributes_, \"ignore_attribute\")\n\n    default_target_attributes = _expand_parameter(default_target_attribute)\n    _validated_data_attributes(default_target_attributes, attributes_, \"default_target_attribute\")\n\n    if row_id_attribute is not None:\n        is_row_id_an_attribute = any(attr[0] == row_id_attribute for attr in attributes_)\n        if not is_row_id_an_attribute:\n            raise ValueError(\n                \"'row_id_attribute' should be one of the data attribute. \"\n                f\" Got '{row_id_attribute}' while candidates are\"\n                f\" {[attr[0] for attr in attributes_]}.\",\n            )\n\n    if isinstance(data, pd.DataFrame):\n        if all(isinstance(dtype, pd.SparseDtype) for dtype in data.dtypes):\n            data = data.sparse.to_coo()\n            # liac-arff only support COO matrices with sorted rows\n            row_idx_sorted = np.argsort(data.row)  # type: ignore\n            data.row = data.row[row_idx_sorted]  # type: ignore\n            data.col = data.col[row_idx_sorted]  # type: ignore\n            data.data = data.data[row_idx_sorted]  # type: ignore\n        else:\n            data = data.to_numpy()\n\n    data_format: Literal[\"arff\", \"sparse_arff\"]\n    if isinstance(data, (list, np.ndarray)):\n        if isinstance(data[0], (list, np.ndarray)):\n            data_format = \"arff\"\n        elif isinstance(data[0], dict):\n            data_format = \"sparse_arff\"\n        else:\n            raise ValueError(\n                \"When giving a list or a numpy.ndarray, \"\n                \"they should contain a list/ numpy.ndarray \"\n                \"for dense data or a dictionary for sparse \"\n                f\"data. Got {data[0]!r} instead.\",\n            )\n    elif isinstance(data, coo_matrix):\n        data_format = \"sparse_arff\"\n    else:\n        raise ValueError(\n            \"When giving a list or a numpy.ndarray, \"\n            \"they should contain a list/ numpy.ndarray \"\n            \"for dense data or a dictionary for sparse \"\n            f\"data. Got {data[0]!r} instead.\",\n        )\n\n    arff_object = {\n        \"relation\": name,\n        \"description\": description,\n        \"attributes\": attributes_,\n        \"data\": data,\n    }\n\n    # serializes the ARFF dataset object and returns a string\n    arff_dataset = arff.dumps(arff_object)\n    try:\n        # check if ARFF is valid\n        decoder = arff.ArffDecoder()\n        return_type = arff.COO if data_format == \"sparse_arff\" else arff.DENSE\n        decoder.decode(arff_dataset, encode_nominal=True, return_type=return_type)\n    except arff.ArffException as e:\n        raise ValueError(\n            \"The arguments you have provided do not construct a valid ARFF file\"\n        ) from e\n\n    return OpenMLDataset(\n        name=name,\n        description=description,\n        data_format=data_format,\n        creator=creator,\n        contributor=contributor,\n        collection_date=collection_date,\n        language=language,\n        licence=licence,\n        default_target_attribute=default_target_attribute,\n        row_id_attribute=row_id_attribute,\n        ignore_attribute=ignore_attribute,\n        citation=citation,\n        version_label=version_label,\n        original_data_url=original_data_url,\n        paper_url=paper_url,\n        update_comment=update_comment,\n        dataset=arff_dataset,\n    )\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.delete_dataset","title":"<code>delete_dataset(dataset_id)</code>","text":"<p>Delete dataset with id <code>dataset_id</code> from the OpenML server.</p> <p>This can only be done if you are the owner of the dataset and no tasks are attached to the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int</code> <p>OpenML id of the dataset</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def delete_dataset(dataset_id: int) -&gt; bool:\n    \"\"\"Delete dataset with id `dataset_id` from the OpenML server.\n\n    This can only be done if you are the owner of the dataset and\n    no tasks are attached to the dataset.\n\n    Parameters\n    ----------\n    dataset_id : int\n        OpenML id of the dataset\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"data\", dataset_id)\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.edit_dataset","title":"<code>edit_dataset(data_id, description=None, creator=None, contributor=None, collection_date=None, language=None, default_target_attribute=None, ignore_attribute=None, citation=None, row_id_attribute=None, original_data_url=None, paper_url=None)</code>","text":"<p>Edits an OpenMLDataset.</p> <p>In addition to providing the dataset id of the dataset to edit (through data_id), you must specify a value for at least one of the optional function arguments, i.e. one value for a field to edit.</p> <p>This function allows editing of both non-critical and critical fields. Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.</p> <ul> <li>Editing non-critical data fields is allowed for all authenticated users.</li> <li>Editing critical fields is allowed only for the owner, provided there are no tasks    associated with this dataset.</li> </ul> <p>If dataset has tasks or if the user is not the owner, the only way to edit critical fields is to use fork_dataset followed by edit_dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>ID of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> <code>None</code> <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> <code>None</code> <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> <code>None</code> <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> <code>None</code> <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> <code>None</code> <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes.</p> <code>None</code> <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset. If <code>data</code> is a dataframe and <code>row_id_attribute</code> is not specified, the index of the dataframe will be used as the <code>row_id_attribute</code>. If the name of the index is <code>None</code>, it will be discarded.</p> <p>.. versionadded: 0.8     Inference of <code>row_id_attribute</code> from a dataframe.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset id</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def edit_dataset(\n    data_id: int,\n    description: str | None = None,\n    creator: str | None = None,\n    contributor: str | None = None,\n    collection_date: str | None = None,\n    language: str | None = None,\n    default_target_attribute: str | None = None,\n    ignore_attribute: str | list[str] | None = None,\n    citation: str | None = None,\n    row_id_attribute: str | None = None,\n    original_data_url: str | None = None,\n    paper_url: str | None = None,\n) -&gt; int:\n    \"\"\"Edits an OpenMLDataset.\n\n    In addition to providing the dataset id of the dataset to edit (through data_id),\n    you must specify a value for at least one of the optional function arguments,\n    i.e. one value for a field to edit.\n\n    This function allows editing of both non-critical and critical fields.\n    Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.\n\n     - Editing non-critical data fields is allowed for all authenticated users.\n     - Editing critical fields is allowed only for the owner, provided there are no tasks\n       associated with this dataset.\n\n    If dataset has tasks or if the user is not the owner, the only way\n    to edit critical fields is to use fork_dataset followed by edit_dataset.\n\n    Parameters\n    ----------\n    data_id : int\n        ID of the dataset.\n    description : str\n        Description of the dataset.\n    creator : str\n        The person who created the dataset.\n    contributor : str\n        People who contributed to the current version of the dataset.\n    collection_date : str\n        The date the data was originally collected, given by the uploader.\n    language : str\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    default_target_attribute : str\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    ignore_attribute : str | list\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n    citation : str\n        Reference(s) that should be cited when building on this data.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column, if present in the\n        dataset. If ``data`` is a dataframe and ``row_id_attribute`` is not\n        specified, the index of the dataframe will be used as the\n        ``row_id_attribute``. If the name of the index is ``None``, it will\n        be discarded.\n\n        .. versionadded: 0.8\n            Inference of ``row_id_attribute`` from a dataframe.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n\n    Returns\n    -------\n    Dataset id\n    \"\"\"\n    if not isinstance(data_id, int):\n        raise TypeError(f\"`data_id` must be of type `int`, not {type(data_id)}.\")\n\n    # compose data edit parameters as xml\n    form_data = {\"data_id\": data_id}  # type: openml._api_calls.DATA_TYPE\n    xml = OrderedDict()  # type: 'OrderedDict[str, OrderedDict]'\n    xml[\"oml:data_edit_parameters\"] = OrderedDict()\n    xml[\"oml:data_edit_parameters\"][\"@xmlns:oml\"] = \"http://openml.org/openml\"\n    xml[\"oml:data_edit_parameters\"][\"oml:description\"] = description\n    xml[\"oml:data_edit_parameters\"][\"oml:creator\"] = creator\n    xml[\"oml:data_edit_parameters\"][\"oml:contributor\"] = contributor\n    xml[\"oml:data_edit_parameters\"][\"oml:collection_date\"] = collection_date\n    xml[\"oml:data_edit_parameters\"][\"oml:language\"] = language\n    xml[\"oml:data_edit_parameters\"][\"oml:default_target_attribute\"] = default_target_attribute\n    xml[\"oml:data_edit_parameters\"][\"oml:row_id_attribute\"] = row_id_attribute\n    xml[\"oml:data_edit_parameters\"][\"oml:ignore_attribute\"] = ignore_attribute\n    xml[\"oml:data_edit_parameters\"][\"oml:citation\"] = citation\n    xml[\"oml:data_edit_parameters\"][\"oml:original_data_url\"] = original_data_url\n    xml[\"oml:data_edit_parameters\"][\"oml:paper_url\"] = paper_url\n\n    # delete None inputs\n    for k in list(xml[\"oml:data_edit_parameters\"]):\n        if not xml[\"oml:data_edit_parameters\"][k]:\n            del xml[\"oml:data_edit_parameters\"][k]\n\n    file_elements = {\n        \"edit_parameters\": (\"description.xml\", xmltodict.unparse(xml)),\n    }  # type: openml._api_calls.FILE_ELEMENTS_TYPE\n    result_xml = openml._api_calls._perform_api_call(\n        \"data/edit\",\n        \"post\",\n        data=form_data,\n        file_elements=file_elements,\n    )\n    result = xmltodict.parse(result_xml)\n    data_id = result[\"oml:data_edit\"][\"oml:id\"]\n    return int(data_id)\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.fork_dataset","title":"<code>fork_dataset(data_id)</code>","text":"<p>Creates a new dataset version, with the authenticated user as the new owner.  The forked dataset can have distinct dataset meta-data,  but the actual data itself is shared with the original version.</p> <p>This API is intended for use when a user is unable to edit the critical fields of a dataset  through the edit_dataset API.  (Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.)</p> <p>Specifically, this happens when the user is:         1. Not the owner of the dataset.         2. User is the owner of the dataset, but the dataset has tasks.</p> <p>In these two cases the only way to edit critical fields is:         1. STEP 1: Fork the dataset using fork_dataset API         2. STEP 2: Call edit_dataset API on the forked version.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>id of the dataset to be forked</p> required <p>Returns:</p> Type Description <code>Dataset id of the forked dataset</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def fork_dataset(data_id: int) -&gt; int:\n    \"\"\"\n     Creates a new dataset version, with the authenticated user as the new owner.\n     The forked dataset can have distinct dataset meta-data,\n     but the actual data itself is shared with the original version.\n\n     This API is intended for use when a user is unable to edit the critical fields of a dataset\n     through the edit_dataset API.\n     (Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.)\n\n     Specifically, this happens when the user is:\n            1. Not the owner of the dataset.\n            2. User is the owner of the dataset, but the dataset has tasks.\n\n     In these two cases the only way to edit critical fields is:\n            1. STEP 1: Fork the dataset using fork_dataset API\n            2. STEP 2: Call edit_dataset API on the forked version.\n\n\n    Parameters\n    ----------\n    data_id : int\n        id of the dataset to be forked\n\n    Returns\n    -------\n    Dataset id of the forked dataset\n\n    \"\"\"\n    if not isinstance(data_id, int):\n        raise TypeError(f\"`data_id` must be of type `int`, not {type(data_id)}.\")\n    # compose data fork parameters\n    form_data = {\"data_id\": data_id}  # type: openml._api_calls.DATA_TYPE\n    result_xml = openml._api_calls._perform_api_call(\"data/fork\", \"post\", data=form_data)\n    result = xmltodict.parse(result_xml)\n    data_id = result[\"oml:data_fork\"][\"oml:id\"]\n    return int(data_id)\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.get_dataset","title":"<code>get_dataset(dataset_id, download_data=False, version=None, error_if_multiple=False, cache_format='pickle', download_qualities=False, download_features_meta_data=False, download_all_files=False, force_refresh_cache=False)</code>","text":"<p>Download the OpenML dataset representation, optionally also download actual data file.</p> <p>This function is by default NOT thread/multiprocessing safe, as this function uses caching. A check will be performed to determine if the information has previously been downloaded to a cache, and if so be loaded from disk instead of retrieved from the server.</p> <p>To make this function thread safe, you can install the python package <code>oslo.concurrency</code>. If <code>oslo.concurrency</code> is installed <code>get_dataset</code> becomes thread safe.</p> <p>Alternatively, to make this function thread/multiprocessing safe initialize the cache first by calling <code>get_dataset(args)</code> once before calling <code>get_dataset(args)</code> many times in parallel. This will initialize the cache and later calls will use the cache in a thread/multiprocessing safe way.</p> <p>If dataset is retrieved by name, a version may be specified. If no version is specified and multiple versions of the dataset exist, the earliest version of the dataset that is still active will be returned. If no version is specified, multiple versions of the dataset exist and <code>exception_if_multiple</code> is set to <code>True</code>, this function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int or str</code> <p>Dataset ID (integer) or dataset name (string) of the dataset to download.</p> required <code>download_data</code> <code>bool(default=False)</code> <p>If True, also download the data file. Beware that some datasets are large and it might make the operation noticeably slower. Metadata is also still retrieved. If False, create the OpenMLDataset and only populate it with the metadata. The data may later be retrieved through the <code>OpenMLDataset.get_data</code> method.</p> <code>False</code> <code>version</code> <code>(int, optional(default=None))</code> <p>Specifies the version if <code>dataset_id</code> is specified by name. If no version is specified, retrieve the least recent still active version.</p> <code>None</code> <code>error_if_multiple</code> <code>bool(default=False)</code> <p>If <code>True</code> raise an error if multiple datasets are found with matching criteria.</p> <code>False</code> <code>cache_format</code> <code>str(default='pickle') in {'pickle', 'feather'}</code> <p>Format for caching the dataset - may be feather or pickle Note that the default 'pickle' option may load slower than feather when no.of.rows is very high.</p> <code>'pickle'</code> <code>download_qualities</code> <code>bool(default=False)</code> <p>Option to download 'qualities' meta-data in addition to the minimal dataset description. If True, download and cache the qualities file. If False, create the OpenMLDataset without qualities metadata. The data may later be added to the OpenMLDataset through the <code>OpenMLDataset.load_metadata(qualities=True)</code> method.</p> <code>False</code> <code>download_features_meta_data</code> <code>bool(default=False)</code> <p>Option to download 'features' meta-data in addition to the minimal dataset description. If True, download and cache the features file. If False, create the OpenMLDataset without features metadata. The data may later be added to the OpenMLDataset through the <code>OpenMLDataset.load_metadata(features=True)</code> method.</p> <code>False</code> <code>download_all_files</code> <code>bool</code> <p>EXPERIMENTAL. Download all files related to the dataset that reside on the server. Useful for datasets which refer to auxiliary files (e.g., meta-album).</p> <code>False</code> <code>force_refresh_cache</code> <code>bool(default=False)</code> <p>Force the cache to refreshed by deleting the cache directory and re-downloading the data. Note, if <code>force_refresh_cache</code> is True, <code>get_dataset</code> is NOT thread/multiprocessing safe, because this creates a race condition to creating and deleting the cache; as in general with the cache.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dataset</code> <code>:class:`openml.OpenMLDataset`</code> <p>The downloaded dataset.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_dataset(  # noqa: C901, PLR0912\n    dataset_id: int | str,\n    download_data: bool = False,  # noqa: FBT002, FBT001\n    version: int | None = None,\n    error_if_multiple: bool = False,  # noqa: FBT002, FBT001\n    cache_format: Literal[\"pickle\", \"feather\"] = \"pickle\",\n    download_qualities: bool = False,  # noqa: FBT002, FBT001\n    download_features_meta_data: bool = False,  # noqa: FBT002, FBT001\n    download_all_files: bool = False,  # noqa: FBT002, FBT001\n    force_refresh_cache: bool = False,  # noqa: FBT001, FBT002\n) -&gt; OpenMLDataset:\n    \"\"\"Download the OpenML dataset representation, optionally also download actual data file.\n\n    This function is by default NOT thread/multiprocessing safe, as this function uses caching.\n    A check will be performed to determine if the information has previously been downloaded to a\n    cache, and if so be loaded from disk instead of retrieved from the server.\n\n    To make this function thread safe, you can install the python package ``oslo.concurrency``.\n    If ``oslo.concurrency`` is installed `get_dataset` becomes thread safe.\n\n    Alternatively, to make this function thread/multiprocessing safe initialize the cache first by\n    calling `get_dataset(args)` once before calling `get_dataset(args)` many times in parallel.\n    This will initialize the cache and later calls will use the cache in a thread/multiprocessing\n    safe way.\n\n    If dataset is retrieved by name, a version may be specified.\n    If no version is specified and multiple versions of the dataset exist,\n    the earliest version of the dataset that is still active will be returned.\n    If no version is specified, multiple versions of the dataset exist and\n    ``exception_if_multiple`` is set to ``True``, this function will raise an exception.\n\n    Parameters\n    ----------\n    dataset_id : int or str\n        Dataset ID (integer) or dataset name (string) of the dataset to download.\n    download_data : bool (default=False)\n        If True, also download the data file. Beware that some datasets are large and it might\n        make the operation noticeably slower. Metadata is also still retrieved.\n        If False, create the OpenMLDataset and only populate it with the metadata.\n        The data may later be retrieved through the `OpenMLDataset.get_data` method.\n    version : int, optional (default=None)\n        Specifies the version if `dataset_id` is specified by name.\n        If no version is specified, retrieve the least recent still active version.\n    error_if_multiple : bool (default=False)\n        If ``True`` raise an error if multiple datasets are found with matching criteria.\n    cache_format : str (default='pickle') in {'pickle', 'feather'}\n        Format for caching the dataset - may be feather or pickle\n        Note that the default 'pickle' option may load slower than feather when\n        no.of.rows is very high.\n    download_qualities : bool (default=False)\n        Option to download 'qualities' meta-data in addition to the minimal dataset description.\n        If True, download and cache the qualities file.\n        If False, create the OpenMLDataset without qualities metadata. The data may later be added\n        to the OpenMLDataset through the `OpenMLDataset.load_metadata(qualities=True)` method.\n    download_features_meta_data : bool (default=False)\n        Option to download 'features' meta-data in addition to the minimal dataset description.\n        If True, download and cache the features file.\n        If False, create the OpenMLDataset without features metadata. The data may later be added\n        to the OpenMLDataset through the `OpenMLDataset.load_metadata(features=True)` method.\n    download_all_files: bool (default=False)\n        EXPERIMENTAL. Download all files related to the dataset that reside on the server.\n        Useful for datasets which refer to auxiliary files (e.g., meta-album).\n    force_refresh_cache : bool (default=False)\n        Force the cache to refreshed by deleting the cache directory and re-downloading the data.\n        Note, if `force_refresh_cache` is True, `get_dataset` is NOT thread/multiprocessing safe,\n        because this creates a race condition to creating and deleting the cache; as in general with\n        the cache.\n\n    Returns\n    -------\n    dataset : :class:`openml.OpenMLDataset`\n        The downloaded dataset.\n    \"\"\"\n    if download_all_files:\n        warnings.warn(\n            \"``download_all_files`` is experimental and is likely to break with new releases.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n\n    if cache_format not in [\"feather\", \"pickle\"]:\n        raise ValueError(\n            \"cache_format must be one of 'feather' or 'pickle. \"\n            f\"Invalid format specified: {cache_format}\",\n        )\n\n    if isinstance(dataset_id, str):\n        try:\n            dataset_id = int(dataset_id)\n        except ValueError:\n            dataset_id = _name_to_id(dataset_id, version, error_if_multiple)  # type: ignore\n    elif not isinstance(dataset_id, int):\n        raise TypeError(\n            f\"`dataset_id` must be one of `str` or `int`, not {type(dataset_id)}.\",\n        )\n\n    if force_refresh_cache:\n        did_cache_dir = _get_cache_dir_for_id(DATASETS_CACHE_DIR_NAME, dataset_id)\n        if did_cache_dir.exists():\n            _remove_cache_dir_for_id(DATASETS_CACHE_DIR_NAME, did_cache_dir)\n\n    did_cache_dir = _create_cache_directory_for_id(\n        DATASETS_CACHE_DIR_NAME,\n        dataset_id,\n    )\n\n    remove_dataset_cache = True\n    try:\n        description = _get_dataset_description(did_cache_dir, dataset_id)\n        features_file = None\n        qualities_file = None\n\n        if download_features_meta_data:\n            features_file = _get_dataset_features_file(did_cache_dir, dataset_id)\n        if download_qualities:\n            qualities_file = _get_dataset_qualities_file(did_cache_dir, dataset_id)\n\n        parquet_file = None\n        skip_parquet = os.environ.get(OPENML_SKIP_PARQUET_ENV_VAR, \"false\").casefold() == \"true\"\n        download_parquet = \"oml:parquet_url\" in description and not skip_parquet\n        if download_parquet and (download_data or download_all_files):\n            try:\n                parquet_file = _get_dataset_parquet(\n                    description,\n                    download_all_files=download_all_files,\n                )\n            except urllib3.exceptions.MaxRetryError:\n                parquet_file = None\n\n        arff_file = None\n        if parquet_file is None and download_data:\n            if download_parquet:\n                logger.warning(\"Failed to download parquet, fallback on ARFF.\")\n            arff_file = _get_dataset_arff(description)\n\n        remove_dataset_cache = False\n    except OpenMLServerException as e:\n        # if there was an exception\n        # check if the user had access to the dataset\n        if e.code == NO_ACCESS_GRANTED_ERRCODE:\n            raise OpenMLPrivateDatasetError(e.message) from None\n\n        raise e\n    finally:\n        if remove_dataset_cache:\n            _remove_cache_dir_for_id(DATASETS_CACHE_DIR_NAME, did_cache_dir)\n\n    return _create_dataset_from_description(\n        description,\n        features_file,\n        qualities_file,\n        arff_file,\n        parquet_file,\n        cache_format,\n    )\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.get_datasets","title":"<code>get_datasets(dataset_ids, download_data=False, download_qualities=False)</code>","text":"<p>Download datasets.</p> <p>This function iterates :meth:<code>openml.datasets.get_dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_ids</code> <code>iterable</code> <p>Integers or strings representing dataset ids or dataset names. If dataset names are specified, the least recent still active dataset version is returned.</p> required <code>download_data</code> <code>bool</code> <p>If True, also download the data file. Beware that some datasets are large and it might make the operation noticeably slower. Metadata is also still retrieved. If False, create the OpenMLDataset and only populate it with the metadata. The data may later be retrieved through the <code>OpenMLDataset.get_data</code> method.</p> <code>False</code> <code>download_qualities</code> <code>(bool, optional(default=True))</code> <p>If True, also download qualities.xml file. If False it skip the qualities.xml.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>list of datasets</code> <p>A list of dataset objects.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def get_datasets(\n    dataset_ids: list[str | int],\n    download_data: bool = False,  # noqa: FBT001, FBT002\n    download_qualities: bool = False,  # noqa: FBT001, FBT002\n) -&gt; list[OpenMLDataset]:\n    \"\"\"Download datasets.\n\n    This function iterates :meth:`openml.datasets.get_dataset`.\n\n    Parameters\n    ----------\n    dataset_ids : iterable\n        Integers or strings representing dataset ids or dataset names.\n        If dataset names are specified, the least recent still active dataset version is returned.\n    download_data : bool, optional\n        If True, also download the data file. Beware that some datasets are large and it might\n        make the operation noticeably slower. Metadata is also still retrieved.\n        If False, create the OpenMLDataset and only populate it with the metadata.\n        The data may later be retrieved through the `OpenMLDataset.get_data` method.\n    download_qualities : bool, optional (default=True)\n        If True, also download qualities.xml file. If False it skip the qualities.xml.\n\n    Returns\n    -------\n    datasets : list of datasets\n        A list of dataset objects.\n    \"\"\"\n    datasets = []\n    for dataset_id in dataset_ids:\n        datasets.append(\n            get_dataset(dataset_id, download_data, download_qualities=download_qualities),\n        )\n    return datasets\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.list_datasets","title":"<code>list_datasets(data_id=None, offset=None, size=None, status=None, tag=None, data_name=None, data_version=None, number_instances=None, number_features=None, number_classes=None, number_missing_values=None)</code>","text":"<p>Return a dataframe of all dataset which are on OpenML.</p> <p>Supports large amount of results.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>list</code> <p>A list of data ids, to specify which datasets should be listed</p> <code>None</code> <code>offset</code> <code>int</code> <p>The number of datasets to skip, starting from the first.</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of datasets to show.</p> <code>None</code> <code>status</code> <code>str</code> <p>Should be {active, in_preparation, deactivated}. By default active datasets are returned, but also datasets from another status can be requested.</p> <code>None</code> <code>tag</code> <code>str</code> <code>None</code> <code>data_name</code> <code>str</code> <code>None</code> <code>data_version</code> <code>int</code> <code>None</code> <code>number_instances</code> <code>int | str</code> <code>None</code> <code>number_features</code> <code>int | str</code> <code>None</code> <code>number_classes</code> <code>int | str</code> <code>None</code> <code>number_missing_values</code> <code>int | str</code> <code>None</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>dataframe</code> <p>Each row maps to a dataset Each column contains the following information: - dataset id - name - format - status If qualities are calculated for the dataset, some of these are also included as columns.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def list_datasets(\n    data_id: list[int] | None = None,\n    offset: int | None = None,\n    size: int | None = None,\n    status: str | None = None,\n    tag: str | None = None,\n    data_name: str | None = None,\n    data_version: int | None = None,\n    number_instances: int | str | None = None,\n    number_features: int | str | None = None,\n    number_classes: int | str | None = None,\n    number_missing_values: int | str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Return a dataframe of all dataset which are on OpenML.\n\n    Supports large amount of results.\n\n    Parameters\n    ----------\n    data_id : list, optional\n        A list of data ids, to specify which datasets should be\n        listed\n    offset : int, optional\n        The number of datasets to skip, starting from the first.\n    size : int, optional\n        The maximum number of datasets to show.\n    status : str, optional\n        Should be {active, in_preparation, deactivated}. By\n        default active datasets are returned, but also datasets\n        from another status can be requested.\n    tag : str, optional\n    data_name : str, optional\n    data_version : int, optional\n    number_instances : int | str, optional\n    number_features : int | str, optional\n    number_classes : int | str, optional\n    number_missing_values : int | str, optional\n\n    Returns\n    -------\n    datasets: dataframe\n        Each row maps to a dataset\n        Each column contains the following information:\n        - dataset id\n        - name\n        - format\n        - status\n        If qualities are calculated for the dataset, some of\n        these are also included as columns.\n    \"\"\"\n    listing_call = partial(\n        _list_datasets,\n        data_id=data_id,\n        status=status,\n        tag=tag,\n        data_name=data_name,\n        data_version=data_version,\n        number_instances=number_instances,\n        number_features=number_features,\n        number_classes=number_classes,\n        number_missing_values=number_missing_values,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.list_qualities","title":"<code>list_qualities()</code>","text":"<p>Return list of data qualities available.</p> <p>The function performs an API call to retrieve the entire list of data qualities that are computed on the datasets uploaded.</p> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def list_qualities() -&gt; list[str]:\n    \"\"\"Return list of data qualities available.\n\n    The function performs an API call to retrieve the entire list of\n    data qualities that are computed on the datasets uploaded.\n\n    Returns\n    -------\n    list\n    \"\"\"\n    api_call = \"data/qualities/list\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    qualities = xmltodict.parse(xml_string, force_list=(\"oml:quality\"))\n    # Minimalistic check if the XML is useful\n    if \"oml:data_qualities_list\" not in qualities:\n        raise ValueError('Error in return XML, does not contain \"oml:data_qualities_list\"')\n\n    if not isinstance(qualities[\"oml:data_qualities_list\"][\"oml:quality\"], list):\n        raise TypeError('Error in return XML, does not contain \"oml:quality\" as a list')\n\n    return qualities[\"oml:data_qualities_list\"][\"oml:quality\"]\n</code></pre>"},{"location":"reference/datasets/#openml.datasets.status_update","title":"<code>status_update(data_id, status)</code>","text":"<p>Updates the status of a dataset to either 'active' or 'deactivated'. Please see the OpenML API documentation for a description of the status and all legal status transitions: https://docs.openml.org/concepts/data/#dataset-status</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>The data id of the dataset</p> required <code>status</code> <code>(str)</code> <p>'active' or 'deactivated'</p> required Source code in <code>openml/datasets/functions.py</code> <pre><code>def status_update(data_id: int, status: Literal[\"active\", \"deactivated\"]) -&gt; None:\n    \"\"\"\n    Updates the status of a dataset to either 'active' or 'deactivated'.\n    Please see the OpenML API documentation for a description of the status\n    and all legal status transitions:\n    https://docs.openml.org/concepts/data/#dataset-status\n\n    Parameters\n    ----------\n    data_id : int\n        The data id of the dataset\n    status : str,\n        'active' or 'deactivated'\n    \"\"\"\n    legal_status = {\"active\", \"deactivated\"}\n    if status not in legal_status:\n        raise ValueError(f\"Illegal status value. Legal values: {legal_status}\")\n\n    data: openml._api_calls.DATA_TYPE = {\"data_id\": data_id, \"status\": status}\n    result_xml = openml._api_calls._perform_api_call(\"data/status/update\", \"post\", data=data)\n    result = xmltodict.parse(result_xml)\n    server_data_id = result[\"oml:data_status_update\"][\"oml:id\"]\n    server_status = result[\"oml:data_status_update\"][\"oml:status\"]\n    if status != server_status or int(data_id) != int(server_data_id):\n        # This should never happen\n        raise ValueError(\"Data id/status does not collide\")\n</code></pre>"},{"location":"reference/datasets/data_feature/","title":"data_feature","text":""},{"location":"reference/datasets/data_feature/#openml.datasets.data_feature.OpenMLDataFeature","title":"<code>OpenMLDataFeature</code>","text":"<p>Data Feature (a.k.a. Attribute) object.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of this feature</p> required <code>name</code> <code>str</code> <p>Name of the feature</p> required <code>data_type</code> <code>str</code> <p>can be nominal, numeric, string, date (corresponds to arff)</p> required <code>nominal_values</code> <code>list(str)</code> <p>list of the possible values, in case of nominal attribute</p> required <code>number_missing_values</code> <code>int</code> <p>Number of rows that have a missing value for this feature.</p> required <code>ontologies</code> <code>list(str)</code> <p>list of ontologies attached to this feature. An ontology describes the concept that are described in a feature. An ontology is defined by an URL where the information is provided.</p> <code>None</code> Source code in <code>openml/datasets/data_feature.py</code> <pre><code>class OpenMLDataFeature:\n    \"\"\"\n    Data Feature (a.k.a. Attribute) object.\n\n    Parameters\n    ----------\n    index : int\n        The index of this feature\n    name : str\n        Name of the feature\n    data_type : str\n        can be nominal, numeric, string, date (corresponds to arff)\n    nominal_values : list(str)\n        list of the possible values, in case of nominal attribute\n    number_missing_values : int\n        Number of rows that have a missing value for this feature.\n    ontologies : list(str)\n        list of ontologies attached to this feature. An ontology describes the\n        concept that are described in a feature. An ontology is defined by an\n        URL where the information is provided.\n    \"\"\"\n\n    LEGAL_DATA_TYPES: ClassVar[Sequence[str]] = [\"nominal\", \"numeric\", \"string\", \"date\"]\n\n    def __init__(  # noqa: PLR0913\n        self,\n        index: int,\n        name: str,\n        data_type: str,\n        nominal_values: list[str],\n        number_missing_values: int,\n        ontologies: list[str] | None = None,\n    ):\n        if not isinstance(index, int):\n            raise TypeError(f\"Index must be `int` but is {type(index)}\")\n\n        if data_type not in self.LEGAL_DATA_TYPES:\n            raise ValueError(\n                f\"data type should be in {self.LEGAL_DATA_TYPES!s}, found: {data_type}\",\n            )\n\n        if data_type == \"nominal\":\n            if nominal_values is None:\n                raise TypeError(\n                    \"Dataset features require attribute `nominal_values` for nominal \"\n                    \"feature type.\",\n                )\n\n            if not isinstance(nominal_values, list):\n                raise TypeError(\n                    \"Argument `nominal_values` is of wrong datatype, should be list, \"\n                    f\"but is {type(nominal_values)}\",\n                )\n        elif nominal_values is not None:\n            raise TypeError(\"Argument `nominal_values` must be None for non-nominal feature.\")\n\n        if not isinstance(number_missing_values, int):\n            msg = f\"number_missing_values must be int but is {type(number_missing_values)}\"\n            raise TypeError(msg)\n\n        self.index = index\n        self.name = str(name)\n        self.data_type = str(data_type)\n        self.nominal_values = nominal_values\n        self.number_missing_values = number_missing_values\n        self.ontologies = ontologies\n\n    def __repr__(self) -&gt; str:\n        return \"[%d - %s (%s)]\" % (self.index, self.name, self.data_type)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, OpenMLDataFeature) and self.__dict__ == other.__dict__\n\n    def _repr_pretty_(self, pp: pretty.PrettyPrinter, cycle: bool) -&gt; None:  # noqa: FBT001, ARG002\n        pp.text(str(self))\n</code></pre>"},{"location":"reference/datasets/dataset/","title":"dataset","text":""},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset","title":"<code>OpenMLDataset</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>Dataset object.</p> <p>Allows fetching and uploading datasets to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> required <code>data_format</code> <code>str</code> <p>Format of the dataset which can be either 'arff' or 'sparse_arff'.</p> <code>'arff'</code> <code>cache_format</code> <code>str</code> <p>Format for caching the dataset which can be either 'feather' or 'pickle'.</p> <code>'pickle'</code> <code>dataset_id</code> <code>int</code> <p>Id autogenerated by the server.</p> <code>None</code> <code>version</code> <code>int</code> <p>Version of this dataset. '1' for original version. Auto-incremented by server.</p> <code>None</code> <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> <code>None</code> <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> <code>None</code> <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> <code>None</code> <code>upload_date</code> <code>str</code> <p>The date-time when the dataset was uploaded, generated by server.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> <code>None</code> <code>licence</code> <code>str</code> <p>License of the data.</p> <code>None</code> <code>url</code> <code>str</code> <p>Valid URL, points to actual data file. The file can be on the OpenML server or another dataset repository.</p> <code>None</code> <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset.</p> <code>None</code> <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes.</p> <code>None</code> <code>version_label</code> <code>str</code> <p>Version label provided by user. Can be a date, hash, or some other type of id.</p> <code>None</code> <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> <code>None</code> <code>tag</code> <code>str</code> <p>Tags, describing the algorithms.</p> <code>None</code> <code>visibility</code> <code>str</code> <p>Who can see the dataset. Typical values: 'Everyone','All my friends','Only me'. Can also be any of the user's circles.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <code>update_comment</code> <code>str</code> <p>An explanation for when the dataset is uploaded.</p> <code>None</code> <code>md5_checksum</code> <code>str</code> <p>MD5 checksum to check if the dataset is downloaded without corruption.</p> <code>None</code> <code>data_file</code> <code>str</code> <p>Path to where the dataset is located.</p> <code>None</code> <code>features_file</code> <code>dict</code> <p>A dictionary of dataset features, which maps a feature index to a OpenMLDataFeature.</p> <code>None</code> <code>qualities_file</code> <code>dict</code> <p>A dictionary of dataset qualities, which maps a quality name to a quality value.</p> <code>None</code> <code>dataset</code> <code>str | None</code> <p>Serialized arff dataset string.</p> <code>None</code> <code>parquet_url</code> <code>str | None</code> <p>This is the URL to the storage location where the dataset files are hosted. This can be a MinIO bucket URL. If specified, the data will be accessed from this URL when reading the files.</p> <code>None</code> <code>parquet_file</code> <code>str | None</code> <p>Path to the local file.</p> <code>None</code> Source code in <code>openml/datasets/dataset.py</code> <pre><code>class OpenMLDataset(OpenMLBase):\n    \"\"\"Dataset object.\n\n    Allows fetching and uploading datasets to OpenML.\n\n    Parameters\n    ----------\n    name : str\n        Name of the dataset.\n    description : str\n        Description of the dataset.\n    data_format : str\n        Format of the dataset which can be either 'arff' or 'sparse_arff'.\n    cache_format : str\n        Format for caching the dataset which can be either 'feather' or 'pickle'.\n    dataset_id : int, optional\n        Id autogenerated by the server.\n    version : int, optional\n        Version of this dataset. '1' for original version.\n        Auto-incremented by server.\n    creator : str, optional\n        The person who created the dataset.\n    contributor : str, optional\n        People who contributed to the current version of the dataset.\n    collection_date : str, optional\n        The date the data was originally collected, given by the uploader.\n    upload_date : str, optional\n        The date-time when the dataset was uploaded, generated by server.\n    language : str, optional\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    licence : str, optional\n        License of the data.\n    url : str, optional\n        Valid URL, points to actual data file.\n        The file can be on the OpenML server or another dataset repository.\n    default_target_attribute : str, optional\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column,\n        if present in the dataset.\n    ignore_attribute : str | list, optional\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n    version_label : str, optional\n        Version label provided by user.\n        Can be a date, hash, or some other type of id.\n    citation : str, optional\n        Reference(s) that should be cited when building on this data.\n    tag : str, optional\n        Tags, describing the algorithms.\n    visibility : str, optional\n        Who can see the dataset.\n        Typical values: 'Everyone','All my friends','Only me'.\n        Can also be any of the user's circles.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n    update_comment : str, optional\n        An explanation for when the dataset is uploaded.\n    md5_checksum : str, optional\n        MD5 checksum to check if the dataset is downloaded without corruption.\n    data_file : str, optional\n        Path to where the dataset is located.\n    features_file : dict, optional\n        A dictionary of dataset features,\n        which maps a feature index to a OpenMLDataFeature.\n    qualities_file : dict, optional\n        A dictionary of dataset qualities,\n        which maps a quality name to a quality value.\n    dataset: string, optional\n        Serialized arff dataset string.\n    parquet_url: string, optional\n        This is the URL to the storage location where the dataset files are hosted.\n        This can be a MinIO bucket URL. If specified, the data will be accessed\n        from this URL when reading the files.\n    parquet_file: string, optional\n        Path to the local file.\n    \"\"\"\n\n    def __init__(  # noqa: C901, PLR0912, PLR0913, PLR0915\n        self,\n        name: str,\n        description: str | None,\n        data_format: Literal[\"arff\", \"sparse_arff\"] = \"arff\",\n        cache_format: Literal[\"feather\", \"pickle\"] = \"pickle\",\n        dataset_id: int | None = None,\n        version: int | None = None,\n        creator: str | None = None,\n        contributor: str | None = None,\n        collection_date: str | None = None,\n        upload_date: str | None = None,\n        language: str | None = None,\n        licence: str | None = None,\n        url: str | None = None,\n        default_target_attribute: str | None = None,\n        row_id_attribute: str | None = None,\n        ignore_attribute: str | list[str] | None = None,\n        version_label: str | None = None,\n        citation: str | None = None,\n        tag: str | None = None,\n        visibility: str | None = None,\n        original_data_url: str | None = None,\n        paper_url: str | None = None,\n        update_comment: str | None = None,\n        md5_checksum: str | None = None,\n        data_file: str | None = None,\n        features_file: str | None = None,\n        qualities_file: str | None = None,\n        dataset: str | None = None,\n        parquet_url: str | None = None,\n        parquet_file: str | None = None,\n    ):\n        if cache_format not in [\"feather\", \"pickle\"]:\n            raise ValueError(\n                \"cache_format must be one of 'feather' or 'pickle. \"\n                f\"Invalid format specified: {cache_format}\",\n            )\n\n        def find_invalid_characters(string: str, pattern: str) -&gt; str:\n            invalid_chars = set()\n            regex = re.compile(pattern)\n            for char in string:\n                if not regex.match(char):\n                    invalid_chars.add(char)\n            return \",\".join(\n                [f\"'{char}'\" if char != \"'\" else f'\"{char}\"' for char in invalid_chars],\n            )\n\n        if dataset_id is None:\n            pattern = \"^[\\x00-\\x7f]*$\"\n            if description and not re.match(pattern, description):\n                # not basiclatin (XSD complains)\n                invalid_characters = find_invalid_characters(description, pattern)\n                raise ValueError(\n                    f\"Invalid symbols {invalid_characters} in description: {description}\",\n                )\n            pattern = \"^[\\x00-\\x7f]*$\"\n            if citation and not re.match(pattern, citation):\n                # not basiclatin (XSD complains)\n                invalid_characters = find_invalid_characters(citation, pattern)\n                raise ValueError(\n                    f\"Invalid symbols {invalid_characters} in citation: {citation}\",\n                )\n            pattern = \"^[a-zA-Z0-9_\\\\-\\\\.\\\\(\\\\),]+$\"\n            if not re.match(pattern, name):\n                # regex given by server in error message\n                invalid_characters = find_invalid_characters(name, pattern)\n                raise ValueError(f\"Invalid symbols {invalid_characters} in name: {name}\")\n\n        self.ignore_attribute: list[str] | None = None\n        if isinstance(ignore_attribute, str):\n            self.ignore_attribute = [ignore_attribute]\n        elif isinstance(ignore_attribute, list) or ignore_attribute is None:\n            self.ignore_attribute = ignore_attribute\n        else:\n            raise ValueError(\"Wrong data type for ignore_attribute. Should be list.\")\n\n        # TODO add function to check if the name is casual_string128\n        # Attributes received by querying the RESTful API\n        self.dataset_id = int(dataset_id) if dataset_id is not None else None\n        self.name = name\n        self.version = int(version) if version is not None else None\n        self.description = description\n        self.cache_format = cache_format\n        # Has to be called format, otherwise there will be an XML upload error\n        self.format = data_format\n        self.creator = creator\n        self.contributor = contributor\n        self.collection_date = collection_date\n        self.upload_date = upload_date\n        self.language = language\n        self.licence = licence\n        self.url = url\n        self.default_target_attribute = default_target_attribute\n        self.row_id_attribute = row_id_attribute\n\n        self.version_label = version_label\n        self.citation = citation\n        self.tag = tag\n        self.visibility = visibility\n        self.original_data_url = original_data_url\n        self.paper_url = paper_url\n        self.update_comment = update_comment\n        self.md5_checksum = md5_checksum\n        self.data_file = data_file\n        self.parquet_file = parquet_file\n        self._dataset = dataset\n        self._parquet_url = parquet_url\n\n        self._features: dict[int, OpenMLDataFeature] | None = None\n        self._qualities: dict[str, float] | None = None\n        self._no_qualities_found = False\n\n        if features_file is not None:\n            self._features = _read_features(Path(features_file))\n\n        # \"\" was the old default value by `get_dataset` and maybe still used by some\n        if qualities_file == \"\":\n            # TODO(0.15): to switch to \"qualities_file is not None\" below and remove warning\n            warnings.warn(\n                \"Starting from Version 0.15 `qualities_file` must be None and not an empty string \"\n                \"to avoid reading the qualities from file. Set `qualities_file` to None to avoid \"\n                \"this warning.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n            qualities_file = None\n\n        if qualities_file is not None:\n            self._qualities = _read_qualities(Path(qualities_file))\n\n        if data_file is not None:\n            data_pickle, data_feather, feather_attribute = self._compressed_cache_file_paths(\n                Path(data_file)\n            )\n            self.data_pickle_file = data_pickle if Path(data_pickle).exists() else None\n            self.data_feather_file = data_feather if Path(data_feather).exists() else None\n            self.feather_attribute_file = feather_attribute if Path(feather_attribute) else None\n        else:\n            self.data_pickle_file = None\n            self.data_feather_file = None\n            self.feather_attribute_file = None\n\n    @property\n    def features(self) -&gt; dict[int, OpenMLDataFeature]:\n        \"\"\"Get the features of this dataset.\"\"\"\n        if self._features is None:\n            # TODO(eddiebergman): These should return a value so we can set it to be not None\n            self._load_features()\n\n        assert self._features is not None\n        return self._features\n\n    @property\n    def qualities(self) -&gt; dict[str, float] | None:\n        \"\"\"Get the qualities of this dataset.\"\"\"\n        # TODO(eddiebergman): Better docstring, I don't know what qualities means\n\n        # We have to check `_no_qualities_found` as there might not be qualities for a dataset\n        if self._qualities is None and (not self._no_qualities_found):\n            self._load_qualities()\n\n        return self._qualities\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Get the dataset numeric id.\"\"\"\n        return self.dataset_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | None]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        # Obtain number of features in accordance with lazy loading.\n        n_features: int | None = None\n        if self._qualities is not None and self._qualities[\"NumberOfFeatures\"] is not None:\n            n_features = int(self._qualities[\"NumberOfFeatures\"])\n        elif self._features is not None:\n            n_features = len(self._features)\n\n        fields: dict[str, int | str | None] = {\n            \"Name\": self.name,\n            \"Version\": self.version,\n            \"Format\": self.format,\n            \"Licence\": self.licence,\n            \"Download URL\": self.url,\n            \"Data file\": str(self.data_file) if self.data_file is not None else None,\n            \"Pickle file\": (\n                str(self.data_pickle_file) if self.data_pickle_file is not None else None\n            ),\n            \"# of features\": n_features,\n        }\n        if self.upload_date is not None:\n            fields[\"Upload Date\"] = self.upload_date.replace(\"T\", \" \")\n        if self.dataset_id is not None:\n            fields[\"OpenML URL\"] = self.openml_url\n        if self._qualities is not None and self._qualities[\"NumberOfInstances\"] is not None:\n            fields[\"# of instances\"] = int(self._qualities[\"NumberOfInstances\"])\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Name\",\n            \"Version\",\n            \"Format\",\n            \"Upload Date\",\n            \"Licence\",\n            \"Download URL\",\n            \"OpenML URL\",\n            \"Data File\",\n            \"Pickle File\",\n            \"# of features\",\n            \"# of instances\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, OpenMLDataset):\n            return False\n\n        server_fields = {\n            \"dataset_id\",\n            \"version\",\n            \"upload_date\",\n            \"url\",\n            \"_parquet_url\",\n            \"dataset\",\n            \"data_file\",\n            \"format\",\n            \"cache_format\",\n        }\n\n        cache_fields = {\n            \"_dataset\",\n            \"data_file\",\n            \"data_pickle_file\",\n            \"data_feather_file\",\n            \"feather_attribute_file\",\n            \"parquet_file\",\n        }\n\n        # check that common keys and values are identical\n        ignore_fields = server_fields | cache_fields\n        self_keys = set(self.__dict__.keys()) - ignore_fields\n        other_keys = set(other.__dict__.keys()) - ignore_fields\n        return self_keys == other_keys and all(\n            self.__dict__[key] == other.__dict__[key] for key in self_keys\n        )\n\n    def _download_data(self) -&gt; None:\n        \"\"\"Download ARFF data file to standard cache directory. Set `self.data_file`.\"\"\"\n        # import required here to avoid circular import.\n        from .functions import _get_dataset_arff, _get_dataset_parquet\n\n        skip_parquet = os.environ.get(OPENML_SKIP_PARQUET_ENV_VAR, \"false\").casefold() == \"true\"\n        if self._parquet_url is not None and not skip_parquet:\n            parquet_file = _get_dataset_parquet(self)\n            self.parquet_file = None if parquet_file is None else str(parquet_file)\n        if self.parquet_file is None:\n            self.data_file = str(_get_dataset_arff(self))\n\n    def _get_arff(self, format: str) -&gt; dict:  # noqa: A002\n        \"\"\"Read ARFF file and return decoded arff.\n\n        Reads the file referenced in self.data_file.\n\n        Parameters\n        ----------\n        format : str\n            Format of the ARFF file.\n            Must be one of 'arff' or 'sparse_arff' or a string that will be either of those\n            when converted to lower case.\n\n\n\n        Returns\n        -------\n        dict\n            Decoded arff.\n\n        \"\"\"\n        # TODO: add a partial read method which only returns the attribute\n        # headers of the corresponding .arff file!\n        import struct\n\n        filename = self.data_file\n        assert filename is not None\n        filepath = Path(filename)\n\n        bits = 8 * struct.calcsize(\"P\")\n\n        # Files can be considered too large on a 32-bit system,\n        # if it exceeds 120mb (slightly more than covtype dataset size)\n        # This number is somewhat arbitrary.\n        if bits != 64:\n            MB_120 = 120_000_000\n            file_size = filepath.stat().st_size\n            if file_size &gt; MB_120:\n                raise NotImplementedError(\n                    f\"File {filename} too big for {file_size}-bit system ({bits} bytes).\",\n                )\n\n        if format.lower() == \"arff\":\n            return_type = arff.DENSE\n        elif format.lower() == \"sparse_arff\":\n            return_type = arff.COO\n        else:\n            raise ValueError(f\"Unknown data format {format}\")\n\n        def decode_arff(fh: Any) -&gt; dict:\n            decoder = arff.ArffDecoder()\n            return decoder.decode(fh, encode_nominal=True, return_type=return_type)  # type: ignore\n\n        if filepath.suffix.endswith(\".gz\"):\n            with gzip.open(filename) as zipfile:\n                return decode_arff(zipfile)\n        else:\n            with filepath.open(encoding=\"utf8\") as fh:\n                return decode_arff(fh)\n\n    def _parse_data_from_arff(  # noqa: C901, PLR0912, PLR0915\n        self,\n        arff_file_path: Path,\n    ) -&gt; tuple[pd.DataFrame | scipy.sparse.csr_matrix, list[bool], list[str]]:\n        \"\"\"Parse all required data from arff file.\n\n        Parameters\n        ----------\n        arff_file_path : str\n            Path to the file on disk.\n\n        Returns\n        -------\n        Tuple[Union[pd.DataFrame, scipy.sparse.csr_matrix], List[bool], List[str]]\n            DataFrame or csr_matrix: dataset\n            List[bool]: List indicating which columns contain categorical variables.\n            List[str]: List of column names.\n        \"\"\"\n        try:\n            data = self._get_arff(self.format)\n        except OSError as e:\n            logger.critical(\n                f\"Please check that the data file {arff_file_path} is there and can be read.\",\n            )\n            raise e\n\n        ARFF_DTYPES_TO_PD_DTYPE = {\n            \"INTEGER\": \"integer\",\n            \"REAL\": \"floating\",\n            \"NUMERIC\": \"floating\",\n            \"STRING\": \"string\",\n        }\n        attribute_dtype = {}\n        attribute_names = []\n        categories_names = {}\n        categorical = []\n        for name, type_ in data[\"attributes\"]:\n            # if the feature is nominal and a sparse matrix is\n            # requested, the categories need to be numeric\n            if isinstance(type_, list) and self.format.lower() == \"sparse_arff\":\n                try:\n                    # checks if the strings which should be the class labels\n                    # can be encoded into integers\n                    pd.factorize(type_)[0]\n                except ValueError as e:\n                    raise ValueError(\n                        \"Categorical data needs to be numeric when using sparse ARFF.\"\n                    ) from e\n\n            # string can only be supported with pandas DataFrame\n            elif type_ == \"STRING\" and self.format.lower() == \"sparse_arff\":\n                raise ValueError(\"Dataset containing strings is not supported with sparse ARFF.\")\n\n            # infer the dtype from the ARFF header\n            if isinstance(type_, list):\n                categorical.append(True)\n                categories_names[name] = type_\n                if len(type_) == 2:\n                    type_norm = [cat.lower().capitalize() for cat in type_]\n                    if {\"True\", \"False\"} == set(type_norm):\n                        categories_names[name] = [cat == \"True\" for cat in type_norm]\n                        attribute_dtype[name] = \"boolean\"\n                    else:\n                        attribute_dtype[name] = \"categorical\"\n                else:\n                    attribute_dtype[name] = \"categorical\"\n            else:\n                categorical.append(False)\n                attribute_dtype[name] = ARFF_DTYPES_TO_PD_DTYPE[type_]\n            attribute_names.append(name)\n\n        if self.format.lower() == \"sparse_arff\":\n            X = data[\"data\"]\n            X_shape = (max(X[1]) + 1, max(X[2]) + 1)\n            X = scipy.sparse.coo_matrix((X[0], (X[1], X[2])), shape=X_shape, dtype=np.float32)\n            X = X.tocsr()\n        elif self.format.lower() == \"arff\":\n            X = pd.DataFrame(data[\"data\"], columns=attribute_names)\n\n            col = []\n            for column_name in X.columns:\n                if attribute_dtype[column_name] in (\"categorical\", \"boolean\"):\n                    categories = self._unpack_categories(\n                        X[column_name],  # type: ignore\n                        categories_names[column_name],\n                    )\n                    col.append(categories)\n                elif attribute_dtype[column_name] in (\"floating\", \"integer\"):\n                    X_col = X[column_name]\n                    if X_col.min() &gt;= 0 and X_col.max() &lt;= 255:\n                        try:\n                            X_col_uint = X_col.astype(\"uint8\")\n                            if (X_col == X_col_uint).all():\n                                col.append(X_col_uint)\n                                continue\n                        except ValueError:\n                            pass\n                    col.append(X[column_name])\n                else:\n                    col.append(X[column_name])\n            X = pd.concat(col, axis=1)\n        else:\n            raise ValueError(f\"Dataset format '{self.format}' is not a valid format.\")\n\n        return X, categorical, attribute_names  # type: ignore\n\n    def _compressed_cache_file_paths(self, data_file: Path) -&gt; tuple[Path, Path, Path]:\n        data_pickle_file = data_file.with_suffix(\".pkl.py3\")\n        data_feather_file = data_file.with_suffix(\".feather\")\n        feather_attribute_file = data_file.with_suffix(\".feather.attributes.pkl.py3\")\n        return data_pickle_file, data_feather_file, feather_attribute_file\n\n    def _cache_compressed_file_from_file(\n        self,\n        data_file: Path,\n    ) -&gt; tuple[pd.DataFrame | scipy.sparse.csr_matrix, list[bool], list[str]]:\n        \"\"\"Store data from the local file in compressed format.\n\n        If a local parquet file is present it will be used instead of the arff file.\n        Sets cache_format to 'pickle' if data is sparse.\n        \"\"\"\n        (\n            data_pickle_file,\n            data_feather_file,\n            feather_attribute_file,\n        ) = self._compressed_cache_file_paths(data_file)\n\n        attribute_names, categorical, data = self._parse_data_from_file(data_file)\n\n        # Feather format does not work for sparse datasets, so we use pickle for sparse datasets\n        if scipy.sparse.issparse(data):\n            self.cache_format = \"pickle\"\n\n        logger.info(f\"{self.cache_format} write {self.name}\")\n        if self.cache_format == \"feather\":\n            assert isinstance(data, pd.DataFrame)\n\n            data.to_feather(data_feather_file)\n            with open(feather_attribute_file, \"wb\") as fh:  # noqa: PTH123\n                pickle.dump((categorical, attribute_names), fh, pickle.HIGHEST_PROTOCOL)\n            self.data_feather_file = data_feather_file\n            self.feather_attribute_file = feather_attribute_file\n\n        else:\n            with open(data_pickle_file, \"wb\") as fh:  # noqa: PTH123\n                pickle.dump((data, categorical, attribute_names), fh, pickle.HIGHEST_PROTOCOL)\n            self.data_pickle_file = data_pickle_file\n\n        data_file = data_pickle_file if self.cache_format == \"pickle\" else data_feather_file\n        logger.debug(f\"Saved dataset {int(self.dataset_id or -1)}: {self.name} to file {data_file}\")\n\n        return data, categorical, attribute_names\n\n    def _parse_data_from_file(\n        self,\n        data_file: Path,\n    ) -&gt; tuple[list[str], list[bool], pd.DataFrame | scipy.sparse.csr_matrix]:\n        if data_file.suffix == \".arff\":\n            data, categorical, attribute_names = self._parse_data_from_arff(data_file)\n        elif data_file.suffix == \".pq\":\n            attribute_names, categorical, data = self._parse_data_from_pq(data_file)\n        else:\n            raise ValueError(f\"Unknown file type for file '{data_file}'.\")\n\n        return attribute_names, categorical, data\n\n    def _parse_data_from_pq(self, data_file: Path) -&gt; tuple[list[str], list[bool], pd.DataFrame]:\n        try:\n            data = pd.read_parquet(data_file)\n        except Exception as e:\n            raise Exception(f\"File: {data_file}\") from e\n        categorical = [data[c].dtype.name == \"category\" for c in data.columns]\n        attribute_names = list(data.columns)\n        return attribute_names, categorical, data\n\n    def _load_data(self) -&gt; tuple[pd.DataFrame, list[bool], list[str]]:  # noqa: PLR0912, C901, PLR0915\n        \"\"\"Load data from compressed format or arff. Download data if not present on disk.\"\"\"\n        need_to_create_pickle = self.cache_format == \"pickle\" and self.data_pickle_file is None\n        need_to_create_feather = self.cache_format == \"feather\" and self.data_feather_file is None\n\n        if need_to_create_pickle or need_to_create_feather:\n            if self.data_file is None:\n                self._download_data()\n\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n            data, cats, attrs = self._cache_compressed_file_from_file(Path(file_to_load))\n            return _ensure_dataframe(data, attrs), cats, attrs\n\n        # helper variable to help identify where errors occur\n        fpath = self.data_feather_file if self.cache_format == \"feather\" else self.data_pickle_file\n        logger.info(f\"{self.cache_format} load data {self.name}\")\n        try:\n            if self.cache_format == \"feather\":\n                assert self.data_feather_file is not None\n                assert self.feather_attribute_file is not None\n\n                data = pd.read_feather(self.data_feather_file)\n                fpath = self.feather_attribute_file\n                with self.feather_attribute_file.open(\"rb\") as fh:\n                    categorical, attribute_names = pickle.load(fh)  # noqa: S301\n            else:\n                assert self.data_pickle_file is not None\n                with self.data_pickle_file.open(\"rb\") as fh:\n                    data, categorical, attribute_names = pickle.load(fh)  # noqa: S301\n\n        except FileNotFoundError as e:\n            raise ValueError(\n                f\"Cannot find file for dataset {self.name} at location '{fpath}'.\"\n            ) from e\n        except (EOFError, ModuleNotFoundError, ValueError, AttributeError) as e:\n            error_message = getattr(e, \"message\", e.args[0])\n            hint = \"\"\n\n            if isinstance(e, EOFError):\n                readable_error = \"Detected a corrupt cache file\"\n            elif isinstance(e, (ModuleNotFoundError, AttributeError)):\n                readable_error = \"Detected likely dependency issues\"\n                hint = (\n                    \"This can happen if the cache was constructed with a different pandas version \"\n                    \"than the one that is used to load the data. See also \"\n                )\n                if isinstance(e, ModuleNotFoundError):\n                    hint += \"https://github.com/openml/openml-python/issues/918. \"\n                elif isinstance(e, AttributeError):\n                    hint += \"https://github.com/openml/openml-python/pull/1121. \"\n\n            elif isinstance(e, ValueError) and \"unsupported pickle protocol\" in e.args[0]:\n                readable_error = \"Encountered unsupported pickle protocol\"\n            else:\n                raise e\n\n            logger.warning(\n                f\"{readable_error} when loading dataset {self.id} from '{fpath}'. \"\n                f\"{hint}\"\n                f\"Error message was: {error_message}. \"\n                \"We will continue loading data from the arff-file, \"\n                \"but this will be much slower for big datasets. \"\n                \"Please manually delete the cache file if you want OpenML-Python \"\n                \"to attempt to reconstruct it.\",\n            )\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n            attr, cat, df = self._parse_data_from_file(Path(file_to_load))\n            return _ensure_dataframe(df), cat, attr\n\n        data_up_to_date = isinstance(data, pd.DataFrame) or scipy.sparse.issparse(data)\n        if self.cache_format == \"pickle\" and not data_up_to_date:\n            logger.info(\"Updating outdated pickle file.\")\n            file_to_load = self.data_file if self.parquet_file is None else self.parquet_file\n            assert file_to_load is not None\n\n            data, cats, attrs = self._cache_compressed_file_from_file(Path(file_to_load))\n\n        return _ensure_dataframe(data, attribute_names), categorical, attribute_names\n\n    @staticmethod\n    def _unpack_categories(series: pd.Series, categories: list) -&gt; pd.Series:\n        # nan-likes can not be explicitly specified as a category\n        def valid_category(cat: Any) -&gt; bool:\n            return isinstance(cat, str) or (cat is not None and not np.isnan(cat))\n\n        filtered_categories = [c for c in categories if valid_category(c)]\n        col = []\n        for x in series:\n            try:\n                col.append(categories[int(x)])\n            except (TypeError, ValueError):\n                col.append(np.nan)\n\n        # We require two lines to create a series of categories as detailed here:\n        # https://pandas.pydata.org/pandas-docs/version/0.24/user_guide/categorical.html#series-creation\n        raw_cat = pd.Categorical(col, ordered=True, categories=filtered_categories)\n        return pd.Series(raw_cat, index=series.index, name=series.name)\n\n    def get_data(  # noqa: C901\n        self,\n        target: list[str] | str | None = None,\n        include_row_id: bool = False,  # noqa: FBT001, FBT002\n        include_ignore_attribute: bool = False,  # noqa: FBT001, FBT002\n    ) -&gt; tuple[pd.DataFrame, pd.Series | None, list[bool], list[str]]:\n        \"\"\"Returns dataset content as dataframes.\n\n        Parameters\n        ----------\n        target : string, List[str] or None (default=None)\n            Name of target column to separate from the data.\n            Splitting multiple columns is currently not supported.\n        include_row_id : boolean (default=False)\n            Whether to include row ids in the returned dataset.\n        include_ignore_attribute : boolean (default=False)\n            Whether to include columns that are marked as \"ignore\"\n            on the server in the dataset.\n\n\n        Returns\n        -------\n        X : dataframe, shape (n_samples, n_columns)\n            Dataset, may have sparse dtypes in the columns if required.\n        y : pd.Series, shape (n_samples, ) or None\n            Target column\n        categorical_indicator : list[bool]\n            Mask that indicate categorical features.\n        attribute_names : list[str]\n            List of attribute names.\n        \"\"\"\n        data, categorical_mask, attribute_names = self._load_data()\n\n        to_exclude = []\n        if not include_row_id and self.row_id_attribute is not None:\n            if isinstance(self.row_id_attribute, str):\n                to_exclude.append(self.row_id_attribute)\n            elif isinstance(self.row_id_attribute, Iterable):\n                to_exclude.extend(self.row_id_attribute)\n\n        if not include_ignore_attribute and self.ignore_attribute is not None:\n            if isinstance(self.ignore_attribute, str):\n                to_exclude.append(self.ignore_attribute)\n            elif isinstance(self.ignore_attribute, Iterable):\n                to_exclude.extend(self.ignore_attribute)\n\n        if len(to_exclude) &gt; 0:\n            logger.info(f\"Going to remove the following attributes: {to_exclude}\")\n            keep = np.array([column not in to_exclude for column in attribute_names])\n            data = data.drop(columns=to_exclude)\n            categorical_mask = [cat for cat, k in zip(categorical_mask, keep) if k]\n            attribute_names = [att for att, k in zip(attribute_names, keep) if k]\n\n        if target is None:\n            return data, None, categorical_mask, attribute_names\n\n        if isinstance(target, str):\n            target_names = target.split(\",\") if \",\" in target else [target]\n        else:\n            target_names = target\n\n        # All the assumptions below for the target are dependant on the number of targets being 1\n        n_targets = len(target_names)\n        if n_targets &gt; 1:\n            raise NotImplementedError(f\"Number of targets {n_targets} not implemented.\")\n\n        target_name = target_names[0]\n        x = data.drop(columns=[target_name])\n        y = data[target_name].squeeze()\n\n        # Finally, remove the target from the list of attributes and categorical mask\n        target_index = attribute_names.index(target_name)\n        categorical_mask.pop(target_index)\n        attribute_names.remove(target_name)\n\n        assert isinstance(y, pd.Series)\n        return x, y, categorical_mask, attribute_names\n\n    def _load_features(self) -&gt; None:\n        \"\"\"Load the features metadata from the server and store it in the dataset object.\"\"\"\n        # Delayed Import to avoid circular imports or having to import all of dataset.functions to\n        # import OpenMLDataset.\n        from openml.datasets.functions import _get_dataset_features_file\n\n        if self.dataset_id is None:\n            raise ValueError(\n                \"No dataset id specified. Please set the dataset id. Otherwise we cannot load \"\n                \"metadata.\",\n            )\n\n        features_file = _get_dataset_features_file(None, self.dataset_id)\n        self._features = _read_features(features_file)\n\n    def _load_qualities(self) -&gt; None:\n        \"\"\"Load qualities information from the server and store it in the dataset object.\"\"\"\n        # same reason as above for _load_features\n        from openml.datasets.functions import _get_dataset_qualities_file\n\n        if self.dataset_id is None:\n            raise ValueError(\n                \"No dataset id specified. Please set the dataset id. Otherwise we cannot load \"\n                \"metadata.\",\n            )\n\n        qualities_file = _get_dataset_qualities_file(None, self.dataset_id)\n\n        if qualities_file is None:\n            self._no_qualities_found = True\n        else:\n            self._qualities = _read_qualities(qualities_file)\n\n    def retrieve_class_labels(self, target_name: str = \"class\") -&gt; None | list[str]:\n        \"\"\"Reads the datasets arff to determine the class-labels.\n\n        If the task has no class labels (for example a regression problem)\n        it returns None. Necessary because the data returned by get_data\n        only contains the indices of the classes, while OpenML needs the real\n        classname when uploading the results of a run.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target attribute\n\n        Returns\n        -------\n        list\n        \"\"\"\n        for feature in self.features.values():\n            if feature.name == target_name:\n                if feature.data_type == \"nominal\":\n                    return feature.nominal_values\n\n                if feature.data_type == \"string\":\n                    # Rel.: #1311\n                    # The target is invalid for a classification task if the feature type is string\n                    # and not nominal. For such miss-configured tasks, we silently fix it here as\n                    # we can safely interpreter string as nominal.\n                    df, *_ = self.get_data()\n                    return list(df[feature.name].unique())\n\n        return None\n\n    def get_features_by_type(  # noqa: C901\n        self,\n        data_type: str,\n        exclude: list[str] | None = None,\n        exclude_ignore_attribute: bool = True,  # noqa: FBT002, FBT001\n        exclude_row_id_attribute: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; list[int]:\n        \"\"\"\n        Return indices of features of a given type, e.g. all nominal features.\n        Optional parameters to exclude various features by index or ontology.\n\n        Parameters\n        ----------\n        data_type : str\n            The data type to return (e.g., nominal, numeric, date, string)\n        exclude : list(int)\n            List of columns to exclude from the return value\n        exclude_ignore_attribute : bool\n            Whether to exclude the defined ignore attributes (and adapt the\n            return values as if these indices are not present)\n        exclude_row_id_attribute : bool\n            Whether to exclude the defined row id attributes (and adapt the\n            return values as if these indices are not present)\n\n        Returns\n        -------\n        result : list\n            a list of indices that have the specified data type\n        \"\"\"\n        if data_type not in OpenMLDataFeature.LEGAL_DATA_TYPES:\n            raise TypeError(\"Illegal feature type requested\")\n        if self.ignore_attribute is not None and not isinstance(self.ignore_attribute, list):\n            raise TypeError(\"ignore_attribute should be a list\")\n        if self.row_id_attribute is not None and not isinstance(self.row_id_attribute, str):\n            raise TypeError(\"row id attribute should be a str\")\n        if exclude is not None and not isinstance(exclude, list):\n            raise TypeError(\"Exclude should be a list\")\n            # assert all(isinstance(elem, str) for elem in exclude),\n            #            \"Exclude should be a list of strings\"\n        to_exclude = []\n        if exclude is not None:\n            to_exclude.extend(exclude)\n        if exclude_ignore_attribute and self.ignore_attribute is not None:\n            to_exclude.extend(self.ignore_attribute)\n        if exclude_row_id_attribute and self.row_id_attribute is not None:\n            to_exclude.append(self.row_id_attribute)\n\n        result = []\n        offset = 0\n        # this function assumes that everything in to_exclude will\n        # be 'excluded' from the dataset (hence the offset)\n        for idx in self.features:\n            name = self.features[idx].name\n            if name in to_exclude:\n                offset += 1\n            elif self.features[idx].data_type == data_type:\n                result.append(idx - offset)\n        return result\n\n    def _get_file_elements(self) -&gt; dict:\n        \"\"\"Adds the 'dataset' to file elements.\"\"\"\n        file_elements: dict = {}\n        path = None if self.data_file is None else Path(self.data_file).absolute()\n\n        if self._dataset is not None:\n            file_elements[\"dataset\"] = self._dataset\n        elif path is not None and path.exists():\n            with path.open(\"rb\") as fp:\n                file_elements[\"dataset\"] = fp.read()\n\n            try:\n                dataset_utf8 = str(file_elements[\"dataset\"], encoding=\"utf8\")\n                arff.ArffDecoder().decode(dataset_utf8, encode_nominal=True)\n            except arff.ArffException as e:\n                raise ValueError(\"The file you have provided is not a valid arff file.\") from e\n\n        elif self.url is None:\n            raise ValueError(\"No valid url/path to the data file was given.\")\n        return file_elements\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.dataset_id = int(xml_response[\"oml:upload_data_set\"][\"oml:id\"])\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        props = [\n            \"id\",\n            \"name\",\n            \"version\",\n            \"description\",\n            \"format\",\n            \"creator\",\n            \"contributor\",\n            \"collection_date\",\n            \"upload_date\",\n            \"language\",\n            \"licence\",\n            \"url\",\n            \"default_target_attribute\",\n            \"row_id_attribute\",\n            \"ignore_attribute\",\n            \"version_label\",\n            \"citation\",\n            \"tag\",\n            \"visibility\",\n            \"original_data_url\",\n            \"paper_url\",\n            \"update_comment\",\n            \"md5_checksum\",\n        ]\n\n        prop_values = {}\n        for prop in props:\n            content = getattr(self, prop, None)\n            if content is not None:\n                prop_values[\"oml:\" + prop] = content\n\n        return {\n            \"oml:data_set_description\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                **prop_values,\n            }\n        }\n</code></pre>"},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset.features","title":"<code>features: dict[int, OpenMLDataFeature]</code>  <code>property</code>","text":"<p>Get the features of this dataset.</p>"},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Get the dataset numeric id.</p>"},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset.qualities","title":"<code>qualities: dict[str, float] | None</code>  <code>property</code>","text":"<p>Get the qualities of this dataset.</p>"},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset.get_data","title":"<code>get_data(target=None, include_row_id=False, include_ignore_attribute=False)</code>","text":"<p>Returns dataset content as dataframes.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>(string, List[str] or None(default=None))</code> <p>Name of target column to separate from the data. Splitting multiple columns is currently not supported.</p> <code>None</code> <code>include_row_id</code> <code>boolean(default=False)</code> <p>Whether to include row ids in the returned dataset.</p> <code>False</code> <code>include_ignore_attribute</code> <code>boolean(default=False)</code> <p>Whether to include columns that are marked as \"ignore\" on the server in the dataset.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>X</code> <code>(dataframe, shape(n_samples, n_columns))</code> <p>Dataset, may have sparse dtypes in the columns if required.</p> <code>y</code> <code>(Series, shape(n_samples) or None)</code> <p>Target column</p> <code>categorical_indicator</code> <code>list[bool]</code> <p>Mask that indicate categorical features.</p> <code>attribute_names</code> <code>list[str]</code> <p>List of attribute names.</p> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def get_data(  # noqa: C901\n    self,\n    target: list[str] | str | None = None,\n    include_row_id: bool = False,  # noqa: FBT001, FBT002\n    include_ignore_attribute: bool = False,  # noqa: FBT001, FBT002\n) -&gt; tuple[pd.DataFrame, pd.Series | None, list[bool], list[str]]:\n    \"\"\"Returns dataset content as dataframes.\n\n    Parameters\n    ----------\n    target : string, List[str] or None (default=None)\n        Name of target column to separate from the data.\n        Splitting multiple columns is currently not supported.\n    include_row_id : boolean (default=False)\n        Whether to include row ids in the returned dataset.\n    include_ignore_attribute : boolean (default=False)\n        Whether to include columns that are marked as \"ignore\"\n        on the server in the dataset.\n\n\n    Returns\n    -------\n    X : dataframe, shape (n_samples, n_columns)\n        Dataset, may have sparse dtypes in the columns if required.\n    y : pd.Series, shape (n_samples, ) or None\n        Target column\n    categorical_indicator : list[bool]\n        Mask that indicate categorical features.\n    attribute_names : list[str]\n        List of attribute names.\n    \"\"\"\n    data, categorical_mask, attribute_names = self._load_data()\n\n    to_exclude = []\n    if not include_row_id and self.row_id_attribute is not None:\n        if isinstance(self.row_id_attribute, str):\n            to_exclude.append(self.row_id_attribute)\n        elif isinstance(self.row_id_attribute, Iterable):\n            to_exclude.extend(self.row_id_attribute)\n\n    if not include_ignore_attribute and self.ignore_attribute is not None:\n        if isinstance(self.ignore_attribute, str):\n            to_exclude.append(self.ignore_attribute)\n        elif isinstance(self.ignore_attribute, Iterable):\n            to_exclude.extend(self.ignore_attribute)\n\n    if len(to_exclude) &gt; 0:\n        logger.info(f\"Going to remove the following attributes: {to_exclude}\")\n        keep = np.array([column not in to_exclude for column in attribute_names])\n        data = data.drop(columns=to_exclude)\n        categorical_mask = [cat for cat, k in zip(categorical_mask, keep) if k]\n        attribute_names = [att for att, k in zip(attribute_names, keep) if k]\n\n    if target is None:\n        return data, None, categorical_mask, attribute_names\n\n    if isinstance(target, str):\n        target_names = target.split(\",\") if \",\" in target else [target]\n    else:\n        target_names = target\n\n    # All the assumptions below for the target are dependant on the number of targets being 1\n    n_targets = len(target_names)\n    if n_targets &gt; 1:\n        raise NotImplementedError(f\"Number of targets {n_targets} not implemented.\")\n\n    target_name = target_names[0]\n    x = data.drop(columns=[target_name])\n    y = data[target_name].squeeze()\n\n    # Finally, remove the target from the list of attributes and categorical mask\n    target_index = attribute_names.index(target_name)\n    categorical_mask.pop(target_index)\n    attribute_names.remove(target_name)\n\n    assert isinstance(y, pd.Series)\n    return x, y, categorical_mask, attribute_names\n</code></pre>"},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset.get_features_by_type","title":"<code>get_features_by_type(data_type, exclude=None, exclude_ignore_attribute=True, exclude_row_id_attribute=True)</code>","text":"<p>Return indices of features of a given type, e.g. all nominal features. Optional parameters to exclude various features by index or ontology.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>The data type to return (e.g., nominal, numeric, date, string)</p> required <code>exclude</code> <code>list(int)</code> <p>List of columns to exclude from the return value</p> <code>None</code> <code>exclude_ignore_attribute</code> <code>bool</code> <p>Whether to exclude the defined ignore attributes (and adapt the return values as if these indices are not present)</p> <code>True</code> <code>exclude_row_id_attribute</code> <code>bool</code> <p>Whether to exclude the defined row id attributes (and adapt the return values as if these indices are not present)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>result</code> <code>list</code> <p>a list of indices that have the specified data type</p> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def get_features_by_type(  # noqa: C901\n    self,\n    data_type: str,\n    exclude: list[str] | None = None,\n    exclude_ignore_attribute: bool = True,  # noqa: FBT002, FBT001\n    exclude_row_id_attribute: bool = True,  # noqa: FBT002, FBT001\n) -&gt; list[int]:\n    \"\"\"\n    Return indices of features of a given type, e.g. all nominal features.\n    Optional parameters to exclude various features by index or ontology.\n\n    Parameters\n    ----------\n    data_type : str\n        The data type to return (e.g., nominal, numeric, date, string)\n    exclude : list(int)\n        List of columns to exclude from the return value\n    exclude_ignore_attribute : bool\n        Whether to exclude the defined ignore attributes (and adapt the\n        return values as if these indices are not present)\n    exclude_row_id_attribute : bool\n        Whether to exclude the defined row id attributes (and adapt the\n        return values as if these indices are not present)\n\n    Returns\n    -------\n    result : list\n        a list of indices that have the specified data type\n    \"\"\"\n    if data_type not in OpenMLDataFeature.LEGAL_DATA_TYPES:\n        raise TypeError(\"Illegal feature type requested\")\n    if self.ignore_attribute is not None and not isinstance(self.ignore_attribute, list):\n        raise TypeError(\"ignore_attribute should be a list\")\n    if self.row_id_attribute is not None and not isinstance(self.row_id_attribute, str):\n        raise TypeError(\"row id attribute should be a str\")\n    if exclude is not None and not isinstance(exclude, list):\n        raise TypeError(\"Exclude should be a list\")\n        # assert all(isinstance(elem, str) for elem in exclude),\n        #            \"Exclude should be a list of strings\"\n    to_exclude = []\n    if exclude is not None:\n        to_exclude.extend(exclude)\n    if exclude_ignore_attribute and self.ignore_attribute is not None:\n        to_exclude.extend(self.ignore_attribute)\n    if exclude_row_id_attribute and self.row_id_attribute is not None:\n        to_exclude.append(self.row_id_attribute)\n\n    result = []\n    offset = 0\n    # this function assumes that everything in to_exclude will\n    # be 'excluded' from the dataset (hence the offset)\n    for idx in self.features:\n        name = self.features[idx].name\n        if name in to_exclude:\n            offset += 1\n        elif self.features[idx].data_type == data_type:\n            result.append(idx - offset)\n    return result\n</code></pre>"},{"location":"reference/datasets/dataset/#openml.datasets.dataset.OpenMLDataset.retrieve_class_labels","title":"<code>retrieve_class_labels(target_name='class')</code>","text":"<p>Reads the datasets arff to determine the class-labels.</p> <p>If the task has no class labels (for example a regression problem) it returns None. Necessary because the data returned by get_data only contains the indices of the classes, while OpenML needs the real classname when uploading the results of a run.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>Name of the target attribute</p> <code>'class'</code> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/datasets/dataset.py</code> <pre><code>def retrieve_class_labels(self, target_name: str = \"class\") -&gt; None | list[str]:\n    \"\"\"Reads the datasets arff to determine the class-labels.\n\n    If the task has no class labels (for example a regression problem)\n    it returns None. Necessary because the data returned by get_data\n    only contains the indices of the classes, while OpenML needs the real\n    classname when uploading the results of a run.\n\n    Parameters\n    ----------\n    target_name : str\n        Name of the target attribute\n\n    Returns\n    -------\n    list\n    \"\"\"\n    for feature in self.features.values():\n        if feature.name == target_name:\n            if feature.data_type == \"nominal\":\n                return feature.nominal_values\n\n            if feature.data_type == \"string\":\n                # Rel.: #1311\n                # The target is invalid for a classification task if the feature type is string\n                # and not nominal. For such miss-configured tasks, we silently fix it here as\n                # we can safely interpreter string as nominal.\n                df, *_ = self.get_data()\n                return list(df[feature.name].unique())\n\n    return None\n</code></pre>"},{"location":"reference/datasets/functions/","title":"functions","text":""},{"location":"reference/datasets/functions/#openml.datasets.functions.attributes_arff_from_df","title":"<code>attributes_arff_from_df(df)</code>","text":"<p>Describe attributes of the dataframe according to ARFF specification.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, shape(n_samples, n_features))</code> <p>The dataframe containing the data set.</p> required <p>Returns:</p> Name Type Description <code>attributes_arff</code> <code>list[str]</code> <p>The data set attributes as required by the ARFF format.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def attributes_arff_from_df(df: pd.DataFrame) -&gt; list[tuple[str, list[str] | str]]:\n    \"\"\"Describe attributes of the dataframe according to ARFF specification.\n\n    Parameters\n    ----------\n    df : DataFrame, shape (n_samples, n_features)\n        The dataframe containing the data set.\n\n    Returns\n    -------\n    attributes_arff : list[str]\n        The data set attributes as required by the ARFF format.\n    \"\"\"\n    PD_DTYPES_TO_ARFF_DTYPE = {\"integer\": \"INTEGER\", \"floating\": \"REAL\", \"string\": \"STRING\"}\n    attributes_arff: list[tuple[str, list[str] | str]] = []\n\n    if not all(isinstance(column_name, str) for column_name in df.columns):\n        logger.warning(\"Converting non-str column names to str.\")\n        df.columns = [str(column_name) for column_name in df.columns]\n\n    for column_name in df:\n        # skipna=True does not infer properly the dtype. The NA values are\n        # dropped before the inference instead.\n        column_dtype = pd.api.types.infer_dtype(df[column_name].dropna(), skipna=False)\n\n        if column_dtype == \"categorical\":\n            # for categorical feature, arff expects a list string. However, a\n            # categorical column can contain mixed type and should therefore\n            # raise an error asking to convert all entries to string.\n            categories = df[column_name].cat.categories\n            categories_dtype = pd.api.types.infer_dtype(categories)\n            if categories_dtype not in (\"string\", \"unicode\"):\n                raise ValueError(\n                    f\"The column '{column_name}' of the dataframe is of \"\n                    \"'category' dtype. Therefore, all values in \"\n                    \"this columns should be string. Please \"\n                    \"convert the entries which are not string. \"\n                    f\"Got {categories_dtype} dtype in this column.\",\n                )\n            attributes_arff.append((column_name, categories.tolist()))\n        elif column_dtype == \"boolean\":\n            # boolean are encoded as categorical.\n            attributes_arff.append((column_name, [\"True\", \"False\"]))\n        elif column_dtype in PD_DTYPES_TO_ARFF_DTYPE:\n            attributes_arff.append((column_name, PD_DTYPES_TO_ARFF_DTYPE[column_dtype]))\n        else:\n            raise ValueError(\n                f\"The dtype '{column_dtype}' of the column '{column_name}' is not \"\n                \"currently supported by liac-arff. Supported \"\n                \"dtypes are categorical, string, integer, \"\n                \"floating, and boolean.\",\n            )\n    return attributes_arff\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.check_datasets_active","title":"<code>check_datasets_active(dataset_ids, raise_error_if_not_exist=True)</code>","text":"<p>Check if the dataset ids provided are active.</p> <p>Raises an error if a dataset_id in the given list of dataset_ids does not exist on the server and <code>raise_error_if_not_exist</code> is set to True (default).</p> <p>Parameters:</p> Name Type Description Default <code>dataset_ids</code> <code>List[int]</code> <p>A list of integers representing dataset ids.</p> required <code>raise_error_if_not_exist</code> <code>bool(default=True)</code> <p>Flag that if activated can raise an error, if one or more of the given dataset ids do not exist on the server.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with items {did: bool}</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def check_datasets_active(\n    dataset_ids: list[int],\n    raise_error_if_not_exist: bool = True,  # noqa: FBT001, FBT002\n) -&gt; dict[int, bool]:\n    \"\"\"\n    Check if the dataset ids provided are active.\n\n    Raises an error if a dataset_id in the given list\n    of dataset_ids does not exist on the server and\n    `raise_error_if_not_exist` is set to True (default).\n\n    Parameters\n    ----------\n    dataset_ids : List[int]\n        A list of integers representing dataset ids.\n    raise_error_if_not_exist : bool (default=True)\n        Flag that if activated can raise an error, if one or more of the\n        given dataset ids do not exist on the server.\n\n    Returns\n    -------\n    dict\n        A dictionary with items {did: bool}\n    \"\"\"\n    datasets = list_datasets(status=\"all\", data_id=dataset_ids)\n    missing = set(dataset_ids) - set(datasets.index)\n    if raise_error_if_not_exist and missing:\n        missing_str = \", \".join(str(did) for did in missing)\n        raise ValueError(f\"Could not find dataset(s) {missing_str} in OpenML dataset list.\")\n    mask = datasets[\"status\"] == \"active\"\n    return dict(mask)\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.create_dataset","title":"<code>create_dataset(name, description, creator, contributor, collection_date, language, licence, attributes, data, default_target_attribute, ignore_attribute, citation, row_id_attribute=None, original_data_url=None, paper_url=None, update_comment=None, version_label=None)</code>","text":"<p>Create a dataset.</p> <p>This function creates an OpenMLDataset object. The OpenMLDataset object contains information related to the dataset and the actual data file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> required <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> required <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> required <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> required <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> required <code>licence</code> <code>str</code> <p>License of the data.</p> required <code>attributes</code> <code>list, dict, or 'auto'</code> <p>A list of tuples. Each tuple consists of the attribute name and type. If passing a pandas DataFrame, the attributes can be automatically inferred by passing <code>'auto'</code>. Specific attributes can be manually specified by a passing a dictionary where the key is the name of the attribute and the value is the data type of the attribute.</p> required <code>data</code> <code>(ndarray, list, dataframe, coo_matrix, shape(n_samples, n_features))</code> <p>An array that contains both the attributes and the targets. When providing a dataframe, the attribute names and type can be inferred by passing <code>attributes='auto'</code>. The target feature is indicated as meta-data of the dataset.</p> required <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> required <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes. Can have multiple values, comma separated.</p> required <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> required <code>version_label</code> <code>str</code> <p>Version label provided by user.  Can be a date, hash, or some other type of id.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset. If <code>data</code> is a dataframe and <code>row_id_attribute</code> is not specified, the index of the dataframe will be used as the <code>row_id_attribute</code>. If the name of the index is <code>None</code>, it will be discarded.</p> <p>.. versionadded: 0.8     Inference of <code>row_id_attribute</code> from a dataframe.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <code>update_comment</code> <code>str</code> <p>An explanation for when the dataset is uploaded.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>class</code> <code>`openml.OpenMLDataset`</code> <code>Dataset description.</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def create_dataset(  # noqa: C901, PLR0912, PLR0915\n    name: str,\n    description: str | None,\n    creator: str | None,\n    contributor: str | None,\n    collection_date: str | None,\n    language: str | None,\n    licence: str | None,\n    # TODO(eddiebergman): Docstring says `type` but I don't know what this is other than strings\n    # Edit: Found it could also be like [\"True\", \"False\"]\n    attributes: list[tuple[str, str | list[str]]] | dict[str, str | list[str]] | Literal[\"auto\"],\n    data: pd.DataFrame | np.ndarray | scipy.sparse.coo_matrix,\n    # TODO(eddiebergman): Function requires `default_target_attribute` exist but API allows None\n    default_target_attribute: str,\n    ignore_attribute: str | list[str] | None,\n    citation: str,\n    row_id_attribute: str | None = None,\n    original_data_url: str | None = None,\n    paper_url: str | None = None,\n    update_comment: str | None = None,\n    version_label: str | None = None,\n) -&gt; OpenMLDataset:\n    \"\"\"Create a dataset.\n\n    This function creates an OpenMLDataset object.\n    The OpenMLDataset object contains information related to the dataset\n    and the actual data file.\n\n    Parameters\n    ----------\n    name : str\n        Name of the dataset.\n    description : str\n        Description of the dataset.\n    creator : str\n        The person who created the dataset.\n    contributor : str\n        People who contributed to the current version of the dataset.\n    collection_date : str\n        The date the data was originally collected, given by the uploader.\n    language : str\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    licence : str\n        License of the data.\n    attributes : list, dict, or 'auto'\n        A list of tuples. Each tuple consists of the attribute name and type.\n        If passing a pandas DataFrame, the attributes can be automatically\n        inferred by passing ``'auto'``. Specific attributes can be manually\n        specified by a passing a dictionary where the key is the name of the\n        attribute and the value is the data type of the attribute.\n    data : ndarray, list, dataframe, coo_matrix, shape (n_samples, n_features)\n        An array that contains both the attributes and the targets. When\n        providing a dataframe, the attribute names and type can be inferred by\n        passing ``attributes='auto'``.\n        The target feature is indicated as meta-data of the dataset.\n    default_target_attribute : str\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    ignore_attribute : str | list\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n        Can have multiple values, comma separated.\n    citation : str\n        Reference(s) that should be cited when building on this data.\n    version_label : str, optional\n        Version label provided by user.\n         Can be a date, hash, or some other type of id.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column, if present in the\n        dataset. If ``data`` is a dataframe and ``row_id_attribute`` is not\n        specified, the index of the dataframe will be used as the\n        ``row_id_attribute``. If the name of the index is ``None``, it will\n        be discarded.\n\n        .. versionadded: 0.8\n            Inference of ``row_id_attribute`` from a dataframe.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n    update_comment : str, optional\n        An explanation for when the dataset is uploaded.\n\n    Returns\n    -------\n    class:`openml.OpenMLDataset`\n    Dataset description.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        # infer the row id from the index of the dataset\n        if row_id_attribute is None:\n            row_id_attribute = data.index.name\n        # When calling data.values, the index will be skipped.\n        # We need to reset the index such that it is part of the data.\n        if data.index.name is not None:\n            data = data.reset_index()\n\n    if attributes == \"auto\" or isinstance(attributes, dict):\n        if not isinstance(data, pd.DataFrame):\n            raise ValueError(\n                \"Automatically inferring attributes requires \"\n                f\"a pandas DataFrame. A {data!r} was given instead.\",\n            )\n        # infer the type of data for each column of the DataFrame\n        attributes_ = attributes_arff_from_df(data)\n        if isinstance(attributes, dict):\n            # override the attributes which was specified by the user\n            for attr_idx in range(len(attributes_)):\n                attr_name = attributes_[attr_idx][0]\n                if attr_name in attributes:\n                    attributes_[attr_idx] = (attr_name, attributes[attr_name])\n    else:\n        attributes_ = attributes\n    ignore_attributes = _expand_parameter(ignore_attribute)\n    _validated_data_attributes(ignore_attributes, attributes_, \"ignore_attribute\")\n\n    default_target_attributes = _expand_parameter(default_target_attribute)\n    _validated_data_attributes(default_target_attributes, attributes_, \"default_target_attribute\")\n\n    if row_id_attribute is not None:\n        is_row_id_an_attribute = any(attr[0] == row_id_attribute for attr in attributes_)\n        if not is_row_id_an_attribute:\n            raise ValueError(\n                \"'row_id_attribute' should be one of the data attribute. \"\n                f\" Got '{row_id_attribute}' while candidates are\"\n                f\" {[attr[0] for attr in attributes_]}.\",\n            )\n\n    if isinstance(data, pd.DataFrame):\n        if all(isinstance(dtype, pd.SparseDtype) for dtype in data.dtypes):\n            data = data.sparse.to_coo()\n            # liac-arff only support COO matrices with sorted rows\n            row_idx_sorted = np.argsort(data.row)  # type: ignore\n            data.row = data.row[row_idx_sorted]  # type: ignore\n            data.col = data.col[row_idx_sorted]  # type: ignore\n            data.data = data.data[row_idx_sorted]  # type: ignore\n        else:\n            data = data.to_numpy()\n\n    data_format: Literal[\"arff\", \"sparse_arff\"]\n    if isinstance(data, (list, np.ndarray)):\n        if isinstance(data[0], (list, np.ndarray)):\n            data_format = \"arff\"\n        elif isinstance(data[0], dict):\n            data_format = \"sparse_arff\"\n        else:\n            raise ValueError(\n                \"When giving a list or a numpy.ndarray, \"\n                \"they should contain a list/ numpy.ndarray \"\n                \"for dense data or a dictionary for sparse \"\n                f\"data. Got {data[0]!r} instead.\",\n            )\n    elif isinstance(data, coo_matrix):\n        data_format = \"sparse_arff\"\n    else:\n        raise ValueError(\n            \"When giving a list or a numpy.ndarray, \"\n            \"they should contain a list/ numpy.ndarray \"\n            \"for dense data or a dictionary for sparse \"\n            f\"data. Got {data[0]!r} instead.\",\n        )\n\n    arff_object = {\n        \"relation\": name,\n        \"description\": description,\n        \"attributes\": attributes_,\n        \"data\": data,\n    }\n\n    # serializes the ARFF dataset object and returns a string\n    arff_dataset = arff.dumps(arff_object)\n    try:\n        # check if ARFF is valid\n        decoder = arff.ArffDecoder()\n        return_type = arff.COO if data_format == \"sparse_arff\" else arff.DENSE\n        decoder.decode(arff_dataset, encode_nominal=True, return_type=return_type)\n    except arff.ArffException as e:\n        raise ValueError(\n            \"The arguments you have provided do not construct a valid ARFF file\"\n        ) from e\n\n    return OpenMLDataset(\n        name=name,\n        description=description,\n        data_format=data_format,\n        creator=creator,\n        contributor=contributor,\n        collection_date=collection_date,\n        language=language,\n        licence=licence,\n        default_target_attribute=default_target_attribute,\n        row_id_attribute=row_id_attribute,\n        ignore_attribute=ignore_attribute,\n        citation=citation,\n        version_label=version_label,\n        original_data_url=original_data_url,\n        paper_url=paper_url,\n        update_comment=update_comment,\n        dataset=arff_dataset,\n    )\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.data_feature_add_ontology","title":"<code>data_feature_add_ontology(data_id, index, ontology)</code>","text":"<p>An ontology describes the concept that are described in a feature. An ontology is defined by an URL where the information is provided. Adds an ontology (URL) to a given dataset feature (defined by a dataset id and index). The dataset has to exists on OpenML and needs to have been processed by the evaluation engine.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>id of the dataset to which the feature belongs</p> required <code>index</code> <code>int</code> <p>index of the feature in dataset (0-based)</p> required <code>ontology</code> <code>str</code> <p>URL to ontology (max. 256 characters)</p> required <p>Returns:</p> Type Description <code>True or throws an OpenML server exception</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def data_feature_add_ontology(data_id: int, index: int, ontology: str) -&gt; bool:\n    \"\"\"\n    An ontology describes the concept that are described in a feature. An\n    ontology is defined by an URL where the information is provided. Adds\n    an ontology (URL) to a given dataset feature (defined by a dataset id\n    and index). The dataset has to exists on OpenML and needs to have been\n    processed by the evaluation engine.\n\n    Parameters\n    ----------\n    data_id : int\n        id of the dataset to which the feature belongs\n    index : int\n        index of the feature in dataset (0-based)\n    ontology : str\n        URL to ontology (max. 256 characters)\n\n    Returns\n    -------\n    True or throws an OpenML server exception\n    \"\"\"\n    upload_data: dict[str, int | str] = {\"data_id\": data_id, \"index\": index, \"ontology\": ontology}\n    openml._api_calls._perform_api_call(\"data/feature/ontology/add\", \"post\", data=upload_data)\n    # an error will be thrown in case the request was unsuccessful\n    return True\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.data_feature_remove_ontology","title":"<code>data_feature_remove_ontology(data_id, index, ontology)</code>","text":"<p>Removes an existing ontology (URL) from a given dataset feature (defined by a dataset id and index). The dataset has to exists on OpenML and needs to have been processed by the evaluation engine. Ontology needs to be attached to the specific fearure.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>id of the dataset to which the feature belongs</p> required <code>index</code> <code>int</code> <p>index of the feature in dataset (0-based)</p> required <code>ontology</code> <code>str</code> <p>URL to ontology (max. 256 characters)</p> required <p>Returns:</p> Type Description <code>True or throws an OpenML server exception</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def data_feature_remove_ontology(data_id: int, index: int, ontology: str) -&gt; bool:\n    \"\"\"\n    Removes an existing ontology (URL) from a given dataset feature (defined\n    by a dataset id and index). The dataset has to exists on OpenML and needs\n    to have been processed by the evaluation engine. Ontology needs to be\n    attached to the specific fearure.\n\n    Parameters\n    ----------\n    data_id : int\n        id of the dataset to which the feature belongs\n    index : int\n        index of the feature in dataset (0-based)\n    ontology : str\n        URL to ontology (max. 256 characters)\n\n    Returns\n    -------\n    True or throws an OpenML server exception\n    \"\"\"\n    upload_data: dict[str, int | str] = {\"data_id\": data_id, \"index\": index, \"ontology\": ontology}\n    openml._api_calls._perform_api_call(\"data/feature/ontology/remove\", \"post\", data=upload_data)\n    # an error will be thrown in case the request was unsuccessful\n    return True\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.delete_dataset","title":"<code>delete_dataset(dataset_id)</code>","text":"<p>Delete dataset with id <code>dataset_id</code> from the OpenML server.</p> <p>This can only be done if you are the owner of the dataset and no tasks are attached to the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int</code> <p>OpenML id of the dataset</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def delete_dataset(dataset_id: int) -&gt; bool:\n    \"\"\"Delete dataset with id `dataset_id` from the OpenML server.\n\n    This can only be done if you are the owner of the dataset and\n    no tasks are attached to the dataset.\n\n    Parameters\n    ----------\n    dataset_id : int\n        OpenML id of the dataset\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"data\", dataset_id)\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.edit_dataset","title":"<code>edit_dataset(data_id, description=None, creator=None, contributor=None, collection_date=None, language=None, default_target_attribute=None, ignore_attribute=None, citation=None, row_id_attribute=None, original_data_url=None, paper_url=None)</code>","text":"<p>Edits an OpenMLDataset.</p> <p>In addition to providing the dataset id of the dataset to edit (through data_id), you must specify a value for at least one of the optional function arguments, i.e. one value for a field to edit.</p> <p>This function allows editing of both non-critical and critical fields. Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.</p> <ul> <li>Editing non-critical data fields is allowed for all authenticated users.</li> <li>Editing critical fields is allowed only for the owner, provided there are no tasks    associated with this dataset.</li> </ul> <p>If dataset has tasks or if the user is not the owner, the only way to edit critical fields is to use fork_dataset followed by edit_dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>ID of the dataset.</p> required <code>description</code> <code>str</code> <p>Description of the dataset.</p> <code>None</code> <code>creator</code> <code>str</code> <p>The person who created the dataset.</p> <code>None</code> <code>contributor</code> <code>str</code> <p>People who contributed to the current version of the dataset.</p> <code>None</code> <code>collection_date</code> <code>str</code> <p>The date the data was originally collected, given by the uploader.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language in which the data is represented. Starts with 1 upper case letter, rest lower case, e.g. 'English'.</p> <code>None</code> <code>default_target_attribute</code> <code>str</code> <p>The default target attribute, if it exists. Can have multiple values, comma separated.</p> <code>None</code> <code>ignore_attribute</code> <code>str | list</code> <p>Attributes that should be excluded in modelling, such as identifiers and indexes.</p> <code>None</code> <code>citation</code> <code>str</code> <p>Reference(s) that should be cited when building on this data.</p> <code>None</code> <code>row_id_attribute</code> <code>str</code> <p>The attribute that represents the row-id column, if present in the dataset. If <code>data</code> is a dataframe and <code>row_id_attribute</code> is not specified, the index of the dataframe will be used as the <code>row_id_attribute</code>. If the name of the index is <code>None</code>, it will be discarded.</p> <p>.. versionadded: 0.8     Inference of <code>row_id_attribute</code> from a dataframe.</p> <code>None</code> <code>original_data_url</code> <code>str</code> <p>For derived data, the url to the original dataset.</p> <code>None</code> <code>paper_url</code> <code>str</code> <p>Link to a paper describing the dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset id</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def edit_dataset(\n    data_id: int,\n    description: str | None = None,\n    creator: str | None = None,\n    contributor: str | None = None,\n    collection_date: str | None = None,\n    language: str | None = None,\n    default_target_attribute: str | None = None,\n    ignore_attribute: str | list[str] | None = None,\n    citation: str | None = None,\n    row_id_attribute: str | None = None,\n    original_data_url: str | None = None,\n    paper_url: str | None = None,\n) -&gt; int:\n    \"\"\"Edits an OpenMLDataset.\n\n    In addition to providing the dataset id of the dataset to edit (through data_id),\n    you must specify a value for at least one of the optional function arguments,\n    i.e. one value for a field to edit.\n\n    This function allows editing of both non-critical and critical fields.\n    Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.\n\n     - Editing non-critical data fields is allowed for all authenticated users.\n     - Editing critical fields is allowed only for the owner, provided there are no tasks\n       associated with this dataset.\n\n    If dataset has tasks or if the user is not the owner, the only way\n    to edit critical fields is to use fork_dataset followed by edit_dataset.\n\n    Parameters\n    ----------\n    data_id : int\n        ID of the dataset.\n    description : str\n        Description of the dataset.\n    creator : str\n        The person who created the dataset.\n    contributor : str\n        People who contributed to the current version of the dataset.\n    collection_date : str\n        The date the data was originally collected, given by the uploader.\n    language : str\n        Language in which the data is represented.\n        Starts with 1 upper case letter, rest lower case, e.g. 'English'.\n    default_target_attribute : str\n        The default target attribute, if it exists.\n        Can have multiple values, comma separated.\n    ignore_attribute : str | list\n        Attributes that should be excluded in modelling,\n        such as identifiers and indexes.\n    citation : str\n        Reference(s) that should be cited when building on this data.\n    row_id_attribute : str, optional\n        The attribute that represents the row-id column, if present in the\n        dataset. If ``data`` is a dataframe and ``row_id_attribute`` is not\n        specified, the index of the dataframe will be used as the\n        ``row_id_attribute``. If the name of the index is ``None``, it will\n        be discarded.\n\n        .. versionadded: 0.8\n            Inference of ``row_id_attribute`` from a dataframe.\n    original_data_url : str, optional\n        For derived data, the url to the original dataset.\n    paper_url : str, optional\n        Link to a paper describing the dataset.\n\n    Returns\n    -------\n    Dataset id\n    \"\"\"\n    if not isinstance(data_id, int):\n        raise TypeError(f\"`data_id` must be of type `int`, not {type(data_id)}.\")\n\n    # compose data edit parameters as xml\n    form_data = {\"data_id\": data_id}  # type: openml._api_calls.DATA_TYPE\n    xml = OrderedDict()  # type: 'OrderedDict[str, OrderedDict]'\n    xml[\"oml:data_edit_parameters\"] = OrderedDict()\n    xml[\"oml:data_edit_parameters\"][\"@xmlns:oml\"] = \"http://openml.org/openml\"\n    xml[\"oml:data_edit_parameters\"][\"oml:description\"] = description\n    xml[\"oml:data_edit_parameters\"][\"oml:creator\"] = creator\n    xml[\"oml:data_edit_parameters\"][\"oml:contributor\"] = contributor\n    xml[\"oml:data_edit_parameters\"][\"oml:collection_date\"] = collection_date\n    xml[\"oml:data_edit_parameters\"][\"oml:language\"] = language\n    xml[\"oml:data_edit_parameters\"][\"oml:default_target_attribute\"] = default_target_attribute\n    xml[\"oml:data_edit_parameters\"][\"oml:row_id_attribute\"] = row_id_attribute\n    xml[\"oml:data_edit_parameters\"][\"oml:ignore_attribute\"] = ignore_attribute\n    xml[\"oml:data_edit_parameters\"][\"oml:citation\"] = citation\n    xml[\"oml:data_edit_parameters\"][\"oml:original_data_url\"] = original_data_url\n    xml[\"oml:data_edit_parameters\"][\"oml:paper_url\"] = paper_url\n\n    # delete None inputs\n    for k in list(xml[\"oml:data_edit_parameters\"]):\n        if not xml[\"oml:data_edit_parameters\"][k]:\n            del xml[\"oml:data_edit_parameters\"][k]\n\n    file_elements = {\n        \"edit_parameters\": (\"description.xml\", xmltodict.unparse(xml)),\n    }  # type: openml._api_calls.FILE_ELEMENTS_TYPE\n    result_xml = openml._api_calls._perform_api_call(\n        \"data/edit\",\n        \"post\",\n        data=form_data,\n        file_elements=file_elements,\n    )\n    result = xmltodict.parse(result_xml)\n    data_id = result[\"oml:data_edit\"][\"oml:id\"]\n    return int(data_id)\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.fork_dataset","title":"<code>fork_dataset(data_id)</code>","text":"<p>Creates a new dataset version, with the authenticated user as the new owner.  The forked dataset can have distinct dataset meta-data,  but the actual data itself is shared with the original version.</p> <p>This API is intended for use when a user is unable to edit the critical fields of a dataset  through the edit_dataset API.  (Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.)</p> <p>Specifically, this happens when the user is:         1. Not the owner of the dataset.         2. User is the owner of the dataset, but the dataset has tasks.</p> <p>In these two cases the only way to edit critical fields is:         1. STEP 1: Fork the dataset using fork_dataset API         2. STEP 2: Call edit_dataset API on the forked version.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>id of the dataset to be forked</p> required <p>Returns:</p> Type Description <code>Dataset id of the forked dataset</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def fork_dataset(data_id: int) -&gt; int:\n    \"\"\"\n     Creates a new dataset version, with the authenticated user as the new owner.\n     The forked dataset can have distinct dataset meta-data,\n     but the actual data itself is shared with the original version.\n\n     This API is intended for use when a user is unable to edit the critical fields of a dataset\n     through the edit_dataset API.\n     (Critical fields are default_target_attribute, ignore_attribute, row_id_attribute.)\n\n     Specifically, this happens when the user is:\n            1. Not the owner of the dataset.\n            2. User is the owner of the dataset, but the dataset has tasks.\n\n     In these two cases the only way to edit critical fields is:\n            1. STEP 1: Fork the dataset using fork_dataset API\n            2. STEP 2: Call edit_dataset API on the forked version.\n\n\n    Parameters\n    ----------\n    data_id : int\n        id of the dataset to be forked\n\n    Returns\n    -------\n    Dataset id of the forked dataset\n\n    \"\"\"\n    if not isinstance(data_id, int):\n        raise TypeError(f\"`data_id` must be of type `int`, not {type(data_id)}.\")\n    # compose data fork parameters\n    form_data = {\"data_id\": data_id}  # type: openml._api_calls.DATA_TYPE\n    result_xml = openml._api_calls._perform_api_call(\"data/fork\", \"post\", data=form_data)\n    result = xmltodict.parse(result_xml)\n    data_id = result[\"oml:data_fork\"][\"oml:id\"]\n    return int(data_id)\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.get_dataset","title":"<code>get_dataset(dataset_id, download_data=False, version=None, error_if_multiple=False, cache_format='pickle', download_qualities=False, download_features_meta_data=False, download_all_files=False, force_refresh_cache=False)</code>","text":"<p>Download the OpenML dataset representation, optionally also download actual data file.</p> <p>This function is by default NOT thread/multiprocessing safe, as this function uses caching. A check will be performed to determine if the information has previously been downloaded to a cache, and if so be loaded from disk instead of retrieved from the server.</p> <p>To make this function thread safe, you can install the python package <code>oslo.concurrency</code>. If <code>oslo.concurrency</code> is installed <code>get_dataset</code> becomes thread safe.</p> <p>Alternatively, to make this function thread/multiprocessing safe initialize the cache first by calling <code>get_dataset(args)</code> once before calling <code>get_dataset(args)</code> many times in parallel. This will initialize the cache and later calls will use the cache in a thread/multiprocessing safe way.</p> <p>If dataset is retrieved by name, a version may be specified. If no version is specified and multiple versions of the dataset exist, the earliest version of the dataset that is still active will be returned. If no version is specified, multiple versions of the dataset exist and <code>exception_if_multiple</code> is set to <code>True</code>, this function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>int or str</code> <p>Dataset ID (integer) or dataset name (string) of the dataset to download.</p> required <code>download_data</code> <code>bool(default=False)</code> <p>If True, also download the data file. Beware that some datasets are large and it might make the operation noticeably slower. Metadata is also still retrieved. If False, create the OpenMLDataset and only populate it with the metadata. The data may later be retrieved through the <code>OpenMLDataset.get_data</code> method.</p> <code>False</code> <code>version</code> <code>(int, optional(default=None))</code> <p>Specifies the version if <code>dataset_id</code> is specified by name. If no version is specified, retrieve the least recent still active version.</p> <code>None</code> <code>error_if_multiple</code> <code>bool(default=False)</code> <p>If <code>True</code> raise an error if multiple datasets are found with matching criteria.</p> <code>False</code> <code>cache_format</code> <code>str(default='pickle') in {'pickle', 'feather'}</code> <p>Format for caching the dataset - may be feather or pickle Note that the default 'pickle' option may load slower than feather when no.of.rows is very high.</p> <code>'pickle'</code> <code>download_qualities</code> <code>bool(default=False)</code> <p>Option to download 'qualities' meta-data in addition to the minimal dataset description. If True, download and cache the qualities file. If False, create the OpenMLDataset without qualities metadata. The data may later be added to the OpenMLDataset through the <code>OpenMLDataset.load_metadata(qualities=True)</code> method.</p> <code>False</code> <code>download_features_meta_data</code> <code>bool(default=False)</code> <p>Option to download 'features' meta-data in addition to the minimal dataset description. If True, download and cache the features file. If False, create the OpenMLDataset without features metadata. The data may later be added to the OpenMLDataset through the <code>OpenMLDataset.load_metadata(features=True)</code> method.</p> <code>False</code> <code>download_all_files</code> <code>bool</code> <p>EXPERIMENTAL. Download all files related to the dataset that reside on the server. Useful for datasets which refer to auxiliary files (e.g., meta-album).</p> <code>False</code> <code>force_refresh_cache</code> <code>bool(default=False)</code> <p>Force the cache to refreshed by deleting the cache directory and re-downloading the data. Note, if <code>force_refresh_cache</code> is True, <code>get_dataset</code> is NOT thread/multiprocessing safe, because this creates a race condition to creating and deleting the cache; as in general with the cache.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dataset</code> <code>:class:`openml.OpenMLDataset`</code> <p>The downloaded dataset.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_dataset(  # noqa: C901, PLR0912\n    dataset_id: int | str,\n    download_data: bool = False,  # noqa: FBT002, FBT001\n    version: int | None = None,\n    error_if_multiple: bool = False,  # noqa: FBT002, FBT001\n    cache_format: Literal[\"pickle\", \"feather\"] = \"pickle\",\n    download_qualities: bool = False,  # noqa: FBT002, FBT001\n    download_features_meta_data: bool = False,  # noqa: FBT002, FBT001\n    download_all_files: bool = False,  # noqa: FBT002, FBT001\n    force_refresh_cache: bool = False,  # noqa: FBT001, FBT002\n) -&gt; OpenMLDataset:\n    \"\"\"Download the OpenML dataset representation, optionally also download actual data file.\n\n    This function is by default NOT thread/multiprocessing safe, as this function uses caching.\n    A check will be performed to determine if the information has previously been downloaded to a\n    cache, and if so be loaded from disk instead of retrieved from the server.\n\n    To make this function thread safe, you can install the python package ``oslo.concurrency``.\n    If ``oslo.concurrency`` is installed `get_dataset` becomes thread safe.\n\n    Alternatively, to make this function thread/multiprocessing safe initialize the cache first by\n    calling `get_dataset(args)` once before calling `get_dataset(args)` many times in parallel.\n    This will initialize the cache and later calls will use the cache in a thread/multiprocessing\n    safe way.\n\n    If dataset is retrieved by name, a version may be specified.\n    If no version is specified and multiple versions of the dataset exist,\n    the earliest version of the dataset that is still active will be returned.\n    If no version is specified, multiple versions of the dataset exist and\n    ``exception_if_multiple`` is set to ``True``, this function will raise an exception.\n\n    Parameters\n    ----------\n    dataset_id : int or str\n        Dataset ID (integer) or dataset name (string) of the dataset to download.\n    download_data : bool (default=False)\n        If True, also download the data file. Beware that some datasets are large and it might\n        make the operation noticeably slower. Metadata is also still retrieved.\n        If False, create the OpenMLDataset and only populate it with the metadata.\n        The data may later be retrieved through the `OpenMLDataset.get_data` method.\n    version : int, optional (default=None)\n        Specifies the version if `dataset_id` is specified by name.\n        If no version is specified, retrieve the least recent still active version.\n    error_if_multiple : bool (default=False)\n        If ``True`` raise an error if multiple datasets are found with matching criteria.\n    cache_format : str (default='pickle') in {'pickle', 'feather'}\n        Format for caching the dataset - may be feather or pickle\n        Note that the default 'pickle' option may load slower than feather when\n        no.of.rows is very high.\n    download_qualities : bool (default=False)\n        Option to download 'qualities' meta-data in addition to the minimal dataset description.\n        If True, download and cache the qualities file.\n        If False, create the OpenMLDataset without qualities metadata. The data may later be added\n        to the OpenMLDataset through the `OpenMLDataset.load_metadata(qualities=True)` method.\n    download_features_meta_data : bool (default=False)\n        Option to download 'features' meta-data in addition to the minimal dataset description.\n        If True, download and cache the features file.\n        If False, create the OpenMLDataset without features metadata. The data may later be added\n        to the OpenMLDataset through the `OpenMLDataset.load_metadata(features=True)` method.\n    download_all_files: bool (default=False)\n        EXPERIMENTAL. Download all files related to the dataset that reside on the server.\n        Useful for datasets which refer to auxiliary files (e.g., meta-album).\n    force_refresh_cache : bool (default=False)\n        Force the cache to refreshed by deleting the cache directory and re-downloading the data.\n        Note, if `force_refresh_cache` is True, `get_dataset` is NOT thread/multiprocessing safe,\n        because this creates a race condition to creating and deleting the cache; as in general with\n        the cache.\n\n    Returns\n    -------\n    dataset : :class:`openml.OpenMLDataset`\n        The downloaded dataset.\n    \"\"\"\n    if download_all_files:\n        warnings.warn(\n            \"``download_all_files`` is experimental and is likely to break with new releases.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n\n    if cache_format not in [\"feather\", \"pickle\"]:\n        raise ValueError(\n            \"cache_format must be one of 'feather' or 'pickle. \"\n            f\"Invalid format specified: {cache_format}\",\n        )\n\n    if isinstance(dataset_id, str):\n        try:\n            dataset_id = int(dataset_id)\n        except ValueError:\n            dataset_id = _name_to_id(dataset_id, version, error_if_multiple)  # type: ignore\n    elif not isinstance(dataset_id, int):\n        raise TypeError(\n            f\"`dataset_id` must be one of `str` or `int`, not {type(dataset_id)}.\",\n        )\n\n    if force_refresh_cache:\n        did_cache_dir = _get_cache_dir_for_id(DATASETS_CACHE_DIR_NAME, dataset_id)\n        if did_cache_dir.exists():\n            _remove_cache_dir_for_id(DATASETS_CACHE_DIR_NAME, did_cache_dir)\n\n    did_cache_dir = _create_cache_directory_for_id(\n        DATASETS_CACHE_DIR_NAME,\n        dataset_id,\n    )\n\n    remove_dataset_cache = True\n    try:\n        description = _get_dataset_description(did_cache_dir, dataset_id)\n        features_file = None\n        qualities_file = None\n\n        if download_features_meta_data:\n            features_file = _get_dataset_features_file(did_cache_dir, dataset_id)\n        if download_qualities:\n            qualities_file = _get_dataset_qualities_file(did_cache_dir, dataset_id)\n\n        parquet_file = None\n        skip_parquet = os.environ.get(OPENML_SKIP_PARQUET_ENV_VAR, \"false\").casefold() == \"true\"\n        download_parquet = \"oml:parquet_url\" in description and not skip_parquet\n        if download_parquet and (download_data or download_all_files):\n            try:\n                parquet_file = _get_dataset_parquet(\n                    description,\n                    download_all_files=download_all_files,\n                )\n            except urllib3.exceptions.MaxRetryError:\n                parquet_file = None\n\n        arff_file = None\n        if parquet_file is None and download_data:\n            if download_parquet:\n                logger.warning(\"Failed to download parquet, fallback on ARFF.\")\n            arff_file = _get_dataset_arff(description)\n\n        remove_dataset_cache = False\n    except OpenMLServerException as e:\n        # if there was an exception\n        # check if the user had access to the dataset\n        if e.code == NO_ACCESS_GRANTED_ERRCODE:\n            raise OpenMLPrivateDatasetError(e.message) from None\n\n        raise e\n    finally:\n        if remove_dataset_cache:\n            _remove_cache_dir_for_id(DATASETS_CACHE_DIR_NAME, did_cache_dir)\n\n    return _create_dataset_from_description(\n        description,\n        features_file,\n        qualities_file,\n        arff_file,\n        parquet_file,\n        cache_format,\n    )\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.get_datasets","title":"<code>get_datasets(dataset_ids, download_data=False, download_qualities=False)</code>","text":"<p>Download datasets.</p> <p>This function iterates :meth:<code>openml.datasets.get_dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_ids</code> <code>iterable</code> <p>Integers or strings representing dataset ids or dataset names. If dataset names are specified, the least recent still active dataset version is returned.</p> required <code>download_data</code> <code>bool</code> <p>If True, also download the data file. Beware that some datasets are large and it might make the operation noticeably slower. Metadata is also still retrieved. If False, create the OpenMLDataset and only populate it with the metadata. The data may later be retrieved through the <code>OpenMLDataset.get_data</code> method.</p> <code>False</code> <code>download_qualities</code> <code>(bool, optional(default=True))</code> <p>If True, also download qualities.xml file. If False it skip the qualities.xml.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>list of datasets</code> <p>A list of dataset objects.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def get_datasets(\n    dataset_ids: list[str | int],\n    download_data: bool = False,  # noqa: FBT001, FBT002\n    download_qualities: bool = False,  # noqa: FBT001, FBT002\n) -&gt; list[OpenMLDataset]:\n    \"\"\"Download datasets.\n\n    This function iterates :meth:`openml.datasets.get_dataset`.\n\n    Parameters\n    ----------\n    dataset_ids : iterable\n        Integers or strings representing dataset ids or dataset names.\n        If dataset names are specified, the least recent still active dataset version is returned.\n    download_data : bool, optional\n        If True, also download the data file. Beware that some datasets are large and it might\n        make the operation noticeably slower. Metadata is also still retrieved.\n        If False, create the OpenMLDataset and only populate it with the metadata.\n        The data may later be retrieved through the `OpenMLDataset.get_data` method.\n    download_qualities : bool, optional (default=True)\n        If True, also download qualities.xml file. If False it skip the qualities.xml.\n\n    Returns\n    -------\n    datasets : list of datasets\n        A list of dataset objects.\n    \"\"\"\n    datasets = []\n    for dataset_id in dataset_ids:\n        datasets.append(\n            get_dataset(dataset_id, download_data, download_qualities=download_qualities),\n        )\n    return datasets\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.list_datasets","title":"<code>list_datasets(data_id=None, offset=None, size=None, status=None, tag=None, data_name=None, data_version=None, number_instances=None, number_features=None, number_classes=None, number_missing_values=None)</code>","text":"<p>Return a dataframe of all dataset which are on OpenML.</p> <p>Supports large amount of results.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>list</code> <p>A list of data ids, to specify which datasets should be listed</p> <code>None</code> <code>offset</code> <code>int</code> <p>The number of datasets to skip, starting from the first.</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of datasets to show.</p> <code>None</code> <code>status</code> <code>str</code> <p>Should be {active, in_preparation, deactivated}. By default active datasets are returned, but also datasets from another status can be requested.</p> <code>None</code> <code>tag</code> <code>str</code> <code>None</code> <code>data_name</code> <code>str</code> <code>None</code> <code>data_version</code> <code>int</code> <code>None</code> <code>number_instances</code> <code>int | str</code> <code>None</code> <code>number_features</code> <code>int | str</code> <code>None</code> <code>number_classes</code> <code>int | str</code> <code>None</code> <code>number_missing_values</code> <code>int | str</code> <code>None</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>dataframe</code> <p>Each row maps to a dataset Each column contains the following information: - dataset id - name - format - status If qualities are calculated for the dataset, some of these are also included as columns.</p> Source code in <code>openml/datasets/functions.py</code> <pre><code>def list_datasets(\n    data_id: list[int] | None = None,\n    offset: int | None = None,\n    size: int | None = None,\n    status: str | None = None,\n    tag: str | None = None,\n    data_name: str | None = None,\n    data_version: int | None = None,\n    number_instances: int | str | None = None,\n    number_features: int | str | None = None,\n    number_classes: int | str | None = None,\n    number_missing_values: int | str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Return a dataframe of all dataset which are on OpenML.\n\n    Supports large amount of results.\n\n    Parameters\n    ----------\n    data_id : list, optional\n        A list of data ids, to specify which datasets should be\n        listed\n    offset : int, optional\n        The number of datasets to skip, starting from the first.\n    size : int, optional\n        The maximum number of datasets to show.\n    status : str, optional\n        Should be {active, in_preparation, deactivated}. By\n        default active datasets are returned, but also datasets\n        from another status can be requested.\n    tag : str, optional\n    data_name : str, optional\n    data_version : int, optional\n    number_instances : int | str, optional\n    number_features : int | str, optional\n    number_classes : int | str, optional\n    number_missing_values : int | str, optional\n\n    Returns\n    -------\n    datasets: dataframe\n        Each row maps to a dataset\n        Each column contains the following information:\n        - dataset id\n        - name\n        - format\n        - status\n        If qualities are calculated for the dataset, some of\n        these are also included as columns.\n    \"\"\"\n    listing_call = partial(\n        _list_datasets,\n        data_id=data_id,\n        status=status,\n        tag=tag,\n        data_name=data_name,\n        data_version=data_version,\n        number_instances=number_instances,\n        number_features=number_features,\n        number_classes=number_classes,\n        number_missing_values=number_missing_values,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.list_qualities","title":"<code>list_qualities()</code>","text":"<p>Return list of data qualities available.</p> <p>The function performs an API call to retrieve the entire list of data qualities that are computed on the datasets uploaded.</p> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/datasets/functions.py</code> <pre><code>def list_qualities() -&gt; list[str]:\n    \"\"\"Return list of data qualities available.\n\n    The function performs an API call to retrieve the entire list of\n    data qualities that are computed on the datasets uploaded.\n\n    Returns\n    -------\n    list\n    \"\"\"\n    api_call = \"data/qualities/list\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    qualities = xmltodict.parse(xml_string, force_list=(\"oml:quality\"))\n    # Minimalistic check if the XML is useful\n    if \"oml:data_qualities_list\" not in qualities:\n        raise ValueError('Error in return XML, does not contain \"oml:data_qualities_list\"')\n\n    if not isinstance(qualities[\"oml:data_qualities_list\"][\"oml:quality\"], list):\n        raise TypeError('Error in return XML, does not contain \"oml:quality\" as a list')\n\n    return qualities[\"oml:data_qualities_list\"][\"oml:quality\"]\n</code></pre>"},{"location":"reference/datasets/functions/#openml.datasets.functions.status_update","title":"<code>status_update(data_id, status)</code>","text":"<p>Updates the status of a dataset to either 'active' or 'deactivated'. Please see the OpenML API documentation for a description of the status and all legal status transitions: https://docs.openml.org/concepts/data/#dataset-status</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>int</code> <p>The data id of the dataset</p> required <code>status</code> <code>(str)</code> <p>'active' or 'deactivated'</p> required Source code in <code>openml/datasets/functions.py</code> <pre><code>def status_update(data_id: int, status: Literal[\"active\", \"deactivated\"]) -&gt; None:\n    \"\"\"\n    Updates the status of a dataset to either 'active' or 'deactivated'.\n    Please see the OpenML API documentation for a description of the status\n    and all legal status transitions:\n    https://docs.openml.org/concepts/data/#dataset-status\n\n    Parameters\n    ----------\n    data_id : int\n        The data id of the dataset\n    status : str,\n        'active' or 'deactivated'\n    \"\"\"\n    legal_status = {\"active\", \"deactivated\"}\n    if status not in legal_status:\n        raise ValueError(f\"Illegal status value. Legal values: {legal_status}\")\n\n    data: openml._api_calls.DATA_TYPE = {\"data_id\": data_id, \"status\": status}\n    result_xml = openml._api_calls._perform_api_call(\"data/status/update\", \"post\", data=data)\n    result = xmltodict.parse(result_xml)\n    server_data_id = result[\"oml:data_status_update\"][\"oml:id\"]\n    server_status = result[\"oml:data_status_update\"][\"oml:status\"]\n    if status != server_status or int(data_id) != int(server_data_id):\n        # This should never happen\n        raise ValueError(\"Data id/status does not collide\")\n</code></pre>"},{"location":"reference/evaluations/","title":"evaluations","text":""},{"location":"reference/evaluations/#openml.evaluations.OpenMLEvaluation","title":"<code>OpenMLEvaluation</code>","text":"<p>Contains all meta-information about a run / evaluation combination, according to the evaluation/list function</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>Refers to the run.</p> required <code>task_id</code> <code>int</code> <p>Refers to the task.</p> required <code>setup_id</code> <code>int</code> <p>Refers to the setup.</p> required <code>flow_id</code> <code>int</code> <p>Refers to the flow.</p> required <code>flow_name</code> <code>str</code> <p>Name of the referred flow.</p> required <code>data_id</code> <code>int</code> <p>Refers to the dataset.</p> required <code>data_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>function</code> <code>str</code> <p>The evaluation metric of this item (e.g., accuracy).</p> required <code>upload_time</code> <code>str</code> <p>The time of evaluation.</p> required <code>uploader</code> <code>int</code> <p>Uploader ID (user ID)</p> required <code>upload_name</code> <code>str</code> <p>Name of the uploader of this evaluation</p> required <code>value</code> <code>float</code> <p>The value (score) of this evaluation.</p> required <code>values</code> <code>List[float]</code> <p>The values (scores) per repeat and fold (if requested)</p> required <code>array_data</code> <code>str</code> <p>list of information per class. (e.g., in case of precision, auroc, recall)</p> <code>None</code> Source code in <code>openml/evaluations/evaluation.py</code> <pre><code>class OpenMLEvaluation:\n    \"\"\"\n    Contains all meta-information about a run / evaluation combination,\n    according to the evaluation/list function\n\n    Parameters\n    ----------\n    run_id : int\n        Refers to the run.\n    task_id : int\n        Refers to the task.\n    setup_id : int\n        Refers to the setup.\n    flow_id : int\n        Refers to the flow.\n    flow_name : str\n        Name of the referred flow.\n    data_id : int\n        Refers to the dataset.\n    data_name : str\n        The name of the dataset.\n    function : str\n        The evaluation metric of this item (e.g., accuracy).\n    upload_time : str\n        The time of evaluation.\n    uploader: int\n        Uploader ID (user ID)\n    upload_name : str\n        Name of the uploader of this evaluation\n    value : float\n        The value (score) of this evaluation.\n    values : List[float]\n        The values (scores) per repeat and fold (if requested)\n    array_data : str\n        list of information per class.\n        (e.g., in case of precision, auroc, recall)\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        run_id: int,\n        task_id: int,\n        setup_id: int,\n        flow_id: int,\n        flow_name: str,\n        data_id: int,\n        data_name: str,\n        function: str,\n        upload_time: str,\n        uploader: int,\n        uploader_name: str,\n        value: float | None,\n        values: list[float] | None,\n        array_data: str | None = None,\n    ):\n        self.run_id = run_id\n        self.task_id = task_id\n        self.setup_id = setup_id\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.data_id = data_id\n        self.data_name = data_name\n        self.function = function\n        self.upload_time = upload_time\n        self.uploader = uploader\n        self.uploader_name = uploader_name\n        self.value = value\n        self.values = values\n        self.array_data = array_data\n\n    def _to_dict(self) -&gt; dict:\n        return {\n            \"run_id\": self.run_id,\n            \"task_id\": self.task_id,\n            \"setup_id\": self.setup_id,\n            \"flow_id\": self.flow_id,\n            \"flow_name\": self.flow_name,\n            \"data_id\": self.data_id,\n            \"data_name\": self.data_name,\n            \"function\": self.function,\n            \"upload_time\": self.upload_time,\n            \"uploader\": self.uploader,\n            \"uploader_name\": self.uploader_name,\n            \"value\": self.value,\n            \"values\": self.values,\n            \"array_data\": self.array_data,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Evaluation\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"Upload Date\": self.upload_time,\n            \"Run ID\": self.run_id,\n            \"OpenML Run URL\": openml.runs.OpenMLRun.url_for_id(self.run_id),\n            \"Task ID\": self.task_id,\n            \"OpenML Task URL\": openml.tasks.OpenMLTask.url_for_id(self.task_id),\n            \"Flow ID\": self.flow_id,\n            \"OpenML Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"Setup ID\": self.setup_id,\n            \"Data ID\": self.data_id,\n            \"Data Name\": self.data_name,\n            \"OpenML Data URL\": openml.datasets.OpenMLDataset.url_for_id(self.data_id),\n            \"Metric Used\": self.function,\n            \"Result\": self.value,\n        }\n\n        order = [\n            \"Uploader Date\",\n            \"Run ID\",\n            \"OpenML Run URL\",\n            \"Task ID\",\n            \"OpenML Task URL\" \"Flow ID\",\n            \"OpenML Flow URL\",\n            \"Setup ID\",\n            \"Data ID\",\n            \"Data Name\",\n            \"OpenML Data URL\",\n            \"Metric Used\",\n            \"Result\",\n        ]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/evaluations/#openml.evaluations.list_evaluation_measures","title":"<code>list_evaluation_measures()</code>","text":"<p>Return list of evaluation measures available.</p> <p>The function performs an API call to retrieve the entire list of evaluation measures that are available.</p> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_evaluation_measures() -&gt; list[str]:\n    \"\"\"Return list of evaluation measures available.\n\n    The function performs an API call to retrieve the entire list of\n    evaluation measures that are available.\n\n    Returns\n    -------\n    list\n\n    \"\"\"\n    api_call = \"evaluationmeasure/list\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    qualities = xmltodict.parse(xml_string, force_list=(\"oml:measures\"))\n    # Minimalistic check if the XML is useful\n    if \"oml:evaluation_measures\" not in qualities:\n        raise ValueError('Error in return XML, does not contain \"oml:evaluation_measures\"')\n\n    if not isinstance(qualities[\"oml:evaluation_measures\"][\"oml:measures\"][0][\"oml:measure\"], list):\n        raise TypeError('Error in return XML, does not contain \"oml:measure\" as a list')\n\n    return qualities[\"oml:evaluation_measures\"][\"oml:measures\"][0][\"oml:measure\"]\n</code></pre>"},{"location":"reference/evaluations/#openml.evaluations.list_evaluations","title":"<code>list_evaluations(function, offset=None, size=None, tasks=None, setups=None, flows=None, runs=None, uploaders=None, tag=None, study=None, per_fold=None, sort_order=None, output_format='object')</code>","text":"<p>List all run-evaluation pairs matching all of the given filters.</p> <p>(Supports large amount of results)</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>the evaluation function. e.g., predictive_accuracy</p> required <code>offset</code> <code>int</code> <p>the number of runs to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of runs to show. If set to <code>None</code>, it returns all the results.</p> <code>10000</code> <code>tasks</code> <code>list[int, str]</code> <p>the list of task IDs</p> <code>None</code> <code>setups</code> <code>list[str | int] | None</code> <p>the list of setup IDs</p> <code>None</code> <code>flows</code> <code>list[int, str]</code> <p>the list of flow IDs</p> <code>None</code> <code>runs</code> <code>list[str | int] | None</code> <p>the list of run IDs</p> <code>None</code> <code>uploaders</code> <code>list[int, str]</code> <p>the list of uploader IDs</p> <code>None</code> <code>tag</code> <code>str</code> <p>filter evaluation based on given tag</p> <code>None</code> <code>study</code> <code>int</code> <code>None</code> <code>per_fold</code> <code>bool</code> <code>None</code> <code>sort_order</code> <code>str</code> <p>order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")</p> <code>None</code> <code>output_format</code> <code>Literal['object', 'dataframe']</code> <p>The parameter decides the format of the output. - If 'object' the output is a dict of OpenMLEvaluation objects - If 'dataframe' the output is a pandas DataFrame</p> <code>'object'</code> <p>Returns:</p> Type Description <code>dict or dataframe</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_evaluations(\n    function: str,\n    offset: int | None = None,\n    size: int | None = None,\n    tasks: list[str | int] | None = None,\n    setups: list[str | int] | None = None,\n    flows: list[str | int] | None = None,\n    runs: list[str | int] | None = None,\n    uploaders: list[str | int] | None = None,\n    tag: str | None = None,\n    study: int | None = None,\n    per_fold: bool | None = None,\n    sort_order: str | None = None,\n    output_format: Literal[\"object\", \"dataframe\"] = \"object\",\n) -&gt; dict[int, OpenMLEvaluation] | pd.DataFrame:\n    \"\"\"List all run-evaluation pairs matching all of the given filters.\n\n    (Supports large amount of results)\n\n    Parameters\n    ----------\n    function : str\n        the evaluation function. e.g., predictive_accuracy\n    offset : int, optional\n        the number of runs to skip, starting from the first\n    size : int, default 10000\n        The maximum number of runs to show.\n        If set to ``None``, it returns all the results.\n\n    tasks : list[int,str], optional\n        the list of task IDs\n    setups: list[int,str], optional\n        the list of setup IDs\n    flows : list[int,str], optional\n        the list of flow IDs\n    runs :list[int,str], optional\n        the list of run IDs\n    uploaders : list[int,str], optional\n        the list of uploader IDs\n    tag : str, optional\n        filter evaluation based on given tag\n\n    study : int, optional\n\n    per_fold : bool, optional\n\n    sort_order : str, optional\n       order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")\n\n    output_format: str, optional (default='object')\n        The parameter decides the format of the output.\n        - If 'object' the output is a dict of OpenMLEvaluation objects\n        - If 'dataframe' the output is a pandas DataFrame\n\n    Returns\n    -------\n    dict or dataframe\n    \"\"\"\n    if output_format not in (\"dataframe\", \"object\"):\n        raise ValueError(\"Invalid output format. Only 'object', 'dataframe'.\")\n\n    per_fold_str = None\n    if per_fold is not None:\n        per_fold_str = str(per_fold).lower()\n\n    listing_call = partial(\n        _list_evaluations,\n        function=function,\n        tasks=tasks,\n        setups=setups,\n        flows=flows,\n        runs=runs,\n        uploaders=uploaders,\n        tag=tag,\n        study=study,\n        sort_order=sort_order,\n        per_fold=per_fold_str,\n    )\n    eval_collection = openml.utils._list_all(listing_call, offset=offset, limit=size)\n\n    flattened = list(chain.from_iterable(eval_collection))\n    if output_format == \"dataframe\":\n        records = [item._to_dict() for item in flattened]\n        return pd.DataFrame.from_records(records)  # No index...\n\n    return {e.run_id: e for e in flattened}\n</code></pre>"},{"location":"reference/evaluations/#openml.evaluations.list_evaluations_setups","title":"<code>list_evaluations_setups(function, offset=None, size=None, tasks=None, setups=None, flows=None, runs=None, uploaders=None, tag=None, per_fold=None, sort_order=None, parameters_in_separate_columns=False)</code>","text":"<p>List all run-evaluation pairs matching all of the given filters and their hyperparameter settings.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>the evaluation function. e.g., predictive_accuracy</p> required <code>offset</code> <code>int</code> <p>the number of runs to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of runs to show</p> <code>None</code> <code>tasks</code> <code>list[int]</code> <p>the list of task IDs</p> <code>None</code> <code>setups</code> <code>list | None</code> <p>the list of setup IDs</p> <code>None</code> <code>flows</code> <code>list[int]</code> <p>the list of flow IDs</p> <code>None</code> <code>runs</code> <code>list[int]</code> <p>the list of run IDs</p> <code>None</code> <code>uploaders</code> <code>list[int]</code> <p>the list of uploader IDs</p> <code>None</code> <code>tag</code> <code>str</code> <p>filter evaluation based on given tag</p> <code>None</code> <code>per_fold</code> <code>bool</code> <code>None</code> <code>sort_order</code> <code>str</code> <p>order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")</p> <code>None</code> <code>parameters_in_separate_columns</code> <code>bool</code> <p>Returns hyperparameters in separate columns if set to True. Valid only for a single flow</p> <code>False</code> <p>Returns:</p> Type Description <code>dataframe with hyperparameter settings as a list of tuples.</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_evaluations_setups(\n    function: str,\n    offset: int | None = None,\n    size: int | None = None,\n    tasks: list | None = None,\n    setups: list | None = None,\n    flows: list | None = None,\n    runs: list | None = None,\n    uploaders: list | None = None,\n    tag: str | None = None,\n    per_fold: bool | None = None,\n    sort_order: str | None = None,\n    parameters_in_separate_columns: bool = False,  # noqa: FBT001, FBT002\n) -&gt; pd.DataFrame:\n    \"\"\"List all run-evaluation pairs matching all of the given filters\n    and their hyperparameter settings.\n\n    Parameters\n    ----------\n    function : str\n        the evaluation function. e.g., predictive_accuracy\n    offset : int, optional\n        the number of runs to skip, starting from the first\n    size : int, optional\n        the maximum number of runs to show\n    tasks : list[int], optional\n        the list of task IDs\n    setups: list[int], optional\n        the list of setup IDs\n    flows : list[int], optional\n        the list of flow IDs\n    runs : list[int], optional\n        the list of run IDs\n    uploaders : list[int], optional\n        the list of uploader IDs\n    tag : str, optional\n        filter evaluation based on given tag\n    per_fold : bool, optional\n    sort_order : str, optional\n       order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")\n    parameters_in_separate_columns: bool, optional (default= False)\n        Returns hyperparameters in separate columns if set to True.\n        Valid only for a single flow\n\n    Returns\n    -------\n    dataframe with hyperparameter settings as a list of tuples.\n    \"\"\"\n    if parameters_in_separate_columns and (flows is None or len(flows) != 1):\n        raise ValueError(\"Can set parameters_in_separate_columns to true only for single flow_id\")\n\n    # List evaluations\n    evals = list_evaluations(\n        function=function,\n        offset=offset,\n        size=size,\n        runs=runs,\n        tasks=tasks,\n        setups=setups,\n        flows=flows,\n        uploaders=uploaders,\n        tag=tag,\n        per_fold=per_fold,\n        sort_order=sort_order,\n        output_format=\"dataframe\",\n    )\n    # List setups\n    # list_setups by setup id does not support large sizes (exceeds URL length limit)\n    # Hence we split the list of unique setup ids returned by list_evaluations into chunks of size N\n    _df = pd.DataFrame()\n    if len(evals) != 0:\n        N = 100  # size of section\n        uniq = np.asarray(evals[\"setup_id\"].unique())\n        length = len(uniq)\n\n        # array_split - allows indices_or_sections to not equally divide the array\n        # array_split -length % N sub-arrays of size length//N + 1 and the rest of size length//N.\n        split_size = ((length - 1) // N) + 1\n        setup_chunks = np.array_split(uniq, split_size)\n\n        setup_data = pd.DataFrame()\n        for _setups in setup_chunks:\n            result = openml.setups.list_setups(setup=_setups, output_format=\"dataframe\")\n            assert isinstance(result, pd.DataFrame)\n            result = result.drop(\"flow_id\", axis=1)\n            # concat resulting setup chunks into single datframe\n            setup_data = pd.concat([setup_data, result])\n\n        parameters = []\n        # Convert parameters of setup into dict of (hyperparameter, value)\n        for parameter_dict in setup_data[\"parameters\"]:\n            if parameter_dict is not None:\n                parameters.append(\n                    {param[\"full_name\"]: param[\"value\"] for param in parameter_dict.values()},\n                )\n            else:\n                parameters.append({})\n        setup_data[\"parameters\"] = parameters\n        # Merge setups with evaluations\n        _df = evals.merge(setup_data, on=\"setup_id\", how=\"left\")\n\n    if parameters_in_separate_columns:\n        _df = pd.concat(\n            [_df.drop(\"parameters\", axis=1), _df[\"parameters\"].apply(pd.Series)],\n            axis=1,\n        )\n\n    return _df\n</code></pre>"},{"location":"reference/evaluations/evaluation/","title":"evaluation","text":""},{"location":"reference/evaluations/evaluation/#openml.evaluations.evaluation.OpenMLEvaluation","title":"<code>OpenMLEvaluation</code>","text":"<p>Contains all meta-information about a run / evaluation combination, according to the evaluation/list function</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>Refers to the run.</p> required <code>task_id</code> <code>int</code> <p>Refers to the task.</p> required <code>setup_id</code> <code>int</code> <p>Refers to the setup.</p> required <code>flow_id</code> <code>int</code> <p>Refers to the flow.</p> required <code>flow_name</code> <code>str</code> <p>Name of the referred flow.</p> required <code>data_id</code> <code>int</code> <p>Refers to the dataset.</p> required <code>data_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>function</code> <code>str</code> <p>The evaluation metric of this item (e.g., accuracy).</p> required <code>upload_time</code> <code>str</code> <p>The time of evaluation.</p> required <code>uploader</code> <code>int</code> <p>Uploader ID (user ID)</p> required <code>upload_name</code> <code>str</code> <p>Name of the uploader of this evaluation</p> required <code>value</code> <code>float</code> <p>The value (score) of this evaluation.</p> required <code>values</code> <code>List[float]</code> <p>The values (scores) per repeat and fold (if requested)</p> required <code>array_data</code> <code>str</code> <p>list of information per class. (e.g., in case of precision, auroc, recall)</p> <code>None</code> Source code in <code>openml/evaluations/evaluation.py</code> <pre><code>class OpenMLEvaluation:\n    \"\"\"\n    Contains all meta-information about a run / evaluation combination,\n    according to the evaluation/list function\n\n    Parameters\n    ----------\n    run_id : int\n        Refers to the run.\n    task_id : int\n        Refers to the task.\n    setup_id : int\n        Refers to the setup.\n    flow_id : int\n        Refers to the flow.\n    flow_name : str\n        Name of the referred flow.\n    data_id : int\n        Refers to the dataset.\n    data_name : str\n        The name of the dataset.\n    function : str\n        The evaluation metric of this item (e.g., accuracy).\n    upload_time : str\n        The time of evaluation.\n    uploader: int\n        Uploader ID (user ID)\n    upload_name : str\n        Name of the uploader of this evaluation\n    value : float\n        The value (score) of this evaluation.\n    values : List[float]\n        The values (scores) per repeat and fold (if requested)\n    array_data : str\n        list of information per class.\n        (e.g., in case of precision, auroc, recall)\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        run_id: int,\n        task_id: int,\n        setup_id: int,\n        flow_id: int,\n        flow_name: str,\n        data_id: int,\n        data_name: str,\n        function: str,\n        upload_time: str,\n        uploader: int,\n        uploader_name: str,\n        value: float | None,\n        values: list[float] | None,\n        array_data: str | None = None,\n    ):\n        self.run_id = run_id\n        self.task_id = task_id\n        self.setup_id = setup_id\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.data_id = data_id\n        self.data_name = data_name\n        self.function = function\n        self.upload_time = upload_time\n        self.uploader = uploader\n        self.uploader_name = uploader_name\n        self.value = value\n        self.values = values\n        self.array_data = array_data\n\n    def _to_dict(self) -&gt; dict:\n        return {\n            \"run_id\": self.run_id,\n            \"task_id\": self.task_id,\n            \"setup_id\": self.setup_id,\n            \"flow_id\": self.flow_id,\n            \"flow_name\": self.flow_name,\n            \"data_id\": self.data_id,\n            \"data_name\": self.data_name,\n            \"function\": self.function,\n            \"upload_time\": self.upload_time,\n            \"uploader\": self.uploader,\n            \"uploader_name\": self.uploader_name,\n            \"value\": self.value,\n            \"values\": self.values,\n            \"array_data\": self.array_data,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Evaluation\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"Upload Date\": self.upload_time,\n            \"Run ID\": self.run_id,\n            \"OpenML Run URL\": openml.runs.OpenMLRun.url_for_id(self.run_id),\n            \"Task ID\": self.task_id,\n            \"OpenML Task URL\": openml.tasks.OpenMLTask.url_for_id(self.task_id),\n            \"Flow ID\": self.flow_id,\n            \"OpenML Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"Setup ID\": self.setup_id,\n            \"Data ID\": self.data_id,\n            \"Data Name\": self.data_name,\n            \"OpenML Data URL\": openml.datasets.OpenMLDataset.url_for_id(self.data_id),\n            \"Metric Used\": self.function,\n            \"Result\": self.value,\n        }\n\n        order = [\n            \"Uploader Date\",\n            \"Run ID\",\n            \"OpenML Run URL\",\n            \"Task ID\",\n            \"OpenML Task URL\" \"Flow ID\",\n            \"OpenML Flow URL\",\n            \"Setup ID\",\n            \"Data ID\",\n            \"Data Name\",\n            \"OpenML Data URL\",\n            \"Metric Used\",\n            \"Result\",\n        ]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/evaluations/functions/","title":"functions","text":""},{"location":"reference/evaluations/functions/#openml.evaluations.functions.__list_evaluations","title":"<code>__list_evaluations(api_call)</code>","text":"<p>Helper function to parse API calls which are lists of runs</p> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def __list_evaluations(api_call: str) -&gt; list[OpenMLEvaluation]:\n    \"\"\"Helper function to parse API calls which are lists of runs\"\"\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    evals_dict = xmltodict.parse(xml_string, force_list=(\"oml:evaluation\",))\n    # Minimalistic check if the XML is useful\n    if \"oml:evaluations\" not in evals_dict:\n        raise ValueError(\n            \"Error in return XML, does not contain \" f'\"oml:evaluations\": {evals_dict!s}',\n        )\n\n    assert isinstance(evals_dict[\"oml:evaluations\"][\"oml:evaluation\"], list), type(\n        evals_dict[\"oml:evaluations\"],\n    )\n\n    uploader_ids = list(\n        {eval_[\"oml:uploader\"] for eval_ in evals_dict[\"oml:evaluations\"][\"oml:evaluation\"]},\n    )\n    api_users = \"user/list/user_id/\" + \",\".join(uploader_ids)\n    xml_string_user = openml._api_calls._perform_api_call(api_users, \"get\")\n\n    users = xmltodict.parse(xml_string_user, force_list=(\"oml:user\",))\n    user_dict = {user[\"oml:id\"]: user[\"oml:username\"] for user in users[\"oml:users\"][\"oml:user\"]}\n\n    evals = []\n    for eval_ in evals_dict[\"oml:evaluations\"][\"oml:evaluation\"]:\n        run_id = int(eval_[\"oml:run_id\"])\n        value = float(eval_[\"oml:value\"]) if \"oml:value\" in eval_ else None\n        values = json.loads(eval_[\"oml:values\"]) if eval_.get(\"oml:values\", None) else None\n        array_data = eval_.get(\"oml:array_data\")\n\n        evals.append(\n            OpenMLEvaluation(\n                run_id=run_id,\n                task_id=int(eval_[\"oml:task_id\"]),\n                setup_id=int(eval_[\"oml:setup_id\"]),\n                flow_id=int(eval_[\"oml:flow_id\"]),\n                flow_name=eval_[\"oml:flow_name\"],\n                data_id=int(eval_[\"oml:data_id\"]),\n                data_name=eval_[\"oml:data_name\"],\n                function=eval_[\"oml:function\"],\n                upload_time=eval_[\"oml:upload_time\"],\n                uploader=int(eval_[\"oml:uploader\"]),\n                uploader_name=user_dict[eval_[\"oml:uploader\"]],\n                value=value,\n                values=values,\n                array_data=array_data,\n            )\n        )\n\n    return evals\n</code></pre>"},{"location":"reference/evaluations/functions/#openml.evaluations.functions.list_estimation_procedures","title":"<code>list_estimation_procedures()</code>","text":"<p>Return list of evaluation procedures available.</p> <p>The function performs an API call to retrieve the entire list of evaluation procedures' names that are available.</p> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_estimation_procedures() -&gt; list[str]:\n    \"\"\"Return list of evaluation procedures available.\n\n    The function performs an API call to retrieve the entire list of\n    evaluation procedures' names that are available.\n\n    Returns\n    -------\n    list\n    \"\"\"\n    api_call = \"estimationprocedure/list\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    api_results = xmltodict.parse(xml_string)\n\n    # Minimalistic check if the XML is useful\n    if \"oml:estimationprocedures\" not in api_results:\n        raise ValueError('Error in return XML, does not contain \"oml:estimationprocedures\"')\n\n    if \"oml:estimationprocedure\" not in api_results[\"oml:estimationprocedures\"]:\n        raise ValueError('Error in return XML, does not contain \"oml:estimationprocedure\"')\n\n    if not isinstance(api_results[\"oml:estimationprocedures\"][\"oml:estimationprocedure\"], list):\n        raise TypeError('Error in return XML, does not contain \"oml:estimationprocedure\" as a list')\n\n    return [\n        prod[\"oml:name\"]\n        for prod in api_results[\"oml:estimationprocedures\"][\"oml:estimationprocedure\"]\n    ]\n</code></pre>"},{"location":"reference/evaluations/functions/#openml.evaluations.functions.list_evaluation_measures","title":"<code>list_evaluation_measures()</code>","text":"<p>Return list of evaluation measures available.</p> <p>The function performs an API call to retrieve the entire list of evaluation measures that are available.</p> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_evaluation_measures() -&gt; list[str]:\n    \"\"\"Return list of evaluation measures available.\n\n    The function performs an API call to retrieve the entire list of\n    evaluation measures that are available.\n\n    Returns\n    -------\n    list\n\n    \"\"\"\n    api_call = \"evaluationmeasure/list\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    qualities = xmltodict.parse(xml_string, force_list=(\"oml:measures\"))\n    # Minimalistic check if the XML is useful\n    if \"oml:evaluation_measures\" not in qualities:\n        raise ValueError('Error in return XML, does not contain \"oml:evaluation_measures\"')\n\n    if not isinstance(qualities[\"oml:evaluation_measures\"][\"oml:measures\"][0][\"oml:measure\"], list):\n        raise TypeError('Error in return XML, does not contain \"oml:measure\" as a list')\n\n    return qualities[\"oml:evaluation_measures\"][\"oml:measures\"][0][\"oml:measure\"]\n</code></pre>"},{"location":"reference/evaluations/functions/#openml.evaluations.functions.list_evaluations","title":"<code>list_evaluations(function, offset=None, size=None, tasks=None, setups=None, flows=None, runs=None, uploaders=None, tag=None, study=None, per_fold=None, sort_order=None, output_format='object')</code>","text":"<p>List all run-evaluation pairs matching all of the given filters.</p> <p>(Supports large amount of results)</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>the evaluation function. e.g., predictive_accuracy</p> required <code>offset</code> <code>int</code> <p>the number of runs to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of runs to show. If set to <code>None</code>, it returns all the results.</p> <code>10000</code> <code>tasks</code> <code>list[int, str]</code> <p>the list of task IDs</p> <code>None</code> <code>setups</code> <code>list[str | int] | None</code> <p>the list of setup IDs</p> <code>None</code> <code>flows</code> <code>list[int, str]</code> <p>the list of flow IDs</p> <code>None</code> <code>runs</code> <code>list[str | int] | None</code> <p>the list of run IDs</p> <code>None</code> <code>uploaders</code> <code>list[int, str]</code> <p>the list of uploader IDs</p> <code>None</code> <code>tag</code> <code>str</code> <p>filter evaluation based on given tag</p> <code>None</code> <code>study</code> <code>int</code> <code>None</code> <code>per_fold</code> <code>bool</code> <code>None</code> <code>sort_order</code> <code>str</code> <p>order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")</p> <code>None</code> <code>output_format</code> <code>Literal['object', 'dataframe']</code> <p>The parameter decides the format of the output. - If 'object' the output is a dict of OpenMLEvaluation objects - If 'dataframe' the output is a pandas DataFrame</p> <code>'object'</code> <p>Returns:</p> Type Description <code>dict or dataframe</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_evaluations(\n    function: str,\n    offset: int | None = None,\n    size: int | None = None,\n    tasks: list[str | int] | None = None,\n    setups: list[str | int] | None = None,\n    flows: list[str | int] | None = None,\n    runs: list[str | int] | None = None,\n    uploaders: list[str | int] | None = None,\n    tag: str | None = None,\n    study: int | None = None,\n    per_fold: bool | None = None,\n    sort_order: str | None = None,\n    output_format: Literal[\"object\", \"dataframe\"] = \"object\",\n) -&gt; dict[int, OpenMLEvaluation] | pd.DataFrame:\n    \"\"\"List all run-evaluation pairs matching all of the given filters.\n\n    (Supports large amount of results)\n\n    Parameters\n    ----------\n    function : str\n        the evaluation function. e.g., predictive_accuracy\n    offset : int, optional\n        the number of runs to skip, starting from the first\n    size : int, default 10000\n        The maximum number of runs to show.\n        If set to ``None``, it returns all the results.\n\n    tasks : list[int,str], optional\n        the list of task IDs\n    setups: list[int,str], optional\n        the list of setup IDs\n    flows : list[int,str], optional\n        the list of flow IDs\n    runs :list[int,str], optional\n        the list of run IDs\n    uploaders : list[int,str], optional\n        the list of uploader IDs\n    tag : str, optional\n        filter evaluation based on given tag\n\n    study : int, optional\n\n    per_fold : bool, optional\n\n    sort_order : str, optional\n       order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")\n\n    output_format: str, optional (default='object')\n        The parameter decides the format of the output.\n        - If 'object' the output is a dict of OpenMLEvaluation objects\n        - If 'dataframe' the output is a pandas DataFrame\n\n    Returns\n    -------\n    dict or dataframe\n    \"\"\"\n    if output_format not in (\"dataframe\", \"object\"):\n        raise ValueError(\"Invalid output format. Only 'object', 'dataframe'.\")\n\n    per_fold_str = None\n    if per_fold is not None:\n        per_fold_str = str(per_fold).lower()\n\n    listing_call = partial(\n        _list_evaluations,\n        function=function,\n        tasks=tasks,\n        setups=setups,\n        flows=flows,\n        runs=runs,\n        uploaders=uploaders,\n        tag=tag,\n        study=study,\n        sort_order=sort_order,\n        per_fold=per_fold_str,\n    )\n    eval_collection = openml.utils._list_all(listing_call, offset=offset, limit=size)\n\n    flattened = list(chain.from_iterable(eval_collection))\n    if output_format == \"dataframe\":\n        records = [item._to_dict() for item in flattened]\n        return pd.DataFrame.from_records(records)  # No index...\n\n    return {e.run_id: e for e in flattened}\n</code></pre>"},{"location":"reference/evaluations/functions/#openml.evaluations.functions.list_evaluations_setups","title":"<code>list_evaluations_setups(function, offset=None, size=None, tasks=None, setups=None, flows=None, runs=None, uploaders=None, tag=None, per_fold=None, sort_order=None, parameters_in_separate_columns=False)</code>","text":"<p>List all run-evaluation pairs matching all of the given filters and their hyperparameter settings.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>the evaluation function. e.g., predictive_accuracy</p> required <code>offset</code> <code>int</code> <p>the number of runs to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of runs to show</p> <code>None</code> <code>tasks</code> <code>list[int]</code> <p>the list of task IDs</p> <code>None</code> <code>setups</code> <code>list | None</code> <p>the list of setup IDs</p> <code>None</code> <code>flows</code> <code>list[int]</code> <p>the list of flow IDs</p> <code>None</code> <code>runs</code> <code>list[int]</code> <p>the list of run IDs</p> <code>None</code> <code>uploaders</code> <code>list[int]</code> <p>the list of uploader IDs</p> <code>None</code> <code>tag</code> <code>str</code> <p>filter evaluation based on given tag</p> <code>None</code> <code>per_fold</code> <code>bool</code> <code>None</code> <code>sort_order</code> <code>str</code> <p>order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")</p> <code>None</code> <code>parameters_in_separate_columns</code> <code>bool</code> <p>Returns hyperparameters in separate columns if set to True. Valid only for a single flow</p> <code>False</code> <p>Returns:</p> Type Description <code>dataframe with hyperparameter settings as a list of tuples.</code> Source code in <code>openml/evaluations/functions.py</code> <pre><code>def list_evaluations_setups(\n    function: str,\n    offset: int | None = None,\n    size: int | None = None,\n    tasks: list | None = None,\n    setups: list | None = None,\n    flows: list | None = None,\n    runs: list | None = None,\n    uploaders: list | None = None,\n    tag: str | None = None,\n    per_fold: bool | None = None,\n    sort_order: str | None = None,\n    parameters_in_separate_columns: bool = False,  # noqa: FBT001, FBT002\n) -&gt; pd.DataFrame:\n    \"\"\"List all run-evaluation pairs matching all of the given filters\n    and their hyperparameter settings.\n\n    Parameters\n    ----------\n    function : str\n        the evaluation function. e.g., predictive_accuracy\n    offset : int, optional\n        the number of runs to skip, starting from the first\n    size : int, optional\n        the maximum number of runs to show\n    tasks : list[int], optional\n        the list of task IDs\n    setups: list[int], optional\n        the list of setup IDs\n    flows : list[int], optional\n        the list of flow IDs\n    runs : list[int], optional\n        the list of run IDs\n    uploaders : list[int], optional\n        the list of uploader IDs\n    tag : str, optional\n        filter evaluation based on given tag\n    per_fold : bool, optional\n    sort_order : str, optional\n       order of sorting evaluations, ascending (\"asc\") or descending (\"desc\")\n    parameters_in_separate_columns: bool, optional (default= False)\n        Returns hyperparameters in separate columns if set to True.\n        Valid only for a single flow\n\n    Returns\n    -------\n    dataframe with hyperparameter settings as a list of tuples.\n    \"\"\"\n    if parameters_in_separate_columns and (flows is None or len(flows) != 1):\n        raise ValueError(\"Can set parameters_in_separate_columns to true only for single flow_id\")\n\n    # List evaluations\n    evals = list_evaluations(\n        function=function,\n        offset=offset,\n        size=size,\n        runs=runs,\n        tasks=tasks,\n        setups=setups,\n        flows=flows,\n        uploaders=uploaders,\n        tag=tag,\n        per_fold=per_fold,\n        sort_order=sort_order,\n        output_format=\"dataframe\",\n    )\n    # List setups\n    # list_setups by setup id does not support large sizes (exceeds URL length limit)\n    # Hence we split the list of unique setup ids returned by list_evaluations into chunks of size N\n    _df = pd.DataFrame()\n    if len(evals) != 0:\n        N = 100  # size of section\n        uniq = np.asarray(evals[\"setup_id\"].unique())\n        length = len(uniq)\n\n        # array_split - allows indices_or_sections to not equally divide the array\n        # array_split -length % N sub-arrays of size length//N + 1 and the rest of size length//N.\n        split_size = ((length - 1) // N) + 1\n        setup_chunks = np.array_split(uniq, split_size)\n\n        setup_data = pd.DataFrame()\n        for _setups in setup_chunks:\n            result = openml.setups.list_setups(setup=_setups, output_format=\"dataframe\")\n            assert isinstance(result, pd.DataFrame)\n            result = result.drop(\"flow_id\", axis=1)\n            # concat resulting setup chunks into single datframe\n            setup_data = pd.concat([setup_data, result])\n\n        parameters = []\n        # Convert parameters of setup into dict of (hyperparameter, value)\n        for parameter_dict in setup_data[\"parameters\"]:\n            if parameter_dict is not None:\n                parameters.append(\n                    {param[\"full_name\"]: param[\"value\"] for param in parameter_dict.values()},\n                )\n            else:\n                parameters.append({})\n        setup_data[\"parameters\"] = parameters\n        # Merge setups with evaluations\n        _df = evals.merge(setup_data, on=\"setup_id\", how=\"left\")\n\n    if parameters_in_separate_columns:\n        _df = pd.concat(\n            [_df.drop(\"parameters\", axis=1), _df[\"parameters\"].apply(pd.Series)],\n            axis=1,\n        )\n\n    return _df\n</code></pre>"},{"location":"reference/extensions/","title":"extensions","text":""},{"location":"reference/extensions/#openml.extensions.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Defines the interface to connect machine learning libraries to OpenML-Python.</p> <p>See <code>openml.extension.sklearn.extension</code> for an implementation to bootstrap from.</p> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>class Extension(ABC):\n    \"\"\"Defines the interface to connect machine learning libraries to OpenML-Python.\n\n    See ``openml.extension.sklearn.extension`` for an implementation to bootstrap from.\n    \"\"\"\n\n    ################################################################################################\n    # General setup\n\n    @classmethod\n    @abstractmethod\n    def can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n        \"\"\"Check whether a given flow can be handled by this extension.\n\n        This is typically done by parsing the ``external_version`` field.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def can_handle_model(cls, model: Any) -&gt; bool:\n        \"\"\"Check whether a model flow can be handled by this extension.\n\n        This is typically done by checking the type of the model, or the package it belongs to.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    ################################################################################################\n    # Abstract methods for flow serialization and de-serialization\n\n    @abstractmethod\n    def flow_to_model(\n        self,\n        flow: OpenMLFlow,\n        initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        \"\"\"Instantiate a model from the flow representation.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n\n        initialize_with_defaults : bool, optional (default=False)\n            If this flag is set, the hyperparameter values of flows will be\n            ignored and a flow with its defaults is returned.\n\n        strict_version : bool, default=True\n            Whether to fail if version requirements are not fulfilled.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n\n    @abstractmethod\n    def model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n        \"\"\"Transform a model to a flow for uploading it to OpenML.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        OpenMLFlow\n        \"\"\"\n\n    @abstractmethod\n    def get_version_information(self) -&gt; list[str]:\n        \"\"\"List versions of libraries required by the flow.\n\n        Returns\n        -------\n        List\n        \"\"\"\n\n    @abstractmethod\n    def create_setup_string(self, model: Any) -&gt; str:\n        \"\"\"Create a string which can be used to reinstantiate the given model.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        str\n        \"\"\"\n\n    ################################################################################################\n    # Abstract methods for performing runs with extension modules\n\n    @abstractmethod\n    def is_estimator(self, model: Any) -&gt; bool:\n        \"\"\"Check whether the given model is an estimator for the given extension.\n\n        This function is only required for backwards compatibility and will be removed in the\n        near future.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    @abstractmethod\n    def seed_model(self, model: Any, seed: int | None) -&gt; Any:\n        \"\"\"Set the seed of all the unseeded components of a model and return the seeded model.\n\n        Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n        Parameters\n        ----------\n        model : Any\n            The model to be seeded\n        seed : int\n\n        Returns\n        -------\n        model\n        \"\"\"\n\n    @abstractmethod\n    def _run_model_on_fold(  # noqa: PLR0913\n        self,\n        model: Any,\n        task: OpenMLTask,\n        X_train: np.ndarray | scipy.sparse.spmatrix,\n        rep_no: int,\n        fold_no: int,\n        y_train: np.ndarray | None = None,\n        X_test: np.ndarray | scipy.sparse.spmatrix | None = None,\n    ) -&gt; tuple[np.ndarray, np.ndarray | None, OrderedDict[str, float], OpenMLRunTrace | None]:\n        \"\"\"Run a model on a repeat, fold, subsample triplet of the task.\n\n        Returns the data that is necessary to construct the OpenML Run object. Is used by\n        :func:`openml.runs.run_flow_on_task`.\n\n        Parameters\n        ----------\n        model : Any\n            The UNTRAINED model to run. The model instance will be copied and not altered.\n        task : OpenMLTask\n            The task to run the model on.\n        X_train : array-like\n            Training data for the given repetition and fold.\n        rep_no : int\n            The repeat of the experiment (0-based; in case of 1 time CV, always 0)\n        fold_no : int\n            The fold nr of the experiment (0-based; in case of holdout, always 0)\n        y_train : Optional[np.ndarray] (default=None)\n            Target attributes for supervised tasks. In case of classification, these are integer\n            indices to the potential classes specified by dataset.\n        X_test : Optional, array-like (default=None)\n            Test attributes to test for generalization in supervised tasks.\n\n        Returns\n        -------\n        predictions : np.ndarray\n            Model predictions.\n        probabilities :  Optional, np.ndarray\n            Predicted probabilities (only applicable for supervised classification tasks).\n        user_defined_measures : OrderedDict[str, float]\n            User defined measures that were generated on this fold\n        trace : Optional, OpenMLRunTrace\n            Hyperparameter optimization trace (only applicable for supervised tasks with\n            hyperparameter optimization).\n        \"\"\"\n\n    @abstractmethod\n    def obtain_parameter_values(\n        self,\n        flow: OpenMLFlow,\n        model: Any = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extracts all parameter settings required for the flow from the model.\n\n        If no explicit model is provided, the parameters will be extracted from `flow.model`\n        instead.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n            OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n        model: Any, optional (default=None)\n            The model from which to obtain the parameter values. Must match the flow signature.\n            If None, use the model specified in ``OpenMLFlow.model``.\n\n        Returns\n        -------\n        list\n            A list of dicts, where each dict has the following entries:\n            - ``oml:name`` : str: The OpenML parameter name\n            - ``oml:value`` : mixed: A representation of the parameter value\n            - ``oml:component`` : int: flow id to which the parameter belongs\n        \"\"\"\n\n    @abstractmethod\n    def check_if_model_fitted(self, model: Any) -&gt; bool:\n        \"\"\"Returns True/False denoting if the model has already been fitted/trained.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    ################################################################################################\n    # Abstract methods for hyperparameter optimization\n\n    @abstractmethod\n    def instantiate_model_from_hpo_class(\n        self,\n        model: Any,\n        trace_iteration: OpenMLTraceIteration,\n    ) -&gt; Any:\n        \"\"\"Instantiate a base model which can be searched over by the hyperparameter optimization\n        model.\n\n        Parameters\n        ----------\n        model : Any\n            A hyperparameter optimization model which defines the model to be instantiated.\n        trace_iteration : OpenMLTraceIteration\n            Describing the hyperparameter settings to instantiate.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.can_handle_flow","title":"<code>can_handle_flow(flow)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Check whether a given flow can be handled by this extension.</p> <p>This is typically done by parsing the <code>external_version</code> field.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@classmethod\n@abstractmethod\ndef can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n    \"\"\"Check whether a given flow can be handled by this extension.\n\n    This is typically done by parsing the ``external_version`` field.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.can_handle_model","title":"<code>can_handle_model(model)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Check whether a model flow can be handled by this extension.</p> <p>This is typically done by checking the type of the model, or the package it belongs to.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@classmethod\n@abstractmethod\ndef can_handle_model(cls, model: Any) -&gt; bool:\n    \"\"\"Check whether a model flow can be handled by this extension.\n\n    This is typically done by checking the type of the model, or the package it belongs to.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.check_if_model_fitted","title":"<code>check_if_model_fitted(model)</code>  <code>abstractmethod</code>","text":"<p>Returns True/False denoting if the model has already been fitted/trained.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef check_if_model_fitted(self, model: Any) -&gt; bool:\n    \"\"\"Returns True/False denoting if the model has already been fitted/trained.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.create_setup_string","title":"<code>create_setup_string(model)</code>  <code>abstractmethod</code>","text":"<p>Create a string which can be used to reinstantiate the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef create_setup_string(self, model: Any) -&gt; str:\n    \"\"\"Create a string which can be used to reinstantiate the given model.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    str\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.flow_to_model","title":"<code>flow_to_model(flow, initialize_with_defaults=False, strict_version=True)</code>  <code>abstractmethod</code>","text":"<p>Instantiate a model from the flow representation.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <code>initialize_with_defaults</code> <code>(bool, optional(default=False))</code> <p>If this flag is set, the hyperparameter values of flows will be ignored and a flow with its defaults is returned.</p> <code>False</code> <code>strict_version</code> <code>bool</code> <p>Whether to fail if version requirements are not fulfilled.</p> <code>True</code> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef flow_to_model(\n    self,\n    flow: OpenMLFlow,\n    initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n    strict_version: bool = True,  # noqa: FBT002, FBT001\n) -&gt; Any:\n    \"\"\"Instantiate a model from the flow representation.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    initialize_with_defaults : bool, optional (default=False)\n        If this flag is set, the hyperparameter values of flows will be\n        ignored and a flow with its defaults is returned.\n\n    strict_version : bool, default=True\n        Whether to fail if version requirements are not fulfilled.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.get_version_information","title":"<code>get_version_information()</code>  <code>abstractmethod</code>","text":"<p>List versions of libraries required by the flow.</p> <p>Returns:</p> Type Description <code>List</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef get_version_information(self) -&gt; list[str]:\n    \"\"\"List versions of libraries required by the flow.\n\n    Returns\n    -------\n    List\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.instantiate_model_from_hpo_class","title":"<code>instantiate_model_from_hpo_class(model, trace_iteration)</code>  <code>abstractmethod</code>","text":"<p>Instantiate a base model which can be searched over by the hyperparameter optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A hyperparameter optimization model which defines the model to be instantiated.</p> required <code>trace_iteration</code> <code>OpenMLTraceIteration</code> <p>Describing the hyperparameter settings to instantiate.</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef instantiate_model_from_hpo_class(\n    self,\n    model: Any,\n    trace_iteration: OpenMLTraceIteration,\n) -&gt; Any:\n    \"\"\"Instantiate a base model which can be searched over by the hyperparameter optimization\n    model.\n\n    Parameters\n    ----------\n    model : Any\n        A hyperparameter optimization model which defines the model to be instantiated.\n    trace_iteration : OpenMLTraceIteration\n        Describing the hyperparameter settings to instantiate.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.is_estimator","title":"<code>is_estimator(model)</code>  <code>abstractmethod</code>","text":"<p>Check whether the given model is an estimator for the given extension.</p> <p>This function is only required for backwards compatibility and will be removed in the near future.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef is_estimator(self, model: Any) -&gt; bool:\n    \"\"\"Check whether the given model is an estimator for the given extension.\n\n    This function is only required for backwards compatibility and will be removed in the\n    near future.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.model_to_flow","title":"<code>model_to_flow(model)</code>  <code>abstractmethod</code>","text":"<p>Transform a model to a flow for uploading it to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n    \"\"\"Transform a model to a flow for uploading it to OpenML.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    OpenMLFlow\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.obtain_parameter_values","title":"<code>obtain_parameter_values(flow, model=None)</code>  <code>abstractmethod</code>","text":"<p>Extracts all parameter settings required for the flow from the model.</p> <p>If no explicit model is provided, the parameters will be extracted from <code>flow.model</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)</p> required <code>model</code> <code>Any</code> <p>The model from which to obtain the parameter values. Must match the flow signature. If None, use the model specified in <code>OpenMLFlow.model</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of dicts, where each dict has the following entries: - <code>oml:name</code> : str: The OpenML parameter name - <code>oml:value</code> : mixed: A representation of the parameter value - <code>oml:component</code> : int: flow id to which the parameter belongs</p> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef obtain_parameter_values(\n    self,\n    flow: OpenMLFlow,\n    model: Any = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extracts all parameter settings required for the flow from the model.\n\n    If no explicit model is provided, the parameters will be extracted from `flow.model`\n    instead.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n    model: Any, optional (default=None)\n        The model from which to obtain the parameter values. Must match the flow signature.\n        If None, use the model specified in ``OpenMLFlow.model``.\n\n    Returns\n    -------\n    list\n        A list of dicts, where each dict has the following entries:\n        - ``oml:name`` : str: The OpenML parameter name\n        - ``oml:value`` : mixed: A representation of the parameter value\n        - ``oml:component`` : int: flow id to which the parameter belongs\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.Extension.seed_model","title":"<code>seed_model(model, seed)</code>  <code>abstractmethod</code>","text":"<p>Set the seed of all the unseeded components of a model and return the seeded model.</p> <p>Required so that all seed information can be uploaded to OpenML for reproducible results.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The model to be seeded</p> required <code>seed</code> <code>int</code> required <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef seed_model(self, model: Any, seed: int | None) -&gt; Any:\n    \"\"\"Set the seed of all the unseeded components of a model and return the seeded model.\n\n    Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n    Parameters\n    ----------\n    model : Any\n        The model to be seeded\n    seed : int\n\n    Returns\n    -------\n    model\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.get_extension_by_flow","title":"<code>get_extension_by_flow(flow, raise_if_no_extension=False)</code>","text":"<p>Get an extension which can handle the given flow.</p> <p>Iterates all registered extensions and checks whether they can handle the presented flow. Raises an exception if two extensions can handle a flow.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <code>raise_if_no_extension</code> <code>bool (optional</code> <p>Raise an exception if no registered extension can handle the presented flow.</p> <code>False)</code> <p>Returns:</p> Type Description <code>Extension or None</code> Source code in <code>openml/extensions/functions.py</code> <pre><code>def get_extension_by_flow(\n    flow: OpenMLFlow,\n    raise_if_no_extension: bool = False,  # noqa: FBT001, FBT002\n) -&gt; Extension | None:\n    \"\"\"Get an extension which can handle the given flow.\n\n    Iterates all registered extensions and checks whether they can handle the presented flow.\n    Raises an exception if two extensions can handle a flow.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    raise_if_no_extension : bool (optional, default=False)\n        Raise an exception if no registered extension can handle the presented flow.\n\n    Returns\n    -------\n    Extension or None\n    \"\"\"\n    candidates = []\n    for extension_class in openml.extensions.extensions:\n        if extension_class.can_handle_flow(flow):\n            candidates.append(extension_class())\n    if len(candidates) == 0:\n        if raise_if_no_extension:\n            raise ValueError(f\"No extension registered which can handle flow: {flow}\")\n\n        return None\n\n    if len(candidates) == 1:\n        return candidates[0]\n\n    raise ValueError(\n        f\"Multiple extensions registered which can handle flow: {flow}, but only one \"\n        f\"is allowed ({candidates}).\",\n    )\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.get_extension_by_model","title":"<code>get_extension_by_model(model, raise_if_no_extension=False)</code>","text":"<p>Get an extension which can handle the given flow.</p> <p>Iterates all registered extensions and checks whether they can handle the presented model. Raises an exception if two extensions can handle a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <code>raise_if_no_extension</code> <code>bool (optional</code> <p>Raise an exception if no registered extension can handle the presented model.</p> <code>False)</code> <p>Returns:</p> Type Description <code>Extension or None</code> Source code in <code>openml/extensions/functions.py</code> <pre><code>def get_extension_by_model(\n    model: Any,\n    raise_if_no_extension: bool = False,  # noqa: FBT001, FBT002\n) -&gt; Extension | None:\n    \"\"\"Get an extension which can handle the given flow.\n\n    Iterates all registered extensions and checks whether they can handle the presented model.\n    Raises an exception if two extensions can handle a model.\n\n    Parameters\n    ----------\n    model : Any\n\n    raise_if_no_extension : bool (optional, default=False)\n        Raise an exception if no registered extension can handle the presented model.\n\n    Returns\n    -------\n    Extension or None\n    \"\"\"\n    candidates = []\n    for extension_class in openml.extensions.extensions:\n        if extension_class.can_handle_model(model):\n            candidates.append(extension_class())\n    if len(candidates) == 0:\n        if raise_if_no_extension:\n            raise ValueError(f\"No extension registered which can handle model: {model}\")\n\n        return None\n\n    if len(candidates) == 1:\n        return candidates[0]\n\n    raise ValueError(\n        f\"Multiple extensions registered which can handle model: {model}, but only one \"\n        f\"is allowed ({candidates}).\",\n    )\n</code></pre>"},{"location":"reference/extensions/#openml.extensions.register_extension","title":"<code>register_extension(extension)</code>","text":"<p>Register an extension.</p> <p>Registered extensions are considered by <code>get_extension_by_flow</code> and <code>get_extension_by_model</code>, which are used by <code>openml.flow</code> and <code>openml.runs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>Type[Extension]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>openml/extensions/functions.py</code> <pre><code>def register_extension(extension: type[Extension]) -&gt; None:\n    \"\"\"Register an extension.\n\n    Registered extensions are considered by ``get_extension_by_flow`` and\n    ``get_extension_by_model``, which are used by ``openml.flow`` and ``openml.runs``.\n\n    Parameters\n    ----------\n    extension : Type[Extension]\n\n    Returns\n    -------\n    None\n    \"\"\"\n    openml.extensions.extensions.append(extension)\n</code></pre>"},{"location":"reference/extensions/extension_interface/","title":"extension_interface","text":""},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Defines the interface to connect machine learning libraries to OpenML-Python.</p> <p>See <code>openml.extension.sklearn.extension</code> for an implementation to bootstrap from.</p> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>class Extension(ABC):\n    \"\"\"Defines the interface to connect machine learning libraries to OpenML-Python.\n\n    See ``openml.extension.sklearn.extension`` for an implementation to bootstrap from.\n    \"\"\"\n\n    ################################################################################################\n    # General setup\n\n    @classmethod\n    @abstractmethod\n    def can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n        \"\"\"Check whether a given flow can be handled by this extension.\n\n        This is typically done by parsing the ``external_version`` field.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def can_handle_model(cls, model: Any) -&gt; bool:\n        \"\"\"Check whether a model flow can be handled by this extension.\n\n        This is typically done by checking the type of the model, or the package it belongs to.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    ################################################################################################\n    # Abstract methods for flow serialization and de-serialization\n\n    @abstractmethod\n    def flow_to_model(\n        self,\n        flow: OpenMLFlow,\n        initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        \"\"\"Instantiate a model from the flow representation.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n\n        initialize_with_defaults : bool, optional (default=False)\n            If this flag is set, the hyperparameter values of flows will be\n            ignored and a flow with its defaults is returned.\n\n        strict_version : bool, default=True\n            Whether to fail if version requirements are not fulfilled.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n\n    @abstractmethod\n    def model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n        \"\"\"Transform a model to a flow for uploading it to OpenML.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        OpenMLFlow\n        \"\"\"\n\n    @abstractmethod\n    def get_version_information(self) -&gt; list[str]:\n        \"\"\"List versions of libraries required by the flow.\n\n        Returns\n        -------\n        List\n        \"\"\"\n\n    @abstractmethod\n    def create_setup_string(self, model: Any) -&gt; str:\n        \"\"\"Create a string which can be used to reinstantiate the given model.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        str\n        \"\"\"\n\n    ################################################################################################\n    # Abstract methods for performing runs with extension modules\n\n    @abstractmethod\n    def is_estimator(self, model: Any) -&gt; bool:\n        \"\"\"Check whether the given model is an estimator for the given extension.\n\n        This function is only required for backwards compatibility and will be removed in the\n        near future.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    @abstractmethod\n    def seed_model(self, model: Any, seed: int | None) -&gt; Any:\n        \"\"\"Set the seed of all the unseeded components of a model and return the seeded model.\n\n        Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n        Parameters\n        ----------\n        model : Any\n            The model to be seeded\n        seed : int\n\n        Returns\n        -------\n        model\n        \"\"\"\n\n    @abstractmethod\n    def _run_model_on_fold(  # noqa: PLR0913\n        self,\n        model: Any,\n        task: OpenMLTask,\n        X_train: np.ndarray | scipy.sparse.spmatrix,\n        rep_no: int,\n        fold_no: int,\n        y_train: np.ndarray | None = None,\n        X_test: np.ndarray | scipy.sparse.spmatrix | None = None,\n    ) -&gt; tuple[np.ndarray, np.ndarray | None, OrderedDict[str, float], OpenMLRunTrace | None]:\n        \"\"\"Run a model on a repeat, fold, subsample triplet of the task.\n\n        Returns the data that is necessary to construct the OpenML Run object. Is used by\n        :func:`openml.runs.run_flow_on_task`.\n\n        Parameters\n        ----------\n        model : Any\n            The UNTRAINED model to run. The model instance will be copied and not altered.\n        task : OpenMLTask\n            The task to run the model on.\n        X_train : array-like\n            Training data for the given repetition and fold.\n        rep_no : int\n            The repeat of the experiment (0-based; in case of 1 time CV, always 0)\n        fold_no : int\n            The fold nr of the experiment (0-based; in case of holdout, always 0)\n        y_train : Optional[np.ndarray] (default=None)\n            Target attributes for supervised tasks. In case of classification, these are integer\n            indices to the potential classes specified by dataset.\n        X_test : Optional, array-like (default=None)\n            Test attributes to test for generalization in supervised tasks.\n\n        Returns\n        -------\n        predictions : np.ndarray\n            Model predictions.\n        probabilities :  Optional, np.ndarray\n            Predicted probabilities (only applicable for supervised classification tasks).\n        user_defined_measures : OrderedDict[str, float]\n            User defined measures that were generated on this fold\n        trace : Optional, OpenMLRunTrace\n            Hyperparameter optimization trace (only applicable for supervised tasks with\n            hyperparameter optimization).\n        \"\"\"\n\n    @abstractmethod\n    def obtain_parameter_values(\n        self,\n        flow: OpenMLFlow,\n        model: Any = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extracts all parameter settings required for the flow from the model.\n\n        If no explicit model is provided, the parameters will be extracted from `flow.model`\n        instead.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n            OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n        model: Any, optional (default=None)\n            The model from which to obtain the parameter values. Must match the flow signature.\n            If None, use the model specified in ``OpenMLFlow.model``.\n\n        Returns\n        -------\n        list\n            A list of dicts, where each dict has the following entries:\n            - ``oml:name`` : str: The OpenML parameter name\n            - ``oml:value`` : mixed: A representation of the parameter value\n            - ``oml:component`` : int: flow id to which the parameter belongs\n        \"\"\"\n\n    @abstractmethod\n    def check_if_model_fitted(self, model: Any) -&gt; bool:\n        \"\"\"Returns True/False denoting if the model has already been fitted/trained.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n\n    ################################################################################################\n    # Abstract methods for hyperparameter optimization\n\n    @abstractmethod\n    def instantiate_model_from_hpo_class(\n        self,\n        model: Any,\n        trace_iteration: OpenMLTraceIteration,\n    ) -&gt; Any:\n        \"\"\"Instantiate a base model which can be searched over by the hyperparameter optimization\n        model.\n\n        Parameters\n        ----------\n        model : Any\n            A hyperparameter optimization model which defines the model to be instantiated.\n        trace_iteration : OpenMLTraceIteration\n            Describing the hyperparameter settings to instantiate.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.can_handle_flow","title":"<code>can_handle_flow(flow)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Check whether a given flow can be handled by this extension.</p> <p>This is typically done by parsing the <code>external_version</code> field.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@classmethod\n@abstractmethod\ndef can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n    \"\"\"Check whether a given flow can be handled by this extension.\n\n    This is typically done by parsing the ``external_version`` field.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.can_handle_model","title":"<code>can_handle_model(model)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Check whether a model flow can be handled by this extension.</p> <p>This is typically done by checking the type of the model, or the package it belongs to.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@classmethod\n@abstractmethod\ndef can_handle_model(cls, model: Any) -&gt; bool:\n    \"\"\"Check whether a model flow can be handled by this extension.\n\n    This is typically done by checking the type of the model, or the package it belongs to.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.check_if_model_fitted","title":"<code>check_if_model_fitted(model)</code>  <code>abstractmethod</code>","text":"<p>Returns True/False denoting if the model has already been fitted/trained.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef check_if_model_fitted(self, model: Any) -&gt; bool:\n    \"\"\"Returns True/False denoting if the model has already been fitted/trained.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.create_setup_string","title":"<code>create_setup_string(model)</code>  <code>abstractmethod</code>","text":"<p>Create a string which can be used to reinstantiate the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef create_setup_string(self, model: Any) -&gt; str:\n    \"\"\"Create a string which can be used to reinstantiate the given model.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    str\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.flow_to_model","title":"<code>flow_to_model(flow, initialize_with_defaults=False, strict_version=True)</code>  <code>abstractmethod</code>","text":"<p>Instantiate a model from the flow representation.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <code>initialize_with_defaults</code> <code>(bool, optional(default=False))</code> <p>If this flag is set, the hyperparameter values of flows will be ignored and a flow with its defaults is returned.</p> <code>False</code> <code>strict_version</code> <code>bool</code> <p>Whether to fail if version requirements are not fulfilled.</p> <code>True</code> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef flow_to_model(\n    self,\n    flow: OpenMLFlow,\n    initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n    strict_version: bool = True,  # noqa: FBT002, FBT001\n) -&gt; Any:\n    \"\"\"Instantiate a model from the flow representation.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    initialize_with_defaults : bool, optional (default=False)\n        If this flag is set, the hyperparameter values of flows will be\n        ignored and a flow with its defaults is returned.\n\n    strict_version : bool, default=True\n        Whether to fail if version requirements are not fulfilled.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.get_version_information","title":"<code>get_version_information()</code>  <code>abstractmethod</code>","text":"<p>List versions of libraries required by the flow.</p> <p>Returns:</p> Type Description <code>List</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef get_version_information(self) -&gt; list[str]:\n    \"\"\"List versions of libraries required by the flow.\n\n    Returns\n    -------\n    List\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.instantiate_model_from_hpo_class","title":"<code>instantiate_model_from_hpo_class(model, trace_iteration)</code>  <code>abstractmethod</code>","text":"<p>Instantiate a base model which can be searched over by the hyperparameter optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A hyperparameter optimization model which defines the model to be instantiated.</p> required <code>trace_iteration</code> <code>OpenMLTraceIteration</code> <p>Describing the hyperparameter settings to instantiate.</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef instantiate_model_from_hpo_class(\n    self,\n    model: Any,\n    trace_iteration: OpenMLTraceIteration,\n) -&gt; Any:\n    \"\"\"Instantiate a base model which can be searched over by the hyperparameter optimization\n    model.\n\n    Parameters\n    ----------\n    model : Any\n        A hyperparameter optimization model which defines the model to be instantiated.\n    trace_iteration : OpenMLTraceIteration\n        Describing the hyperparameter settings to instantiate.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.is_estimator","title":"<code>is_estimator(model)</code>  <code>abstractmethod</code>","text":"<p>Check whether the given model is an estimator for the given extension.</p> <p>This function is only required for backwards compatibility and will be removed in the near future.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef is_estimator(self, model: Any) -&gt; bool:\n    \"\"\"Check whether the given model is an estimator for the given extension.\n\n    This function is only required for backwards compatibility and will be removed in the\n    near future.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.model_to_flow","title":"<code>model_to_flow(model)</code>  <code>abstractmethod</code>","text":"<p>Transform a model to a flow for uploading it to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n    \"\"\"Transform a model to a flow for uploading it to OpenML.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    OpenMLFlow\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.obtain_parameter_values","title":"<code>obtain_parameter_values(flow, model=None)</code>  <code>abstractmethod</code>","text":"<p>Extracts all parameter settings required for the flow from the model.</p> <p>If no explicit model is provided, the parameters will be extracted from <code>flow.model</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)</p> required <code>model</code> <code>Any</code> <p>The model from which to obtain the parameter values. Must match the flow signature. If None, use the model specified in <code>OpenMLFlow.model</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of dicts, where each dict has the following entries: - <code>oml:name</code> : str: The OpenML parameter name - <code>oml:value</code> : mixed: A representation of the parameter value - <code>oml:component</code> : int: flow id to which the parameter belongs</p> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef obtain_parameter_values(\n    self,\n    flow: OpenMLFlow,\n    model: Any = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extracts all parameter settings required for the flow from the model.\n\n    If no explicit model is provided, the parameters will be extracted from `flow.model`\n    instead.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n    model: Any, optional (default=None)\n        The model from which to obtain the parameter values. Must match the flow signature.\n        If None, use the model specified in ``OpenMLFlow.model``.\n\n    Returns\n    -------\n    list\n        A list of dicts, where each dict has the following entries:\n        - ``oml:name`` : str: The OpenML parameter name\n        - ``oml:value`` : mixed: A representation of the parameter value\n        - ``oml:component`` : int: flow id to which the parameter belongs\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/extension_interface/#openml.extensions.extension_interface.Extension.seed_model","title":"<code>seed_model(model, seed)</code>  <code>abstractmethod</code>","text":"<p>Set the seed of all the unseeded components of a model and return the seeded model.</p> <p>Required so that all seed information can be uploaded to OpenML for reproducible results.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The model to be seeded</p> required <code>seed</code> <code>int</code> required <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/extensions/extension_interface.py</code> <pre><code>@abstractmethod\ndef seed_model(self, model: Any, seed: int | None) -&gt; Any:\n    \"\"\"Set the seed of all the unseeded components of a model and return the seeded model.\n\n    Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n    Parameters\n    ----------\n    model : Any\n        The model to be seeded\n    seed : int\n\n    Returns\n    -------\n    model\n    \"\"\"\n</code></pre>"},{"location":"reference/extensions/functions/","title":"functions","text":""},{"location":"reference/extensions/functions/#openml.extensions.functions.get_extension_by_flow","title":"<code>get_extension_by_flow(flow, raise_if_no_extension=False)</code>","text":"<p>Get an extension which can handle the given flow.</p> <p>Iterates all registered extensions and checks whether they can handle the presented flow. Raises an exception if two extensions can handle a flow.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <code>raise_if_no_extension</code> <code>bool (optional</code> <p>Raise an exception if no registered extension can handle the presented flow.</p> <code>False)</code> <p>Returns:</p> Type Description <code>Extension or None</code> Source code in <code>openml/extensions/functions.py</code> <pre><code>def get_extension_by_flow(\n    flow: OpenMLFlow,\n    raise_if_no_extension: bool = False,  # noqa: FBT001, FBT002\n) -&gt; Extension | None:\n    \"\"\"Get an extension which can handle the given flow.\n\n    Iterates all registered extensions and checks whether they can handle the presented flow.\n    Raises an exception if two extensions can handle a flow.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    raise_if_no_extension : bool (optional, default=False)\n        Raise an exception if no registered extension can handle the presented flow.\n\n    Returns\n    -------\n    Extension or None\n    \"\"\"\n    candidates = []\n    for extension_class in openml.extensions.extensions:\n        if extension_class.can_handle_flow(flow):\n            candidates.append(extension_class())\n    if len(candidates) == 0:\n        if raise_if_no_extension:\n            raise ValueError(f\"No extension registered which can handle flow: {flow}\")\n\n        return None\n\n    if len(candidates) == 1:\n        return candidates[0]\n\n    raise ValueError(\n        f\"Multiple extensions registered which can handle flow: {flow}, but only one \"\n        f\"is allowed ({candidates}).\",\n    )\n</code></pre>"},{"location":"reference/extensions/functions/#openml.extensions.functions.get_extension_by_model","title":"<code>get_extension_by_model(model, raise_if_no_extension=False)</code>","text":"<p>Get an extension which can handle the given flow.</p> <p>Iterates all registered extensions and checks whether they can handle the presented model. Raises an exception if two extensions can handle a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <code>raise_if_no_extension</code> <code>bool (optional</code> <p>Raise an exception if no registered extension can handle the presented model.</p> <code>False)</code> <p>Returns:</p> Type Description <code>Extension or None</code> Source code in <code>openml/extensions/functions.py</code> <pre><code>def get_extension_by_model(\n    model: Any,\n    raise_if_no_extension: bool = False,  # noqa: FBT001, FBT002\n) -&gt; Extension | None:\n    \"\"\"Get an extension which can handle the given flow.\n\n    Iterates all registered extensions and checks whether they can handle the presented model.\n    Raises an exception if two extensions can handle a model.\n\n    Parameters\n    ----------\n    model : Any\n\n    raise_if_no_extension : bool (optional, default=False)\n        Raise an exception if no registered extension can handle the presented model.\n\n    Returns\n    -------\n    Extension or None\n    \"\"\"\n    candidates = []\n    for extension_class in openml.extensions.extensions:\n        if extension_class.can_handle_model(model):\n            candidates.append(extension_class())\n    if len(candidates) == 0:\n        if raise_if_no_extension:\n            raise ValueError(f\"No extension registered which can handle model: {model}\")\n\n        return None\n\n    if len(candidates) == 1:\n        return candidates[0]\n\n    raise ValueError(\n        f\"Multiple extensions registered which can handle model: {model}, but only one \"\n        f\"is allowed ({candidates}).\",\n    )\n</code></pre>"},{"location":"reference/extensions/functions/#openml.extensions.functions.register_extension","title":"<code>register_extension(extension)</code>","text":"<p>Register an extension.</p> <p>Registered extensions are considered by <code>get_extension_by_flow</code> and <code>get_extension_by_model</code>, which are used by <code>openml.flow</code> and <code>openml.runs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>Type[Extension]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>openml/extensions/functions.py</code> <pre><code>def register_extension(extension: type[Extension]) -&gt; None:\n    \"\"\"Register an extension.\n\n    Registered extensions are considered by ``get_extension_by_flow`` and\n    ``get_extension_by_model``, which are used by ``openml.flow`` and ``openml.runs``.\n\n    Parameters\n    ----------\n    extension : Type[Extension]\n\n    Returns\n    -------\n    None\n    \"\"\"\n    openml.extensions.extensions.append(extension)\n</code></pre>"},{"location":"reference/extensions/sklearn/","title":"sklearn","text":""},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension","title":"<code>SklearnExtension</code>","text":"<p>               Bases: <code>Extension</code></p> <p>Connect scikit-learn to OpenML-Python. The estimators which use this extension must be scikit-learn compatible, i.e needs to be a subclass of sklearn.base.BaseEstimator\".</p> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>class SklearnExtension(Extension):\n    \"\"\"Connect scikit-learn to OpenML-Python.\n    The estimators which use this extension must be scikit-learn compatible,\n    i.e needs to be a subclass of sklearn.base.BaseEstimator\".\n    \"\"\"\n\n    ################################################################################################\n    # General setup\n\n    @classmethod\n    def can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n        \"\"\"Check whether a given describes a scikit-learn estimator.\n\n        This is done by parsing the ``external_version`` field.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return cls._is_sklearn_flow(flow)\n\n    @classmethod\n    def can_handle_model(cls, model: Any) -&gt; bool:\n        \"\"\"Check whether a model is an instance of ``sklearn.base.BaseEstimator``.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return isinstance(model, sklearn.base.BaseEstimator)\n\n    @classmethod\n    def trim_flow_name(  # noqa: C901\n        cls,\n        long_name: str,\n        extra_trim_length: int = 100,\n        _outer: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; str:\n        \"\"\"Shorten generated sklearn flow name to at most ``max_length`` characters.\n\n        Flows are assumed to have the following naming structure:\n        ``(model_selection)? (pipeline)? (steps)+``\n        and will be shortened to:\n        ``sklearn.(selection.)?(pipeline.)?(steps)+``\n        e.g. (white spaces and newlines added for readability)\n\n        .. code ::\n\n            sklearn.pipeline.Pipeline(\n                columntransformer=sklearn.compose._column_transformer.ColumnTransformer(\n                    numeric=sklearn.pipeline.Pipeline(\n                        imputer=sklearn.preprocessing.imputation.Imputer,\n                        standardscaler=sklearn.preprocessing.data.StandardScaler),\n                    nominal=sklearn.pipeline.Pipeline(\n                        simpleimputer=sklearn.impute.SimpleImputer,\n                        onehotencoder=sklearn.preprocessing._encoders.OneHotEncoder)),\n                variancethreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,\n                svc=sklearn.svm.classes.SVC)\n\n        -&gt;\n        ``sklearn.Pipeline(ColumnTransformer,VarianceThreshold,SVC)``\n\n        Parameters\n        ----------\n        long_name : str\n            The full flow name generated by the scikit-learn extension.\n        extra_trim_length: int (default=100)\n            If the trimmed name would exceed `extra_trim_length` characters, additional trimming\n            of the short name is performed. This reduces the produced short name length.\n            There is no guarantee the end result will not exceed `extra_trim_length`.\n        _outer : bool (default=True)\n            For internal use only. Specifies if the function is called recursively.\n\n        Returns\n        -------\n        str\n\n        \"\"\"\n\n        def remove_all_in_parentheses(string: str) -&gt; str:\n            string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n            while removals &gt; 0:\n                string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n            return string\n\n        # Generally, we want to trim all hyperparameters, the exception to that is for model\n        # selection, as the `estimator` hyperparameter is very indicative of what is in the flow.\n        # So we first trim name of the `estimator` specified in mode selection. For reference, in\n        # the example below, we want to trim `sklearn.tree.tree.DecisionTreeClassifier`, and\n        # keep it in the final trimmed flow name:\n        # sklearn.pipeline.Pipeline(Imputer=sklearn.preprocessing.imputation.Imputer,\n        # VarianceThreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,  # noqa: ERA001, E501\n        # Estimator=sklearn.model_selection._search.RandomizedSearchCV(estimator=\n        # sklearn.tree.tree.DecisionTreeClassifier))\n        if \"sklearn.model_selection\" in long_name:\n            start_index = long_name.index(\"sklearn.model_selection\")\n            estimator_start = (\n                start_index + long_name[start_index:].index(\"estimator=\") + len(\"estimator=\")\n            )\n\n            model_select_boilerplate = long_name[start_index:estimator_start]\n            # above is .g. \"sklearn.model_selection._search.RandomizedSearchCV(estimator=\"\n            model_selection_class = model_select_boilerplate.split(\"(\")[0].split(\".\")[-1]\n\n            # Now we want to also find and parse the `estimator`, for this we find the closing\n            # parenthesis to the model selection technique:\n            closing_parenthesis_expected = 1\n            for char in long_name[estimator_start:]:\n                if char == \"(\":\n                    closing_parenthesis_expected += 1\n                if char == \")\":\n                    closing_parenthesis_expected -= 1\n                if closing_parenthesis_expected == 0:\n                    break\n\n            _end: int = estimator_start + len(long_name[estimator_start:]) - 1\n            model_select_pipeline = long_name[estimator_start:_end]\n\n            trimmed_pipeline = cls.trim_flow_name(model_select_pipeline, _outer=False)\n            _, trimmed_pipeline = trimmed_pipeline.split(\".\", maxsplit=1)  # trim module prefix\n            model_select_short = f\"sklearn.{model_selection_class}[{trimmed_pipeline}]\"\n            name = long_name[:start_index] + model_select_short + long_name[_end + 1 :]\n        else:\n            name = long_name\n\n        module_name = long_name.split(\".\")[0]\n        short_name = module_name + \".{}\"\n\n        if name.startswith(\"sklearn.pipeline\"):\n            full_pipeline_class, pipeline = name[:-1].split(\"(\", maxsplit=1)\n            pipeline_class = full_pipeline_class.split(\".\")[-1]\n            # We don't want nested pipelines in the short name, so we trim all complicated\n            # subcomponents, i.e. those with parentheses:\n            pipeline = remove_all_in_parentheses(pipeline)\n\n            # then the pipeline steps are formatted e.g.:\n            # step1name=sklearn.submodule.ClassName,step2name...\n            components = [component.split(\".\")[-1] for component in pipeline.split(\",\")]\n            pipeline = f\"{pipeline_class}({','.join(components)})\"\n            if len(short_name.format(pipeline)) &gt; extra_trim_length:\n                pipeline = f\"{pipeline_class}(...,{components[-1]})\"\n        else:\n            # Just a simple component: e.g. sklearn.tree.DecisionTreeClassifier\n            pipeline = remove_all_in_parentheses(name).split(\".\")[-1]\n\n        if not _outer:\n            # Anything from parenthesis in inner calls should not be culled, so we use brackets\n            pipeline = pipeline.replace(\"(\", \"[\").replace(\")\", \"]\")\n        else:\n            # Square brackets may be introduced with nested model_selection\n            pipeline = pipeline.replace(\"[\", \"(\").replace(\"]\", \")\")\n\n        return short_name.format(pipeline)\n\n    @classmethod\n    def _min_dependency_str(cls, sklearn_version: str) -&gt; str:\n        \"\"\"Returns a string containing the minimum dependencies for the sklearn version passed.\n\n        Parameters\n        ----------\n        sklearn_version : str\n            A version string of the xx.xx.xx\n\n        Returns\n        -------\n        str\n        \"\"\"\n        # This explicit check is necessary to support existing entities on the OpenML servers\n        # that used the fixed dependency string (in the else block)\n        if Version(openml.__version__) &gt; Version(\"0.11\"):\n            # OpenML v0.11 onwards supports sklearn&gt;=0.24\n            # assumption: 0.24 onwards sklearn should contain a _min_dependencies.py file with\n            # variables declared for extracting minimum dependency for that version\n            if Version(sklearn_version) &gt;= Version(\"0.24\"):\n                from sklearn import _min_dependencies as _mindep\n\n                dependency_list = {\n                    \"numpy\": f\"{_mindep.NUMPY_MIN_VERSION}\",\n                    \"scipy\": f\"{_mindep.SCIPY_MIN_VERSION}\",\n                    \"joblib\": f\"{_mindep.JOBLIB_MIN_VERSION}\",\n                    \"threadpoolctl\": f\"{_mindep.THREADPOOLCTL_MIN_VERSION}\",\n                }\n            elif Version(sklearn_version) &gt;= Version(\"0.23\"):\n                dependency_list = {\n                    \"numpy\": \"1.13.3\",\n                    \"scipy\": \"0.19.1\",\n                    \"joblib\": \"0.11\",\n                    \"threadpoolctl\": \"2.0.0\",\n                }\n                if Version(sklearn_version).micro == 0:\n                    dependency_list.pop(\"threadpoolctl\")\n            elif Version(sklearn_version) &gt;= Version(\"0.21\"):\n                dependency_list = {\"numpy\": \"1.11.0\", \"scipy\": \"0.17.0\", \"joblib\": \"0.11\"}\n            elif Version(sklearn_version) &gt;= Version(\"0.19\"):\n                dependency_list = {\"numpy\": \"1.8.2\", \"scipy\": \"0.13.3\"}\n            else:\n                dependency_list = {\"numpy\": \"1.6.1\", \"scipy\": \"0.9\"}\n        else:\n            # this is INCORRECT for sklearn versions &gt;= 0.19 and &lt; 0.24\n            # given that OpenML has existing flows uploaded with such dependency information,\n            # we change no behaviour for older sklearn version, however from 0.24 onwards\n            # the dependency list will be accurately updated for any flow uploaded to OpenML\n            dependency_list = {\"numpy\": \"1.6.1\", \"scipy\": \"0.9\"}\n\n        sklearn_dep = f\"sklearn=={sklearn_version}\"\n        dep_str = \"\\n\".join([f\"{k}&gt;={v}\" for k, v in dependency_list.items()])\n        return \"\\n\".join([sklearn_dep, dep_str])\n\n    ################################################################################################\n    # Methods for flow serialization and de-serialization\n\n    def flow_to_model(\n        self,\n        flow: OpenMLFlow,\n        initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n        strict_version: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; Any:\n        \"\"\"Initializes a sklearn model based on a flow.\n\n        Parameters\n        ----------\n        flow : mixed\n            the object to deserialize (can be flow object, or any serialized\n            parameter value that is accepted by)\n\n        initialize_with_defaults : bool, optional (default=False)\n            If this flag is set, the hyperparameter values of flows will be\n            ignored and a flow with its defaults is returned.\n\n        strict_version : bool, default=True\n            Whether to fail if version requirements are not fulfilled.\n\n        Returns\n        -------\n        mixed\n        \"\"\"\n        return self._deserialize_sklearn(\n            flow,\n            initialize_with_defaults=initialize_with_defaults,\n            strict_version=strict_version,\n        )\n\n    def _deserialize_sklearn(  # noqa: PLR0915, C901, PLR0912\n        self,\n        o: Any,\n        components: dict | None = None,\n        initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n        recursion_depth: int = 0,\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        \"\"\"Recursive function to deserialize a scikit-learn flow.\n\n        This function inspects an object to deserialize and decides how to do so. This function\n        delegates all work to the respective functions to deserialize special data structures etc.\n        This function works on everything that has been serialized to OpenML: OpenMLFlow,\n        components (which are flows themselves), functions, hyperparameter distributions (for\n        random search) and the actual hyperparameter values themselves.\n\n        Parameters\n        ----------\n        o : mixed\n            the object to deserialize (can be flow object, or any serialized\n            parameter value that is accepted by)\n\n        components : Optional[dict]\n            Components of the current flow being de-serialized. These will not be used when\n            de-serializing the actual flow, but when de-serializing a component reference.\n\n        initialize_with_defaults : bool, optional (default=False)\n            If this flag is set, the hyperparameter values of flows will be\n            ignored and a flow with its defaults is returned.\n\n        recursion_depth : int\n            The depth at which this flow is called, mostly for debugging\n            purposes\n\n        strict_version : bool, default=True\n            Whether to fail if version requirements are not fulfilled.\n\n        Returns\n        -------\n        mixed\n        \"\"\"\n        logger.info(\n            \"-{} flow_to_sklearn START o={}, components={}, init_defaults={}\".format(\n                \"-\" * recursion_depth, o, components, initialize_with_defaults\n            ),\n        )\n        depth_pp = recursion_depth + 1  # shortcut var, depth plus plus\n\n        # First, we need to check whether the presented object is a json string.\n        # JSON strings are used to encoder parameter values. By passing around\n        # json strings for parameters, we make sure that we can flow_to_sklearn\n        # the parameter values to the correct type.\n\n        if isinstance(o, str):\n            with contextlib.suppress(JSONDecodeError):\n                o = json.loads(o)\n\n        if isinstance(o, dict):\n            # Check if the dict encodes a 'special' object, which could not\n            # easily converted into a string, but rather the information to\n            # re-create the object were stored in a dictionary.\n            if \"oml-python:serialized_object\" in o:\n                serialized_type = o[\"oml-python:serialized_object\"]\n                value = o[\"value\"]\n                if serialized_type == \"type\":\n                    rval = self._deserialize_type(value)\n                elif serialized_type == \"rv_frozen\":\n                    rval = self._deserialize_rv_frozen(value)\n                elif serialized_type == \"function\":\n                    rval = self._deserialize_function(value)\n                elif serialized_type in (COMPOSITION_STEP_CONSTANT, COMPONENT_REFERENCE):\n                    if serialized_type == COMPOSITION_STEP_CONSTANT:\n                        pass\n                    elif serialized_type == COMPONENT_REFERENCE:\n                        value = self._deserialize_sklearn(\n                            value,\n                            recursion_depth=depth_pp,\n                            strict_version=strict_version,\n                        )\n                    else:\n                        raise NotImplementedError(serialized_type)\n                    assert components is not None  # Necessary for mypy\n                    step_name = value[\"step_name\"]\n                    key = value[\"key\"]\n                    component = self._deserialize_sklearn(\n                        components[key],\n                        initialize_with_defaults=initialize_with_defaults,\n                        recursion_depth=depth_pp,\n                        strict_version=strict_version,\n                    )\n                    # The component is now added to where it should be used\n                    # later. It should not be passed to the constructor of the\n                    # main flow object.\n                    del components[key]\n                    if step_name is None:\n                        rval = component\n                    elif \"argument_1\" not in value:\n                        rval = (step_name, component)\n                    else:\n                        rval = (step_name, component, value[\"argument_1\"])\n                elif serialized_type == \"cv_object\":\n                    rval = self._deserialize_cross_validator(\n                        value,\n                        recursion_depth=recursion_depth,\n                        strict_version=strict_version,\n                    )\n                else:\n                    raise ValueError(f\"Cannot flow_to_sklearn {serialized_type}\")\n\n            else:\n                rval = OrderedDict(\n                    (\n                        self._deserialize_sklearn(\n                            o=key,\n                            components=components,\n                            initialize_with_defaults=initialize_with_defaults,\n                            recursion_depth=depth_pp,\n                            strict_version=strict_version,\n                        ),\n                        self._deserialize_sklearn(\n                            o=value,\n                            components=components,\n                            initialize_with_defaults=initialize_with_defaults,\n                            recursion_depth=depth_pp,\n                            strict_version=strict_version,\n                        ),\n                    )\n                    for key, value in sorted(o.items())\n                )\n        elif isinstance(o, (list, tuple)):\n            rval = [\n                self._deserialize_sklearn(\n                    o=element,\n                    components=components,\n                    initialize_with_defaults=initialize_with_defaults,\n                    recursion_depth=depth_pp,\n                    strict_version=strict_version,\n                )\n                for element in o\n            ]\n            if isinstance(o, tuple):\n                rval = tuple(rval)\n        elif isinstance(o, (bool, int, float, str)) or o is None:\n            rval = o\n        elif isinstance(o, OpenMLFlow):\n            if not self._is_sklearn_flow(o):\n                raise ValueError(\"Only sklearn flows can be reinstantiated\")\n            rval = self._deserialize_model(\n                flow=o,\n                keep_defaults=initialize_with_defaults,\n                recursion_depth=recursion_depth,\n                strict_version=strict_version,\n            )\n        else:\n            raise TypeError(o)\n        logger.info(f\"-{'-' * recursion_depth} flow_to_sklearn END   o={o}, rval={rval}\")\n        return rval\n\n    def model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n        \"\"\"Transform a scikit-learn model to a flow for uploading it to OpenML.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        OpenMLFlow\n        \"\"\"\n        # Necessary to make pypy not complain about all the different possible return types\n        return self._serialize_sklearn(model)\n\n    def _serialize_sklearn(self, o: Any, parent_model: Any | None = None) -&gt; Any:  # noqa: PLR0912, C901\n        rval = None  # type: Any\n\n        # TODO: assert that only on first recursion lvl `parent_model` can be None\n        if self.is_estimator(o):\n            # is the main model or a submodel\n            rval = self._serialize_model(o)\n        elif (\n            isinstance(o, (list, tuple))\n            and len(o) == 2\n            and o[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n            and isinstance(parent_model, sklearn.pipeline._BaseComposition)\n        ):\n            rval = o\n        elif isinstance(o, (list, tuple)):\n            # TODO: explain what type of parameter is here\n            rval = [self._serialize_sklearn(element, parent_model) for element in o]\n            if isinstance(o, tuple):\n                rval = tuple(rval)\n        elif isinstance(o, SIMPLE_TYPES) or o is None:\n            if isinstance(o, tuple(SIMPLE_NUMPY_TYPES)):\n                o = o.item()  # type: ignore\n            # base parameter values\n            rval = o\n        elif isinstance(o, dict):\n            # TODO: explain what type of parameter is here\n            if not isinstance(o, OrderedDict):\n                o = OrderedDict(sorted(o.items()))\n\n            rval = OrderedDict()\n            for key, value in o.items():\n                if not isinstance(key, str):\n                    raise TypeError(\n                        \"Can only use string as keys, you passed \"\n                        f\"type {type(key)} for value {key!s}.\",\n                    )\n                _key = self._serialize_sklearn(key, parent_model)\n                rval[_key] = self._serialize_sklearn(value, parent_model)\n        elif isinstance(o, type):\n            # TODO: explain what type of parameter is here\n            rval = self._serialize_type(o)\n        elif isinstance(o, scipy.stats.distributions.rv_frozen):\n            rval = self._serialize_rv_frozen(o)\n        # This only works for user-defined functions (and not even partial).\n        # I think this is exactly what we want here as there shouldn't be any\n        # built-in or functool.partials in a pipeline\n        elif inspect.isfunction(o):\n            # TODO: explain what type of parameter is here\n            rval = self._serialize_function(o)\n        elif self._is_cross_validator(o):\n            # TODO: explain what type of parameter is here\n            rval = self._serialize_cross_validator(o)\n        else:\n            raise TypeError(o, type(o))\n\n        return rval\n\n    def get_version_information(self) -&gt; list[str]:\n        \"\"\"List versions of libraries required by the flow.\n\n        Libraries listed are ``Python``, ``scikit-learn``, ``numpy`` and ``scipy``.\n\n        Returns\n        -------\n        List\n        \"\"\"\n        # This can possibly be done by a package such as pyxb, but I could not get\n        # it to work properly.\n        import numpy\n        import scipy\n        import sklearn\n\n        major, minor, micro, _, _ = sys.version_info\n        python_version = f\"Python_{'.'.join([str(major), str(minor), str(micro)])}.\"\n        sklearn_version = f\"Sklearn_{sklearn.__version__}.\"\n        numpy_version = f\"NumPy_{numpy.__version__}.\"  # type: ignore\n        scipy_version = f\"SciPy_{scipy.__version__}.\"\n\n        return [python_version, sklearn_version, numpy_version, scipy_version]\n\n    def create_setup_string(self, model: Any) -&gt; str:  # noqa: ARG002\n        \"\"\"Create a string which can be used to reinstantiate the given model.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        str\n        \"\"\"\n        return \" \".join(self.get_version_information())\n\n    def _is_cross_validator(self, o: Any) -&gt; bool:\n        return isinstance(o, sklearn.model_selection.BaseCrossValidator)\n\n    @classmethod\n    def _is_sklearn_flow(cls, flow: OpenMLFlow) -&gt; bool:\n        sklearn_dependency = isinstance(flow.dependencies, str) and \"sklearn\" in flow.dependencies\n        sklearn_as_external = isinstance(flow.external_version, str) and (\n            flow.external_version.startswith(\"sklearn==\") or \",sklearn==\" in flow.external_version\n        )\n        return sklearn_dependency or sklearn_as_external\n\n    def _get_sklearn_description(self, model: Any, char_lim: int = 1024) -&gt; str:\n        r\"\"\"Fetches the sklearn function docstring for the flow description\n\n        Retrieves the sklearn docstring available and does the following:\n        * If length of docstring &lt;= char_lim, then returns the complete docstring\n        * Else, trims the docstring till it encounters a 'Read more in the :ref:'\n        * Or till it encounters a 'Parameters\\n----------\\n'\n        The final string returned is at most of length char_lim with leading and\n        trailing whitespaces removed.\n\n        Parameters\n        ----------\n        model : sklearn model\n        char_lim : int\n            Specifying the max length of the returned string.\n            OpenML servers have a constraint of 1024 characters for the 'description' field.\n\n        Returns\n        -------\n        str\n        \"\"\"\n\n        def match_format(s):\n            return f\"{s}\\n{len(s) * '-'}\\n\"\n\n        s = inspect.getdoc(model)\n        if s is None:\n            return \"\"\n        try:\n            # trim till 'Read more'\n            pattern = \"Read more in the :ref:\"\n            index = s.index(pattern)\n            s = s[:index]\n            # trimming docstring to be within char_lim\n            if len(s) &gt; char_lim:\n                s = f\"{s[: char_lim - 3]}...\"\n            return s.strip()\n        except ValueError:\n            logger.warning(\n                \"'Read more' not found in descriptions. \"\n                \"Trying to trim till 'Parameters' if available in docstring.\",\n            )\n        try:\n            # if 'Read more' doesn't exist, trim till 'Parameters'\n            pattern = \"Parameters\"\n            index = s.index(match_format(pattern))\n        except ValueError:\n            # returning full docstring\n            logger.warning(\"'Parameters' not found in docstring. Omitting docstring trimming.\")\n            index = len(s)\n        s = s[:index]\n        # trimming docstring to be within char_lim\n        if len(s) &gt; char_lim:\n            s = f\"{s[: char_lim - 3]}...\"\n        return s.strip()\n\n    def _extract_sklearn_parameter_docstring(self, model) -&gt; None | str:\n        \"\"\"Extracts the part of sklearn docstring containing parameter information\n\n        Fetches the entire docstring and trims just the Parameter section.\n        The assumption is that 'Parameters' is the first section in sklearn docstrings,\n        followed by other sections titled 'Attributes', 'See also', 'Note', 'References',\n        appearing in that order if defined.\n        Returns a None if no section with 'Parameters' can be found in the docstring.\n\n        Parameters\n        ----------\n        model : sklearn model\n\n        Returns\n        -------\n        str, or None\n        \"\"\"\n\n        def match_format(s):\n            return f\"{s}\\n{len(s) * '-'}\\n\"\n\n        s = inspect.getdoc(model)\n        if s is None:\n            return None\n        try:\n            index1 = s.index(match_format(\"Parameters\"))\n        except ValueError as e:\n            # when sklearn docstring has no 'Parameters' section\n            logger.warning(f\"{match_format('Parameters')} {e}\")\n            return None\n\n        headings = [\"Attributes\", \"Notes\", \"See also\", \"Note\", \"References\"]\n        for h in headings:\n            try:\n                # to find end of Parameters section\n                index2 = s.index(match_format(h))\n                break\n            except ValueError:\n                logger.warning(f\"{h} not available in docstring\")\n                continue\n        else:\n            # in the case only 'Parameters' exist, trim till end of docstring\n            index2 = len(s)\n        s = s[index1:index2]\n        return s.strip()\n\n    def _extract_sklearn_param_info(self, model, char_lim=1024) -&gt; None | dict:\n        \"\"\"Parses parameter type and description from sklearn dosctring\n\n        Parameters\n        ----------\n        model : sklearn model\n        char_lim : int\n            Specifying the max length of the returned string.\n            OpenML servers have a constraint of 1024 characters string fields.\n\n        Returns\n        -------\n        Dict, or None\n        \"\"\"\n        docstring = self._extract_sklearn_parameter_docstring(model)\n        if docstring is None:\n            # when sklearn docstring has no 'Parameters' section\n            return None\n\n        n = re.compile(\"[.]*\\n\", flags=IGNORECASE)\n        lines = n.split(docstring)\n        p = re.compile(\"[a-z0-9_ ]+ : [a-z0-9_']+[a-z0-9_ ]*\", flags=IGNORECASE)\n        # The above regular expression is designed to detect sklearn parameter names and type\n        # in the format of [variable_name][space]:[space][type]\n        # The expectation is that the parameter description for this detected parameter will\n        # be all the lines in the docstring till the regex finds another parameter match\n\n        # collecting parameters and their descriptions\n        description = []  # type: List\n        for s in lines:\n            param = p.findall(s)\n            if param != []:\n                # a parameter definition is found by regex\n                # creating placeholder when parameter found which will be a list of strings\n                # string descriptions will be appended in subsequent iterations\n                # till another parameter is found and a new placeholder is created\n                placeholder = [\"\"]  # type: List[str]\n                description.append(placeholder)\n            elif len(description) &gt; 0:  # description=[] means no parameters found yet\n                # appending strings to the placeholder created when parameter found\n                description[-1].append(s)\n        for i in range(len(description)):\n            # concatenating parameter description strings\n            description[i] = \"\\n\".join(description[i]).strip()\n            # limiting all parameter descriptions to accepted OpenML string length\n            if len(description[i]) &gt; char_lim:\n                description[i] = f\"{description[i][: char_lim - 3]}...\"\n\n        # collecting parameters and their types\n        parameter_docs = OrderedDict()\n        matches = p.findall(docstring)\n        for i, param in enumerate(matches):\n            key, value = str(param).split(\":\")\n            parameter_docs[key.strip()] = [value.strip(), description[i]]\n\n        # to avoid KeyError for missing parameters\n        param_list_true = list(model.get_params().keys())\n        param_list_found = list(parameter_docs.keys())\n        for param in list(set(param_list_true) - set(param_list_found)):\n            parameter_docs[param] = [None, None]\n\n        return parameter_docs\n\n    def _serialize_model(self, model: Any) -&gt; OpenMLFlow:\n        \"\"\"Create an OpenMLFlow.\n\n        Calls `sklearn_to_flow` recursively to properly serialize the\n        parameters to strings and the components (other models) to OpenMLFlows.\n\n        Parameters\n        ----------\n        model : sklearn estimator\n\n        Returns\n        -------\n        OpenMLFlow\n\n        \"\"\"\n        # Get all necessary information about the model objects itself\n        (\n            parameters,\n            parameters_meta_info,\n            subcomponents,\n            subcomponents_explicit,\n        ) = self._extract_information_from_model(model)\n\n        # Check that a component does not occur multiple times in a flow as this\n        # is not supported by OpenML\n        self._check_multiple_occurence_of_component_in_flow(model, subcomponents)\n\n        # Create a flow name, which contains all components in brackets, e.g.:\n        # RandomizedSearchCV(Pipeline(StandardScaler,AdaBoostClassifier(DecisionTreeClassifier)),\n        # StandardScaler,AdaBoostClassifier(DecisionTreeClassifier))\n        class_name = model.__module__ + \".\" + model.__class__.__name__\n\n        # will be part of the name (in brackets)\n        sub_components_names = \"\"\n        for key in subcomponents:\n            name_thing = subcomponents[key]\n            if isinstance(name_thing, OpenMLFlow):\n                name = name_thing.name\n            elif (\n                isinstance(name_thing, str)\n                and subcomponents[key] in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                name = name_thing\n            else:\n                raise TypeError(type(subcomponents[key]))\n\n            if key in subcomponents_explicit:\n                sub_components_names += \",\" + key + \"=\" + name\n            else:\n                sub_components_names += \",\" + name\n\n        # slice operation on string in order to get rid of leading comma\n        name = f\"{class_name}({sub_components_names[1:]})\" if sub_components_names else class_name\n        short_name = SklearnExtension.trim_flow_name(name)\n\n        # Get the external versions of all sub-components\n        external_version = self._get_external_version_string(model, subcomponents)\n        dependencies = self._get_dependencies()\n        tags = self._get_tags()\n\n        sklearn_description = self._get_sklearn_description(model)\n        return OpenMLFlow(\n            name=name,\n            class_name=class_name,\n            custom_name=short_name,\n            description=sklearn_description,\n            model=model,\n            components=subcomponents,\n            parameters=parameters,\n            parameters_meta_info=parameters_meta_info,\n            external_version=external_version,\n            tags=tags,\n            extension=self,\n            language=\"English\",\n            dependencies=dependencies,\n        )\n\n    def _get_dependencies(self) -&gt; str:\n        return self._min_dependency_str(sklearn.__version__)  # type: ignore\n\n    def _get_tags(self) -&gt; list[str]:\n        sklearn_version = self._format_external_version(\"sklearn\", sklearn.__version__)  # type: ignore\n        sklearn_version_formatted = sklearn_version.replace(\"==\", \"_\")\n        return [\n            \"openml-python\",\n            \"sklearn\",\n            \"scikit-learn\",\n            \"python\",\n            sklearn_version_formatted,\n            # TODO: add more tags based on the scikit-learn\n            # module a flow is in? For example automatically\n            # annotate a class of sklearn.svm.SVC() with the\n            # tag svm?\n        ]\n\n    def _get_external_version_string(\n        self,\n        model: Any,\n        sub_components: dict[str, OpenMLFlow],\n    ) -&gt; str:\n        # Create external version string for a flow, given the model and the\n        # already parsed dictionary of sub_components. Retrieves the external\n        # version of all subcomponents, which themselves already contain all\n        # requirements for their subcomponents. The external version string is a\n        # sorted concatenation of all modules which are present in this run.\n\n        external_versions = set()\n\n        # The model is None if the flow is a placeholder flow such as 'passthrough' or 'drop'\n        if model is not None:\n            model_package_name = model.__module__.split(\".\")[0]\n            module = importlib.import_module(model_package_name)\n            model_package_version_number = module.__version__  # type: ignore\n            external_version = self._format_external_version(\n                model_package_name,\n                model_package_version_number,\n            )\n            external_versions.add(external_version)\n\n        openml_version = self._format_external_version(\"openml\", openml.__version__)\n        sklearn_version = self._format_external_version(\"sklearn\", sklearn.__version__)  # type: ignore\n        external_versions.add(openml_version)\n        external_versions.add(sklearn_version)\n        for visitee in sub_components.values():\n            if isinstance(visitee, str) and visitee in SKLEARN_PIPELINE_STRING_COMPONENTS:\n                continue\n            for external_version in visitee.external_version.split(\",\"):\n                external_versions.add(external_version)\n        return \",\".join(sorted(external_versions))\n\n    def _check_multiple_occurence_of_component_in_flow(\n        self,\n        model: Any,\n        sub_components: dict[str, OpenMLFlow],\n    ) -&gt; None:\n        to_visit_stack: list[OpenMLFlow] = []\n        to_visit_stack.extend(sub_components.values())\n        known_sub_components: set[str] = set()\n\n        while len(to_visit_stack) &gt; 0:\n            visitee = to_visit_stack.pop()\n            if isinstance(visitee, str) and visitee in SKLEARN_PIPELINE_STRING_COMPONENTS:\n                known_sub_components.add(visitee)\n            elif visitee.name in known_sub_components:\n                raise ValueError(\n                    f\"Found a second occurence of component {visitee.name} when \"\n                    f\"trying to serialize {model}.\",\n                )\n            else:\n                known_sub_components.add(visitee.name)\n                to_visit_stack.extend(visitee.components.values())\n\n    def _extract_information_from_model(  # noqa: PLR0915, C901, PLR0912\n        self,\n        model: Any,\n    ) -&gt; tuple[\n        OrderedDict[str, str | None],\n        OrderedDict[str, dict | None],\n        OrderedDict[str, OpenMLFlow],\n        set,\n    ]:\n        # This function contains four \"global\" states and is quite long and\n        # complicated. If it gets to complicated to ensure it's correctness,\n        # it would be best to make it a class with the four \"global\" states being\n        # the class attributes and the if/elif/else in the for-loop calls to\n        # separate class methods\n\n        # stores all entities that should become subcomponents\n        sub_components = OrderedDict()  # type: OrderedDict[str, OpenMLFlow]\n        # stores the keys of all subcomponents that should become\n        sub_components_explicit = set()\n        parameters: OrderedDict[str, str | None] = OrderedDict()\n        parameters_meta_info: OrderedDict[str, dict | None] = OrderedDict()\n        parameters_docs = self._extract_sklearn_param_info(model)\n\n        model_parameters = model.get_params(deep=False)\n        for k, v in sorted(model_parameters.items(), key=lambda t: t[0]):\n            rval = self._serialize_sklearn(v, model)\n\n            def flatten_all(list_):\n                \"\"\"Flattens arbitrary depth lists of lists (e.g. [[1,2],[3,[1]]] -&gt; [1,2,3,1]).\"\"\"\n                for el in list_:\n                    if isinstance(el, (list, tuple)) and len(el) &gt; 0:\n                        yield from flatten_all(el)\n                    else:\n                        yield el\n\n            # In case rval is a list of lists (or tuples), we need to identify two situations:\n            # - sklearn pipeline steps, feature union or base classifiers in voting classifier.\n            #   They look like e.g. [(\"imputer\", Imputer()), (\"classifier\", SVC())]\n            # - a list of lists with simple types (e.g. int or str), such as for an OrdinalEncoder\n            #   where all possible values for each feature are described: [[0,1,2], [1,2,5]]\n            is_non_empty_list_of_lists_with_same_type = (\n                isinstance(rval, (list, tuple))\n                and len(rval) &gt; 0\n                and isinstance(rval[0], (list, tuple))\n                and all(isinstance(rval_i, type(rval[0])) for rval_i in rval)\n            )\n\n            # Check that all list elements are of simple types.\n            nested_list_of_simple_types = (\n                is_non_empty_list_of_lists_with_same_type\n                and all(isinstance(el, SIMPLE_TYPES) for el in flatten_all(rval))\n                and all(\n                    len(rv) in (2, 3) and rv[1] not in SKLEARN_PIPELINE_STRING_COMPONENTS\n                    for rv in rval\n                )\n            )\n\n            if is_non_empty_list_of_lists_with_same_type and not nested_list_of_simple_types:\n                # If a list of lists is identified that include 'non-simple' types (e.g. objects),\n                # we assume they are steps in a pipeline, feature union, or base classifiers in\n                # a voting classifier.\n                parameter_value = []  # type: List\n                reserved_keywords = set(model.get_params(deep=False).keys())\n\n                for sub_component_tuple in rval:\n                    identifier = sub_component_tuple[0]\n                    sub_component = sub_component_tuple[1]\n                    sub_component_type = type(sub_component_tuple)\n                    if not 2 &lt;= len(sub_component_tuple) &lt;= 3:\n                        # length 2 is for {VotingClassifier.estimators,\n                        # Pipeline.steps, FeatureUnion.transformer_list}\n                        # length 3 is for ColumnTransformer\n                        raise ValueError(\n                            f\"Length of tuple of type {sub_component_type}\"\n                            \" does not match assumptions\"\n                        )\n\n                    if isinstance(sub_component, str):\n                        if sub_component not in SKLEARN_PIPELINE_STRING_COMPONENTS:\n                            msg = (\n                                \"Second item of tuple does not match assumptions. \"\n                                \"If string, can be only 'drop' or 'passthrough' but\"\n                                f\"got {sub_component}\"\n                            )\n                            raise ValueError(msg)\n                    elif sub_component is None:\n                        msg = (\n                            \"Cannot serialize objects of None type. Please use a valid \"\n                            \"placeholder for None. Note that empty sklearn estimators can be \"\n                            \"replaced with 'drop' or 'passthrough'.\"\n                        )\n                        raise ValueError(msg)\n                    elif not isinstance(sub_component, OpenMLFlow):\n                        msg = (\n                            \"Second item of tuple does not match assumptions. \"\n                            f\"Expected OpenMLFlow, got {type(sub_component)}\"\n                        )\n                        raise TypeError(msg)\n\n                    if identifier in reserved_keywords:\n                        parent_model = f\"{model.__module__}.{model.__class__.__name__}\"\n                        msg = (\n                            \"Found element shadowing official \"\n                            f\"parameter for {parent_model}: {identifier}\"\n                        )\n                        raise PyOpenMLError(msg)\n\n                    # when deserializing the parameter\n                    sub_components_explicit.add(identifier)\n                    if isinstance(sub_component, str):\n                        external_version = self._get_external_version_string(None, {})\n                        dependencies = self._get_dependencies()\n                        tags = self._get_tags()\n\n                        sub_components[identifier] = OpenMLFlow(\n                            name=sub_component,\n                            description=\"Placeholder flow for scikit-learn's string pipeline \"\n                            \"members\",\n                            components=OrderedDict(),\n                            parameters=OrderedDict(),\n                            parameters_meta_info=OrderedDict(),\n                            external_version=external_version,\n                            tags=tags,\n                            language=\"English\",\n                            dependencies=dependencies,\n                            model=None,\n                        )\n                        component_reference: OrderedDict[str, str | dict] = OrderedDict()\n                        component_reference[\"oml-python:serialized_object\"] = (\n                            COMPOSITION_STEP_CONSTANT\n                        )\n                        cr_value: dict[str, Any] = OrderedDict()\n                        cr_value[\"key\"] = identifier\n                        cr_value[\"step_name\"] = identifier\n                        if len(sub_component_tuple) == 3:\n                            cr_value[\"argument_1\"] = sub_component_tuple[2]\n                        component_reference[\"value\"] = cr_value\n                    else:\n                        sub_components[identifier] = sub_component\n                        component_reference = OrderedDict()\n                        component_reference[\"oml-python:serialized_object\"] = COMPONENT_REFERENCE\n                        cr_value = OrderedDict()\n                        cr_value[\"key\"] = identifier\n                        cr_value[\"step_name\"] = identifier\n                        if len(sub_component_tuple) == 3:\n                            cr_value[\"argument_1\"] = sub_component_tuple[2]\n                        component_reference[\"value\"] = cr_value\n                    parameter_value.append(component_reference)\n\n                # Here (and in the elif and else branch below) are the only\n                # places where we encode a value as json to make sure that all\n                # parameter values still have the same type after\n                # deserialization\n                if isinstance(rval, tuple):\n                    parameter_json = json.dumps(tuple(parameter_value))\n                else:\n                    parameter_json = json.dumps(parameter_value)\n                parameters[k] = parameter_json\n\n            elif isinstance(rval, OpenMLFlow):\n                # A subcomponent, for example the base model in\n                # AdaBoostClassifier\n                sub_components[k] = rval\n                sub_components_explicit.add(k)\n                component_reference = OrderedDict()\n                component_reference[\"oml-python:serialized_object\"] = COMPONENT_REFERENCE\n                cr_value = OrderedDict()\n                cr_value[\"key\"] = k\n                cr_value[\"step_name\"] = None\n                component_reference[\"value\"] = cr_value\n                cr = self._serialize_sklearn(component_reference, model)\n                parameters[k] = json.dumps(cr)\n\n            elif not (hasattr(rval, \"__len__\") and len(rval) == 0):\n                rval = json.dumps(rval)\n                parameters[k] = rval\n            # a regular hyperparameter\n            else:\n                parameters[k] = None\n\n            if parameters_docs is not None:\n                data_type, description = parameters_docs[k]\n                parameters_meta_info[k] = OrderedDict(\n                    ((\"description\", description), (\"data_type\", data_type)),\n                )\n            else:\n                parameters_meta_info[k] = OrderedDict(((\"description\", None), (\"data_type\", None)))\n\n        return parameters, parameters_meta_info, sub_components, sub_components_explicit\n\n    def _get_fn_arguments_with_defaults(self, fn_name: Callable) -&gt; tuple[dict, set]:\n        \"\"\"\n        Returns\n        -------\n            i) a dict with all parameter names that have a default value, and\n            ii) a set with all parameter names that do not have a default\n\n        Parameters\n        ----------\n        fn_name : callable\n            The function of which we want to obtain the defaults\n\n        Returns\n        -------\n        params_with_defaults: dict\n            a dict mapping parameter name to the default value\n        params_without_defaults: set\n            a set with all parameters that do not have a default value\n        \"\"\"\n        # parameters with defaults are optional, all others are required.\n        parameters = inspect.signature(fn_name).parameters\n        required_params = set()\n        optional_params = {}\n        for param in parameters:\n            parameter = parameters.get(param)\n            default_val = parameter.default  # type: ignore\n            if default_val is inspect.Signature.empty:\n                required_params.add(param)\n            else:\n                optional_params[param] = default_val\n        return optional_params, required_params\n\n    def _deserialize_model(  # noqa: C901\n        self,\n        flow: OpenMLFlow,\n        keep_defaults: bool,  # noqa: FBT001\n        recursion_depth: int,\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        logger.info(f\"-{'-' * recursion_depth} deserialize {flow.name}\")\n        model_name = flow.class_name\n        self._check_dependencies(flow.dependencies, strict_version=strict_version)\n\n        parameters = flow.parameters\n        components = flow.components\n        parameter_dict: dict[str, Any] = OrderedDict()\n\n        # Do a shallow copy of the components dictionary so we can remove the\n        # components from this copy once we added them into the pipeline. This\n        # allows us to not consider them any more when looping over the\n        # components, but keeping the dictionary of components untouched in the\n        # original components dictionary.\n        components_ = copy.copy(components)\n\n        for name in parameters:\n            value = parameters.get(name)\n            logger.info(f\"--{'-' * recursion_depth} flow_parameter={name}, value={value}\")\n            rval = self._deserialize_sklearn(\n                value,\n                components=components_,\n                initialize_with_defaults=keep_defaults,\n                recursion_depth=recursion_depth + 1,\n                strict_version=strict_version,\n            )\n            parameter_dict[name] = rval\n\n        for name in components:\n            if name in parameter_dict:\n                continue\n            if name not in components_:\n                continue\n            value = components[name]\n            logger.info(f\"--{'-' * recursion_depth} flow_component={name}, value={value}\")\n            rval = self._deserialize_sklearn(\n                value,\n                recursion_depth=recursion_depth + 1,\n                strict_version=strict_version,\n            )\n            parameter_dict[name] = rval\n\n        if model_name is None and flow.name in SKLEARN_PIPELINE_STRING_COMPONENTS:\n            return flow.name\n\n        assert model_name is not None\n        module_name = model_name.rsplit(\".\", 1)\n        model_class = getattr(importlib.import_module(module_name[0]), module_name[1])\n\n        if keep_defaults:\n            # obtain all params with a default\n            param_defaults, _ = self._get_fn_arguments_with_defaults(model_class.__init__)\n\n            # delete the params that have a default from the dict,\n            # so they get initialized with their default value\n            # except [...]\n            for param in param_defaults:\n                # [...] the ones that also have a key in the components dict.\n                # As OpenML stores different flows for ensembles with different\n                # (base-)components, in OpenML terms, these are not considered\n                # hyperparameters but rather constants (i.e., changing them would\n                # result in a different flow)\n                if param not in components:\n                    del parameter_dict[param]\n\n        if not strict_version:\n            # Ignore incompatible parameters\n            allowed_parameter = list(inspect.signature(model_class.__init__).parameters)\n            for p in list(parameter_dict.keys()):\n                if p not in allowed_parameter:\n                    warnings.warn(\n                        f\"While deserializing in a non-strict way, parameter {p} is not \"\n                        f\"allowed for {model_class.__name__} likely due to a version mismatch. \"\n                        \"We ignore the parameter.\",\n                        UserWarning,\n                        stacklevel=2,\n                    )\n                    del parameter_dict[p]\n\n        return model_class(**parameter_dict)\n\n    def _check_dependencies(\n        self,\n        dependencies: str,\n        strict_version: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; None:\n        if not dependencies:\n            return\n\n        dependencies_list = dependencies.split(\"\\n\")\n        for dependency_string in dependencies_list:\n            match = DEPENDENCIES_PATTERN.match(dependency_string)\n            if not match:\n                raise ValueError(f\"Cannot parse dependency {dependency_string}\")\n\n            dependency_name = match.group(\"name\")\n            operation = match.group(\"operation\")\n            version = match.group(\"version\")\n\n            module = importlib.import_module(dependency_name)\n            required_version = Version(version)\n            installed_version = Version(module.__version__)  # type: ignore\n\n            if operation == \"==\":\n                check = required_version == installed_version\n            elif operation == \"&gt;\":\n                check = installed_version &gt; required_version\n            elif operation == \"&gt;=\":\n                check = (\n                    installed_version &gt; required_version or installed_version == required_version\n                )\n            else:\n                raise NotImplementedError(f\"operation '{operation}' is not supported\")\n            message = (\n                f\"Trying to deserialize a model with dependency {dependency_string} not satisfied.\"\n            )\n            if not check:\n                if strict_version:\n                    raise ValueError(message)\n\n                warnings.warn(message, category=UserWarning, stacklevel=2)\n\n    def _serialize_type(self, o: Any) -&gt; OrderedDict[str, str]:\n        mapping = {\n            float: \"float\",\n            np.float32: \"np.float32\",\n            np.float64: \"np.float64\",\n            int: \"int\",\n            np.int32: \"np.int32\",\n            np.int64: \"np.int64\",\n        }\n        if Version(np.__version__) &lt; Version(\"1.24\"):\n            mapping[float] = \"np.float\"\n            mapping[int] = \"np.int\"\n\n        ret = OrderedDict()  # type: 'OrderedDict[str, str]'\n        ret[\"oml-python:serialized_object\"] = \"type\"\n        ret[\"value\"] = mapping[o]\n        return ret\n\n    def _deserialize_type(self, o: str) -&gt; Any:\n        mapping = {\n            \"float\": float,\n            \"np.float32\": np.float32,\n            \"np.float64\": np.float64,\n            \"int\": int,\n            \"np.int32\": np.int32,\n            \"np.int64\": np.int64,\n        }\n\n        # TODO(eddiebergman): Might be able to remove this\n        if Version(np.__version__) &lt; Version(\"1.24\"):\n            mapping[\"np.float\"] = np.float  # type: ignore # noqa: NPY001\n            mapping[\"np.int\"] = np.int  # type: ignore # noqa: NPY001\n\n        return mapping[o]\n\n    def _serialize_rv_frozen(self, o: Any) -&gt; OrderedDict[str, str | dict]:\n        args = o.args\n        kwds = o.kwds\n        a = o.a\n        b = o.b\n        dist = o.dist.__class__.__module__ + \".\" + o.dist.__class__.__name__\n        ret: OrderedDict[str, str | dict] = OrderedDict()\n        ret[\"oml-python:serialized_object\"] = \"rv_frozen\"\n        ret[\"value\"] = OrderedDict(\n            ((\"dist\", dist), (\"a\", a), (\"b\", b), (\"args\", args), (\"kwds\", kwds)),\n        )\n        return ret\n\n    def _deserialize_rv_frozen(self, o: OrderedDict[str, str]) -&gt; Any:\n        args = o[\"args\"]\n        kwds = o[\"kwds\"]\n        a = o[\"a\"]\n        b = o[\"b\"]\n        dist_name = o[\"dist\"]\n\n        module_name = dist_name.rsplit(\".\", 1)\n        try:\n            rv_class = getattr(importlib.import_module(module_name[0]), module_name[1])\n        except AttributeError as e:\n            _tb = traceback.format_exc()\n            warnings.warn(\n                f\"Cannot create model {dist_name} for flow. Reason is from error {type(e)}:{e}\"\n                f\"\\nTraceback: {_tb}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n            return None\n\n        dist = scipy.stats.distributions.rv_frozen(rv_class(), *args, **kwds)  # type: ignore\n        dist.a = a\n        dist.b = b\n\n        return dist\n\n    def _serialize_function(self, o: Callable) -&gt; OrderedDict[str, str]:\n        name = o.__module__ + \".\" + o.__name__\n        ret = OrderedDict()  # type: 'OrderedDict[str, str]'\n        ret[\"oml-python:serialized_object\"] = \"function\"\n        ret[\"value\"] = name\n        return ret\n\n    def _deserialize_function(self, name: str) -&gt; Callable:\n        module_name = name.rsplit(\".\", 1)\n        return getattr(importlib.import_module(module_name[0]), module_name[1])\n\n    def _serialize_cross_validator(self, o: Any) -&gt; OrderedDict[str, str | dict]:\n        ret: OrderedDict[str, str | dict] = OrderedDict()\n\n        parameters = OrderedDict()  # type: 'OrderedDict[str, Any]'\n\n        # XXX this is copied from sklearn.model_selection._split\n        cls = o.__class__\n        init = getattr(cls.__init__, \"deprecated_original\", cls.__init__)\n        # Ignore varargs, kw and default values and pop self\n        init_signature = inspect.signature(init)  # type: ignore\n        # Consider the constructor parameters excluding 'self'\n        if init is object.__init__:\n            args = []  # type: List\n        else:\n            args = sorted(\n                [\n                    p.name\n                    for p in init_signature.parameters.values()\n                    if p.name != \"self\" and p.kind != p.VAR_KEYWORD\n                ],\n            )\n\n        for key in args:\n            # We need deprecation warnings to always be on in order to\n            # catch deprecated param values.\n            # This is set in utils/__init__.py but it gets overwritten\n            # when running under python3 somehow.\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter(\"always\", DeprecationWarning)\n                value = getattr(o, key, None)\n                if w is not None and len(w) and w[0].category is DeprecationWarning:\n                    # if the parameter is deprecated, don't show it\n                    continue\n\n            if not (isinstance(value, Sized) and len(value) == 0):\n                value = json.dumps(value)\n                parameters[key] = value\n            else:\n                parameters[key] = None\n\n        ret[\"oml-python:serialized_object\"] = \"cv_object\"\n        name = o.__module__ + \".\" + o.__class__.__name__\n        value = OrderedDict([(\"name\", name), (\"parameters\", parameters)])\n        ret[\"value\"] = value\n\n        return ret\n\n    def _deserialize_cross_validator(\n        self,\n        value: OrderedDict[str, Any],\n        recursion_depth: int,\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        model_name = value[\"name\"]\n        parameters = value[\"parameters\"]\n\n        module_name = model_name.rsplit(\".\", 1)\n        model_class = getattr(importlib.import_module(module_name[0]), module_name[1])\n        for parameter in parameters:\n            parameters[parameter] = self._deserialize_sklearn(\n                parameters[parameter],\n                recursion_depth=recursion_depth + 1,\n                strict_version=strict_version,\n            )\n        return model_class(**parameters)\n\n    def _format_external_version(\n        self,\n        model_package_name: str,\n        model_package_version_number: str,\n    ) -&gt; str:\n        return f\"{model_package_name}=={model_package_version_number}\"\n\n    @staticmethod\n    def _get_parameter_values_recursive(\n        param_grid: dict | list[dict],\n        parameter_name: str,\n    ) -&gt; list[Any]:\n        \"\"\"\n        Returns a list of values for a given hyperparameter, encountered\n        recursively throughout the flow. (e.g., n_jobs can be defined\n        for various flows)\n\n        Parameters\n        ----------\n        param_grid: Union[Dict, List[Dict]]\n            Dict mapping from hyperparameter list to value, to a list of\n            such dicts\n\n        parameter_name: str\n            The hyperparameter that needs to be inspected\n\n        Returns\n        -------\n        List\n            A list of all values of hyperparameters with this name\n        \"\"\"\n        if isinstance(param_grid, dict):\n            return [\n                value\n                for param, value in param_grid.items()\n                if param.split(\"__\")[-1] == parameter_name\n            ]\n\n        if isinstance(param_grid, list):\n            result = []\n            for sub_grid in param_grid:\n                result.extend(\n                    SklearnExtension._get_parameter_values_recursive(sub_grid, parameter_name),\n                )\n            return result\n\n        raise ValueError(\"Param_grid should either be a dict or list of dicts\")\n\n    def _prevent_optimize_n_jobs(self, model):\n        \"\"\"\n        Ensures that HPO classes will not optimize the n_jobs hyperparameter\n\n        Parameters\n        ----------\n        model:\n            The model that will be fitted\n        \"\"\"\n        if self._is_hpo_class(model):\n            if isinstance(model, sklearn.model_selection.GridSearchCV):\n                param_distributions = model.param_grid\n            elif isinstance(model, sklearn.model_selection.RandomizedSearchCV):\n                param_distributions = model.param_distributions\n            else:\n                if hasattr(model, \"param_distributions\"):\n                    param_distributions = model.param_distributions\n                else:\n                    raise AttributeError(\n                        \"Using subclass BaseSearchCV other than \"\n                        \"{GridSearchCV, RandomizedSearchCV}. \"\n                        \"Could not find attribute \"\n                        \"param_distributions.\",\n                    )\n                logger.warning(\n                    \"Warning! Using subclass BaseSearchCV other than \"\n                    \"{GridSearchCV, RandomizedSearchCV}. \"\n                    \"Should implement param check. \",\n                )\n            n_jobs_vals = SklearnExtension._get_parameter_values_recursive(\n                param_distributions,\n                \"n_jobs\",\n            )\n            if len(n_jobs_vals) &gt; 0:\n                raise PyOpenMLError(\n                    \"openml-python should not be used to optimize the n_jobs parameter.\",\n                )\n\n    ################################################################################################\n    # Methods for performing runs with extension modules\n\n    def is_estimator(self, model: Any) -&gt; bool:\n        \"\"\"Check whether the given model is a scikit-learn estimator.\n\n        This function is only required for backwards compatibility and will be removed in the\n        near future.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        o = model\n        return hasattr(o, \"fit\") and hasattr(o, \"get_params\") and hasattr(o, \"set_params\")\n\n    def seed_model(self, model: Any, seed: int | None = None) -&gt; Any:  # noqa: C901\n        \"\"\"Set the random state of all the unseeded components of a model and return the seeded\n        model.\n\n        Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n        Models that are already seeded will maintain the seed. In this case,\n        only integer seeds are allowed (An exception is raised when a RandomState was used as\n        seed).\n\n        Parameters\n        ----------\n        model : sklearn model\n            The model to be seeded\n        seed : int\n            The seed to initialize the RandomState with. Unseeded subcomponents\n            will be seeded with a random number from the RandomState.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n\n        def _seed_current_object(current_value):\n            if isinstance(current_value, int):  # acceptable behaviour\n                return False\n\n            if isinstance(current_value, np.random.RandomState):\n                raise ValueError(\n                    \"Models initialized with a RandomState object are not \"\n                    \"supported. Please seed with an integer. \",\n                )\n\n            if current_value is not None:\n                raise ValueError(\n                    \"Models should be seeded with int or None (this should never happen). \",\n                )\n\n            return True\n\n        rs = np.random.RandomState(seed)\n        model_params = model.get_params()\n        random_states = {}\n        for param_name in sorted(model_params):\n            if \"random_state\" in param_name:\n                current_value = model_params[param_name]\n                # important to draw the value at this point (and not in the if\n                # statement) this way we guarantee that if a different set of\n                # subflows is seeded, the same number of the random generator is\n                # used\n                new_value = rs.randint(0, 2**16)\n                if _seed_current_object(current_value):\n                    random_states[param_name] = new_value\n\n            # Also seed CV objects!\n            elif isinstance(model_params[param_name], sklearn.model_selection.BaseCrossValidator):\n                if not hasattr(model_params[param_name], \"random_state\"):\n                    continue\n\n                current_value = model_params[param_name].random_state\n                new_value = rs.randint(0, 2**16)\n                if _seed_current_object(current_value):\n                    model_params[param_name].random_state = new_value\n\n        model.set_params(**random_states)\n        return model\n\n    def check_if_model_fitted(self, model: Any) -&gt; bool:\n        \"\"\"Returns True/False denoting if the model has already been fitted/trained\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        from sklearn.exceptions import NotFittedError\n        from sklearn.utils.validation import check_is_fitted\n\n        try:\n            # check if model is fitted\n            check_is_fitted(model)\n\n            # Creating random dummy data of arbitrary size\n            dummy_data = np.random.uniform(size=(10, 3))  # noqa: NPY002\n            # Using 'predict' instead of 'sklearn.utils.validation.check_is_fitted' for a more\n            # robust check that works across sklearn versions and models. Internally, 'predict'\n            # should call 'check_is_fitted' for every concerned attribute, thus offering a more\n            # assured check than explicit calls to 'check_is_fitted'\n            model.predict(dummy_data)\n            # Will reach here if the model was fit on a dataset with 3 features\n            return True\n        except NotFittedError:  # needs to be the first exception to be caught\n            # Model is not fitted, as is required\n            return False\n        except ValueError:\n            # Will reach here if the model was fit on a dataset with more or less than 3 features\n            return True\n\n    def _run_model_on_fold(  # noqa: PLR0915, PLR0913, C901, PLR0912\n        self,\n        model: Any,\n        task: OpenMLTask,\n        X_train: np.ndarray | scipy.sparse.spmatrix | pd.DataFrame,\n        rep_no: int,\n        fold_no: int,\n        y_train: np.ndarray | None = None,\n        X_test: np.ndarray | scipy.sparse.spmatrix | pd.DataFrame | None = None,\n    ) -&gt; tuple[\n        np.ndarray,\n        pd.DataFrame | None,\n        OrderedDict[str, float],\n        OpenMLRunTrace | None,\n    ]:\n        \"\"\"Run a model on a repeat,fold,subsample triplet of the task and return prediction\n        information.\n\n        Furthermore, it will measure run time measures in case multi-core behaviour allows this.\n        * exact user cpu time will be measured if the number of cores is set (recursive throughout\n        the model) exactly to 1\n        * wall clock time will be measured if the number of cores is set (recursive throughout the\n        model) to any given number (but not when it is set to -1)\n\n        Returns the data that is necessary to construct the OpenML Run object. Is used by\n        run_task_get_arff_content. Do not use this function unless you know what you are doing.\n\n        Parameters\n        ----------\n        model : Any\n            The UNTRAINED model to run. The model instance will be copied and not altered.\n        task : OpenMLTask\n            The task to run the model on.\n        X_train : array-like\n            Training data for the given repetition and fold.\n        rep_no : int\n            The repeat of the experiment (0-based; in case of 1 time CV, always 0)\n        fold_no : int\n            The fold nr of the experiment (0-based; in case of holdout, always 0)\n        y_train : Optional[np.ndarray] (default=None)\n            Target attributes for supervised tasks. In case of classification, these are integer\n            indices to the potential classes specified by dataset.\n        X_test : Optional, array-like (default=None)\n            Test attributes to test for generalization in supervised tasks.\n\n        Returns\n        -------\n        pred_y : np.ndarray\n            Predictions on the training/test set, depending on the task type.\n            For supervised tasks, predictions are on the test set.\n            For unsupervised tasks, predictions are on the training set.\n        proba_y : pd.DataFrame, optional\n            Predicted probabilities for the test set.\n            None, if task is not Classification or Learning Curve prediction.\n        user_defined_measures : OrderedDict[str, float]\n            User defined measures that were generated on this fold\n        trace : OpenMLRunTrace, optional\n            arff trace object from a fitted model and the trace content obtained by\n            repeatedly calling ``run_model_on_task``\n        \"\"\"\n\n        def _prediction_to_probabilities(\n            y: np.ndarray | list,\n            model_classes: list[Any],\n            class_labels: list[str] | None,\n        ) -&gt; pd.DataFrame:\n            \"\"\"Transforms predicted probabilities to match with OpenML class indices.\n\n            Parameters\n            ----------\n            y : np.ndarray\n                Predicted probabilities (possibly omitting classes if they were not present in the\n                training data).\n            model_classes : list\n                List of classes known_predicted by the model, ordered by their index.\n            class_labels : list\n                List of classes as stored in the task object fetched from server.\n\n            Returns\n            -------\n            pd.DataFrame\n            \"\"\"\n            if class_labels is None:\n                raise ValueError(\"The task has no class labels\")\n\n            if isinstance(y_train, np.ndarray) and isinstance(class_labels[0], str):\n                # mapping (decoding) the predictions to the categories\n                # creating a separate copy to not change the expected pred_y type\n                y = [class_labels[pred] for pred in y]  # list or numpy array of predictions\n\n            # model_classes: sklearn classifier mapping from original array id to\n            # prediction index id\n            if not isinstance(model_classes, list):\n                raise ValueError(\"please convert model classes to list prior to calling this fn\")\n\n            # DataFrame allows more accurate mapping of classes as column names\n            result = pd.DataFrame(\n                0,\n                index=np.arange(len(y)),\n                columns=model_classes,\n                dtype=np.float32,\n            )\n            for obs, prediction in enumerate(y):\n                result.loc[obs, prediction] = 1.0\n            return result\n\n        if isinstance(task, OpenMLSupervisedTask):\n            if y_train is None:\n                raise TypeError(\"argument y_train must not be of type None\")\n            if X_test is None:\n                raise TypeError(\"argument X_test must not be of type None\")\n\n        model_copy = sklearn.base.clone(model, safe=True)\n        # sanity check: prohibit users from optimizing n_jobs\n        self._prevent_optimize_n_jobs(model_copy)\n        # measures and stores runtimes\n        user_defined_measures = OrderedDict()  # type: 'OrderedDict[str, float]'\n        try:\n            # for measuring runtime. Only available since Python 3.3\n            modelfit_start_cputime = time.process_time()\n            modelfit_start_walltime = time.time()\n\n            if isinstance(task, OpenMLSupervisedTask):\n                model_copy.fit(X_train, y_train)  # type: ignore\n            elif isinstance(task, OpenMLClusteringTask):\n                model_copy.fit(X_train)  # type: ignore\n\n            modelfit_dur_cputime = (time.process_time() - modelfit_start_cputime) * 1000\n            modelfit_dur_walltime = (time.time() - modelfit_start_walltime) * 1000\n\n            user_defined_measures[\"usercpu_time_millis_training\"] = modelfit_dur_cputime\n            refit_time = model_copy.refit_time_ * 1000 if hasattr(model_copy, \"refit_time_\") else 0  # type: ignore\n            user_defined_measures[\"wall_clock_time_millis_training\"] = modelfit_dur_walltime\n\n        except AttributeError as e:\n            # typically happens when training a regressor on classification task\n            raise PyOpenMLError(str(e)) from e\n\n        if isinstance(task, (OpenMLClassificationTask, OpenMLLearningCurveTask)):\n            # search for model classes_ (might differ depending on modeltype)\n            # first, pipelines are a special case (these don't have a classes_\n            # object, but rather borrows it from the last step. We do this manually,\n            # because of the BaseSearch check)\n            if isinstance(model_copy, sklearn.pipeline.Pipeline):\n                used_estimator = model_copy.steps[-1][-1]\n            else:\n                used_estimator = model_copy\n\n            if self._is_hpo_class(used_estimator):\n                model_classes = used_estimator.best_estimator_.classes_\n            else:\n                model_classes = used_estimator.classes_\n\n            if not isinstance(model_classes, list):\n                model_classes = model_classes.tolist()\n\n            # to handle the case when dataset is numpy and categories are encoded\n            # however the class labels stored in task are still categories\n            if isinstance(y_train, np.ndarray) and isinstance(\n                cast(\"List\", task.class_labels)[0],\n                str,\n            ):\n                model_classes = [cast(\"List[str]\", task.class_labels)[i] for i in model_classes]\n\n        modelpredict_start_cputime = time.process_time()\n        modelpredict_start_walltime = time.time()\n\n        # In supervised learning this returns the predictions for Y, in clustering\n        # it returns the clusters\n        if isinstance(task, OpenMLSupervisedTask):\n            pred_y = model_copy.predict(X_test)\n        elif isinstance(task, OpenMLClusteringTask):\n            pred_y = model_copy.predict(X_train)\n        else:\n            raise ValueError(task)\n\n        modelpredict_duration_cputime = (time.process_time() - modelpredict_start_cputime) * 1000\n        user_defined_measures[\"usercpu_time_millis_testing\"] = modelpredict_duration_cputime\n        user_defined_measures[\"usercpu_time_millis\"] = (\n            modelfit_dur_cputime + modelpredict_duration_cputime\n        )\n        modelpredict_duration_walltime = (time.time() - modelpredict_start_walltime) * 1000\n        user_defined_measures[\"wall_clock_time_millis_testing\"] = modelpredict_duration_walltime\n        user_defined_measures[\"wall_clock_time_millis\"] = (\n            modelfit_dur_walltime + modelpredict_duration_walltime + refit_time\n        )\n\n        if isinstance(task, (OpenMLClassificationTask, OpenMLLearningCurveTask)):\n            try:\n                proba_y = model_copy.predict_proba(X_test)\n                proba_y = pd.DataFrame(proba_y, columns=model_classes)  # handles X_test as numpy\n            except AttributeError:  # predict_proba is not available when probability=False\n                proba_y = _prediction_to_probabilities(pred_y, model_classes, task.class_labels)\n\n            if task.class_labels is not None:\n                if proba_y.shape[1] != len(task.class_labels):\n                    # Remap the probabilities in case there was a class missing\n                    # at training time. By default, the classification targets\n                    # are mapped to be zero-based indices to the actual classes.\n                    # Therefore, the model_classes contain the correct indices to\n                    # the correct probability array. Example:\n                    # classes in the dataset: 0, 1, 2, 3, 4, 5\n                    # classes in the training set: 0, 1, 2, 4, 5\n                    # then we need to add a column full of zeros into the probabilities\n                    # for class 3 because the rest of the library expects that the\n                    # probabilities are ordered the same way as the classes are ordered).\n                    message = (\n                        f\"Estimator only predicted for {proba_y.shape[1]}/{len(task.class_labels)}\"\n                        \" classes!\"\n                    )\n                    warnings.warn(message, stacklevel=2)\n                    openml.config.logger.warning(message)\n\n                    for _i, col in enumerate(task.class_labels):\n                        # adding missing columns with 0 probability\n                        if col not in model_classes:\n                            proba_y[col] = 0\n                    # We re-order the columns to move possibly added missing columns into place.\n                    proba_y = proba_y[task.class_labels]\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n            if not np.all(set(proba_y.columns) == set(task.class_labels)):\n                missing_cols = list(set(task.class_labels) - set(proba_y.columns))\n                raise ValueError(\"Predicted probabilities missing for the columns: \", missing_cols)\n\n        elif isinstance(task, (OpenMLRegressionTask, OpenMLClusteringTask)):\n            proba_y = None\n        else:\n            raise TypeError(type(task))\n\n        if self._is_hpo_class(model_copy):\n            trace_data = self._extract_trace_data(model_copy, rep_no, fold_no)\n            trace: OpenMLRunTrace | None = self._obtain_arff_trace(\n                model_copy,\n                trace_data,\n            )\n        else:\n            trace = None\n\n        return pred_y, proba_y, user_defined_measures, trace\n\n    def obtain_parameter_values(  # noqa: C901, PLR0915\n        self,\n        flow: OpenMLFlow,\n        model: Any = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extracts all parameter settings required for the flow from the model.\n\n        If no explicit model is provided, the parameters will be extracted from `flow.model`\n        instead.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n            OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n        model: Any, optional (default=None)\n            The model from which to obtain the parameter values. Must match the flow signature.\n            If None, use the model specified in ``OpenMLFlow.model``.\n\n        Returns\n        -------\n        list\n            A list of dicts, where each dict has the following entries:\n            - ``oml:name`` : str: The OpenML parameter name\n            - ``oml:value`` : mixed: A representation of the parameter value\n            - ``oml:component`` : int: flow id to which the parameter belongs\n        \"\"\"\n        openml.flows.functions._check_flow_for_server_id(flow)\n\n        def get_flow_dict(_flow):\n            flow_map = {_flow.name: _flow.flow_id}\n            for subflow in _flow.components:\n                flow_map.update(get_flow_dict(_flow.components[subflow]))\n            return flow_map\n\n        def extract_parameters(  # noqa: PLR0915, PLR0912, C901\n            _flow,\n            _flow_dict,\n            component_model,\n            _main_call=False,  # noqa: FBT002\n            main_id=None,\n        ):\n            def is_subcomponent_specification(values):\n                # checks whether the current value can be a specification of\n                # subcomponents, as for example the value for steps parameter\n                # (in Pipeline) or transformers parameter (in\n                # ColumnTransformer).\n                return (\n                    # Specification requires list/tuple of list/tuple with\n                    # at least length 2.\n                    isinstance(values, (tuple, list))\n                    and all(isinstance(item, (tuple, list)) and len(item) &gt; 1 for item in values)\n                    # And each component needs to be a flow or interpretable string\n                    and all(\n                        isinstance(item[1], openml.flows.OpenMLFlow)\n                        or (\n                            isinstance(item[1], str)\n                            and item[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n                        )\n                        for item in values\n                    )\n                )\n\n            # _flow is openml flow object, _param dict maps from flow name to flow\n            # id for the main call, the param dict can be overridden (useful for\n            # unit tests / sentinels) this way, for flows without subflows we do\n            # not have to rely on _flow_dict\n            exp_parameters = set(_flow.parameters)\n            if (\n                isinstance(component_model, str)\n                and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                model_parameters = set()\n            else:\n                model_parameters = set(component_model.get_params(deep=False))\n            if len(exp_parameters.symmetric_difference(model_parameters)) != 0:\n                flow_params = sorted(exp_parameters)\n                model_params = sorted(model_parameters)\n                raise ValueError(\n                    \"Parameters of the model do not match the \"\n                    \"parameters expected by the \"\n                    \"flow:\\nexpected flow parameters: \"\n                    f\"{flow_params}\\nmodel parameters: {model_params}\",\n                )\n            exp_components = set(_flow.components)\n            if (\n                isinstance(component_model, str)\n                and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                model_components = set()\n            else:\n                _ = set(component_model.get_params(deep=False))\n                model_components = {\n                    mp\n                    for mp in component_model.get_params(deep=True)\n                    if \"__\" not in mp and mp not in _\n                }\n            if len(exp_components.symmetric_difference(model_components)) != 0:\n                is_problem = True\n                if len(exp_components - model_components) &gt; 0:\n                    # If an expected component is not returned as a component by get_params(),\n                    # this means that it is also a parameter -&gt; we need to check that this is\n                    # actually the case\n                    difference = exp_components - model_components\n                    component_in_model_parameters = []\n                    for component in difference:\n                        if component in model_parameters:\n                            component_in_model_parameters.append(True)\n                        else:\n                            component_in_model_parameters.append(False)\n                    is_problem = not all(component_in_model_parameters)\n                if is_problem:\n                    flow_components = sorted(exp_components)\n                    model_components = sorted(model_components)\n                    raise ValueError(\n                        \"Subcomponents of the model do not match the \"\n                        \"parameters expected by the \"\n                        \"flow:\\nexpected flow subcomponents: \"\n                        f\"{flow_components}\\nmodel subcomponents: {model_components}\",\n                    )\n\n            _params = []\n            for _param_name in _flow.parameters:\n                _current = OrderedDict()\n                _current[\"oml:name\"] = _param_name\n\n                current_param_values = self.model_to_flow(component_model.get_params()[_param_name])\n\n                # Try to filter out components (a.k.a. subflows) which are\n                # handled further down in the code (by recursively calling\n                # this function)!\n                if isinstance(current_param_values, openml.flows.OpenMLFlow):\n                    continue\n\n                if is_subcomponent_specification(current_param_values):\n                    # complex parameter value, with subcomponents\n                    parsed_values = []\n                    for subcomponent in current_param_values:\n                        # scikit-learn stores usually tuples in the form\n                        # (name (str), subcomponent (mixed), argument\n                        # (mixed)). OpenML replaces the subcomponent by an\n                        # OpenMLFlow object.\n                        if len(subcomponent) &lt; 2 or len(subcomponent) &gt; 3:\n                            raise ValueError(\"Component reference should be size {2,3}. \")\n\n                        subcomponent_identifier = subcomponent[0]\n                        subcomponent_flow = subcomponent[1]\n                        if not isinstance(subcomponent_identifier, str):\n                            raise TypeError(\n                                \"Subcomponent identifier should be of type string, \"\n                                f\"but is {type(subcomponent_identifier)}\",\n                            )\n                        if not isinstance(subcomponent_flow, (openml.flows.OpenMLFlow, str)):\n                            if (\n                                isinstance(subcomponent_flow, str)\n                                and subcomponent_flow in SKLEARN_PIPELINE_STRING_COMPONENTS\n                            ):\n                                pass\n                            else:\n                                raise TypeError(\n                                    \"Subcomponent flow should be of type flow, but is\"\n                                    f\" {type(subcomponent_flow)}\",\n                                )\n\n                        current = {\n                            \"oml-python:serialized_object\": COMPONENT_REFERENCE,\n                            \"value\": {\n                                \"key\": subcomponent_identifier,\n                                \"step_name\": subcomponent_identifier,\n                            },\n                        }\n                        if len(subcomponent) == 3:\n                            if not isinstance(subcomponent[2], list) and not isinstance(\n                                subcomponent[2],\n                                OrderedDict,\n                            ):\n                                raise TypeError(\n                                    \"Subcomponent argument should be list or OrderedDict\",\n                                )\n                            current[\"value\"][\"argument_1\"] = subcomponent[2]\n                        parsed_values.append(current)\n                    parsed_values = json.dumps(parsed_values)\n                else:\n                    # vanilla parameter value\n                    parsed_values = json.dumps(current_param_values)\n\n                _current[\"oml:value\"] = parsed_values\n                if _main_call:\n                    _current[\"oml:component\"] = main_id\n                else:\n                    _current[\"oml:component\"] = _flow_dict[_flow.name]\n                _params.append(_current)\n\n            for _identifier in _flow.components:\n                subcomponent_model = component_model.get_params()[_identifier]\n                _params.extend(\n                    extract_parameters(\n                        _flow.components[_identifier],\n                        _flow_dict,\n                        subcomponent_model,\n                    ),\n                )\n            return _params\n\n        flow_dict = get_flow_dict(flow)\n        model = model if model is not None else flow.model\n        return extract_parameters(flow, flow_dict, model, _main_call=True, main_id=flow.flow_id)\n\n    def _openml_param_name_to_sklearn(\n        self,\n        openml_parameter: openml.setups.OpenMLParameter,\n        flow: OpenMLFlow,\n    ) -&gt; str:\n        \"\"\"\n        Converts the name of an OpenMLParameter into the sklean name, given a flow.\n\n        Parameters\n        ----------\n        openml_parameter: OpenMLParameter\n            The parameter under consideration\n\n        flow: OpenMLFlow\n            The flow that provides context.\n\n        Returns\n        -------\n        sklearn_parameter_name: str\n            The name the parameter will have once used in scikit-learn\n        \"\"\"\n        if not isinstance(openml_parameter, openml.setups.OpenMLParameter):\n            raise ValueError(\"openml_parameter should be an instance of OpenMLParameter\")\n        if not isinstance(flow, OpenMLFlow):\n            raise ValueError(\"flow should be an instance of OpenMLFlow\")\n\n        flow_structure = flow.get_structure(\"name\")\n        if openml_parameter.flow_name not in flow_structure:\n            raise ValueError(\"Obtained OpenMLParameter and OpenMLFlow do not correspond. \")\n        name = openml_parameter.flow_name  # for PEP8\n        return \"__\".join(flow_structure[name] + [openml_parameter.parameter_name])\n\n    ################################################################################################\n    # Methods for hyperparameter optimization\n\n    def _is_hpo_class(self, model: Any) -&gt; bool:\n        \"\"\"Check whether the model performs hyperparameter optimization.\n\n        Used to check whether an optimization trace can be extracted from the model after\n        running it.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return isinstance(model, sklearn.model_selection._search.BaseSearchCV)\n\n    def instantiate_model_from_hpo_class(\n        self,\n        model: Any,\n        trace_iteration: OpenMLTraceIteration,\n    ) -&gt; Any:\n        \"\"\"Instantiate a ``base_estimator`` which can be searched over by the hyperparameter\n        optimization model.\n\n        Parameters\n        ----------\n        model : Any\n            A hyperparameter optimization model which defines the model to be instantiated.\n        trace_iteration : OpenMLTraceIteration\n            Describing the hyperparameter settings to instantiate.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n        if not self._is_hpo_class(model):\n            raise AssertionError(\n                f\"Flow model {model} is not an instance of\"\n                \" sklearn.model_selection._search.BaseSearchCV\",\n            )\n        base_estimator = model.estimator\n        base_estimator.set_params(**trace_iteration.get_parameters())\n        return base_estimator\n\n    def _extract_trace_data(self, model, rep_no, fold_no):\n        \"\"\"Extracts data from a machine learning model's cross-validation results\n        and creates an ARFF (Attribute-Relation File Format) trace.\n\n        Parameters\n        ----------\n        model : Any\n            A fitted hyperparameter optimization model.\n        rep_no : int\n            The repetition number.\n        fold_no : int\n            The fold number.\n\n        Returns\n        -------\n        A list of ARFF tracecontent.\n        \"\"\"\n        arff_tracecontent = []\n        for itt_no in range(len(model.cv_results_[\"mean_test_score\"])):\n            # we use the string values for True and False, as it is defined in\n            # this way by the OpenML server\n            selected = \"false\"\n            if itt_no == model.best_index_:\n                selected = \"true\"\n            test_score = model.cv_results_[\"mean_test_score\"][itt_no]\n            arff_line = [rep_no, fold_no, itt_no, test_score, selected]\n            for key in model.cv_results_:\n                if key.startswith(\"param_\"):\n                    value = model.cv_results_[key][itt_no]\n                    # Built-in serializer does not convert all numpy types,\n                    # these methods convert them to built-in types instead.\n                    if isinstance(value, np.generic):\n                        # For scalars it actually returns scalars, not a list\n                        value = value.tolist()\n                    serialized_value = json.dumps(value) if value is not np.ma.masked else np.nan\n                    arff_line.append(serialized_value)\n            arff_tracecontent.append(arff_line)\n        return arff_tracecontent\n\n    def _obtain_arff_trace(\n        self,\n        model: Any,\n        trace_content: list,\n    ) -&gt; OpenMLRunTrace:\n        \"\"\"Create arff trace object from a fitted model and the trace content obtained by\n        repeatedly calling ``run_model_on_task``.\n\n        Parameters\n        ----------\n        model : Any\n            A fitted hyperparameter optimization model.\n\n        trace_content : List[List]\n            Trace content obtained by ``openml.runs.run_flow_on_task``.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        if not self._is_hpo_class(model):\n            raise AssertionError(\n                f\"Flow model {model} is not an instance of \"\n                \"sklearn.model_selection._search.BaseSearchCV\",\n            )\n        if not hasattr(model, \"cv_results_\"):\n            raise ValueError(\"model should contain `cv_results_`\")\n\n        # attributes that will be in trace arff, regardless of the model\n        trace_attributes = [\n            (\"repeat\", \"NUMERIC\"),\n            (\"fold\", \"NUMERIC\"),\n            (\"iteration\", \"NUMERIC\"),\n            (\"evaluation\", \"NUMERIC\"),\n            (\"selected\", [\"true\", \"false\"]),\n        ]\n\n        # model dependent attributes for trace arff\n        for key in model.cv_results_:\n            if key.startswith(\"param_\"):\n                # supported types should include all types, including bool,\n                # int float\n                supported_basic_types = (bool, int, float, str)\n                for param_value in model.cv_results_[key]:\n                    if isinstance(param_value, np.generic):\n                        param_value = param_value.tolist()  # noqa: PLW2901\n                    if (\n                        isinstance(param_value, supported_basic_types)\n                        or param_value is None\n                        or param_value is np.ma.masked\n                    ):\n                        # basic string values\n                        type = \"STRING\"  # noqa: A001\n                    elif isinstance(param_value, (list, tuple)) and all(\n                        isinstance(i, int) for i in param_value\n                    ):\n                        # list of integers (usually for selecting features)\n                        # hyperparameter layer_sizes of MLPClassifier\n                        type = \"STRING\"  # noqa: A001\n                    else:\n                        raise TypeError(f\"Unsupported param type in param grid: {key}\")\n\n                # renamed the attribute param to parameter, as this is a required\n                # OpenML convention - this also guards against name collisions\n                # with the required trace attributes\n                attribute = (PREFIX + key[6:], type)  # type: ignore\n                trace_attributes.append(attribute)\n\n        return OpenMLRunTrace.generate(\n            trace_attributes,\n            trace_content,\n        )\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.can_handle_flow","title":"<code>can_handle_flow(flow)</code>  <code>classmethod</code>","text":"<p>Check whether a given describes a scikit-learn estimator.</p> <p>This is done by parsing the <code>external_version</code> field.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>@classmethod\ndef can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n    \"\"\"Check whether a given describes a scikit-learn estimator.\n\n    This is done by parsing the ``external_version`` field.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return cls._is_sklearn_flow(flow)\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.can_handle_model","title":"<code>can_handle_model(model)</code>  <code>classmethod</code>","text":"<p>Check whether a model is an instance of <code>sklearn.base.BaseEstimator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>@classmethod\ndef can_handle_model(cls, model: Any) -&gt; bool:\n    \"\"\"Check whether a model is an instance of ``sklearn.base.BaseEstimator``.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return isinstance(model, sklearn.base.BaseEstimator)\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.check_if_model_fitted","title":"<code>check_if_model_fitted(model)</code>","text":"<p>Returns True/False denoting if the model has already been fitted/trained</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def check_if_model_fitted(self, model: Any) -&gt; bool:\n    \"\"\"Returns True/False denoting if the model has already been fitted/trained\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from sklearn.exceptions import NotFittedError\n    from sklearn.utils.validation import check_is_fitted\n\n    try:\n        # check if model is fitted\n        check_is_fitted(model)\n\n        # Creating random dummy data of arbitrary size\n        dummy_data = np.random.uniform(size=(10, 3))  # noqa: NPY002\n        # Using 'predict' instead of 'sklearn.utils.validation.check_is_fitted' for a more\n        # robust check that works across sklearn versions and models. Internally, 'predict'\n        # should call 'check_is_fitted' for every concerned attribute, thus offering a more\n        # assured check than explicit calls to 'check_is_fitted'\n        model.predict(dummy_data)\n        # Will reach here if the model was fit on a dataset with 3 features\n        return True\n    except NotFittedError:  # needs to be the first exception to be caught\n        # Model is not fitted, as is required\n        return False\n    except ValueError:\n        # Will reach here if the model was fit on a dataset with more or less than 3 features\n        return True\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.create_setup_string","title":"<code>create_setup_string(model)</code>","text":"<p>Create a string which can be used to reinstantiate the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def create_setup_string(self, model: Any) -&gt; str:  # noqa: ARG002\n    \"\"\"Create a string which can be used to reinstantiate the given model.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    str\n    \"\"\"\n    return \" \".join(self.get_version_information())\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.flow_to_model","title":"<code>flow_to_model(flow, initialize_with_defaults=False, strict_version=True)</code>","text":"<p>Initializes a sklearn model based on a flow.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>mixed</code> <p>the object to deserialize (can be flow object, or any serialized parameter value that is accepted by)</p> required <code>initialize_with_defaults</code> <code>(bool, optional(default=False))</code> <p>If this flag is set, the hyperparameter values of flows will be ignored and a flow with its defaults is returned.</p> <code>False</code> <code>strict_version</code> <code>bool</code> <p>Whether to fail if version requirements are not fulfilled.</p> <code>True</code> <p>Returns:</p> Type Description <code>mixed</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def flow_to_model(\n    self,\n    flow: OpenMLFlow,\n    initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n    strict_version: bool = True,  # noqa: FBT001, FBT002\n) -&gt; Any:\n    \"\"\"Initializes a sklearn model based on a flow.\n\n    Parameters\n    ----------\n    flow : mixed\n        the object to deserialize (can be flow object, or any serialized\n        parameter value that is accepted by)\n\n    initialize_with_defaults : bool, optional (default=False)\n        If this flag is set, the hyperparameter values of flows will be\n        ignored and a flow with its defaults is returned.\n\n    strict_version : bool, default=True\n        Whether to fail if version requirements are not fulfilled.\n\n    Returns\n    -------\n    mixed\n    \"\"\"\n    return self._deserialize_sklearn(\n        flow,\n        initialize_with_defaults=initialize_with_defaults,\n        strict_version=strict_version,\n    )\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.get_version_information","title":"<code>get_version_information()</code>","text":"<p>List versions of libraries required by the flow.</p> <p>Libraries listed are <code>Python</code>, <code>scikit-learn</code>, <code>numpy</code> and <code>scipy</code>.</p> <p>Returns:</p> Type Description <code>List</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def get_version_information(self) -&gt; list[str]:\n    \"\"\"List versions of libraries required by the flow.\n\n    Libraries listed are ``Python``, ``scikit-learn``, ``numpy`` and ``scipy``.\n\n    Returns\n    -------\n    List\n    \"\"\"\n    # This can possibly be done by a package such as pyxb, but I could not get\n    # it to work properly.\n    import numpy\n    import scipy\n    import sklearn\n\n    major, minor, micro, _, _ = sys.version_info\n    python_version = f\"Python_{'.'.join([str(major), str(minor), str(micro)])}.\"\n    sklearn_version = f\"Sklearn_{sklearn.__version__}.\"\n    numpy_version = f\"NumPy_{numpy.__version__}.\"  # type: ignore\n    scipy_version = f\"SciPy_{scipy.__version__}.\"\n\n    return [python_version, sklearn_version, numpy_version, scipy_version]\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.instantiate_model_from_hpo_class","title":"<code>instantiate_model_from_hpo_class(model, trace_iteration)</code>","text":"<p>Instantiate a <code>base_estimator</code> which can be searched over by the hyperparameter optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A hyperparameter optimization model which defines the model to be instantiated.</p> required <code>trace_iteration</code> <code>OpenMLTraceIteration</code> <p>Describing the hyperparameter settings to instantiate.</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def instantiate_model_from_hpo_class(\n    self,\n    model: Any,\n    trace_iteration: OpenMLTraceIteration,\n) -&gt; Any:\n    \"\"\"Instantiate a ``base_estimator`` which can be searched over by the hyperparameter\n    optimization model.\n\n    Parameters\n    ----------\n    model : Any\n        A hyperparameter optimization model which defines the model to be instantiated.\n    trace_iteration : OpenMLTraceIteration\n        Describing the hyperparameter settings to instantiate.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    if not self._is_hpo_class(model):\n        raise AssertionError(\n            f\"Flow model {model} is not an instance of\"\n            \" sklearn.model_selection._search.BaseSearchCV\",\n        )\n    base_estimator = model.estimator\n    base_estimator.set_params(**trace_iteration.get_parameters())\n    return base_estimator\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.is_estimator","title":"<code>is_estimator(model)</code>","text":"<p>Check whether the given model is a scikit-learn estimator.</p> <p>This function is only required for backwards compatibility and will be removed in the near future.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def is_estimator(self, model: Any) -&gt; bool:\n    \"\"\"Check whether the given model is a scikit-learn estimator.\n\n    This function is only required for backwards compatibility and will be removed in the\n    near future.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    o = model\n    return hasattr(o, \"fit\") and hasattr(o, \"get_params\") and hasattr(o, \"set_params\")\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.model_to_flow","title":"<code>model_to_flow(model)</code>","text":"<p>Transform a scikit-learn model to a flow for uploading it to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n    \"\"\"Transform a scikit-learn model to a flow for uploading it to OpenML.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    OpenMLFlow\n    \"\"\"\n    # Necessary to make pypy not complain about all the different possible return types\n    return self._serialize_sklearn(model)\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.obtain_parameter_values","title":"<code>obtain_parameter_values(flow, model=None)</code>","text":"<p>Extracts all parameter settings required for the flow from the model.</p> <p>If no explicit model is provided, the parameters will be extracted from <code>flow.model</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)</p> required <code>model</code> <code>Any</code> <p>The model from which to obtain the parameter values. Must match the flow signature. If None, use the model specified in <code>OpenMLFlow.model</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of dicts, where each dict has the following entries: - <code>oml:name</code> : str: The OpenML parameter name - <code>oml:value</code> : mixed: A representation of the parameter value - <code>oml:component</code> : int: flow id to which the parameter belongs</p> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def obtain_parameter_values(  # noqa: C901, PLR0915\n    self,\n    flow: OpenMLFlow,\n    model: Any = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extracts all parameter settings required for the flow from the model.\n\n    If no explicit model is provided, the parameters will be extracted from `flow.model`\n    instead.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n    model: Any, optional (default=None)\n        The model from which to obtain the parameter values. Must match the flow signature.\n        If None, use the model specified in ``OpenMLFlow.model``.\n\n    Returns\n    -------\n    list\n        A list of dicts, where each dict has the following entries:\n        - ``oml:name`` : str: The OpenML parameter name\n        - ``oml:value`` : mixed: A representation of the parameter value\n        - ``oml:component`` : int: flow id to which the parameter belongs\n    \"\"\"\n    openml.flows.functions._check_flow_for_server_id(flow)\n\n    def get_flow_dict(_flow):\n        flow_map = {_flow.name: _flow.flow_id}\n        for subflow in _flow.components:\n            flow_map.update(get_flow_dict(_flow.components[subflow]))\n        return flow_map\n\n    def extract_parameters(  # noqa: PLR0915, PLR0912, C901\n        _flow,\n        _flow_dict,\n        component_model,\n        _main_call=False,  # noqa: FBT002\n        main_id=None,\n    ):\n        def is_subcomponent_specification(values):\n            # checks whether the current value can be a specification of\n            # subcomponents, as for example the value for steps parameter\n            # (in Pipeline) or transformers parameter (in\n            # ColumnTransformer).\n            return (\n                # Specification requires list/tuple of list/tuple with\n                # at least length 2.\n                isinstance(values, (tuple, list))\n                and all(isinstance(item, (tuple, list)) and len(item) &gt; 1 for item in values)\n                # And each component needs to be a flow or interpretable string\n                and all(\n                    isinstance(item[1], openml.flows.OpenMLFlow)\n                    or (\n                        isinstance(item[1], str)\n                        and item[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n                    )\n                    for item in values\n                )\n            )\n\n        # _flow is openml flow object, _param dict maps from flow name to flow\n        # id for the main call, the param dict can be overridden (useful for\n        # unit tests / sentinels) this way, for flows without subflows we do\n        # not have to rely on _flow_dict\n        exp_parameters = set(_flow.parameters)\n        if (\n            isinstance(component_model, str)\n            and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n        ):\n            model_parameters = set()\n        else:\n            model_parameters = set(component_model.get_params(deep=False))\n        if len(exp_parameters.symmetric_difference(model_parameters)) != 0:\n            flow_params = sorted(exp_parameters)\n            model_params = sorted(model_parameters)\n            raise ValueError(\n                \"Parameters of the model do not match the \"\n                \"parameters expected by the \"\n                \"flow:\\nexpected flow parameters: \"\n                f\"{flow_params}\\nmodel parameters: {model_params}\",\n            )\n        exp_components = set(_flow.components)\n        if (\n            isinstance(component_model, str)\n            and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n        ):\n            model_components = set()\n        else:\n            _ = set(component_model.get_params(deep=False))\n            model_components = {\n                mp\n                for mp in component_model.get_params(deep=True)\n                if \"__\" not in mp and mp not in _\n            }\n        if len(exp_components.symmetric_difference(model_components)) != 0:\n            is_problem = True\n            if len(exp_components - model_components) &gt; 0:\n                # If an expected component is not returned as a component by get_params(),\n                # this means that it is also a parameter -&gt; we need to check that this is\n                # actually the case\n                difference = exp_components - model_components\n                component_in_model_parameters = []\n                for component in difference:\n                    if component in model_parameters:\n                        component_in_model_parameters.append(True)\n                    else:\n                        component_in_model_parameters.append(False)\n                is_problem = not all(component_in_model_parameters)\n            if is_problem:\n                flow_components = sorted(exp_components)\n                model_components = sorted(model_components)\n                raise ValueError(\n                    \"Subcomponents of the model do not match the \"\n                    \"parameters expected by the \"\n                    \"flow:\\nexpected flow subcomponents: \"\n                    f\"{flow_components}\\nmodel subcomponents: {model_components}\",\n                )\n\n        _params = []\n        for _param_name in _flow.parameters:\n            _current = OrderedDict()\n            _current[\"oml:name\"] = _param_name\n\n            current_param_values = self.model_to_flow(component_model.get_params()[_param_name])\n\n            # Try to filter out components (a.k.a. subflows) which are\n            # handled further down in the code (by recursively calling\n            # this function)!\n            if isinstance(current_param_values, openml.flows.OpenMLFlow):\n                continue\n\n            if is_subcomponent_specification(current_param_values):\n                # complex parameter value, with subcomponents\n                parsed_values = []\n                for subcomponent in current_param_values:\n                    # scikit-learn stores usually tuples in the form\n                    # (name (str), subcomponent (mixed), argument\n                    # (mixed)). OpenML replaces the subcomponent by an\n                    # OpenMLFlow object.\n                    if len(subcomponent) &lt; 2 or len(subcomponent) &gt; 3:\n                        raise ValueError(\"Component reference should be size {2,3}. \")\n\n                    subcomponent_identifier = subcomponent[0]\n                    subcomponent_flow = subcomponent[1]\n                    if not isinstance(subcomponent_identifier, str):\n                        raise TypeError(\n                            \"Subcomponent identifier should be of type string, \"\n                            f\"but is {type(subcomponent_identifier)}\",\n                        )\n                    if not isinstance(subcomponent_flow, (openml.flows.OpenMLFlow, str)):\n                        if (\n                            isinstance(subcomponent_flow, str)\n                            and subcomponent_flow in SKLEARN_PIPELINE_STRING_COMPONENTS\n                        ):\n                            pass\n                        else:\n                            raise TypeError(\n                                \"Subcomponent flow should be of type flow, but is\"\n                                f\" {type(subcomponent_flow)}\",\n                            )\n\n                    current = {\n                        \"oml-python:serialized_object\": COMPONENT_REFERENCE,\n                        \"value\": {\n                            \"key\": subcomponent_identifier,\n                            \"step_name\": subcomponent_identifier,\n                        },\n                    }\n                    if len(subcomponent) == 3:\n                        if not isinstance(subcomponent[2], list) and not isinstance(\n                            subcomponent[2],\n                            OrderedDict,\n                        ):\n                            raise TypeError(\n                                \"Subcomponent argument should be list or OrderedDict\",\n                            )\n                        current[\"value\"][\"argument_1\"] = subcomponent[2]\n                    parsed_values.append(current)\n                parsed_values = json.dumps(parsed_values)\n            else:\n                # vanilla parameter value\n                parsed_values = json.dumps(current_param_values)\n\n            _current[\"oml:value\"] = parsed_values\n            if _main_call:\n                _current[\"oml:component\"] = main_id\n            else:\n                _current[\"oml:component\"] = _flow_dict[_flow.name]\n            _params.append(_current)\n\n        for _identifier in _flow.components:\n            subcomponent_model = component_model.get_params()[_identifier]\n            _params.extend(\n                extract_parameters(\n                    _flow.components[_identifier],\n                    _flow_dict,\n                    subcomponent_model,\n                ),\n            )\n        return _params\n\n    flow_dict = get_flow_dict(flow)\n    model = model if model is not None else flow.model\n    return extract_parameters(flow, flow_dict, model, _main_call=True, main_id=flow.flow_id)\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.seed_model","title":"<code>seed_model(model, seed=None)</code>","text":"<p>Set the random state of all the unseeded components of a model and return the seeded model.</p> <p>Required so that all seed information can be uploaded to OpenML for reproducible results.</p> <p>Models that are already seeded will maintain the seed. In this case, only integer seeds are allowed (An exception is raised when a RandomState was used as seed).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>sklearn model</code> <p>The model to be seeded</p> required <code>seed</code> <code>int</code> <p>The seed to initialize the RandomState with. Unseeded subcomponents will be seeded with a random number from the RandomState.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def seed_model(self, model: Any, seed: int | None = None) -&gt; Any:  # noqa: C901\n    \"\"\"Set the random state of all the unseeded components of a model and return the seeded\n    model.\n\n    Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n    Models that are already seeded will maintain the seed. In this case,\n    only integer seeds are allowed (An exception is raised when a RandomState was used as\n    seed).\n\n    Parameters\n    ----------\n    model : sklearn model\n        The model to be seeded\n    seed : int\n        The seed to initialize the RandomState with. Unseeded subcomponents\n        will be seeded with a random number from the RandomState.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n\n    def _seed_current_object(current_value):\n        if isinstance(current_value, int):  # acceptable behaviour\n            return False\n\n        if isinstance(current_value, np.random.RandomState):\n            raise ValueError(\n                \"Models initialized with a RandomState object are not \"\n                \"supported. Please seed with an integer. \",\n            )\n\n        if current_value is not None:\n            raise ValueError(\n                \"Models should be seeded with int or None (this should never happen). \",\n            )\n\n        return True\n\n    rs = np.random.RandomState(seed)\n    model_params = model.get_params()\n    random_states = {}\n    for param_name in sorted(model_params):\n        if \"random_state\" in param_name:\n            current_value = model_params[param_name]\n            # important to draw the value at this point (and not in the if\n            # statement) this way we guarantee that if a different set of\n            # subflows is seeded, the same number of the random generator is\n            # used\n            new_value = rs.randint(0, 2**16)\n            if _seed_current_object(current_value):\n                random_states[param_name] = new_value\n\n        # Also seed CV objects!\n        elif isinstance(model_params[param_name], sklearn.model_selection.BaseCrossValidator):\n            if not hasattr(model_params[param_name], \"random_state\"):\n                continue\n\n            current_value = model_params[param_name].random_state\n            new_value = rs.randint(0, 2**16)\n            if _seed_current_object(current_value):\n                model_params[param_name].random_state = new_value\n\n    model.set_params(**random_states)\n    return model\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.SklearnExtension.trim_flow_name","title":"<code>trim_flow_name(long_name, extra_trim_length=100, _outer=True)</code>  <code>classmethod</code>","text":"<p>Shorten generated sklearn flow name to at most <code>max_length</code> characters.</p> <p>Flows are assumed to have the following naming structure: <code>(model_selection)? (pipeline)? (steps)+</code> and will be shortened to: <code>sklearn.(selection.)?(pipeline.)?(steps)+</code> e.g. (white spaces and newlines added for readability)</p> <p>.. code ::</p> <pre><code>sklearn.pipeline.Pipeline(\n    columntransformer=sklearn.compose._column_transformer.ColumnTransformer(\n        numeric=sklearn.pipeline.Pipeline(\n            imputer=sklearn.preprocessing.imputation.Imputer,\n            standardscaler=sklearn.preprocessing.data.StandardScaler),\n        nominal=sklearn.pipeline.Pipeline(\n            simpleimputer=sklearn.impute.SimpleImputer,\n            onehotencoder=sklearn.preprocessing._encoders.OneHotEncoder)),\n    variancethreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,\n    svc=sklearn.svm.classes.SVC)\n</code></pre> <p>-&gt; <code>sklearn.Pipeline(ColumnTransformer,VarianceThreshold,SVC)</code></p> <p>Parameters:</p> Name Type Description Default <code>long_name</code> <code>str</code> <p>The full flow name generated by the scikit-learn extension.</p> required <code>extra_trim_length</code> <code>int</code> <p>If the trimmed name would exceed <code>extra_trim_length</code> characters, additional trimming of the short name is performed. This reduces the produced short name length. There is no guarantee the end result will not exceed <code>extra_trim_length</code>.</p> <code>100</code> <code>_outer</code> <code>bool(default=True)</code> <p>For internal use only. Specifies if the function is called recursively.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>@classmethod\ndef trim_flow_name(  # noqa: C901\n    cls,\n    long_name: str,\n    extra_trim_length: int = 100,\n    _outer: bool = True,  # noqa: FBT001, FBT002\n) -&gt; str:\n    \"\"\"Shorten generated sklearn flow name to at most ``max_length`` characters.\n\n    Flows are assumed to have the following naming structure:\n    ``(model_selection)? (pipeline)? (steps)+``\n    and will be shortened to:\n    ``sklearn.(selection.)?(pipeline.)?(steps)+``\n    e.g. (white spaces and newlines added for readability)\n\n    .. code ::\n\n        sklearn.pipeline.Pipeline(\n            columntransformer=sklearn.compose._column_transformer.ColumnTransformer(\n                numeric=sklearn.pipeline.Pipeline(\n                    imputer=sklearn.preprocessing.imputation.Imputer,\n                    standardscaler=sklearn.preprocessing.data.StandardScaler),\n                nominal=sklearn.pipeline.Pipeline(\n                    simpleimputer=sklearn.impute.SimpleImputer,\n                    onehotencoder=sklearn.preprocessing._encoders.OneHotEncoder)),\n            variancethreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,\n            svc=sklearn.svm.classes.SVC)\n\n    -&gt;\n    ``sklearn.Pipeline(ColumnTransformer,VarianceThreshold,SVC)``\n\n    Parameters\n    ----------\n    long_name : str\n        The full flow name generated by the scikit-learn extension.\n    extra_trim_length: int (default=100)\n        If the trimmed name would exceed `extra_trim_length` characters, additional trimming\n        of the short name is performed. This reduces the produced short name length.\n        There is no guarantee the end result will not exceed `extra_trim_length`.\n    _outer : bool (default=True)\n        For internal use only. Specifies if the function is called recursively.\n\n    Returns\n    -------\n    str\n\n    \"\"\"\n\n    def remove_all_in_parentheses(string: str) -&gt; str:\n        string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n        while removals &gt; 0:\n            string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n        return string\n\n    # Generally, we want to trim all hyperparameters, the exception to that is for model\n    # selection, as the `estimator` hyperparameter is very indicative of what is in the flow.\n    # So we first trim name of the `estimator` specified in mode selection. For reference, in\n    # the example below, we want to trim `sklearn.tree.tree.DecisionTreeClassifier`, and\n    # keep it in the final trimmed flow name:\n    # sklearn.pipeline.Pipeline(Imputer=sklearn.preprocessing.imputation.Imputer,\n    # VarianceThreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,  # noqa: ERA001, E501\n    # Estimator=sklearn.model_selection._search.RandomizedSearchCV(estimator=\n    # sklearn.tree.tree.DecisionTreeClassifier))\n    if \"sklearn.model_selection\" in long_name:\n        start_index = long_name.index(\"sklearn.model_selection\")\n        estimator_start = (\n            start_index + long_name[start_index:].index(\"estimator=\") + len(\"estimator=\")\n        )\n\n        model_select_boilerplate = long_name[start_index:estimator_start]\n        # above is .g. \"sklearn.model_selection._search.RandomizedSearchCV(estimator=\"\n        model_selection_class = model_select_boilerplate.split(\"(\")[0].split(\".\")[-1]\n\n        # Now we want to also find and parse the `estimator`, for this we find the closing\n        # parenthesis to the model selection technique:\n        closing_parenthesis_expected = 1\n        for char in long_name[estimator_start:]:\n            if char == \"(\":\n                closing_parenthesis_expected += 1\n            if char == \")\":\n                closing_parenthesis_expected -= 1\n            if closing_parenthesis_expected == 0:\n                break\n\n        _end: int = estimator_start + len(long_name[estimator_start:]) - 1\n        model_select_pipeline = long_name[estimator_start:_end]\n\n        trimmed_pipeline = cls.trim_flow_name(model_select_pipeline, _outer=False)\n        _, trimmed_pipeline = trimmed_pipeline.split(\".\", maxsplit=1)  # trim module prefix\n        model_select_short = f\"sklearn.{model_selection_class}[{trimmed_pipeline}]\"\n        name = long_name[:start_index] + model_select_short + long_name[_end + 1 :]\n    else:\n        name = long_name\n\n    module_name = long_name.split(\".\")[0]\n    short_name = module_name + \".{}\"\n\n    if name.startswith(\"sklearn.pipeline\"):\n        full_pipeline_class, pipeline = name[:-1].split(\"(\", maxsplit=1)\n        pipeline_class = full_pipeline_class.split(\".\")[-1]\n        # We don't want nested pipelines in the short name, so we trim all complicated\n        # subcomponents, i.e. those with parentheses:\n        pipeline = remove_all_in_parentheses(pipeline)\n\n        # then the pipeline steps are formatted e.g.:\n        # step1name=sklearn.submodule.ClassName,step2name...\n        components = [component.split(\".\")[-1] for component in pipeline.split(\",\")]\n        pipeline = f\"{pipeline_class}({','.join(components)})\"\n        if len(short_name.format(pipeline)) &gt; extra_trim_length:\n            pipeline = f\"{pipeline_class}(...,{components[-1]})\"\n    else:\n        # Just a simple component: e.g. sklearn.tree.DecisionTreeClassifier\n        pipeline = remove_all_in_parentheses(name).split(\".\")[-1]\n\n    if not _outer:\n        # Anything from parenthesis in inner calls should not be culled, so we use brackets\n        pipeline = pipeline.replace(\"(\", \"[\").replace(\")\", \"]\")\n    else:\n        # Square brackets may be introduced with nested model_selection\n        pipeline = pipeline.replace(\"[\", \"(\").replace(\"]\", \")\")\n\n    return short_name.format(pipeline)\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.cat","title":"<code>cat(X)</code>","text":"<p>Returns True for all categorical columns, False for the rest.</p> <p>This is a helper function for OpenML datasets encoded as DataFrames simplifying the handling of mixed data types. To build sklearn models on mixed data types, a ColumnTransformer is required to process each type of columns separately. This function allows transformations meant for categorical columns to access the categorical columns given the dataset as DataFrame.</p> Source code in <code>openml/extensions/sklearn/__init__.py</code> <pre><code>def cat(X: pd.DataFrame) -&gt; pd.Series:\n    \"\"\"Returns True for all categorical columns, False for the rest.\n\n    This is a helper function for OpenML datasets encoded as DataFrames simplifying the handling\n    of mixed data types. To build sklearn models on mixed data types, a ColumnTransformer is\n    required to process each type of columns separately.\n    This function allows transformations meant for categorical columns to access the\n    categorical columns given the dataset as DataFrame.\n    \"\"\"\n    if not hasattr(X, \"dtypes\"):\n        raise AttributeError(\"Not a Pandas DataFrame with 'dtypes' as attribute!\")\n    return X.dtypes == \"category\"\n</code></pre>"},{"location":"reference/extensions/sklearn/#openml.extensions.sklearn.cont","title":"<code>cont(X)</code>","text":"<p>Returns True for all non-categorical columns, False for the rest.</p> <p>This is a helper function for OpenML datasets encoded as DataFrames simplifying the handling of mixed data types. To build sklearn models on mixed data types, a ColumnTransformer is required to process each type of columns separately. This function allows transformations meant for continuous/numeric columns to access the continuous/numeric columns given the dataset as DataFrame.</p> Source code in <code>openml/extensions/sklearn/__init__.py</code> <pre><code>def cont(X: pd.DataFrame) -&gt; pd.Series:\n    \"\"\"Returns True for all non-categorical columns, False for the rest.\n\n    This is a helper function for OpenML datasets encoded as DataFrames simplifying the handling\n    of mixed data types. To build sklearn models on mixed data types, a ColumnTransformer is\n    required to process each type of columns separately.\n    This function allows transformations meant for continuous/numeric columns to access the\n    continuous/numeric columns given the dataset as DataFrame.\n    \"\"\"\n    if not hasattr(X, \"dtypes\"):\n        raise AttributeError(\"Not a Pandas DataFrame with 'dtypes' as attribute!\")\n    return X.dtypes != \"category\"\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/","title":"extension","text":""},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension","title":"<code>SklearnExtension</code>","text":"<p>               Bases: <code>Extension</code></p> <p>Connect scikit-learn to OpenML-Python. The estimators which use this extension must be scikit-learn compatible, i.e needs to be a subclass of sklearn.base.BaseEstimator\".</p> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>class SklearnExtension(Extension):\n    \"\"\"Connect scikit-learn to OpenML-Python.\n    The estimators which use this extension must be scikit-learn compatible,\n    i.e needs to be a subclass of sklearn.base.BaseEstimator\".\n    \"\"\"\n\n    ################################################################################################\n    # General setup\n\n    @classmethod\n    def can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n        \"\"\"Check whether a given describes a scikit-learn estimator.\n\n        This is done by parsing the ``external_version`` field.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return cls._is_sklearn_flow(flow)\n\n    @classmethod\n    def can_handle_model(cls, model: Any) -&gt; bool:\n        \"\"\"Check whether a model is an instance of ``sklearn.base.BaseEstimator``.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return isinstance(model, sklearn.base.BaseEstimator)\n\n    @classmethod\n    def trim_flow_name(  # noqa: C901\n        cls,\n        long_name: str,\n        extra_trim_length: int = 100,\n        _outer: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; str:\n        \"\"\"Shorten generated sklearn flow name to at most ``max_length`` characters.\n\n        Flows are assumed to have the following naming structure:\n        ``(model_selection)? (pipeline)? (steps)+``\n        and will be shortened to:\n        ``sklearn.(selection.)?(pipeline.)?(steps)+``\n        e.g. (white spaces and newlines added for readability)\n\n        .. code ::\n\n            sklearn.pipeline.Pipeline(\n                columntransformer=sklearn.compose._column_transformer.ColumnTransformer(\n                    numeric=sklearn.pipeline.Pipeline(\n                        imputer=sklearn.preprocessing.imputation.Imputer,\n                        standardscaler=sklearn.preprocessing.data.StandardScaler),\n                    nominal=sklearn.pipeline.Pipeline(\n                        simpleimputer=sklearn.impute.SimpleImputer,\n                        onehotencoder=sklearn.preprocessing._encoders.OneHotEncoder)),\n                variancethreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,\n                svc=sklearn.svm.classes.SVC)\n\n        -&gt;\n        ``sklearn.Pipeline(ColumnTransformer,VarianceThreshold,SVC)``\n\n        Parameters\n        ----------\n        long_name : str\n            The full flow name generated by the scikit-learn extension.\n        extra_trim_length: int (default=100)\n            If the trimmed name would exceed `extra_trim_length` characters, additional trimming\n            of the short name is performed. This reduces the produced short name length.\n            There is no guarantee the end result will not exceed `extra_trim_length`.\n        _outer : bool (default=True)\n            For internal use only. Specifies if the function is called recursively.\n\n        Returns\n        -------\n        str\n\n        \"\"\"\n\n        def remove_all_in_parentheses(string: str) -&gt; str:\n            string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n            while removals &gt; 0:\n                string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n            return string\n\n        # Generally, we want to trim all hyperparameters, the exception to that is for model\n        # selection, as the `estimator` hyperparameter is very indicative of what is in the flow.\n        # So we first trim name of the `estimator` specified in mode selection. For reference, in\n        # the example below, we want to trim `sklearn.tree.tree.DecisionTreeClassifier`, and\n        # keep it in the final trimmed flow name:\n        # sklearn.pipeline.Pipeline(Imputer=sklearn.preprocessing.imputation.Imputer,\n        # VarianceThreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,  # noqa: ERA001, E501\n        # Estimator=sklearn.model_selection._search.RandomizedSearchCV(estimator=\n        # sklearn.tree.tree.DecisionTreeClassifier))\n        if \"sklearn.model_selection\" in long_name:\n            start_index = long_name.index(\"sklearn.model_selection\")\n            estimator_start = (\n                start_index + long_name[start_index:].index(\"estimator=\") + len(\"estimator=\")\n            )\n\n            model_select_boilerplate = long_name[start_index:estimator_start]\n            # above is .g. \"sklearn.model_selection._search.RandomizedSearchCV(estimator=\"\n            model_selection_class = model_select_boilerplate.split(\"(\")[0].split(\".\")[-1]\n\n            # Now we want to also find and parse the `estimator`, for this we find the closing\n            # parenthesis to the model selection technique:\n            closing_parenthesis_expected = 1\n            for char in long_name[estimator_start:]:\n                if char == \"(\":\n                    closing_parenthesis_expected += 1\n                if char == \")\":\n                    closing_parenthesis_expected -= 1\n                if closing_parenthesis_expected == 0:\n                    break\n\n            _end: int = estimator_start + len(long_name[estimator_start:]) - 1\n            model_select_pipeline = long_name[estimator_start:_end]\n\n            trimmed_pipeline = cls.trim_flow_name(model_select_pipeline, _outer=False)\n            _, trimmed_pipeline = trimmed_pipeline.split(\".\", maxsplit=1)  # trim module prefix\n            model_select_short = f\"sklearn.{model_selection_class}[{trimmed_pipeline}]\"\n            name = long_name[:start_index] + model_select_short + long_name[_end + 1 :]\n        else:\n            name = long_name\n\n        module_name = long_name.split(\".\")[0]\n        short_name = module_name + \".{}\"\n\n        if name.startswith(\"sklearn.pipeline\"):\n            full_pipeline_class, pipeline = name[:-1].split(\"(\", maxsplit=1)\n            pipeline_class = full_pipeline_class.split(\".\")[-1]\n            # We don't want nested pipelines in the short name, so we trim all complicated\n            # subcomponents, i.e. those with parentheses:\n            pipeline = remove_all_in_parentheses(pipeline)\n\n            # then the pipeline steps are formatted e.g.:\n            # step1name=sklearn.submodule.ClassName,step2name...\n            components = [component.split(\".\")[-1] for component in pipeline.split(\",\")]\n            pipeline = f\"{pipeline_class}({','.join(components)})\"\n            if len(short_name.format(pipeline)) &gt; extra_trim_length:\n                pipeline = f\"{pipeline_class}(...,{components[-1]})\"\n        else:\n            # Just a simple component: e.g. sklearn.tree.DecisionTreeClassifier\n            pipeline = remove_all_in_parentheses(name).split(\".\")[-1]\n\n        if not _outer:\n            # Anything from parenthesis in inner calls should not be culled, so we use brackets\n            pipeline = pipeline.replace(\"(\", \"[\").replace(\")\", \"]\")\n        else:\n            # Square brackets may be introduced with nested model_selection\n            pipeline = pipeline.replace(\"[\", \"(\").replace(\"]\", \")\")\n\n        return short_name.format(pipeline)\n\n    @classmethod\n    def _min_dependency_str(cls, sklearn_version: str) -&gt; str:\n        \"\"\"Returns a string containing the minimum dependencies for the sklearn version passed.\n\n        Parameters\n        ----------\n        sklearn_version : str\n            A version string of the xx.xx.xx\n\n        Returns\n        -------\n        str\n        \"\"\"\n        # This explicit check is necessary to support existing entities on the OpenML servers\n        # that used the fixed dependency string (in the else block)\n        if Version(openml.__version__) &gt; Version(\"0.11\"):\n            # OpenML v0.11 onwards supports sklearn&gt;=0.24\n            # assumption: 0.24 onwards sklearn should contain a _min_dependencies.py file with\n            # variables declared for extracting minimum dependency for that version\n            if Version(sklearn_version) &gt;= Version(\"0.24\"):\n                from sklearn import _min_dependencies as _mindep\n\n                dependency_list = {\n                    \"numpy\": f\"{_mindep.NUMPY_MIN_VERSION}\",\n                    \"scipy\": f\"{_mindep.SCIPY_MIN_VERSION}\",\n                    \"joblib\": f\"{_mindep.JOBLIB_MIN_VERSION}\",\n                    \"threadpoolctl\": f\"{_mindep.THREADPOOLCTL_MIN_VERSION}\",\n                }\n            elif Version(sklearn_version) &gt;= Version(\"0.23\"):\n                dependency_list = {\n                    \"numpy\": \"1.13.3\",\n                    \"scipy\": \"0.19.1\",\n                    \"joblib\": \"0.11\",\n                    \"threadpoolctl\": \"2.0.0\",\n                }\n                if Version(sklearn_version).micro == 0:\n                    dependency_list.pop(\"threadpoolctl\")\n            elif Version(sklearn_version) &gt;= Version(\"0.21\"):\n                dependency_list = {\"numpy\": \"1.11.0\", \"scipy\": \"0.17.0\", \"joblib\": \"0.11\"}\n            elif Version(sklearn_version) &gt;= Version(\"0.19\"):\n                dependency_list = {\"numpy\": \"1.8.2\", \"scipy\": \"0.13.3\"}\n            else:\n                dependency_list = {\"numpy\": \"1.6.1\", \"scipy\": \"0.9\"}\n        else:\n            # this is INCORRECT for sklearn versions &gt;= 0.19 and &lt; 0.24\n            # given that OpenML has existing flows uploaded with such dependency information,\n            # we change no behaviour for older sklearn version, however from 0.24 onwards\n            # the dependency list will be accurately updated for any flow uploaded to OpenML\n            dependency_list = {\"numpy\": \"1.6.1\", \"scipy\": \"0.9\"}\n\n        sklearn_dep = f\"sklearn=={sklearn_version}\"\n        dep_str = \"\\n\".join([f\"{k}&gt;={v}\" for k, v in dependency_list.items()])\n        return \"\\n\".join([sklearn_dep, dep_str])\n\n    ################################################################################################\n    # Methods for flow serialization and de-serialization\n\n    def flow_to_model(\n        self,\n        flow: OpenMLFlow,\n        initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n        strict_version: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; Any:\n        \"\"\"Initializes a sklearn model based on a flow.\n\n        Parameters\n        ----------\n        flow : mixed\n            the object to deserialize (can be flow object, or any serialized\n            parameter value that is accepted by)\n\n        initialize_with_defaults : bool, optional (default=False)\n            If this flag is set, the hyperparameter values of flows will be\n            ignored and a flow with its defaults is returned.\n\n        strict_version : bool, default=True\n            Whether to fail if version requirements are not fulfilled.\n\n        Returns\n        -------\n        mixed\n        \"\"\"\n        return self._deserialize_sklearn(\n            flow,\n            initialize_with_defaults=initialize_with_defaults,\n            strict_version=strict_version,\n        )\n\n    def _deserialize_sklearn(  # noqa: PLR0915, C901, PLR0912\n        self,\n        o: Any,\n        components: dict | None = None,\n        initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n        recursion_depth: int = 0,\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        \"\"\"Recursive function to deserialize a scikit-learn flow.\n\n        This function inspects an object to deserialize and decides how to do so. This function\n        delegates all work to the respective functions to deserialize special data structures etc.\n        This function works on everything that has been serialized to OpenML: OpenMLFlow,\n        components (which are flows themselves), functions, hyperparameter distributions (for\n        random search) and the actual hyperparameter values themselves.\n\n        Parameters\n        ----------\n        o : mixed\n            the object to deserialize (can be flow object, or any serialized\n            parameter value that is accepted by)\n\n        components : Optional[dict]\n            Components of the current flow being de-serialized. These will not be used when\n            de-serializing the actual flow, but when de-serializing a component reference.\n\n        initialize_with_defaults : bool, optional (default=False)\n            If this flag is set, the hyperparameter values of flows will be\n            ignored and a flow with its defaults is returned.\n\n        recursion_depth : int\n            The depth at which this flow is called, mostly for debugging\n            purposes\n\n        strict_version : bool, default=True\n            Whether to fail if version requirements are not fulfilled.\n\n        Returns\n        -------\n        mixed\n        \"\"\"\n        logger.info(\n            \"-{} flow_to_sklearn START o={}, components={}, init_defaults={}\".format(\n                \"-\" * recursion_depth, o, components, initialize_with_defaults\n            ),\n        )\n        depth_pp = recursion_depth + 1  # shortcut var, depth plus plus\n\n        # First, we need to check whether the presented object is a json string.\n        # JSON strings are used to encoder parameter values. By passing around\n        # json strings for parameters, we make sure that we can flow_to_sklearn\n        # the parameter values to the correct type.\n\n        if isinstance(o, str):\n            with contextlib.suppress(JSONDecodeError):\n                o = json.loads(o)\n\n        if isinstance(o, dict):\n            # Check if the dict encodes a 'special' object, which could not\n            # easily converted into a string, but rather the information to\n            # re-create the object were stored in a dictionary.\n            if \"oml-python:serialized_object\" in o:\n                serialized_type = o[\"oml-python:serialized_object\"]\n                value = o[\"value\"]\n                if serialized_type == \"type\":\n                    rval = self._deserialize_type(value)\n                elif serialized_type == \"rv_frozen\":\n                    rval = self._deserialize_rv_frozen(value)\n                elif serialized_type == \"function\":\n                    rval = self._deserialize_function(value)\n                elif serialized_type in (COMPOSITION_STEP_CONSTANT, COMPONENT_REFERENCE):\n                    if serialized_type == COMPOSITION_STEP_CONSTANT:\n                        pass\n                    elif serialized_type == COMPONENT_REFERENCE:\n                        value = self._deserialize_sklearn(\n                            value,\n                            recursion_depth=depth_pp,\n                            strict_version=strict_version,\n                        )\n                    else:\n                        raise NotImplementedError(serialized_type)\n                    assert components is not None  # Necessary for mypy\n                    step_name = value[\"step_name\"]\n                    key = value[\"key\"]\n                    component = self._deserialize_sklearn(\n                        components[key],\n                        initialize_with_defaults=initialize_with_defaults,\n                        recursion_depth=depth_pp,\n                        strict_version=strict_version,\n                    )\n                    # The component is now added to where it should be used\n                    # later. It should not be passed to the constructor of the\n                    # main flow object.\n                    del components[key]\n                    if step_name is None:\n                        rval = component\n                    elif \"argument_1\" not in value:\n                        rval = (step_name, component)\n                    else:\n                        rval = (step_name, component, value[\"argument_1\"])\n                elif serialized_type == \"cv_object\":\n                    rval = self._deserialize_cross_validator(\n                        value,\n                        recursion_depth=recursion_depth,\n                        strict_version=strict_version,\n                    )\n                else:\n                    raise ValueError(f\"Cannot flow_to_sklearn {serialized_type}\")\n\n            else:\n                rval = OrderedDict(\n                    (\n                        self._deserialize_sklearn(\n                            o=key,\n                            components=components,\n                            initialize_with_defaults=initialize_with_defaults,\n                            recursion_depth=depth_pp,\n                            strict_version=strict_version,\n                        ),\n                        self._deserialize_sklearn(\n                            o=value,\n                            components=components,\n                            initialize_with_defaults=initialize_with_defaults,\n                            recursion_depth=depth_pp,\n                            strict_version=strict_version,\n                        ),\n                    )\n                    for key, value in sorted(o.items())\n                )\n        elif isinstance(o, (list, tuple)):\n            rval = [\n                self._deserialize_sklearn(\n                    o=element,\n                    components=components,\n                    initialize_with_defaults=initialize_with_defaults,\n                    recursion_depth=depth_pp,\n                    strict_version=strict_version,\n                )\n                for element in o\n            ]\n            if isinstance(o, tuple):\n                rval = tuple(rval)\n        elif isinstance(o, (bool, int, float, str)) or o is None:\n            rval = o\n        elif isinstance(o, OpenMLFlow):\n            if not self._is_sklearn_flow(o):\n                raise ValueError(\"Only sklearn flows can be reinstantiated\")\n            rval = self._deserialize_model(\n                flow=o,\n                keep_defaults=initialize_with_defaults,\n                recursion_depth=recursion_depth,\n                strict_version=strict_version,\n            )\n        else:\n            raise TypeError(o)\n        logger.info(f\"-{'-' * recursion_depth} flow_to_sklearn END   o={o}, rval={rval}\")\n        return rval\n\n    def model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n        \"\"\"Transform a scikit-learn model to a flow for uploading it to OpenML.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        OpenMLFlow\n        \"\"\"\n        # Necessary to make pypy not complain about all the different possible return types\n        return self._serialize_sklearn(model)\n\n    def _serialize_sklearn(self, o: Any, parent_model: Any | None = None) -&gt; Any:  # noqa: PLR0912, C901\n        rval = None  # type: Any\n\n        # TODO: assert that only on first recursion lvl `parent_model` can be None\n        if self.is_estimator(o):\n            # is the main model or a submodel\n            rval = self._serialize_model(o)\n        elif (\n            isinstance(o, (list, tuple))\n            and len(o) == 2\n            and o[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n            and isinstance(parent_model, sklearn.pipeline._BaseComposition)\n        ):\n            rval = o\n        elif isinstance(o, (list, tuple)):\n            # TODO: explain what type of parameter is here\n            rval = [self._serialize_sklearn(element, parent_model) for element in o]\n            if isinstance(o, tuple):\n                rval = tuple(rval)\n        elif isinstance(o, SIMPLE_TYPES) or o is None:\n            if isinstance(o, tuple(SIMPLE_NUMPY_TYPES)):\n                o = o.item()  # type: ignore\n            # base parameter values\n            rval = o\n        elif isinstance(o, dict):\n            # TODO: explain what type of parameter is here\n            if not isinstance(o, OrderedDict):\n                o = OrderedDict(sorted(o.items()))\n\n            rval = OrderedDict()\n            for key, value in o.items():\n                if not isinstance(key, str):\n                    raise TypeError(\n                        \"Can only use string as keys, you passed \"\n                        f\"type {type(key)} for value {key!s}.\",\n                    )\n                _key = self._serialize_sklearn(key, parent_model)\n                rval[_key] = self._serialize_sklearn(value, parent_model)\n        elif isinstance(o, type):\n            # TODO: explain what type of parameter is here\n            rval = self._serialize_type(o)\n        elif isinstance(o, scipy.stats.distributions.rv_frozen):\n            rval = self._serialize_rv_frozen(o)\n        # This only works for user-defined functions (and not even partial).\n        # I think this is exactly what we want here as there shouldn't be any\n        # built-in or functool.partials in a pipeline\n        elif inspect.isfunction(o):\n            # TODO: explain what type of parameter is here\n            rval = self._serialize_function(o)\n        elif self._is_cross_validator(o):\n            # TODO: explain what type of parameter is here\n            rval = self._serialize_cross_validator(o)\n        else:\n            raise TypeError(o, type(o))\n\n        return rval\n\n    def get_version_information(self) -&gt; list[str]:\n        \"\"\"List versions of libraries required by the flow.\n\n        Libraries listed are ``Python``, ``scikit-learn``, ``numpy`` and ``scipy``.\n\n        Returns\n        -------\n        List\n        \"\"\"\n        # This can possibly be done by a package such as pyxb, but I could not get\n        # it to work properly.\n        import numpy\n        import scipy\n        import sklearn\n\n        major, minor, micro, _, _ = sys.version_info\n        python_version = f\"Python_{'.'.join([str(major), str(minor), str(micro)])}.\"\n        sklearn_version = f\"Sklearn_{sklearn.__version__}.\"\n        numpy_version = f\"NumPy_{numpy.__version__}.\"  # type: ignore\n        scipy_version = f\"SciPy_{scipy.__version__}.\"\n\n        return [python_version, sklearn_version, numpy_version, scipy_version]\n\n    def create_setup_string(self, model: Any) -&gt; str:  # noqa: ARG002\n        \"\"\"Create a string which can be used to reinstantiate the given model.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        str\n        \"\"\"\n        return \" \".join(self.get_version_information())\n\n    def _is_cross_validator(self, o: Any) -&gt; bool:\n        return isinstance(o, sklearn.model_selection.BaseCrossValidator)\n\n    @classmethod\n    def _is_sklearn_flow(cls, flow: OpenMLFlow) -&gt; bool:\n        sklearn_dependency = isinstance(flow.dependencies, str) and \"sklearn\" in flow.dependencies\n        sklearn_as_external = isinstance(flow.external_version, str) and (\n            flow.external_version.startswith(\"sklearn==\") or \",sklearn==\" in flow.external_version\n        )\n        return sklearn_dependency or sklearn_as_external\n\n    def _get_sklearn_description(self, model: Any, char_lim: int = 1024) -&gt; str:\n        r\"\"\"Fetches the sklearn function docstring for the flow description\n\n        Retrieves the sklearn docstring available and does the following:\n        * If length of docstring &lt;= char_lim, then returns the complete docstring\n        * Else, trims the docstring till it encounters a 'Read more in the :ref:'\n        * Or till it encounters a 'Parameters\\n----------\\n'\n        The final string returned is at most of length char_lim with leading and\n        trailing whitespaces removed.\n\n        Parameters\n        ----------\n        model : sklearn model\n        char_lim : int\n            Specifying the max length of the returned string.\n            OpenML servers have a constraint of 1024 characters for the 'description' field.\n\n        Returns\n        -------\n        str\n        \"\"\"\n\n        def match_format(s):\n            return f\"{s}\\n{len(s) * '-'}\\n\"\n\n        s = inspect.getdoc(model)\n        if s is None:\n            return \"\"\n        try:\n            # trim till 'Read more'\n            pattern = \"Read more in the :ref:\"\n            index = s.index(pattern)\n            s = s[:index]\n            # trimming docstring to be within char_lim\n            if len(s) &gt; char_lim:\n                s = f\"{s[: char_lim - 3]}...\"\n            return s.strip()\n        except ValueError:\n            logger.warning(\n                \"'Read more' not found in descriptions. \"\n                \"Trying to trim till 'Parameters' if available in docstring.\",\n            )\n        try:\n            # if 'Read more' doesn't exist, trim till 'Parameters'\n            pattern = \"Parameters\"\n            index = s.index(match_format(pattern))\n        except ValueError:\n            # returning full docstring\n            logger.warning(\"'Parameters' not found in docstring. Omitting docstring trimming.\")\n            index = len(s)\n        s = s[:index]\n        # trimming docstring to be within char_lim\n        if len(s) &gt; char_lim:\n            s = f\"{s[: char_lim - 3]}...\"\n        return s.strip()\n\n    def _extract_sklearn_parameter_docstring(self, model) -&gt; None | str:\n        \"\"\"Extracts the part of sklearn docstring containing parameter information\n\n        Fetches the entire docstring and trims just the Parameter section.\n        The assumption is that 'Parameters' is the first section in sklearn docstrings,\n        followed by other sections titled 'Attributes', 'See also', 'Note', 'References',\n        appearing in that order if defined.\n        Returns a None if no section with 'Parameters' can be found in the docstring.\n\n        Parameters\n        ----------\n        model : sklearn model\n\n        Returns\n        -------\n        str, or None\n        \"\"\"\n\n        def match_format(s):\n            return f\"{s}\\n{len(s) * '-'}\\n\"\n\n        s = inspect.getdoc(model)\n        if s is None:\n            return None\n        try:\n            index1 = s.index(match_format(\"Parameters\"))\n        except ValueError as e:\n            # when sklearn docstring has no 'Parameters' section\n            logger.warning(f\"{match_format('Parameters')} {e}\")\n            return None\n\n        headings = [\"Attributes\", \"Notes\", \"See also\", \"Note\", \"References\"]\n        for h in headings:\n            try:\n                # to find end of Parameters section\n                index2 = s.index(match_format(h))\n                break\n            except ValueError:\n                logger.warning(f\"{h} not available in docstring\")\n                continue\n        else:\n            # in the case only 'Parameters' exist, trim till end of docstring\n            index2 = len(s)\n        s = s[index1:index2]\n        return s.strip()\n\n    def _extract_sklearn_param_info(self, model, char_lim=1024) -&gt; None | dict:\n        \"\"\"Parses parameter type and description from sklearn dosctring\n\n        Parameters\n        ----------\n        model : sklearn model\n        char_lim : int\n            Specifying the max length of the returned string.\n            OpenML servers have a constraint of 1024 characters string fields.\n\n        Returns\n        -------\n        Dict, or None\n        \"\"\"\n        docstring = self._extract_sklearn_parameter_docstring(model)\n        if docstring is None:\n            # when sklearn docstring has no 'Parameters' section\n            return None\n\n        n = re.compile(\"[.]*\\n\", flags=IGNORECASE)\n        lines = n.split(docstring)\n        p = re.compile(\"[a-z0-9_ ]+ : [a-z0-9_']+[a-z0-9_ ]*\", flags=IGNORECASE)\n        # The above regular expression is designed to detect sklearn parameter names and type\n        # in the format of [variable_name][space]:[space][type]\n        # The expectation is that the parameter description for this detected parameter will\n        # be all the lines in the docstring till the regex finds another parameter match\n\n        # collecting parameters and their descriptions\n        description = []  # type: List\n        for s in lines:\n            param = p.findall(s)\n            if param != []:\n                # a parameter definition is found by regex\n                # creating placeholder when parameter found which will be a list of strings\n                # string descriptions will be appended in subsequent iterations\n                # till another parameter is found and a new placeholder is created\n                placeholder = [\"\"]  # type: List[str]\n                description.append(placeholder)\n            elif len(description) &gt; 0:  # description=[] means no parameters found yet\n                # appending strings to the placeholder created when parameter found\n                description[-1].append(s)\n        for i in range(len(description)):\n            # concatenating parameter description strings\n            description[i] = \"\\n\".join(description[i]).strip()\n            # limiting all parameter descriptions to accepted OpenML string length\n            if len(description[i]) &gt; char_lim:\n                description[i] = f\"{description[i][: char_lim - 3]}...\"\n\n        # collecting parameters and their types\n        parameter_docs = OrderedDict()\n        matches = p.findall(docstring)\n        for i, param in enumerate(matches):\n            key, value = str(param).split(\":\")\n            parameter_docs[key.strip()] = [value.strip(), description[i]]\n\n        # to avoid KeyError for missing parameters\n        param_list_true = list(model.get_params().keys())\n        param_list_found = list(parameter_docs.keys())\n        for param in list(set(param_list_true) - set(param_list_found)):\n            parameter_docs[param] = [None, None]\n\n        return parameter_docs\n\n    def _serialize_model(self, model: Any) -&gt; OpenMLFlow:\n        \"\"\"Create an OpenMLFlow.\n\n        Calls `sklearn_to_flow` recursively to properly serialize the\n        parameters to strings and the components (other models) to OpenMLFlows.\n\n        Parameters\n        ----------\n        model : sklearn estimator\n\n        Returns\n        -------\n        OpenMLFlow\n\n        \"\"\"\n        # Get all necessary information about the model objects itself\n        (\n            parameters,\n            parameters_meta_info,\n            subcomponents,\n            subcomponents_explicit,\n        ) = self._extract_information_from_model(model)\n\n        # Check that a component does not occur multiple times in a flow as this\n        # is not supported by OpenML\n        self._check_multiple_occurence_of_component_in_flow(model, subcomponents)\n\n        # Create a flow name, which contains all components in brackets, e.g.:\n        # RandomizedSearchCV(Pipeline(StandardScaler,AdaBoostClassifier(DecisionTreeClassifier)),\n        # StandardScaler,AdaBoostClassifier(DecisionTreeClassifier))\n        class_name = model.__module__ + \".\" + model.__class__.__name__\n\n        # will be part of the name (in brackets)\n        sub_components_names = \"\"\n        for key in subcomponents:\n            name_thing = subcomponents[key]\n            if isinstance(name_thing, OpenMLFlow):\n                name = name_thing.name\n            elif (\n                isinstance(name_thing, str)\n                and subcomponents[key] in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                name = name_thing\n            else:\n                raise TypeError(type(subcomponents[key]))\n\n            if key in subcomponents_explicit:\n                sub_components_names += \",\" + key + \"=\" + name\n            else:\n                sub_components_names += \",\" + name\n\n        # slice operation on string in order to get rid of leading comma\n        name = f\"{class_name}({sub_components_names[1:]})\" if sub_components_names else class_name\n        short_name = SklearnExtension.trim_flow_name(name)\n\n        # Get the external versions of all sub-components\n        external_version = self._get_external_version_string(model, subcomponents)\n        dependencies = self._get_dependencies()\n        tags = self._get_tags()\n\n        sklearn_description = self._get_sklearn_description(model)\n        return OpenMLFlow(\n            name=name,\n            class_name=class_name,\n            custom_name=short_name,\n            description=sklearn_description,\n            model=model,\n            components=subcomponents,\n            parameters=parameters,\n            parameters_meta_info=parameters_meta_info,\n            external_version=external_version,\n            tags=tags,\n            extension=self,\n            language=\"English\",\n            dependencies=dependencies,\n        )\n\n    def _get_dependencies(self) -&gt; str:\n        return self._min_dependency_str(sklearn.__version__)  # type: ignore\n\n    def _get_tags(self) -&gt; list[str]:\n        sklearn_version = self._format_external_version(\"sklearn\", sklearn.__version__)  # type: ignore\n        sklearn_version_formatted = sklearn_version.replace(\"==\", \"_\")\n        return [\n            \"openml-python\",\n            \"sklearn\",\n            \"scikit-learn\",\n            \"python\",\n            sklearn_version_formatted,\n            # TODO: add more tags based on the scikit-learn\n            # module a flow is in? For example automatically\n            # annotate a class of sklearn.svm.SVC() with the\n            # tag svm?\n        ]\n\n    def _get_external_version_string(\n        self,\n        model: Any,\n        sub_components: dict[str, OpenMLFlow],\n    ) -&gt; str:\n        # Create external version string for a flow, given the model and the\n        # already parsed dictionary of sub_components. Retrieves the external\n        # version of all subcomponents, which themselves already contain all\n        # requirements for their subcomponents. The external version string is a\n        # sorted concatenation of all modules which are present in this run.\n\n        external_versions = set()\n\n        # The model is None if the flow is a placeholder flow such as 'passthrough' or 'drop'\n        if model is not None:\n            model_package_name = model.__module__.split(\".\")[0]\n            module = importlib.import_module(model_package_name)\n            model_package_version_number = module.__version__  # type: ignore\n            external_version = self._format_external_version(\n                model_package_name,\n                model_package_version_number,\n            )\n            external_versions.add(external_version)\n\n        openml_version = self._format_external_version(\"openml\", openml.__version__)\n        sklearn_version = self._format_external_version(\"sklearn\", sklearn.__version__)  # type: ignore\n        external_versions.add(openml_version)\n        external_versions.add(sklearn_version)\n        for visitee in sub_components.values():\n            if isinstance(visitee, str) and visitee in SKLEARN_PIPELINE_STRING_COMPONENTS:\n                continue\n            for external_version in visitee.external_version.split(\",\"):\n                external_versions.add(external_version)\n        return \",\".join(sorted(external_versions))\n\n    def _check_multiple_occurence_of_component_in_flow(\n        self,\n        model: Any,\n        sub_components: dict[str, OpenMLFlow],\n    ) -&gt; None:\n        to_visit_stack: list[OpenMLFlow] = []\n        to_visit_stack.extend(sub_components.values())\n        known_sub_components: set[str] = set()\n\n        while len(to_visit_stack) &gt; 0:\n            visitee = to_visit_stack.pop()\n            if isinstance(visitee, str) and visitee in SKLEARN_PIPELINE_STRING_COMPONENTS:\n                known_sub_components.add(visitee)\n            elif visitee.name in known_sub_components:\n                raise ValueError(\n                    f\"Found a second occurence of component {visitee.name} when \"\n                    f\"trying to serialize {model}.\",\n                )\n            else:\n                known_sub_components.add(visitee.name)\n                to_visit_stack.extend(visitee.components.values())\n\n    def _extract_information_from_model(  # noqa: PLR0915, C901, PLR0912\n        self,\n        model: Any,\n    ) -&gt; tuple[\n        OrderedDict[str, str | None],\n        OrderedDict[str, dict | None],\n        OrderedDict[str, OpenMLFlow],\n        set,\n    ]:\n        # This function contains four \"global\" states and is quite long and\n        # complicated. If it gets to complicated to ensure it's correctness,\n        # it would be best to make it a class with the four \"global\" states being\n        # the class attributes and the if/elif/else in the for-loop calls to\n        # separate class methods\n\n        # stores all entities that should become subcomponents\n        sub_components = OrderedDict()  # type: OrderedDict[str, OpenMLFlow]\n        # stores the keys of all subcomponents that should become\n        sub_components_explicit = set()\n        parameters: OrderedDict[str, str | None] = OrderedDict()\n        parameters_meta_info: OrderedDict[str, dict | None] = OrderedDict()\n        parameters_docs = self._extract_sklearn_param_info(model)\n\n        model_parameters = model.get_params(deep=False)\n        for k, v in sorted(model_parameters.items(), key=lambda t: t[0]):\n            rval = self._serialize_sklearn(v, model)\n\n            def flatten_all(list_):\n                \"\"\"Flattens arbitrary depth lists of lists (e.g. [[1,2],[3,[1]]] -&gt; [1,2,3,1]).\"\"\"\n                for el in list_:\n                    if isinstance(el, (list, tuple)) and len(el) &gt; 0:\n                        yield from flatten_all(el)\n                    else:\n                        yield el\n\n            # In case rval is a list of lists (or tuples), we need to identify two situations:\n            # - sklearn pipeline steps, feature union or base classifiers in voting classifier.\n            #   They look like e.g. [(\"imputer\", Imputer()), (\"classifier\", SVC())]\n            # - a list of lists with simple types (e.g. int or str), such as for an OrdinalEncoder\n            #   where all possible values for each feature are described: [[0,1,2], [1,2,5]]\n            is_non_empty_list_of_lists_with_same_type = (\n                isinstance(rval, (list, tuple))\n                and len(rval) &gt; 0\n                and isinstance(rval[0], (list, tuple))\n                and all(isinstance(rval_i, type(rval[0])) for rval_i in rval)\n            )\n\n            # Check that all list elements are of simple types.\n            nested_list_of_simple_types = (\n                is_non_empty_list_of_lists_with_same_type\n                and all(isinstance(el, SIMPLE_TYPES) for el in flatten_all(rval))\n                and all(\n                    len(rv) in (2, 3) and rv[1] not in SKLEARN_PIPELINE_STRING_COMPONENTS\n                    for rv in rval\n                )\n            )\n\n            if is_non_empty_list_of_lists_with_same_type and not nested_list_of_simple_types:\n                # If a list of lists is identified that include 'non-simple' types (e.g. objects),\n                # we assume they are steps in a pipeline, feature union, or base classifiers in\n                # a voting classifier.\n                parameter_value = []  # type: List\n                reserved_keywords = set(model.get_params(deep=False).keys())\n\n                for sub_component_tuple in rval:\n                    identifier = sub_component_tuple[0]\n                    sub_component = sub_component_tuple[1]\n                    sub_component_type = type(sub_component_tuple)\n                    if not 2 &lt;= len(sub_component_tuple) &lt;= 3:\n                        # length 2 is for {VotingClassifier.estimators,\n                        # Pipeline.steps, FeatureUnion.transformer_list}\n                        # length 3 is for ColumnTransformer\n                        raise ValueError(\n                            f\"Length of tuple of type {sub_component_type}\"\n                            \" does not match assumptions\"\n                        )\n\n                    if isinstance(sub_component, str):\n                        if sub_component not in SKLEARN_PIPELINE_STRING_COMPONENTS:\n                            msg = (\n                                \"Second item of tuple does not match assumptions. \"\n                                \"If string, can be only 'drop' or 'passthrough' but\"\n                                f\"got {sub_component}\"\n                            )\n                            raise ValueError(msg)\n                    elif sub_component is None:\n                        msg = (\n                            \"Cannot serialize objects of None type. Please use a valid \"\n                            \"placeholder for None. Note that empty sklearn estimators can be \"\n                            \"replaced with 'drop' or 'passthrough'.\"\n                        )\n                        raise ValueError(msg)\n                    elif not isinstance(sub_component, OpenMLFlow):\n                        msg = (\n                            \"Second item of tuple does not match assumptions. \"\n                            f\"Expected OpenMLFlow, got {type(sub_component)}\"\n                        )\n                        raise TypeError(msg)\n\n                    if identifier in reserved_keywords:\n                        parent_model = f\"{model.__module__}.{model.__class__.__name__}\"\n                        msg = (\n                            \"Found element shadowing official \"\n                            f\"parameter for {parent_model}: {identifier}\"\n                        )\n                        raise PyOpenMLError(msg)\n\n                    # when deserializing the parameter\n                    sub_components_explicit.add(identifier)\n                    if isinstance(sub_component, str):\n                        external_version = self._get_external_version_string(None, {})\n                        dependencies = self._get_dependencies()\n                        tags = self._get_tags()\n\n                        sub_components[identifier] = OpenMLFlow(\n                            name=sub_component,\n                            description=\"Placeholder flow for scikit-learn's string pipeline \"\n                            \"members\",\n                            components=OrderedDict(),\n                            parameters=OrderedDict(),\n                            parameters_meta_info=OrderedDict(),\n                            external_version=external_version,\n                            tags=tags,\n                            language=\"English\",\n                            dependencies=dependencies,\n                            model=None,\n                        )\n                        component_reference: OrderedDict[str, str | dict] = OrderedDict()\n                        component_reference[\"oml-python:serialized_object\"] = (\n                            COMPOSITION_STEP_CONSTANT\n                        )\n                        cr_value: dict[str, Any] = OrderedDict()\n                        cr_value[\"key\"] = identifier\n                        cr_value[\"step_name\"] = identifier\n                        if len(sub_component_tuple) == 3:\n                            cr_value[\"argument_1\"] = sub_component_tuple[2]\n                        component_reference[\"value\"] = cr_value\n                    else:\n                        sub_components[identifier] = sub_component\n                        component_reference = OrderedDict()\n                        component_reference[\"oml-python:serialized_object\"] = COMPONENT_REFERENCE\n                        cr_value = OrderedDict()\n                        cr_value[\"key\"] = identifier\n                        cr_value[\"step_name\"] = identifier\n                        if len(sub_component_tuple) == 3:\n                            cr_value[\"argument_1\"] = sub_component_tuple[2]\n                        component_reference[\"value\"] = cr_value\n                    parameter_value.append(component_reference)\n\n                # Here (and in the elif and else branch below) are the only\n                # places where we encode a value as json to make sure that all\n                # parameter values still have the same type after\n                # deserialization\n                if isinstance(rval, tuple):\n                    parameter_json = json.dumps(tuple(parameter_value))\n                else:\n                    parameter_json = json.dumps(parameter_value)\n                parameters[k] = parameter_json\n\n            elif isinstance(rval, OpenMLFlow):\n                # A subcomponent, for example the base model in\n                # AdaBoostClassifier\n                sub_components[k] = rval\n                sub_components_explicit.add(k)\n                component_reference = OrderedDict()\n                component_reference[\"oml-python:serialized_object\"] = COMPONENT_REFERENCE\n                cr_value = OrderedDict()\n                cr_value[\"key\"] = k\n                cr_value[\"step_name\"] = None\n                component_reference[\"value\"] = cr_value\n                cr = self._serialize_sklearn(component_reference, model)\n                parameters[k] = json.dumps(cr)\n\n            elif not (hasattr(rval, \"__len__\") and len(rval) == 0):\n                rval = json.dumps(rval)\n                parameters[k] = rval\n            # a regular hyperparameter\n            else:\n                parameters[k] = None\n\n            if parameters_docs is not None:\n                data_type, description = parameters_docs[k]\n                parameters_meta_info[k] = OrderedDict(\n                    ((\"description\", description), (\"data_type\", data_type)),\n                )\n            else:\n                parameters_meta_info[k] = OrderedDict(((\"description\", None), (\"data_type\", None)))\n\n        return parameters, parameters_meta_info, sub_components, sub_components_explicit\n\n    def _get_fn_arguments_with_defaults(self, fn_name: Callable) -&gt; tuple[dict, set]:\n        \"\"\"\n        Returns\n        -------\n            i) a dict with all parameter names that have a default value, and\n            ii) a set with all parameter names that do not have a default\n\n        Parameters\n        ----------\n        fn_name : callable\n            The function of which we want to obtain the defaults\n\n        Returns\n        -------\n        params_with_defaults: dict\n            a dict mapping parameter name to the default value\n        params_without_defaults: set\n            a set with all parameters that do not have a default value\n        \"\"\"\n        # parameters with defaults are optional, all others are required.\n        parameters = inspect.signature(fn_name).parameters\n        required_params = set()\n        optional_params = {}\n        for param in parameters:\n            parameter = parameters.get(param)\n            default_val = parameter.default  # type: ignore\n            if default_val is inspect.Signature.empty:\n                required_params.add(param)\n            else:\n                optional_params[param] = default_val\n        return optional_params, required_params\n\n    def _deserialize_model(  # noqa: C901\n        self,\n        flow: OpenMLFlow,\n        keep_defaults: bool,  # noqa: FBT001\n        recursion_depth: int,\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        logger.info(f\"-{'-' * recursion_depth} deserialize {flow.name}\")\n        model_name = flow.class_name\n        self._check_dependencies(flow.dependencies, strict_version=strict_version)\n\n        parameters = flow.parameters\n        components = flow.components\n        parameter_dict: dict[str, Any] = OrderedDict()\n\n        # Do a shallow copy of the components dictionary so we can remove the\n        # components from this copy once we added them into the pipeline. This\n        # allows us to not consider them any more when looping over the\n        # components, but keeping the dictionary of components untouched in the\n        # original components dictionary.\n        components_ = copy.copy(components)\n\n        for name in parameters:\n            value = parameters.get(name)\n            logger.info(f\"--{'-' * recursion_depth} flow_parameter={name}, value={value}\")\n            rval = self._deserialize_sklearn(\n                value,\n                components=components_,\n                initialize_with_defaults=keep_defaults,\n                recursion_depth=recursion_depth + 1,\n                strict_version=strict_version,\n            )\n            parameter_dict[name] = rval\n\n        for name in components:\n            if name in parameter_dict:\n                continue\n            if name not in components_:\n                continue\n            value = components[name]\n            logger.info(f\"--{'-' * recursion_depth} flow_component={name}, value={value}\")\n            rval = self._deserialize_sklearn(\n                value,\n                recursion_depth=recursion_depth + 1,\n                strict_version=strict_version,\n            )\n            parameter_dict[name] = rval\n\n        if model_name is None and flow.name in SKLEARN_PIPELINE_STRING_COMPONENTS:\n            return flow.name\n\n        assert model_name is not None\n        module_name = model_name.rsplit(\".\", 1)\n        model_class = getattr(importlib.import_module(module_name[0]), module_name[1])\n\n        if keep_defaults:\n            # obtain all params with a default\n            param_defaults, _ = self._get_fn_arguments_with_defaults(model_class.__init__)\n\n            # delete the params that have a default from the dict,\n            # so they get initialized with their default value\n            # except [...]\n            for param in param_defaults:\n                # [...] the ones that also have a key in the components dict.\n                # As OpenML stores different flows for ensembles with different\n                # (base-)components, in OpenML terms, these are not considered\n                # hyperparameters but rather constants (i.e., changing them would\n                # result in a different flow)\n                if param not in components:\n                    del parameter_dict[param]\n\n        if not strict_version:\n            # Ignore incompatible parameters\n            allowed_parameter = list(inspect.signature(model_class.__init__).parameters)\n            for p in list(parameter_dict.keys()):\n                if p not in allowed_parameter:\n                    warnings.warn(\n                        f\"While deserializing in a non-strict way, parameter {p} is not \"\n                        f\"allowed for {model_class.__name__} likely due to a version mismatch. \"\n                        \"We ignore the parameter.\",\n                        UserWarning,\n                        stacklevel=2,\n                    )\n                    del parameter_dict[p]\n\n        return model_class(**parameter_dict)\n\n    def _check_dependencies(\n        self,\n        dependencies: str,\n        strict_version: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; None:\n        if not dependencies:\n            return\n\n        dependencies_list = dependencies.split(\"\\n\")\n        for dependency_string in dependencies_list:\n            match = DEPENDENCIES_PATTERN.match(dependency_string)\n            if not match:\n                raise ValueError(f\"Cannot parse dependency {dependency_string}\")\n\n            dependency_name = match.group(\"name\")\n            operation = match.group(\"operation\")\n            version = match.group(\"version\")\n\n            module = importlib.import_module(dependency_name)\n            required_version = Version(version)\n            installed_version = Version(module.__version__)  # type: ignore\n\n            if operation == \"==\":\n                check = required_version == installed_version\n            elif operation == \"&gt;\":\n                check = installed_version &gt; required_version\n            elif operation == \"&gt;=\":\n                check = (\n                    installed_version &gt; required_version or installed_version == required_version\n                )\n            else:\n                raise NotImplementedError(f\"operation '{operation}' is not supported\")\n            message = (\n                f\"Trying to deserialize a model with dependency {dependency_string} not satisfied.\"\n            )\n            if not check:\n                if strict_version:\n                    raise ValueError(message)\n\n                warnings.warn(message, category=UserWarning, stacklevel=2)\n\n    def _serialize_type(self, o: Any) -&gt; OrderedDict[str, str]:\n        mapping = {\n            float: \"float\",\n            np.float32: \"np.float32\",\n            np.float64: \"np.float64\",\n            int: \"int\",\n            np.int32: \"np.int32\",\n            np.int64: \"np.int64\",\n        }\n        if Version(np.__version__) &lt; Version(\"1.24\"):\n            mapping[float] = \"np.float\"\n            mapping[int] = \"np.int\"\n\n        ret = OrderedDict()  # type: 'OrderedDict[str, str]'\n        ret[\"oml-python:serialized_object\"] = \"type\"\n        ret[\"value\"] = mapping[o]\n        return ret\n\n    def _deserialize_type(self, o: str) -&gt; Any:\n        mapping = {\n            \"float\": float,\n            \"np.float32\": np.float32,\n            \"np.float64\": np.float64,\n            \"int\": int,\n            \"np.int32\": np.int32,\n            \"np.int64\": np.int64,\n        }\n\n        # TODO(eddiebergman): Might be able to remove this\n        if Version(np.__version__) &lt; Version(\"1.24\"):\n            mapping[\"np.float\"] = np.float  # type: ignore # noqa: NPY001\n            mapping[\"np.int\"] = np.int  # type: ignore # noqa: NPY001\n\n        return mapping[o]\n\n    def _serialize_rv_frozen(self, o: Any) -&gt; OrderedDict[str, str | dict]:\n        args = o.args\n        kwds = o.kwds\n        a = o.a\n        b = o.b\n        dist = o.dist.__class__.__module__ + \".\" + o.dist.__class__.__name__\n        ret: OrderedDict[str, str | dict] = OrderedDict()\n        ret[\"oml-python:serialized_object\"] = \"rv_frozen\"\n        ret[\"value\"] = OrderedDict(\n            ((\"dist\", dist), (\"a\", a), (\"b\", b), (\"args\", args), (\"kwds\", kwds)),\n        )\n        return ret\n\n    def _deserialize_rv_frozen(self, o: OrderedDict[str, str]) -&gt; Any:\n        args = o[\"args\"]\n        kwds = o[\"kwds\"]\n        a = o[\"a\"]\n        b = o[\"b\"]\n        dist_name = o[\"dist\"]\n\n        module_name = dist_name.rsplit(\".\", 1)\n        try:\n            rv_class = getattr(importlib.import_module(module_name[0]), module_name[1])\n        except AttributeError as e:\n            _tb = traceback.format_exc()\n            warnings.warn(\n                f\"Cannot create model {dist_name} for flow. Reason is from error {type(e)}:{e}\"\n                f\"\\nTraceback: {_tb}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n            return None\n\n        dist = scipy.stats.distributions.rv_frozen(rv_class(), *args, **kwds)  # type: ignore\n        dist.a = a\n        dist.b = b\n\n        return dist\n\n    def _serialize_function(self, o: Callable) -&gt; OrderedDict[str, str]:\n        name = o.__module__ + \".\" + o.__name__\n        ret = OrderedDict()  # type: 'OrderedDict[str, str]'\n        ret[\"oml-python:serialized_object\"] = \"function\"\n        ret[\"value\"] = name\n        return ret\n\n    def _deserialize_function(self, name: str) -&gt; Callable:\n        module_name = name.rsplit(\".\", 1)\n        return getattr(importlib.import_module(module_name[0]), module_name[1])\n\n    def _serialize_cross_validator(self, o: Any) -&gt; OrderedDict[str, str | dict]:\n        ret: OrderedDict[str, str | dict] = OrderedDict()\n\n        parameters = OrderedDict()  # type: 'OrderedDict[str, Any]'\n\n        # XXX this is copied from sklearn.model_selection._split\n        cls = o.__class__\n        init = getattr(cls.__init__, \"deprecated_original\", cls.__init__)\n        # Ignore varargs, kw and default values and pop self\n        init_signature = inspect.signature(init)  # type: ignore\n        # Consider the constructor parameters excluding 'self'\n        if init is object.__init__:\n            args = []  # type: List\n        else:\n            args = sorted(\n                [\n                    p.name\n                    for p in init_signature.parameters.values()\n                    if p.name != \"self\" and p.kind != p.VAR_KEYWORD\n                ],\n            )\n\n        for key in args:\n            # We need deprecation warnings to always be on in order to\n            # catch deprecated param values.\n            # This is set in utils/__init__.py but it gets overwritten\n            # when running under python3 somehow.\n            with warnings.catch_warnings(record=True) as w:\n                warnings.simplefilter(\"always\", DeprecationWarning)\n                value = getattr(o, key, None)\n                if w is not None and len(w) and w[0].category is DeprecationWarning:\n                    # if the parameter is deprecated, don't show it\n                    continue\n\n            if not (isinstance(value, Sized) and len(value) == 0):\n                value = json.dumps(value)\n                parameters[key] = value\n            else:\n                parameters[key] = None\n\n        ret[\"oml-python:serialized_object\"] = \"cv_object\"\n        name = o.__module__ + \".\" + o.__class__.__name__\n        value = OrderedDict([(\"name\", name), (\"parameters\", parameters)])\n        ret[\"value\"] = value\n\n        return ret\n\n    def _deserialize_cross_validator(\n        self,\n        value: OrderedDict[str, Any],\n        recursion_depth: int,\n        strict_version: bool = True,  # noqa: FBT002, FBT001\n    ) -&gt; Any:\n        model_name = value[\"name\"]\n        parameters = value[\"parameters\"]\n\n        module_name = model_name.rsplit(\".\", 1)\n        model_class = getattr(importlib.import_module(module_name[0]), module_name[1])\n        for parameter in parameters:\n            parameters[parameter] = self._deserialize_sklearn(\n                parameters[parameter],\n                recursion_depth=recursion_depth + 1,\n                strict_version=strict_version,\n            )\n        return model_class(**parameters)\n\n    def _format_external_version(\n        self,\n        model_package_name: str,\n        model_package_version_number: str,\n    ) -&gt; str:\n        return f\"{model_package_name}=={model_package_version_number}\"\n\n    @staticmethod\n    def _get_parameter_values_recursive(\n        param_grid: dict | list[dict],\n        parameter_name: str,\n    ) -&gt; list[Any]:\n        \"\"\"\n        Returns a list of values for a given hyperparameter, encountered\n        recursively throughout the flow. (e.g., n_jobs can be defined\n        for various flows)\n\n        Parameters\n        ----------\n        param_grid: Union[Dict, List[Dict]]\n            Dict mapping from hyperparameter list to value, to a list of\n            such dicts\n\n        parameter_name: str\n            The hyperparameter that needs to be inspected\n\n        Returns\n        -------\n        List\n            A list of all values of hyperparameters with this name\n        \"\"\"\n        if isinstance(param_grid, dict):\n            return [\n                value\n                for param, value in param_grid.items()\n                if param.split(\"__\")[-1] == parameter_name\n            ]\n\n        if isinstance(param_grid, list):\n            result = []\n            for sub_grid in param_grid:\n                result.extend(\n                    SklearnExtension._get_parameter_values_recursive(sub_grid, parameter_name),\n                )\n            return result\n\n        raise ValueError(\"Param_grid should either be a dict or list of dicts\")\n\n    def _prevent_optimize_n_jobs(self, model):\n        \"\"\"\n        Ensures that HPO classes will not optimize the n_jobs hyperparameter\n\n        Parameters\n        ----------\n        model:\n            The model that will be fitted\n        \"\"\"\n        if self._is_hpo_class(model):\n            if isinstance(model, sklearn.model_selection.GridSearchCV):\n                param_distributions = model.param_grid\n            elif isinstance(model, sklearn.model_selection.RandomizedSearchCV):\n                param_distributions = model.param_distributions\n            else:\n                if hasattr(model, \"param_distributions\"):\n                    param_distributions = model.param_distributions\n                else:\n                    raise AttributeError(\n                        \"Using subclass BaseSearchCV other than \"\n                        \"{GridSearchCV, RandomizedSearchCV}. \"\n                        \"Could not find attribute \"\n                        \"param_distributions.\",\n                    )\n                logger.warning(\n                    \"Warning! Using subclass BaseSearchCV other than \"\n                    \"{GridSearchCV, RandomizedSearchCV}. \"\n                    \"Should implement param check. \",\n                )\n            n_jobs_vals = SklearnExtension._get_parameter_values_recursive(\n                param_distributions,\n                \"n_jobs\",\n            )\n            if len(n_jobs_vals) &gt; 0:\n                raise PyOpenMLError(\n                    \"openml-python should not be used to optimize the n_jobs parameter.\",\n                )\n\n    ################################################################################################\n    # Methods for performing runs with extension modules\n\n    def is_estimator(self, model: Any) -&gt; bool:\n        \"\"\"Check whether the given model is a scikit-learn estimator.\n\n        This function is only required for backwards compatibility and will be removed in the\n        near future.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        o = model\n        return hasattr(o, \"fit\") and hasattr(o, \"get_params\") and hasattr(o, \"set_params\")\n\n    def seed_model(self, model: Any, seed: int | None = None) -&gt; Any:  # noqa: C901\n        \"\"\"Set the random state of all the unseeded components of a model and return the seeded\n        model.\n\n        Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n        Models that are already seeded will maintain the seed. In this case,\n        only integer seeds are allowed (An exception is raised when a RandomState was used as\n        seed).\n\n        Parameters\n        ----------\n        model : sklearn model\n            The model to be seeded\n        seed : int\n            The seed to initialize the RandomState with. Unseeded subcomponents\n            will be seeded with a random number from the RandomState.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n\n        def _seed_current_object(current_value):\n            if isinstance(current_value, int):  # acceptable behaviour\n                return False\n\n            if isinstance(current_value, np.random.RandomState):\n                raise ValueError(\n                    \"Models initialized with a RandomState object are not \"\n                    \"supported. Please seed with an integer. \",\n                )\n\n            if current_value is not None:\n                raise ValueError(\n                    \"Models should be seeded with int or None (this should never happen). \",\n                )\n\n            return True\n\n        rs = np.random.RandomState(seed)\n        model_params = model.get_params()\n        random_states = {}\n        for param_name in sorted(model_params):\n            if \"random_state\" in param_name:\n                current_value = model_params[param_name]\n                # important to draw the value at this point (and not in the if\n                # statement) this way we guarantee that if a different set of\n                # subflows is seeded, the same number of the random generator is\n                # used\n                new_value = rs.randint(0, 2**16)\n                if _seed_current_object(current_value):\n                    random_states[param_name] = new_value\n\n            # Also seed CV objects!\n            elif isinstance(model_params[param_name], sklearn.model_selection.BaseCrossValidator):\n                if not hasattr(model_params[param_name], \"random_state\"):\n                    continue\n\n                current_value = model_params[param_name].random_state\n                new_value = rs.randint(0, 2**16)\n                if _seed_current_object(current_value):\n                    model_params[param_name].random_state = new_value\n\n        model.set_params(**random_states)\n        return model\n\n    def check_if_model_fitted(self, model: Any) -&gt; bool:\n        \"\"\"Returns True/False denoting if the model has already been fitted/trained\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        from sklearn.exceptions import NotFittedError\n        from sklearn.utils.validation import check_is_fitted\n\n        try:\n            # check if model is fitted\n            check_is_fitted(model)\n\n            # Creating random dummy data of arbitrary size\n            dummy_data = np.random.uniform(size=(10, 3))  # noqa: NPY002\n            # Using 'predict' instead of 'sklearn.utils.validation.check_is_fitted' for a more\n            # robust check that works across sklearn versions and models. Internally, 'predict'\n            # should call 'check_is_fitted' for every concerned attribute, thus offering a more\n            # assured check than explicit calls to 'check_is_fitted'\n            model.predict(dummy_data)\n            # Will reach here if the model was fit on a dataset with 3 features\n            return True\n        except NotFittedError:  # needs to be the first exception to be caught\n            # Model is not fitted, as is required\n            return False\n        except ValueError:\n            # Will reach here if the model was fit on a dataset with more or less than 3 features\n            return True\n\n    def _run_model_on_fold(  # noqa: PLR0915, PLR0913, C901, PLR0912\n        self,\n        model: Any,\n        task: OpenMLTask,\n        X_train: np.ndarray | scipy.sparse.spmatrix | pd.DataFrame,\n        rep_no: int,\n        fold_no: int,\n        y_train: np.ndarray | None = None,\n        X_test: np.ndarray | scipy.sparse.spmatrix | pd.DataFrame | None = None,\n    ) -&gt; tuple[\n        np.ndarray,\n        pd.DataFrame | None,\n        OrderedDict[str, float],\n        OpenMLRunTrace | None,\n    ]:\n        \"\"\"Run a model on a repeat,fold,subsample triplet of the task and return prediction\n        information.\n\n        Furthermore, it will measure run time measures in case multi-core behaviour allows this.\n        * exact user cpu time will be measured if the number of cores is set (recursive throughout\n        the model) exactly to 1\n        * wall clock time will be measured if the number of cores is set (recursive throughout the\n        model) to any given number (but not when it is set to -1)\n\n        Returns the data that is necessary to construct the OpenML Run object. Is used by\n        run_task_get_arff_content. Do not use this function unless you know what you are doing.\n\n        Parameters\n        ----------\n        model : Any\n            The UNTRAINED model to run. The model instance will be copied and not altered.\n        task : OpenMLTask\n            The task to run the model on.\n        X_train : array-like\n            Training data for the given repetition and fold.\n        rep_no : int\n            The repeat of the experiment (0-based; in case of 1 time CV, always 0)\n        fold_no : int\n            The fold nr of the experiment (0-based; in case of holdout, always 0)\n        y_train : Optional[np.ndarray] (default=None)\n            Target attributes for supervised tasks. In case of classification, these are integer\n            indices to the potential classes specified by dataset.\n        X_test : Optional, array-like (default=None)\n            Test attributes to test for generalization in supervised tasks.\n\n        Returns\n        -------\n        pred_y : np.ndarray\n            Predictions on the training/test set, depending on the task type.\n            For supervised tasks, predictions are on the test set.\n            For unsupervised tasks, predictions are on the training set.\n        proba_y : pd.DataFrame, optional\n            Predicted probabilities for the test set.\n            None, if task is not Classification or Learning Curve prediction.\n        user_defined_measures : OrderedDict[str, float]\n            User defined measures that were generated on this fold\n        trace : OpenMLRunTrace, optional\n            arff trace object from a fitted model and the trace content obtained by\n            repeatedly calling ``run_model_on_task``\n        \"\"\"\n\n        def _prediction_to_probabilities(\n            y: np.ndarray | list,\n            model_classes: list[Any],\n            class_labels: list[str] | None,\n        ) -&gt; pd.DataFrame:\n            \"\"\"Transforms predicted probabilities to match with OpenML class indices.\n\n            Parameters\n            ----------\n            y : np.ndarray\n                Predicted probabilities (possibly omitting classes if they were not present in the\n                training data).\n            model_classes : list\n                List of classes known_predicted by the model, ordered by their index.\n            class_labels : list\n                List of classes as stored in the task object fetched from server.\n\n            Returns\n            -------\n            pd.DataFrame\n            \"\"\"\n            if class_labels is None:\n                raise ValueError(\"The task has no class labels\")\n\n            if isinstance(y_train, np.ndarray) and isinstance(class_labels[0], str):\n                # mapping (decoding) the predictions to the categories\n                # creating a separate copy to not change the expected pred_y type\n                y = [class_labels[pred] for pred in y]  # list or numpy array of predictions\n\n            # model_classes: sklearn classifier mapping from original array id to\n            # prediction index id\n            if not isinstance(model_classes, list):\n                raise ValueError(\"please convert model classes to list prior to calling this fn\")\n\n            # DataFrame allows more accurate mapping of classes as column names\n            result = pd.DataFrame(\n                0,\n                index=np.arange(len(y)),\n                columns=model_classes,\n                dtype=np.float32,\n            )\n            for obs, prediction in enumerate(y):\n                result.loc[obs, prediction] = 1.0\n            return result\n\n        if isinstance(task, OpenMLSupervisedTask):\n            if y_train is None:\n                raise TypeError(\"argument y_train must not be of type None\")\n            if X_test is None:\n                raise TypeError(\"argument X_test must not be of type None\")\n\n        model_copy = sklearn.base.clone(model, safe=True)\n        # sanity check: prohibit users from optimizing n_jobs\n        self._prevent_optimize_n_jobs(model_copy)\n        # measures and stores runtimes\n        user_defined_measures = OrderedDict()  # type: 'OrderedDict[str, float]'\n        try:\n            # for measuring runtime. Only available since Python 3.3\n            modelfit_start_cputime = time.process_time()\n            modelfit_start_walltime = time.time()\n\n            if isinstance(task, OpenMLSupervisedTask):\n                model_copy.fit(X_train, y_train)  # type: ignore\n            elif isinstance(task, OpenMLClusteringTask):\n                model_copy.fit(X_train)  # type: ignore\n\n            modelfit_dur_cputime = (time.process_time() - modelfit_start_cputime) * 1000\n            modelfit_dur_walltime = (time.time() - modelfit_start_walltime) * 1000\n\n            user_defined_measures[\"usercpu_time_millis_training\"] = modelfit_dur_cputime\n            refit_time = model_copy.refit_time_ * 1000 if hasattr(model_copy, \"refit_time_\") else 0  # type: ignore\n            user_defined_measures[\"wall_clock_time_millis_training\"] = modelfit_dur_walltime\n\n        except AttributeError as e:\n            # typically happens when training a regressor on classification task\n            raise PyOpenMLError(str(e)) from e\n\n        if isinstance(task, (OpenMLClassificationTask, OpenMLLearningCurveTask)):\n            # search for model classes_ (might differ depending on modeltype)\n            # first, pipelines are a special case (these don't have a classes_\n            # object, but rather borrows it from the last step. We do this manually,\n            # because of the BaseSearch check)\n            if isinstance(model_copy, sklearn.pipeline.Pipeline):\n                used_estimator = model_copy.steps[-1][-1]\n            else:\n                used_estimator = model_copy\n\n            if self._is_hpo_class(used_estimator):\n                model_classes = used_estimator.best_estimator_.classes_\n            else:\n                model_classes = used_estimator.classes_\n\n            if not isinstance(model_classes, list):\n                model_classes = model_classes.tolist()\n\n            # to handle the case when dataset is numpy and categories are encoded\n            # however the class labels stored in task are still categories\n            if isinstance(y_train, np.ndarray) and isinstance(\n                cast(\"List\", task.class_labels)[0],\n                str,\n            ):\n                model_classes = [cast(\"List[str]\", task.class_labels)[i] for i in model_classes]\n\n        modelpredict_start_cputime = time.process_time()\n        modelpredict_start_walltime = time.time()\n\n        # In supervised learning this returns the predictions for Y, in clustering\n        # it returns the clusters\n        if isinstance(task, OpenMLSupervisedTask):\n            pred_y = model_copy.predict(X_test)\n        elif isinstance(task, OpenMLClusteringTask):\n            pred_y = model_copy.predict(X_train)\n        else:\n            raise ValueError(task)\n\n        modelpredict_duration_cputime = (time.process_time() - modelpredict_start_cputime) * 1000\n        user_defined_measures[\"usercpu_time_millis_testing\"] = modelpredict_duration_cputime\n        user_defined_measures[\"usercpu_time_millis\"] = (\n            modelfit_dur_cputime + modelpredict_duration_cputime\n        )\n        modelpredict_duration_walltime = (time.time() - modelpredict_start_walltime) * 1000\n        user_defined_measures[\"wall_clock_time_millis_testing\"] = modelpredict_duration_walltime\n        user_defined_measures[\"wall_clock_time_millis\"] = (\n            modelfit_dur_walltime + modelpredict_duration_walltime + refit_time\n        )\n\n        if isinstance(task, (OpenMLClassificationTask, OpenMLLearningCurveTask)):\n            try:\n                proba_y = model_copy.predict_proba(X_test)\n                proba_y = pd.DataFrame(proba_y, columns=model_classes)  # handles X_test as numpy\n            except AttributeError:  # predict_proba is not available when probability=False\n                proba_y = _prediction_to_probabilities(pred_y, model_classes, task.class_labels)\n\n            if task.class_labels is not None:\n                if proba_y.shape[1] != len(task.class_labels):\n                    # Remap the probabilities in case there was a class missing\n                    # at training time. By default, the classification targets\n                    # are mapped to be zero-based indices to the actual classes.\n                    # Therefore, the model_classes contain the correct indices to\n                    # the correct probability array. Example:\n                    # classes in the dataset: 0, 1, 2, 3, 4, 5\n                    # classes in the training set: 0, 1, 2, 4, 5\n                    # then we need to add a column full of zeros into the probabilities\n                    # for class 3 because the rest of the library expects that the\n                    # probabilities are ordered the same way as the classes are ordered).\n                    message = (\n                        f\"Estimator only predicted for {proba_y.shape[1]}/{len(task.class_labels)}\"\n                        \" classes!\"\n                    )\n                    warnings.warn(message, stacklevel=2)\n                    openml.config.logger.warning(message)\n\n                    for _i, col in enumerate(task.class_labels):\n                        # adding missing columns with 0 probability\n                        if col not in model_classes:\n                            proba_y[col] = 0\n                    # We re-order the columns to move possibly added missing columns into place.\n                    proba_y = proba_y[task.class_labels]\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n            if not np.all(set(proba_y.columns) == set(task.class_labels)):\n                missing_cols = list(set(task.class_labels) - set(proba_y.columns))\n                raise ValueError(\"Predicted probabilities missing for the columns: \", missing_cols)\n\n        elif isinstance(task, (OpenMLRegressionTask, OpenMLClusteringTask)):\n            proba_y = None\n        else:\n            raise TypeError(type(task))\n\n        if self._is_hpo_class(model_copy):\n            trace_data = self._extract_trace_data(model_copy, rep_no, fold_no)\n            trace: OpenMLRunTrace | None = self._obtain_arff_trace(\n                model_copy,\n                trace_data,\n            )\n        else:\n            trace = None\n\n        return pred_y, proba_y, user_defined_measures, trace\n\n    def obtain_parameter_values(  # noqa: C901, PLR0915\n        self,\n        flow: OpenMLFlow,\n        model: Any = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extracts all parameter settings required for the flow from the model.\n\n        If no explicit model is provided, the parameters will be extracted from `flow.model`\n        instead.\n\n        Parameters\n        ----------\n        flow : OpenMLFlow\n            OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n        model: Any, optional (default=None)\n            The model from which to obtain the parameter values. Must match the flow signature.\n            If None, use the model specified in ``OpenMLFlow.model``.\n\n        Returns\n        -------\n        list\n            A list of dicts, where each dict has the following entries:\n            - ``oml:name`` : str: The OpenML parameter name\n            - ``oml:value`` : mixed: A representation of the parameter value\n            - ``oml:component`` : int: flow id to which the parameter belongs\n        \"\"\"\n        openml.flows.functions._check_flow_for_server_id(flow)\n\n        def get_flow_dict(_flow):\n            flow_map = {_flow.name: _flow.flow_id}\n            for subflow in _flow.components:\n                flow_map.update(get_flow_dict(_flow.components[subflow]))\n            return flow_map\n\n        def extract_parameters(  # noqa: PLR0915, PLR0912, C901\n            _flow,\n            _flow_dict,\n            component_model,\n            _main_call=False,  # noqa: FBT002\n            main_id=None,\n        ):\n            def is_subcomponent_specification(values):\n                # checks whether the current value can be a specification of\n                # subcomponents, as for example the value for steps parameter\n                # (in Pipeline) or transformers parameter (in\n                # ColumnTransformer).\n                return (\n                    # Specification requires list/tuple of list/tuple with\n                    # at least length 2.\n                    isinstance(values, (tuple, list))\n                    and all(isinstance(item, (tuple, list)) and len(item) &gt; 1 for item in values)\n                    # And each component needs to be a flow or interpretable string\n                    and all(\n                        isinstance(item[1], openml.flows.OpenMLFlow)\n                        or (\n                            isinstance(item[1], str)\n                            and item[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n                        )\n                        for item in values\n                    )\n                )\n\n            # _flow is openml flow object, _param dict maps from flow name to flow\n            # id for the main call, the param dict can be overridden (useful for\n            # unit tests / sentinels) this way, for flows without subflows we do\n            # not have to rely on _flow_dict\n            exp_parameters = set(_flow.parameters)\n            if (\n                isinstance(component_model, str)\n                and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                model_parameters = set()\n            else:\n                model_parameters = set(component_model.get_params(deep=False))\n            if len(exp_parameters.symmetric_difference(model_parameters)) != 0:\n                flow_params = sorted(exp_parameters)\n                model_params = sorted(model_parameters)\n                raise ValueError(\n                    \"Parameters of the model do not match the \"\n                    \"parameters expected by the \"\n                    \"flow:\\nexpected flow parameters: \"\n                    f\"{flow_params}\\nmodel parameters: {model_params}\",\n                )\n            exp_components = set(_flow.components)\n            if (\n                isinstance(component_model, str)\n                and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                model_components = set()\n            else:\n                _ = set(component_model.get_params(deep=False))\n                model_components = {\n                    mp\n                    for mp in component_model.get_params(deep=True)\n                    if \"__\" not in mp and mp not in _\n                }\n            if len(exp_components.symmetric_difference(model_components)) != 0:\n                is_problem = True\n                if len(exp_components - model_components) &gt; 0:\n                    # If an expected component is not returned as a component by get_params(),\n                    # this means that it is also a parameter -&gt; we need to check that this is\n                    # actually the case\n                    difference = exp_components - model_components\n                    component_in_model_parameters = []\n                    for component in difference:\n                        if component in model_parameters:\n                            component_in_model_parameters.append(True)\n                        else:\n                            component_in_model_parameters.append(False)\n                    is_problem = not all(component_in_model_parameters)\n                if is_problem:\n                    flow_components = sorted(exp_components)\n                    model_components = sorted(model_components)\n                    raise ValueError(\n                        \"Subcomponents of the model do not match the \"\n                        \"parameters expected by the \"\n                        \"flow:\\nexpected flow subcomponents: \"\n                        f\"{flow_components}\\nmodel subcomponents: {model_components}\",\n                    )\n\n            _params = []\n            for _param_name in _flow.parameters:\n                _current = OrderedDict()\n                _current[\"oml:name\"] = _param_name\n\n                current_param_values = self.model_to_flow(component_model.get_params()[_param_name])\n\n                # Try to filter out components (a.k.a. subflows) which are\n                # handled further down in the code (by recursively calling\n                # this function)!\n                if isinstance(current_param_values, openml.flows.OpenMLFlow):\n                    continue\n\n                if is_subcomponent_specification(current_param_values):\n                    # complex parameter value, with subcomponents\n                    parsed_values = []\n                    for subcomponent in current_param_values:\n                        # scikit-learn stores usually tuples in the form\n                        # (name (str), subcomponent (mixed), argument\n                        # (mixed)). OpenML replaces the subcomponent by an\n                        # OpenMLFlow object.\n                        if len(subcomponent) &lt; 2 or len(subcomponent) &gt; 3:\n                            raise ValueError(\"Component reference should be size {2,3}. \")\n\n                        subcomponent_identifier = subcomponent[0]\n                        subcomponent_flow = subcomponent[1]\n                        if not isinstance(subcomponent_identifier, str):\n                            raise TypeError(\n                                \"Subcomponent identifier should be of type string, \"\n                                f\"but is {type(subcomponent_identifier)}\",\n                            )\n                        if not isinstance(subcomponent_flow, (openml.flows.OpenMLFlow, str)):\n                            if (\n                                isinstance(subcomponent_flow, str)\n                                and subcomponent_flow in SKLEARN_PIPELINE_STRING_COMPONENTS\n                            ):\n                                pass\n                            else:\n                                raise TypeError(\n                                    \"Subcomponent flow should be of type flow, but is\"\n                                    f\" {type(subcomponent_flow)}\",\n                                )\n\n                        current = {\n                            \"oml-python:serialized_object\": COMPONENT_REFERENCE,\n                            \"value\": {\n                                \"key\": subcomponent_identifier,\n                                \"step_name\": subcomponent_identifier,\n                            },\n                        }\n                        if len(subcomponent) == 3:\n                            if not isinstance(subcomponent[2], list) and not isinstance(\n                                subcomponent[2],\n                                OrderedDict,\n                            ):\n                                raise TypeError(\n                                    \"Subcomponent argument should be list or OrderedDict\",\n                                )\n                            current[\"value\"][\"argument_1\"] = subcomponent[2]\n                        parsed_values.append(current)\n                    parsed_values = json.dumps(parsed_values)\n                else:\n                    # vanilla parameter value\n                    parsed_values = json.dumps(current_param_values)\n\n                _current[\"oml:value\"] = parsed_values\n                if _main_call:\n                    _current[\"oml:component\"] = main_id\n                else:\n                    _current[\"oml:component\"] = _flow_dict[_flow.name]\n                _params.append(_current)\n\n            for _identifier in _flow.components:\n                subcomponent_model = component_model.get_params()[_identifier]\n                _params.extend(\n                    extract_parameters(\n                        _flow.components[_identifier],\n                        _flow_dict,\n                        subcomponent_model,\n                    ),\n                )\n            return _params\n\n        flow_dict = get_flow_dict(flow)\n        model = model if model is not None else flow.model\n        return extract_parameters(flow, flow_dict, model, _main_call=True, main_id=flow.flow_id)\n\n    def _openml_param_name_to_sklearn(\n        self,\n        openml_parameter: openml.setups.OpenMLParameter,\n        flow: OpenMLFlow,\n    ) -&gt; str:\n        \"\"\"\n        Converts the name of an OpenMLParameter into the sklean name, given a flow.\n\n        Parameters\n        ----------\n        openml_parameter: OpenMLParameter\n            The parameter under consideration\n\n        flow: OpenMLFlow\n            The flow that provides context.\n\n        Returns\n        -------\n        sklearn_parameter_name: str\n            The name the parameter will have once used in scikit-learn\n        \"\"\"\n        if not isinstance(openml_parameter, openml.setups.OpenMLParameter):\n            raise ValueError(\"openml_parameter should be an instance of OpenMLParameter\")\n        if not isinstance(flow, OpenMLFlow):\n            raise ValueError(\"flow should be an instance of OpenMLFlow\")\n\n        flow_structure = flow.get_structure(\"name\")\n        if openml_parameter.flow_name not in flow_structure:\n            raise ValueError(\"Obtained OpenMLParameter and OpenMLFlow do not correspond. \")\n        name = openml_parameter.flow_name  # for PEP8\n        return \"__\".join(flow_structure[name] + [openml_parameter.parameter_name])\n\n    ################################################################################################\n    # Methods for hyperparameter optimization\n\n    def _is_hpo_class(self, model: Any) -&gt; bool:\n        \"\"\"Check whether the model performs hyperparameter optimization.\n\n        Used to check whether an optimization trace can be extracted from the model after\n        running it.\n\n        Parameters\n        ----------\n        model : Any\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return isinstance(model, sklearn.model_selection._search.BaseSearchCV)\n\n    def instantiate_model_from_hpo_class(\n        self,\n        model: Any,\n        trace_iteration: OpenMLTraceIteration,\n    ) -&gt; Any:\n        \"\"\"Instantiate a ``base_estimator`` which can be searched over by the hyperparameter\n        optimization model.\n\n        Parameters\n        ----------\n        model : Any\n            A hyperparameter optimization model which defines the model to be instantiated.\n        trace_iteration : OpenMLTraceIteration\n            Describing the hyperparameter settings to instantiate.\n\n        Returns\n        -------\n        Any\n        \"\"\"\n        if not self._is_hpo_class(model):\n            raise AssertionError(\n                f\"Flow model {model} is not an instance of\"\n                \" sklearn.model_selection._search.BaseSearchCV\",\n            )\n        base_estimator = model.estimator\n        base_estimator.set_params(**trace_iteration.get_parameters())\n        return base_estimator\n\n    def _extract_trace_data(self, model, rep_no, fold_no):\n        \"\"\"Extracts data from a machine learning model's cross-validation results\n        and creates an ARFF (Attribute-Relation File Format) trace.\n\n        Parameters\n        ----------\n        model : Any\n            A fitted hyperparameter optimization model.\n        rep_no : int\n            The repetition number.\n        fold_no : int\n            The fold number.\n\n        Returns\n        -------\n        A list of ARFF tracecontent.\n        \"\"\"\n        arff_tracecontent = []\n        for itt_no in range(len(model.cv_results_[\"mean_test_score\"])):\n            # we use the string values for True and False, as it is defined in\n            # this way by the OpenML server\n            selected = \"false\"\n            if itt_no == model.best_index_:\n                selected = \"true\"\n            test_score = model.cv_results_[\"mean_test_score\"][itt_no]\n            arff_line = [rep_no, fold_no, itt_no, test_score, selected]\n            for key in model.cv_results_:\n                if key.startswith(\"param_\"):\n                    value = model.cv_results_[key][itt_no]\n                    # Built-in serializer does not convert all numpy types,\n                    # these methods convert them to built-in types instead.\n                    if isinstance(value, np.generic):\n                        # For scalars it actually returns scalars, not a list\n                        value = value.tolist()\n                    serialized_value = json.dumps(value) if value is not np.ma.masked else np.nan\n                    arff_line.append(serialized_value)\n            arff_tracecontent.append(arff_line)\n        return arff_tracecontent\n\n    def _obtain_arff_trace(\n        self,\n        model: Any,\n        trace_content: list,\n    ) -&gt; OpenMLRunTrace:\n        \"\"\"Create arff trace object from a fitted model and the trace content obtained by\n        repeatedly calling ``run_model_on_task``.\n\n        Parameters\n        ----------\n        model : Any\n            A fitted hyperparameter optimization model.\n\n        trace_content : List[List]\n            Trace content obtained by ``openml.runs.run_flow_on_task``.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        if not self._is_hpo_class(model):\n            raise AssertionError(\n                f\"Flow model {model} is not an instance of \"\n                \"sklearn.model_selection._search.BaseSearchCV\",\n            )\n        if not hasattr(model, \"cv_results_\"):\n            raise ValueError(\"model should contain `cv_results_`\")\n\n        # attributes that will be in trace arff, regardless of the model\n        trace_attributes = [\n            (\"repeat\", \"NUMERIC\"),\n            (\"fold\", \"NUMERIC\"),\n            (\"iteration\", \"NUMERIC\"),\n            (\"evaluation\", \"NUMERIC\"),\n            (\"selected\", [\"true\", \"false\"]),\n        ]\n\n        # model dependent attributes for trace arff\n        for key in model.cv_results_:\n            if key.startswith(\"param_\"):\n                # supported types should include all types, including bool,\n                # int float\n                supported_basic_types = (bool, int, float, str)\n                for param_value in model.cv_results_[key]:\n                    if isinstance(param_value, np.generic):\n                        param_value = param_value.tolist()  # noqa: PLW2901\n                    if (\n                        isinstance(param_value, supported_basic_types)\n                        or param_value is None\n                        or param_value is np.ma.masked\n                    ):\n                        # basic string values\n                        type = \"STRING\"  # noqa: A001\n                    elif isinstance(param_value, (list, tuple)) and all(\n                        isinstance(i, int) for i in param_value\n                    ):\n                        # list of integers (usually for selecting features)\n                        # hyperparameter layer_sizes of MLPClassifier\n                        type = \"STRING\"  # noqa: A001\n                    else:\n                        raise TypeError(f\"Unsupported param type in param grid: {key}\")\n\n                # renamed the attribute param to parameter, as this is a required\n                # OpenML convention - this also guards against name collisions\n                # with the required trace attributes\n                attribute = (PREFIX + key[6:], type)  # type: ignore\n                trace_attributes.append(attribute)\n\n        return OpenMLRunTrace.generate(\n            trace_attributes,\n            trace_content,\n        )\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.can_handle_flow","title":"<code>can_handle_flow(flow)</code>  <code>classmethod</code>","text":"<p>Check whether a given describes a scikit-learn estimator.</p> <p>This is done by parsing the <code>external_version</code> field.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>@classmethod\ndef can_handle_flow(cls, flow: OpenMLFlow) -&gt; bool:\n    \"\"\"Check whether a given describes a scikit-learn estimator.\n\n    This is done by parsing the ``external_version`` field.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return cls._is_sklearn_flow(flow)\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.can_handle_model","title":"<code>can_handle_model(model)</code>  <code>classmethod</code>","text":"<p>Check whether a model is an instance of <code>sklearn.base.BaseEstimator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>@classmethod\ndef can_handle_model(cls, model: Any) -&gt; bool:\n    \"\"\"Check whether a model is an instance of ``sklearn.base.BaseEstimator``.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return isinstance(model, sklearn.base.BaseEstimator)\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.check_if_model_fitted","title":"<code>check_if_model_fitted(model)</code>","text":"<p>Returns True/False denoting if the model has already been fitted/trained</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def check_if_model_fitted(self, model: Any) -&gt; bool:\n    \"\"\"Returns True/False denoting if the model has already been fitted/trained\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from sklearn.exceptions import NotFittedError\n    from sklearn.utils.validation import check_is_fitted\n\n    try:\n        # check if model is fitted\n        check_is_fitted(model)\n\n        # Creating random dummy data of arbitrary size\n        dummy_data = np.random.uniform(size=(10, 3))  # noqa: NPY002\n        # Using 'predict' instead of 'sklearn.utils.validation.check_is_fitted' for a more\n        # robust check that works across sklearn versions and models. Internally, 'predict'\n        # should call 'check_is_fitted' for every concerned attribute, thus offering a more\n        # assured check than explicit calls to 'check_is_fitted'\n        model.predict(dummy_data)\n        # Will reach here if the model was fit on a dataset with 3 features\n        return True\n    except NotFittedError:  # needs to be the first exception to be caught\n        # Model is not fitted, as is required\n        return False\n    except ValueError:\n        # Will reach here if the model was fit on a dataset with more or less than 3 features\n        return True\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.create_setup_string","title":"<code>create_setup_string(model)</code>","text":"<p>Create a string which can be used to reinstantiate the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def create_setup_string(self, model: Any) -&gt; str:  # noqa: ARG002\n    \"\"\"Create a string which can be used to reinstantiate the given model.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    str\n    \"\"\"\n    return \" \".join(self.get_version_information())\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.flow_to_model","title":"<code>flow_to_model(flow, initialize_with_defaults=False, strict_version=True)</code>","text":"<p>Initializes a sklearn model based on a flow.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>mixed</code> <p>the object to deserialize (can be flow object, or any serialized parameter value that is accepted by)</p> required <code>initialize_with_defaults</code> <code>(bool, optional(default=False))</code> <p>If this flag is set, the hyperparameter values of flows will be ignored and a flow with its defaults is returned.</p> <code>False</code> <code>strict_version</code> <code>bool</code> <p>Whether to fail if version requirements are not fulfilled.</p> <code>True</code> <p>Returns:</p> Type Description <code>mixed</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def flow_to_model(\n    self,\n    flow: OpenMLFlow,\n    initialize_with_defaults: bool = False,  # noqa: FBT001, FBT002\n    strict_version: bool = True,  # noqa: FBT001, FBT002\n) -&gt; Any:\n    \"\"\"Initializes a sklearn model based on a flow.\n\n    Parameters\n    ----------\n    flow : mixed\n        the object to deserialize (can be flow object, or any serialized\n        parameter value that is accepted by)\n\n    initialize_with_defaults : bool, optional (default=False)\n        If this flag is set, the hyperparameter values of flows will be\n        ignored and a flow with its defaults is returned.\n\n    strict_version : bool, default=True\n        Whether to fail if version requirements are not fulfilled.\n\n    Returns\n    -------\n    mixed\n    \"\"\"\n    return self._deserialize_sklearn(\n        flow,\n        initialize_with_defaults=initialize_with_defaults,\n        strict_version=strict_version,\n    )\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.get_version_information","title":"<code>get_version_information()</code>","text":"<p>List versions of libraries required by the flow.</p> <p>Libraries listed are <code>Python</code>, <code>scikit-learn</code>, <code>numpy</code> and <code>scipy</code>.</p> <p>Returns:</p> Type Description <code>List</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def get_version_information(self) -&gt; list[str]:\n    \"\"\"List versions of libraries required by the flow.\n\n    Libraries listed are ``Python``, ``scikit-learn``, ``numpy`` and ``scipy``.\n\n    Returns\n    -------\n    List\n    \"\"\"\n    # This can possibly be done by a package such as pyxb, but I could not get\n    # it to work properly.\n    import numpy\n    import scipy\n    import sklearn\n\n    major, minor, micro, _, _ = sys.version_info\n    python_version = f\"Python_{'.'.join([str(major), str(minor), str(micro)])}.\"\n    sklearn_version = f\"Sklearn_{sklearn.__version__}.\"\n    numpy_version = f\"NumPy_{numpy.__version__}.\"  # type: ignore\n    scipy_version = f\"SciPy_{scipy.__version__}.\"\n\n    return [python_version, sklearn_version, numpy_version, scipy_version]\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.instantiate_model_from_hpo_class","title":"<code>instantiate_model_from_hpo_class(model, trace_iteration)</code>","text":"<p>Instantiate a <code>base_estimator</code> which can be searched over by the hyperparameter optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A hyperparameter optimization model which defines the model to be instantiated.</p> required <code>trace_iteration</code> <code>OpenMLTraceIteration</code> <p>Describing the hyperparameter settings to instantiate.</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def instantiate_model_from_hpo_class(\n    self,\n    model: Any,\n    trace_iteration: OpenMLTraceIteration,\n) -&gt; Any:\n    \"\"\"Instantiate a ``base_estimator`` which can be searched over by the hyperparameter\n    optimization model.\n\n    Parameters\n    ----------\n    model : Any\n        A hyperparameter optimization model which defines the model to be instantiated.\n    trace_iteration : OpenMLTraceIteration\n        Describing the hyperparameter settings to instantiate.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    if not self._is_hpo_class(model):\n        raise AssertionError(\n            f\"Flow model {model} is not an instance of\"\n            \" sklearn.model_selection._search.BaseSearchCV\",\n        )\n    base_estimator = model.estimator\n    base_estimator.set_params(**trace_iteration.get_parameters())\n    return base_estimator\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.is_estimator","title":"<code>is_estimator(model)</code>","text":"<p>Check whether the given model is a scikit-learn estimator.</p> <p>This function is only required for backwards compatibility and will be removed in the near future.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def is_estimator(self, model: Any) -&gt; bool:\n    \"\"\"Check whether the given model is a scikit-learn estimator.\n\n    This function is only required for backwards compatibility and will be removed in the\n    near future.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    o = model\n    return hasattr(o, \"fit\") and hasattr(o, \"get_params\") and hasattr(o, \"set_params\")\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.model_to_flow","title":"<code>model_to_flow(model)</code>","text":"<p>Transform a scikit-learn model to a flow for uploading it to OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def model_to_flow(self, model: Any) -&gt; OpenMLFlow:\n    \"\"\"Transform a scikit-learn model to a flow for uploading it to OpenML.\n\n    Parameters\n    ----------\n    model : Any\n\n    Returns\n    -------\n    OpenMLFlow\n    \"\"\"\n    # Necessary to make pypy not complain about all the different possible return types\n    return self._serialize_sklearn(model)\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.obtain_parameter_values","title":"<code>obtain_parameter_values(flow, model=None)</code>","text":"<p>Extracts all parameter settings required for the flow from the model.</p> <p>If no explicit model is provided, the parameters will be extracted from <code>flow.model</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)</p> required <code>model</code> <code>Any</code> <p>The model from which to obtain the parameter values. Must match the flow signature. If None, use the model specified in <code>OpenMLFlow.model</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of dicts, where each dict has the following entries: - <code>oml:name</code> : str: The OpenML parameter name - <code>oml:value</code> : mixed: A representation of the parameter value - <code>oml:component</code> : int: flow id to which the parameter belongs</p> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def obtain_parameter_values(  # noqa: C901, PLR0915\n    self,\n    flow: OpenMLFlow,\n    model: Any = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extracts all parameter settings required for the flow from the model.\n\n    If no explicit model is provided, the parameters will be extracted from `flow.model`\n    instead.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        OpenMLFlow object (containing flow ids, i.e., it has to be downloaded from the server)\n\n    model: Any, optional (default=None)\n        The model from which to obtain the parameter values. Must match the flow signature.\n        If None, use the model specified in ``OpenMLFlow.model``.\n\n    Returns\n    -------\n    list\n        A list of dicts, where each dict has the following entries:\n        - ``oml:name`` : str: The OpenML parameter name\n        - ``oml:value`` : mixed: A representation of the parameter value\n        - ``oml:component`` : int: flow id to which the parameter belongs\n    \"\"\"\n    openml.flows.functions._check_flow_for_server_id(flow)\n\n    def get_flow_dict(_flow):\n        flow_map = {_flow.name: _flow.flow_id}\n        for subflow in _flow.components:\n            flow_map.update(get_flow_dict(_flow.components[subflow]))\n        return flow_map\n\n    def extract_parameters(  # noqa: PLR0915, PLR0912, C901\n        _flow,\n        _flow_dict,\n        component_model,\n        _main_call=False,  # noqa: FBT002\n        main_id=None,\n    ):\n        def is_subcomponent_specification(values):\n            # checks whether the current value can be a specification of\n            # subcomponents, as for example the value for steps parameter\n            # (in Pipeline) or transformers parameter (in\n            # ColumnTransformer).\n            return (\n                # Specification requires list/tuple of list/tuple with\n                # at least length 2.\n                isinstance(values, (tuple, list))\n                and all(isinstance(item, (tuple, list)) and len(item) &gt; 1 for item in values)\n                # And each component needs to be a flow or interpretable string\n                and all(\n                    isinstance(item[1], openml.flows.OpenMLFlow)\n                    or (\n                        isinstance(item[1], str)\n                        and item[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n                    )\n                    for item in values\n                )\n            )\n\n        # _flow is openml flow object, _param dict maps from flow name to flow\n        # id for the main call, the param dict can be overridden (useful for\n        # unit tests / sentinels) this way, for flows without subflows we do\n        # not have to rely on _flow_dict\n        exp_parameters = set(_flow.parameters)\n        if (\n            isinstance(component_model, str)\n            and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n        ):\n            model_parameters = set()\n        else:\n            model_parameters = set(component_model.get_params(deep=False))\n        if len(exp_parameters.symmetric_difference(model_parameters)) != 0:\n            flow_params = sorted(exp_parameters)\n            model_params = sorted(model_parameters)\n            raise ValueError(\n                \"Parameters of the model do not match the \"\n                \"parameters expected by the \"\n                \"flow:\\nexpected flow parameters: \"\n                f\"{flow_params}\\nmodel parameters: {model_params}\",\n            )\n        exp_components = set(_flow.components)\n        if (\n            isinstance(component_model, str)\n            and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n        ):\n            model_components = set()\n        else:\n            _ = set(component_model.get_params(deep=False))\n            model_components = {\n                mp\n                for mp in component_model.get_params(deep=True)\n                if \"__\" not in mp and mp not in _\n            }\n        if len(exp_components.symmetric_difference(model_components)) != 0:\n            is_problem = True\n            if len(exp_components - model_components) &gt; 0:\n                # If an expected component is not returned as a component by get_params(),\n                # this means that it is also a parameter -&gt; we need to check that this is\n                # actually the case\n                difference = exp_components - model_components\n                component_in_model_parameters = []\n                for component in difference:\n                    if component in model_parameters:\n                        component_in_model_parameters.append(True)\n                    else:\n                        component_in_model_parameters.append(False)\n                is_problem = not all(component_in_model_parameters)\n            if is_problem:\n                flow_components = sorted(exp_components)\n                model_components = sorted(model_components)\n                raise ValueError(\n                    \"Subcomponents of the model do not match the \"\n                    \"parameters expected by the \"\n                    \"flow:\\nexpected flow subcomponents: \"\n                    f\"{flow_components}\\nmodel subcomponents: {model_components}\",\n                )\n\n        _params = []\n        for _param_name in _flow.parameters:\n            _current = OrderedDict()\n            _current[\"oml:name\"] = _param_name\n\n            current_param_values = self.model_to_flow(component_model.get_params()[_param_name])\n\n            # Try to filter out components (a.k.a. subflows) which are\n            # handled further down in the code (by recursively calling\n            # this function)!\n            if isinstance(current_param_values, openml.flows.OpenMLFlow):\n                continue\n\n            if is_subcomponent_specification(current_param_values):\n                # complex parameter value, with subcomponents\n                parsed_values = []\n                for subcomponent in current_param_values:\n                    # scikit-learn stores usually tuples in the form\n                    # (name (str), subcomponent (mixed), argument\n                    # (mixed)). OpenML replaces the subcomponent by an\n                    # OpenMLFlow object.\n                    if len(subcomponent) &lt; 2 or len(subcomponent) &gt; 3:\n                        raise ValueError(\"Component reference should be size {2,3}. \")\n\n                    subcomponent_identifier = subcomponent[0]\n                    subcomponent_flow = subcomponent[1]\n                    if not isinstance(subcomponent_identifier, str):\n                        raise TypeError(\n                            \"Subcomponent identifier should be of type string, \"\n                            f\"but is {type(subcomponent_identifier)}\",\n                        )\n                    if not isinstance(subcomponent_flow, (openml.flows.OpenMLFlow, str)):\n                        if (\n                            isinstance(subcomponent_flow, str)\n                            and subcomponent_flow in SKLEARN_PIPELINE_STRING_COMPONENTS\n                        ):\n                            pass\n                        else:\n                            raise TypeError(\n                                \"Subcomponent flow should be of type flow, but is\"\n                                f\" {type(subcomponent_flow)}\",\n                            )\n\n                    current = {\n                        \"oml-python:serialized_object\": COMPONENT_REFERENCE,\n                        \"value\": {\n                            \"key\": subcomponent_identifier,\n                            \"step_name\": subcomponent_identifier,\n                        },\n                    }\n                    if len(subcomponent) == 3:\n                        if not isinstance(subcomponent[2], list) and not isinstance(\n                            subcomponent[2],\n                            OrderedDict,\n                        ):\n                            raise TypeError(\n                                \"Subcomponent argument should be list or OrderedDict\",\n                            )\n                        current[\"value\"][\"argument_1\"] = subcomponent[2]\n                    parsed_values.append(current)\n                parsed_values = json.dumps(parsed_values)\n            else:\n                # vanilla parameter value\n                parsed_values = json.dumps(current_param_values)\n\n            _current[\"oml:value\"] = parsed_values\n            if _main_call:\n                _current[\"oml:component\"] = main_id\n            else:\n                _current[\"oml:component\"] = _flow_dict[_flow.name]\n            _params.append(_current)\n\n        for _identifier in _flow.components:\n            subcomponent_model = component_model.get_params()[_identifier]\n            _params.extend(\n                extract_parameters(\n                    _flow.components[_identifier],\n                    _flow_dict,\n                    subcomponent_model,\n                ),\n            )\n        return _params\n\n    flow_dict = get_flow_dict(flow)\n    model = model if model is not None else flow.model\n    return extract_parameters(flow, flow_dict, model, _main_call=True, main_id=flow.flow_id)\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.seed_model","title":"<code>seed_model(model, seed=None)</code>","text":"<p>Set the random state of all the unseeded components of a model and return the seeded model.</p> <p>Required so that all seed information can be uploaded to OpenML for reproducible results.</p> <p>Models that are already seeded will maintain the seed. In this case, only integer seeds are allowed (An exception is raised when a RandomState was used as seed).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>sklearn model</code> <p>The model to be seeded</p> required <code>seed</code> <code>int</code> <p>The seed to initialize the RandomState with. Unseeded subcomponents will be seeded with a random number from the RandomState.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>def seed_model(self, model: Any, seed: int | None = None) -&gt; Any:  # noqa: C901\n    \"\"\"Set the random state of all the unseeded components of a model and return the seeded\n    model.\n\n    Required so that all seed information can be uploaded to OpenML for reproducible results.\n\n    Models that are already seeded will maintain the seed. In this case,\n    only integer seeds are allowed (An exception is raised when a RandomState was used as\n    seed).\n\n    Parameters\n    ----------\n    model : sklearn model\n        The model to be seeded\n    seed : int\n        The seed to initialize the RandomState with. Unseeded subcomponents\n        will be seeded with a random number from the RandomState.\n\n    Returns\n    -------\n    Any\n    \"\"\"\n\n    def _seed_current_object(current_value):\n        if isinstance(current_value, int):  # acceptable behaviour\n            return False\n\n        if isinstance(current_value, np.random.RandomState):\n            raise ValueError(\n                \"Models initialized with a RandomState object are not \"\n                \"supported. Please seed with an integer. \",\n            )\n\n        if current_value is not None:\n            raise ValueError(\n                \"Models should be seeded with int or None (this should never happen). \",\n            )\n\n        return True\n\n    rs = np.random.RandomState(seed)\n    model_params = model.get_params()\n    random_states = {}\n    for param_name in sorted(model_params):\n        if \"random_state\" in param_name:\n            current_value = model_params[param_name]\n            # important to draw the value at this point (and not in the if\n            # statement) this way we guarantee that if a different set of\n            # subflows is seeded, the same number of the random generator is\n            # used\n            new_value = rs.randint(0, 2**16)\n            if _seed_current_object(current_value):\n                random_states[param_name] = new_value\n\n        # Also seed CV objects!\n        elif isinstance(model_params[param_name], sklearn.model_selection.BaseCrossValidator):\n            if not hasattr(model_params[param_name], \"random_state\"):\n                continue\n\n            current_value = model_params[param_name].random_state\n            new_value = rs.randint(0, 2**16)\n            if _seed_current_object(current_value):\n                model_params[param_name].random_state = new_value\n\n    model.set_params(**random_states)\n    return model\n</code></pre>"},{"location":"reference/extensions/sklearn/extension/#openml.extensions.sklearn.extension.SklearnExtension.trim_flow_name","title":"<code>trim_flow_name(long_name, extra_trim_length=100, _outer=True)</code>  <code>classmethod</code>","text":"<p>Shorten generated sklearn flow name to at most <code>max_length</code> characters.</p> <p>Flows are assumed to have the following naming structure: <code>(model_selection)? (pipeline)? (steps)+</code> and will be shortened to: <code>sklearn.(selection.)?(pipeline.)?(steps)+</code> e.g. (white spaces and newlines added for readability)</p> <p>.. code ::</p> <pre><code>sklearn.pipeline.Pipeline(\n    columntransformer=sklearn.compose._column_transformer.ColumnTransformer(\n        numeric=sklearn.pipeline.Pipeline(\n            imputer=sklearn.preprocessing.imputation.Imputer,\n            standardscaler=sklearn.preprocessing.data.StandardScaler),\n        nominal=sklearn.pipeline.Pipeline(\n            simpleimputer=sklearn.impute.SimpleImputer,\n            onehotencoder=sklearn.preprocessing._encoders.OneHotEncoder)),\n    variancethreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,\n    svc=sklearn.svm.classes.SVC)\n</code></pre> <p>-&gt; <code>sklearn.Pipeline(ColumnTransformer,VarianceThreshold,SVC)</code></p> <p>Parameters:</p> Name Type Description Default <code>long_name</code> <code>str</code> <p>The full flow name generated by the scikit-learn extension.</p> required <code>extra_trim_length</code> <code>int</code> <p>If the trimmed name would exceed <code>extra_trim_length</code> characters, additional trimming of the short name is performed. This reduces the produced short name length. There is no guarantee the end result will not exceed <code>extra_trim_length</code>.</p> <code>100</code> <code>_outer</code> <code>bool(default=True)</code> <p>For internal use only. Specifies if the function is called recursively.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>openml/extensions/sklearn/extension.py</code> <pre><code>@classmethod\ndef trim_flow_name(  # noqa: C901\n    cls,\n    long_name: str,\n    extra_trim_length: int = 100,\n    _outer: bool = True,  # noqa: FBT001, FBT002\n) -&gt; str:\n    \"\"\"Shorten generated sklearn flow name to at most ``max_length`` characters.\n\n    Flows are assumed to have the following naming structure:\n    ``(model_selection)? (pipeline)? (steps)+``\n    and will be shortened to:\n    ``sklearn.(selection.)?(pipeline.)?(steps)+``\n    e.g. (white spaces and newlines added for readability)\n\n    .. code ::\n\n        sklearn.pipeline.Pipeline(\n            columntransformer=sklearn.compose._column_transformer.ColumnTransformer(\n                numeric=sklearn.pipeline.Pipeline(\n                    imputer=sklearn.preprocessing.imputation.Imputer,\n                    standardscaler=sklearn.preprocessing.data.StandardScaler),\n                nominal=sklearn.pipeline.Pipeline(\n                    simpleimputer=sklearn.impute.SimpleImputer,\n                    onehotencoder=sklearn.preprocessing._encoders.OneHotEncoder)),\n            variancethreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,\n            svc=sklearn.svm.classes.SVC)\n\n    -&gt;\n    ``sklearn.Pipeline(ColumnTransformer,VarianceThreshold,SVC)``\n\n    Parameters\n    ----------\n    long_name : str\n        The full flow name generated by the scikit-learn extension.\n    extra_trim_length: int (default=100)\n        If the trimmed name would exceed `extra_trim_length` characters, additional trimming\n        of the short name is performed. This reduces the produced short name length.\n        There is no guarantee the end result will not exceed `extra_trim_length`.\n    _outer : bool (default=True)\n        For internal use only. Specifies if the function is called recursively.\n\n    Returns\n    -------\n    str\n\n    \"\"\"\n\n    def remove_all_in_parentheses(string: str) -&gt; str:\n        string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n        while removals &gt; 0:\n            string, removals = re.subn(r\"\\([^()]*\\)\", \"\", string)\n        return string\n\n    # Generally, we want to trim all hyperparameters, the exception to that is for model\n    # selection, as the `estimator` hyperparameter is very indicative of what is in the flow.\n    # So we first trim name of the `estimator` specified in mode selection. For reference, in\n    # the example below, we want to trim `sklearn.tree.tree.DecisionTreeClassifier`, and\n    # keep it in the final trimmed flow name:\n    # sklearn.pipeline.Pipeline(Imputer=sklearn.preprocessing.imputation.Imputer,\n    # VarianceThreshold=sklearn.feature_selection.variance_threshold.VarianceThreshold,  # noqa: ERA001, E501\n    # Estimator=sklearn.model_selection._search.RandomizedSearchCV(estimator=\n    # sklearn.tree.tree.DecisionTreeClassifier))\n    if \"sklearn.model_selection\" in long_name:\n        start_index = long_name.index(\"sklearn.model_selection\")\n        estimator_start = (\n            start_index + long_name[start_index:].index(\"estimator=\") + len(\"estimator=\")\n        )\n\n        model_select_boilerplate = long_name[start_index:estimator_start]\n        # above is .g. \"sklearn.model_selection._search.RandomizedSearchCV(estimator=\"\n        model_selection_class = model_select_boilerplate.split(\"(\")[0].split(\".\")[-1]\n\n        # Now we want to also find and parse the `estimator`, for this we find the closing\n        # parenthesis to the model selection technique:\n        closing_parenthesis_expected = 1\n        for char in long_name[estimator_start:]:\n            if char == \"(\":\n                closing_parenthesis_expected += 1\n            if char == \")\":\n                closing_parenthesis_expected -= 1\n            if closing_parenthesis_expected == 0:\n                break\n\n        _end: int = estimator_start + len(long_name[estimator_start:]) - 1\n        model_select_pipeline = long_name[estimator_start:_end]\n\n        trimmed_pipeline = cls.trim_flow_name(model_select_pipeline, _outer=False)\n        _, trimmed_pipeline = trimmed_pipeline.split(\".\", maxsplit=1)  # trim module prefix\n        model_select_short = f\"sklearn.{model_selection_class}[{trimmed_pipeline}]\"\n        name = long_name[:start_index] + model_select_short + long_name[_end + 1 :]\n    else:\n        name = long_name\n\n    module_name = long_name.split(\".\")[0]\n    short_name = module_name + \".{}\"\n\n    if name.startswith(\"sklearn.pipeline\"):\n        full_pipeline_class, pipeline = name[:-1].split(\"(\", maxsplit=1)\n        pipeline_class = full_pipeline_class.split(\".\")[-1]\n        # We don't want nested pipelines in the short name, so we trim all complicated\n        # subcomponents, i.e. those with parentheses:\n        pipeline = remove_all_in_parentheses(pipeline)\n\n        # then the pipeline steps are formatted e.g.:\n        # step1name=sklearn.submodule.ClassName,step2name...\n        components = [component.split(\".\")[-1] for component in pipeline.split(\",\")]\n        pipeline = f\"{pipeline_class}({','.join(components)})\"\n        if len(short_name.format(pipeline)) &gt; extra_trim_length:\n            pipeline = f\"{pipeline_class}(...,{components[-1]})\"\n    else:\n        # Just a simple component: e.g. sklearn.tree.DecisionTreeClassifier\n        pipeline = remove_all_in_parentheses(name).split(\".\")[-1]\n\n    if not _outer:\n        # Anything from parenthesis in inner calls should not be culled, so we use brackets\n        pipeline = pipeline.replace(\"(\", \"[\").replace(\")\", \"]\")\n    else:\n        # Square brackets may be introduced with nested model_selection\n        pipeline = pipeline.replace(\"[\", \"(\").replace(\"]\", \")\")\n\n    return short_name.format(pipeline)\n</code></pre>"},{"location":"reference/flows/","title":"flows","text":""},{"location":"reference/flows/#openml.flows.OpenMLFlow","title":"<code>OpenMLFlow</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Flow. Stores machine learning models.</p> <p>Flows should not be generated manually, but by the function :meth:<code>openml.flows.create_flow_from_model</code>. Using this helper function ensures that all relevant fields are filled in.</p> <p>Implements <code>openml.implementation.upload.xsd &lt;https://github.com/openml/openml/blob/master/openml_OS/views/pages/api_new/v1/xsd/ openml.implementation.upload.xsd&gt;</code>_.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the flow. Is used together with the attribute <code>external_version</code> as a unique identifier of the flow.</p> required <code>description</code> <code>str</code> <p>Human-readable description of the flow (free text).</p> required <code>model</code> <code>object</code> <p>ML model which is described by this flow.</p> required <code>components</code> <code>OrderedDict</code> <p>Mapping from component identifier to an OpenMLFlow object. Components are usually subfunctions of an algorithm (e.g. kernels), base learners in ensemble algorithms (decision tree in adaboost) or building blocks of a machine learning pipeline. Components are modeled as independent flows and can be shared between flows (different pipelines can use the same components).</p> required <code>parameters</code> <code>OrderedDict</code> <p>Mapping from parameter name to the parameter default value. The parameter default value must be of type <code>str</code>, so that the respective toolbox plugin can take care of casting the parameter default value to the correct type.</p> required <code>parameters_meta_info</code> <code>OrderedDict</code> <p>Mapping from parameter name to <code>dict</code>. Stores additional information for each parameter. Required keys are <code>data_type</code> and <code>description</code>.</p> required <code>external_version</code> <code>str</code> <p>Version number of the software the flow is implemented in. Is used together with the attribute <code>name</code> as a uniquer identifier of the flow.</p> required <code>tags</code> <code>list</code> <p>List of tags. Created on the server by other API calls.</p> required <code>language</code> <code>str</code> <p>Natural language the flow is described in (not the programming language).</p> required <code>dependencies</code> <code>str</code> <p>A list of dependencies necessary to run the flow. This field should contain all libraries the flow depends on. To allow reproducibility it should also specify the exact version numbers.</p> required <code>class_name</code> <code>str</code> <p>The development language name of the class which is described by this flow.</p> <code>None</code> <code>custom_name</code> <code>str</code> <p>Custom name of the flow given by the owner.</p> <code>None</code> <code>binary_url</code> <code>str</code> <p>Url from which the binary can be downloaded. Added by the server. Ignored when uploaded manually. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>binary_format</code> <code>str</code> <p>Format in which the binary code was uploaded. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>binary_md5</code> <code>str</code> <p>MD5 checksum to check if the binary code was correctly downloaded. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>uploader</code> <code>str</code> <p>OpenML user ID of the uploader. Filled in by the server.</p> <code>None</code> <code>upload_date</code> <code>str</code> <p>Date the flow was uploaded. Filled in by the server.</p> <code>None</code> <code>flow_id</code> <code>int</code> <p>Flow ID. Assigned by the server.</p> <code>None</code> <code>extension</code> <code>Extension</code> <p>The extension for a flow (e.g., sklearn).</p> <code>None</code> <code>version</code> <code>str</code> <p>OpenML version of the flow. Assigned by the server.</p> <code>None</code> Source code in <code>openml/flows/flow.py</code> <pre><code>class OpenMLFlow(OpenMLBase):\n    \"\"\"OpenML Flow. Stores machine learning models.\n\n    Flows should not be generated manually, but by the function\n    :meth:`openml.flows.create_flow_from_model`. Using this helper function\n    ensures that all relevant fields are filled in.\n\n    Implements `openml.implementation.upload.xsd\n    &lt;https://github.com/openml/openml/blob/master/openml_OS/views/pages/api_new/v1/xsd/\n    openml.implementation.upload.xsd&gt;`_.\n\n    Parameters\n    ----------\n    name : str\n        Name of the flow. Is used together with the attribute\n        `external_version` as a unique identifier of the flow.\n    description : str\n        Human-readable description of the flow (free text).\n    model : object\n        ML model which is described by this flow.\n    components : OrderedDict\n        Mapping from component identifier to an OpenMLFlow object. Components\n        are usually subfunctions of an algorithm (e.g. kernels), base learners\n        in ensemble algorithms (decision tree in adaboost) or building blocks\n        of a machine learning pipeline. Components are modeled as independent\n        flows and can be shared between flows (different pipelines can use\n        the same components).\n    parameters : OrderedDict\n        Mapping from parameter name to the parameter default value. The\n        parameter default value must be of type `str`, so that the respective\n        toolbox plugin can take care of casting the parameter default value to\n        the correct type.\n    parameters_meta_info : OrderedDict\n        Mapping from parameter name to `dict`. Stores additional information\n        for each parameter. Required keys are `data_type` and `description`.\n    external_version : str\n        Version number of the software the flow is implemented in. Is used\n        together with the attribute `name` as a uniquer identifier of the flow.\n    tags : list\n        List of tags. Created on the server by other API calls.\n    language : str\n        Natural language the flow is described in (not the programming\n        language).\n    dependencies : str\n        A list of dependencies necessary to run the flow. This field should\n        contain all libraries the flow depends on. To allow reproducibility\n        it should also specify the exact version numbers.\n    class_name : str, optional\n        The development language name of the class which is described by this\n        flow.\n    custom_name : str, optional\n        Custom name of the flow given by the owner.\n    binary_url : str, optional\n        Url from which the binary can be downloaded. Added by the server.\n        Ignored when uploaded manually. Will not be used by the python API\n        because binaries aren't compatible across machines.\n    binary_format : str, optional\n        Format in which the binary code was uploaded. Will not be used by the\n        python API because binaries aren't compatible across machines.\n    binary_md5 : str, optional\n        MD5 checksum to check if the binary code was correctly downloaded. Will\n        not be used by the python API because binaries aren't compatible across\n        machines.\n    uploader : str, optional\n        OpenML user ID of the uploader. Filled in by the server.\n    upload_date : str, optional\n        Date the flow was uploaded. Filled in by the server.\n    flow_id : int, optional\n        Flow ID. Assigned by the server.\n    extension : Extension, optional\n        The extension for a flow (e.g., sklearn).\n    version : str, optional\n        OpenML version of the flow. Assigned by the server.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        name: str,\n        description: str,\n        model: object,\n        components: dict,\n        parameters: dict,\n        parameters_meta_info: dict,\n        external_version: str,\n        tags: list,\n        language: str,\n        dependencies: str,\n        class_name: str | None = None,\n        custom_name: str | None = None,\n        binary_url: str | None = None,\n        binary_format: str | None = None,\n        binary_md5: str | None = None,\n        uploader: str | None = None,\n        upload_date: str | None = None,\n        flow_id: int | None = None,\n        extension: Extension | None = None,\n        version: str | None = None,\n    ):\n        self.name = name\n        self.description = description\n        self.model = model\n\n        for variable, variable_name in [\n            [components, \"components\"],\n            [parameters, \"parameters\"],\n            [parameters_meta_info, \"parameters_meta_info\"],\n        ]:\n            if not isinstance(variable, (OrderedDict, dict)):\n                raise TypeError(\n                    f\"{variable_name} must be of type OrderedDict or dict, \"\n                    f\"but is {type(variable)}.\",\n                )\n\n        self.components = components\n        self.parameters = parameters\n        self.parameters_meta_info = parameters_meta_info\n        self.class_name = class_name\n\n        keys_parameters = set(parameters.keys())\n        keys_parameters_meta_info = set(parameters_meta_info.keys())\n        if len(keys_parameters.difference(keys_parameters_meta_info)) &gt; 0:\n            raise ValueError(\n                f\"Parameter {keys_parameters.difference(keys_parameters_meta_info)!s} only in \"\n                \"parameters, but not in parameters_meta_info.\",\n            )\n        if len(keys_parameters_meta_info.difference(keys_parameters)) &gt; 0:\n            raise ValueError(\n                f\"Parameter {keys_parameters_meta_info.difference(keys_parameters)!s} only in \"\n                \" parameters_meta_info, but not in parameters.\",\n            )\n\n        self.external_version = external_version\n        self.uploader = uploader\n\n        self.custom_name = custom_name\n        self.tags = tags if tags is not None else []\n        self.binary_url = binary_url\n        self.binary_format = binary_format\n        self.binary_md5 = binary_md5\n        self.version = version\n        self.upload_date = upload_date\n        self.language = language\n        self.dependencies = dependencies\n        self.flow_id = flow_id\n        if extension is None:\n            self._extension = get_extension_by_flow(self)\n        else:\n            self._extension = extension\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"The ID of the flow.\"\"\"\n        return self.flow_id\n\n    @property\n    def extension(self) -&gt; Extension:\n        \"\"\"The extension of the flow (e.g., sklearn).\"\"\"\n        if self._extension is not None:\n            return self._extension\n\n        raise RuntimeError(\n            f\"No extension could be found for flow {self.flow_id}: {self.name}\",\n        )\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        fields = {\n            \"Flow Name\": self.name,\n            \"Flow Description\": self.description,\n            \"Dependencies\": self.dependencies,\n        }\n        if self.flow_id is not None:\n            fields[\"Flow URL\"] = self.openml_url if self.openml_url is not None else \"None\"\n            fields[\"Flow ID\"] = str(self.flow_id)\n            if self.version is not None:\n                fields[\"Flow ID\"] += f\" (version {self.version})\"\n        if self.upload_date is not None:\n            fields[\"Upload Date\"] = self.upload_date.replace(\"T\", \" \")\n        if self.binary_url is not None:\n            fields[\"Binary URL\"] = self.binary_url\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Flow ID\",\n            \"Flow URL\",\n            \"Flow Name\",\n            \"Flow Description\",\n            \"Binary URL\",\n            \"Upload Date\",\n            \"Dependencies\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def _to_dict(self) -&gt; dict[str, dict]:  # noqa: C901, PLR0912\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        flow_container = OrderedDict()  # type: 'dict[str, dict]'\n        flow_dict = OrderedDict(\n            [(\"@xmlns:oml\", \"http://openml.org/openml\")],\n        )  # type: 'dict[str, list | str]'  # E501\n        flow_container[\"oml:flow\"] = flow_dict\n        _add_if_nonempty(flow_dict, \"oml:id\", self.flow_id)\n\n        for required in [\"name\", \"external_version\"]:\n            if getattr(self, required) is None:\n                raise ValueError(f\"self.{required} is required but None\")\n        for attribute in [\n            \"uploader\",\n            \"name\",\n            \"custom_name\",\n            \"class_name\",\n            \"version\",\n            \"external_version\",\n            \"description\",\n            \"upload_date\",\n            \"language\",\n            \"dependencies\",\n        ]:\n            _add_if_nonempty(flow_dict, f\"oml:{attribute}\", getattr(self, attribute))\n\n        if not self.description:\n            logger = logging.getLogger(__name__)\n            logger.warning(\"Flow % has empty description\", self.name)\n\n        flow_parameters = []\n        for key in self.parameters:\n            param_dict = OrderedDict()  # type: 'OrderedDict[str, str]'\n            param_dict[\"oml:name\"] = key\n            meta_info = self.parameters_meta_info[key]\n\n            _add_if_nonempty(param_dict, \"oml:data_type\", meta_info[\"data_type\"])\n            param_dict[\"oml:default_value\"] = self.parameters[key]\n            _add_if_nonempty(param_dict, \"oml:description\", meta_info[\"description\"])\n\n            for key_, value in param_dict.items():\n                if key_ is not None and not isinstance(key_, str):\n                    raise ValueError(\n                        f\"Parameter name {key_} cannot be serialized \"\n                        f\"because it is of type {type(key_)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n                if value is not None and not isinstance(value, str):\n                    raise ValueError(\n                        f\"Parameter value {value} cannot be serialized \"\n                        f\"because it is of type {type(value)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n\n            flow_parameters.append(param_dict)\n\n        flow_dict[\"oml:parameter\"] = flow_parameters\n\n        components = []\n        for key in self.components:\n            component_dict = OrderedDict()  # type: 'OrderedDict[str, dict]'\n            component_dict[\"oml:identifier\"] = key\n            if self.components[key] in [\"passthrough\", \"drop\"]:\n                component_dict[\"oml:flow\"] = {\n                    \"oml-python:serialized_object\": \"component_reference\",\n                    \"value\": {\"key\": self.components[key], \"step_name\": self.components[key]},\n                }\n            else:\n                component_dict[\"oml:flow\"] = self.components[key]._to_dict()[\"oml:flow\"]\n\n            for key_ in component_dict:\n                # We only need to check if the key is a string, because the\n                # value is a flow. The flow itself is valid by recursion\n                if key_ is not None and not isinstance(key_, str):\n                    raise ValueError(\n                        f\"Parameter name {key_} cannot be serialized \"\n                        f\"because it is of type {type(key_)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n\n            components.append(component_dict)\n\n        flow_dict[\"oml:component\"] = components\n        flow_dict[\"oml:tag\"] = self.tags\n        for attribute in [\"binary_url\", \"binary_format\", \"binary_md5\"]:\n            _add_if_nonempty(flow_dict, f\"oml:{attribute}\", getattr(self, attribute))\n\n        return flow_container\n\n    @classmethod\n    def _from_dict(cls, xml_dict: dict) -&gt; OpenMLFlow:\n        \"\"\"Create a flow from an xml description.\n\n        Calls itself recursively to create :class:`OpenMLFlow` objects of\n        subflows (components).\n\n        XML definition of a flow is available at\n        https://github.com/openml/OpenML/blob/master/openml_OS/views/pages/api_new/v1/xsd/openml.implementation.upload.xsd\n\n        Parameters\n        ----------\n        xml_dict : dict\n            Dictionary representation of the flow as created by _to_dict()\n\n        Returns\n        -------\n            OpenMLFlow\n\n        \"\"\"  # E501\n        arguments = OrderedDict()\n        dic = xml_dict[\"oml:flow\"]\n\n        # Mandatory parts in the xml file\n        for key in [\"name\"]:\n            arguments[key] = dic[\"oml:\" + key]\n\n        # non-mandatory parts in the xml file\n        for key in [\n            \"external_version\",\n            \"uploader\",\n            \"description\",\n            \"upload_date\",\n            \"language\",\n            \"dependencies\",\n            \"version\",\n            \"binary_url\",\n            \"binary_format\",\n            \"binary_md5\",\n            \"class_name\",\n            \"custom_name\",\n        ]:\n            arguments[key] = dic.get(\"oml:\" + key)\n\n        # has to be converted to an int if present and cannot parsed in the\n        # two loops above\n        arguments[\"flow_id\"] = int(dic[\"oml:id\"]) if dic.get(\"oml:id\") is not None else None\n\n        # Now parse parts of a flow which can occur multiple times like\n        # parameters, components (subflows) and tags. These can't be tackled\n        # in the loops above because xmltodict returns a dict if such an\n        # entity occurs once, and a list if it occurs multiple times.\n        # Furthermore, they must be treated differently, for example\n        # for components this method is called recursively and\n        # for parameters the actual information is split into two dictionaries\n        # for easier access in python.\n\n        parameters = OrderedDict()\n        parameters_meta_info = OrderedDict()\n        if \"oml:parameter\" in dic:\n            # In case of a single parameter, xmltodict returns a dictionary,\n            # otherwise a list.\n            oml_parameters = extract_xml_tags(\"oml:parameter\", dic, allow_none=False)\n\n            for oml_parameter in oml_parameters:\n                parameter_name = oml_parameter[\"oml:name\"]\n                default_value = oml_parameter[\"oml:default_value\"]\n                parameters[parameter_name] = default_value\n\n                meta_info = OrderedDict()\n                meta_info[\"description\"] = oml_parameter.get(\"oml:description\")\n                meta_info[\"data_type\"] = oml_parameter.get(\"oml:data_type\")\n                parameters_meta_info[parameter_name] = meta_info\n        arguments[\"parameters\"] = parameters\n        arguments[\"parameters_meta_info\"] = parameters_meta_info\n\n        components = OrderedDict()\n        if \"oml:component\" in dic:\n            # In case of a single component xmltodict returns a dict,\n            # otherwise a list.\n            oml_components = extract_xml_tags(\"oml:component\", dic, allow_none=False)\n\n            for component in oml_components:\n                flow = OpenMLFlow._from_dict(component)\n                components[component[\"oml:identifier\"]] = flow\n        arguments[\"components\"] = components\n        arguments[\"tags\"] = extract_xml_tags(\"oml:tag\", dic)\n\n        arguments[\"model\"] = None\n        return cls(**arguments)\n\n    def to_filesystem(self, output_directory: str | Path) -&gt; None:\n        \"\"\"Write a flow to the filesystem as XML to output_directory.\"\"\"\n        output_directory = Path(output_directory)\n        output_directory.mkdir(parents=True, exist_ok=True)\n\n        output_path = output_directory / \"flow.xml\"\n        if output_path.exists():\n            raise ValueError(\"Output directory already contains a flow.xml file.\")\n\n        run_xml = self._to_xml()\n        with output_path.open(\"w\") as f:\n            f.write(run_xml)\n\n    @classmethod\n    def from_filesystem(cls, input_directory: str | Path) -&gt; OpenMLFlow:\n        \"\"\"Read a flow from an XML in input_directory on the filesystem.\"\"\"\n        input_directory = Path(input_directory) / \"flow.xml\"\n        with input_directory.open() as f:\n            xml_string = f.read()\n        return OpenMLFlow._from_dict(xmltodict.parse(xml_string))\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.flow_id = int(xml_response[\"oml:upload_flow\"][\"oml:id\"])\n\n    def publish(self, raise_error_if_exists: bool = False) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n        \"\"\"Publish this flow to OpenML server.\n\n        Raises a PyOpenMLError if the flow exists on the server, but\n        `self.flow_id` does not match the server known flow id.\n\n        Parameters\n        ----------\n        raise_error_if_exists : bool, optional (default=False)\n            If True, raise PyOpenMLError if the flow exists on the server.\n            If False, update the local flow to match the server flow.\n\n        Returns\n        -------\n        self : OpenMLFlow\n\n        \"\"\"\n        # Import at top not possible because of cyclic dependencies. In\n        # particular, flow.py tries to import functions.py in order to call\n        # get_flow(), while functions.py tries to import flow.py in order to\n        # instantiate an OpenMLFlow.\n        import openml.flows.functions\n\n        flow_id = openml.flows.functions.flow_exists(self.name, self.external_version)\n        if not flow_id:\n            if self.flow_id:\n                raise openml.exceptions.PyOpenMLError(\n                    \"Flow does not exist on the server, \" \"but 'flow.flow_id' is not None.\",\n                )\n            super().publish()\n            assert self.flow_id is not None  # for mypy\n            flow_id = self.flow_id\n        elif raise_error_if_exists:\n            error_message = f\"This OpenMLFlow already exists with id: {flow_id}.\"\n            raise openml.exceptions.PyOpenMLError(error_message)\n        elif self.flow_id is not None and self.flow_id != flow_id:\n            raise openml.exceptions.PyOpenMLError(\n                \"Local flow_id does not match server flow_id: \" f\"'{self.flow_id}' vs '{flow_id}'\",\n            )\n\n        flow = openml.flows.functions.get_flow(flow_id)\n        _copy_server_fields(flow, self)\n        try:\n            openml.flows.functions.assert_flows_equal(\n                self,\n                flow,\n                flow.upload_date,\n                ignore_parameter_values=True,\n                ignore_custom_name_if_none=True,\n            )\n        except ValueError as e:\n            message = e.args[0]\n            raise ValueError(\n                \"The flow on the server is inconsistent with the local flow. \"\n                f\"The server flow ID is {flow_id}. Please check manually and remove \"\n                f\"the flow if necessary! Error is:\\n'{message}'\",\n            ) from e\n        return self\n\n    def get_structure(self, key_item: str) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Returns for each sub-component of the flow the path of identifiers\n        that should be traversed to reach this component. The resulting dict\n        maps a key (identifying a flow by either its id, name or fullname) to\n        the parameter prefix.\n\n        Parameters\n        ----------\n        key_item: str\n            The flow attribute that will be used to identify flows in the\n            structure. Allowed values {flow_id, name}\n\n        Returns\n        -------\n        dict[str, List[str]]\n            The flow structure\n        \"\"\"\n        if key_item not in [\"flow_id\", \"name\"]:\n            raise ValueError(\"key_item should be in {flow_id, name}\")\n        structure = {}\n        for key, sub_flow in self.components.items():\n            sub_structure = sub_flow.get_structure(key_item)\n            for flow_name, flow_sub_structure in sub_structure.items():\n                structure[flow_name] = [key, *flow_sub_structure]\n        structure[getattr(self, key_item)] = []\n        return structure\n\n    def get_subflow(self, structure: list[str]) -&gt; OpenMLFlow:\n        \"\"\"\n        Returns a subflow from the tree of dependencies.\n\n        Parameters\n        ----------\n        structure: list[str]\n            A list of strings, indicating the location of the subflow\n\n        Returns\n        -------\n        OpenMLFlow\n            The OpenMLFlow that corresponds to the structure\n        \"\"\"\n        # make a copy of structure, as we don't want to change it in the\n        # outer scope\n        structure = list(structure)\n        if len(structure) &lt; 1:\n            raise ValueError(\"Please provide a structure list of size &gt;= 1\")\n        sub_identifier = structure[0]\n        if sub_identifier not in self.components:\n            raise ValueError(\n                f\"Flow {self.name} does not contain component with \" f\"identifier {sub_identifier}\",\n            )\n        if len(structure) == 1:\n            return self.components[sub_identifier]  # type: ignore\n\n        structure.pop(0)\n        return self.components[sub_identifier].get_subflow(structure)  # type: ignore\n</code></pre>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.extension","title":"<code>extension: Extension</code>  <code>property</code>","text":"<p>The extension of the flow (e.g., sklearn).</p>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>The ID of the flow.</p>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.from_filesystem","title":"<code>from_filesystem(input_directory)</code>  <code>classmethod</code>","text":"<p>Read a flow from an XML in input_directory on the filesystem.</p> Source code in <code>openml/flows/flow.py</code> <pre><code>@classmethod\ndef from_filesystem(cls, input_directory: str | Path) -&gt; OpenMLFlow:\n    \"\"\"Read a flow from an XML in input_directory on the filesystem.\"\"\"\n    input_directory = Path(input_directory) / \"flow.xml\"\n    with input_directory.open() as f:\n        xml_string = f.read()\n    return OpenMLFlow._from_dict(xmltodict.parse(xml_string))\n</code></pre>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.get_structure","title":"<code>get_structure(key_item)</code>","text":"<p>Returns for each sub-component of the flow the path of identifiers that should be traversed to reach this component. The resulting dict maps a key (identifying a flow by either its id, name or fullname) to the parameter prefix.</p> <p>Parameters:</p> Name Type Description Default <code>key_item</code> <code>str</code> <p>The flow attribute that will be used to identify flows in the structure. Allowed values {flow_id, name}</p> required <p>Returns:</p> Type Description <code>dict[str, List[str]]</code> <p>The flow structure</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def get_structure(self, key_item: str) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Returns for each sub-component of the flow the path of identifiers\n    that should be traversed to reach this component. The resulting dict\n    maps a key (identifying a flow by either its id, name or fullname) to\n    the parameter prefix.\n\n    Parameters\n    ----------\n    key_item: str\n        The flow attribute that will be used to identify flows in the\n        structure. Allowed values {flow_id, name}\n\n    Returns\n    -------\n    dict[str, List[str]]\n        The flow structure\n    \"\"\"\n    if key_item not in [\"flow_id\", \"name\"]:\n        raise ValueError(\"key_item should be in {flow_id, name}\")\n    structure = {}\n    for key, sub_flow in self.components.items():\n        sub_structure = sub_flow.get_structure(key_item)\n        for flow_name, flow_sub_structure in sub_structure.items():\n            structure[flow_name] = [key, *flow_sub_structure]\n    structure[getattr(self, key_item)] = []\n    return structure\n</code></pre>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.get_subflow","title":"<code>get_subflow(structure)</code>","text":"<p>Returns a subflow from the tree of dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>list[str]</code> <p>A list of strings, indicating the location of the subflow</p> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> <p>The OpenMLFlow that corresponds to the structure</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def get_subflow(self, structure: list[str]) -&gt; OpenMLFlow:\n    \"\"\"\n    Returns a subflow from the tree of dependencies.\n\n    Parameters\n    ----------\n    structure: list[str]\n        A list of strings, indicating the location of the subflow\n\n    Returns\n    -------\n    OpenMLFlow\n        The OpenMLFlow that corresponds to the structure\n    \"\"\"\n    # make a copy of structure, as we don't want to change it in the\n    # outer scope\n    structure = list(structure)\n    if len(structure) &lt; 1:\n        raise ValueError(\"Please provide a structure list of size &gt;= 1\")\n    sub_identifier = structure[0]\n    if sub_identifier not in self.components:\n        raise ValueError(\n            f\"Flow {self.name} does not contain component with \" f\"identifier {sub_identifier}\",\n        )\n    if len(structure) == 1:\n        return self.components[sub_identifier]  # type: ignore\n\n    structure.pop(0)\n    return self.components[sub_identifier].get_subflow(structure)  # type: ignore\n</code></pre>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.publish","title":"<code>publish(raise_error_if_exists=False)</code>","text":"<p>Publish this flow to OpenML server.</p> <p>Raises a PyOpenMLError if the flow exists on the server, but <code>self.flow_id</code> does not match the server known flow id.</p> <p>Parameters:</p> Name Type Description Default <code>raise_error_if_exists</code> <code>(bool, optional(default=False))</code> <p>If True, raise PyOpenMLError if the flow exists on the server. If False, update the local flow to match the server flow.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>self</code> <code>OpenMLFlow</code> Source code in <code>openml/flows/flow.py</code> <pre><code>def publish(self, raise_error_if_exists: bool = False) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n    \"\"\"Publish this flow to OpenML server.\n\n    Raises a PyOpenMLError if the flow exists on the server, but\n    `self.flow_id` does not match the server known flow id.\n\n    Parameters\n    ----------\n    raise_error_if_exists : bool, optional (default=False)\n        If True, raise PyOpenMLError if the flow exists on the server.\n        If False, update the local flow to match the server flow.\n\n    Returns\n    -------\n    self : OpenMLFlow\n\n    \"\"\"\n    # Import at top not possible because of cyclic dependencies. In\n    # particular, flow.py tries to import functions.py in order to call\n    # get_flow(), while functions.py tries to import flow.py in order to\n    # instantiate an OpenMLFlow.\n    import openml.flows.functions\n\n    flow_id = openml.flows.functions.flow_exists(self.name, self.external_version)\n    if not flow_id:\n        if self.flow_id:\n            raise openml.exceptions.PyOpenMLError(\n                \"Flow does not exist on the server, \" \"but 'flow.flow_id' is not None.\",\n            )\n        super().publish()\n        assert self.flow_id is not None  # for mypy\n        flow_id = self.flow_id\n    elif raise_error_if_exists:\n        error_message = f\"This OpenMLFlow already exists with id: {flow_id}.\"\n        raise openml.exceptions.PyOpenMLError(error_message)\n    elif self.flow_id is not None and self.flow_id != flow_id:\n        raise openml.exceptions.PyOpenMLError(\n            \"Local flow_id does not match server flow_id: \" f\"'{self.flow_id}' vs '{flow_id}'\",\n        )\n\n    flow = openml.flows.functions.get_flow(flow_id)\n    _copy_server_fields(flow, self)\n    try:\n        openml.flows.functions.assert_flows_equal(\n            self,\n            flow,\n            flow.upload_date,\n            ignore_parameter_values=True,\n            ignore_custom_name_if_none=True,\n        )\n    except ValueError as e:\n        message = e.args[0]\n        raise ValueError(\n            \"The flow on the server is inconsistent with the local flow. \"\n            f\"The server flow ID is {flow_id}. Please check manually and remove \"\n            f\"the flow if necessary! Error is:\\n'{message}'\",\n        ) from e\n    return self\n</code></pre>"},{"location":"reference/flows/#openml.flows.OpenMLFlow.to_filesystem","title":"<code>to_filesystem(output_directory)</code>","text":"<p>Write a flow to the filesystem as XML to output_directory.</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def to_filesystem(self, output_directory: str | Path) -&gt; None:\n    \"\"\"Write a flow to the filesystem as XML to output_directory.\"\"\"\n    output_directory = Path(output_directory)\n    output_directory.mkdir(parents=True, exist_ok=True)\n\n    output_path = output_directory / \"flow.xml\"\n    if output_path.exists():\n        raise ValueError(\"Output directory already contains a flow.xml file.\")\n\n    run_xml = self._to_xml()\n    with output_path.open(\"w\") as f:\n        f.write(run_xml)\n</code></pre>"},{"location":"reference/flows/#openml.flows.assert_flows_equal","title":"<code>assert_flows_equal(flow1, flow2, ignore_parameter_values_on_older_children=None, ignore_parameter_values=False, ignore_custom_name_if_none=False, check_description=True)</code>","text":"<p>Check equality of two flows.</p> <p>Two flows are equal if their all keys which are not set by the server are equal, as well as all their parameters and components.</p> <p>Parameters:</p> Name Type Description Default <code>flow1</code> <code>OpenMLFlow</code> required <code>flow2</code> <code>OpenMLFlow</code> required <code>ignore_parameter_values_on_older_children</code> <code>str(optional)</code> <p>If set to <code>OpenMLFlow.upload_date</code>, ignores parameters in a child flow if it's upload date predates the upload date of the parent flow.</p> <code>None</code> <code>ignore_parameter_values</code> <code>bool</code> <p>Whether to ignore parameter values when comparing flows.</p> <code>False</code> <code>ignore_custom_name_if_none</code> <code>bool</code> <p>Whether to ignore the custom name field if either flow has <code>custom_name</code> equal to <code>None</code>.</p> <code>False</code> <code>check_description</code> <code>bool</code> <p>Whether to ignore matching of flow descriptions.</p> <code>True</code> Source code in <code>openml/flows/functions.py</code> <pre><code>def assert_flows_equal(  # noqa: C901, PLR0912, PLR0913, PLR0915\n    flow1: OpenMLFlow,\n    flow2: OpenMLFlow,\n    ignore_parameter_values_on_older_children: str | None = None,\n    ignore_parameter_values: bool = False,  # noqa: FBT001, FBT002\n    ignore_custom_name_if_none: bool = False,  # noqa:  FBT001, FBT002\n    check_description: bool = True,  # noqa:  FBT001, FBT002\n) -&gt; None:\n    \"\"\"Check equality of two flows.\n\n    Two flows are equal if their all keys which are not set by the server\n    are equal, as well as all their parameters and components.\n\n    Parameters\n    ----------\n    flow1 : OpenMLFlow\n\n    flow2 : OpenMLFlow\n\n    ignore_parameter_values_on_older_children : str (optional)\n        If set to ``OpenMLFlow.upload_date``, ignores parameters in a child\n        flow if it's upload date predates the upload date of the parent flow.\n\n    ignore_parameter_values : bool\n        Whether to ignore parameter values when comparing flows.\n\n    ignore_custom_name_if_none : bool\n        Whether to ignore the custom name field if either flow has `custom_name` equal to `None`.\n\n    check_description : bool\n        Whether to ignore matching of flow descriptions.\n    \"\"\"\n    if not isinstance(flow1, OpenMLFlow):\n        raise TypeError(f\"Argument 1 must be of type OpenMLFlow, but is {type(flow1)}\")\n\n    if not isinstance(flow2, OpenMLFlow):\n        raise TypeError(f\"Argument 2 must be of type OpenMLFlow, but is {type(flow2)}\")\n\n    # TODO as they are actually now saved during publish, it might be good to\n    # check for the equality of these as well.\n    generated_by_the_server = [\n        \"flow_id\",\n        \"uploader\",\n        \"version\",\n        \"upload_date\",\n        # Tags aren't directly created by the server,\n        # but the uploader has no control over them!\n        \"tags\",\n    ]\n    ignored_by_python_api = [\"binary_url\", \"binary_format\", \"binary_md5\", \"model\", \"_entity_id\"]\n\n    for key in set(flow1.__dict__.keys()).union(flow2.__dict__.keys()):\n        if key in generated_by_the_server + ignored_by_python_api:\n            continue\n        attr1 = getattr(flow1, key, None)\n        attr2 = getattr(flow2, key, None)\n        if key == \"components\":\n            if not (isinstance(attr1, Dict) and isinstance(attr2, Dict)):\n                raise TypeError(\"Cannot compare components because they are not dictionary.\")\n\n            for name in set(attr1.keys()).union(attr2.keys()):\n                if name not in attr1:\n                    raise ValueError(\n                        f\"Component {name} only available in argument2, but not in argument1.\",\n                    )\n                if name not in attr2:\n                    raise ValueError(\n                        f\"Component {name} only available in argument2, but not in argument1.\",\n                    )\n                assert_flows_equal(\n                    attr1[name],\n                    attr2[name],\n                    ignore_parameter_values_on_older_children,\n                    ignore_parameter_values,\n                    ignore_custom_name_if_none,\n                )\n        elif key == \"_extension\":\n            continue\n        elif check_description and key == \"description\":\n            # to ignore matching of descriptions since sklearn based flows may have\n            # altering docstrings and is not guaranteed to be consistent\n            continue\n        else:\n            if key == \"parameters\":\n                if ignore_parameter_values or ignore_parameter_values_on_older_children:\n                    params_flow_1 = set(flow1.parameters.keys())\n                    params_flow_2 = set(flow2.parameters.keys())\n                    symmetric_difference = params_flow_1 ^ params_flow_2\n                    if len(symmetric_difference) &gt; 0:\n                        raise ValueError(\n                            f\"Flow {flow1.name}: parameter set of flow \"\n                            \"differs from the parameters stored \"\n                            \"on the server.\",\n                        )\n\n                if ignore_parameter_values_on_older_children:\n                    assert (\n                        flow1.upload_date is not None\n                    ), \"Flow1 has no upload date that allows us to compare age of children.\"\n                    upload_date_current_flow = dateutil.parser.parse(flow1.upload_date)\n                    upload_date_parent_flow = dateutil.parser.parse(\n                        ignore_parameter_values_on_older_children,\n                    )\n                    if upload_date_current_flow &lt; upload_date_parent_flow:\n                        continue\n\n                if ignore_parameter_values:\n                    # Continue needs to be done here as the first if\n                    # statement triggers in both special cases\n                    continue\n            elif (\n                key == \"custom_name\"\n                and ignore_custom_name_if_none\n                and (attr1 is None or attr2 is None)\n            ):\n                # If specified, we allow `custom_name` inequality if one flow's name is None.\n                # Helps with backwards compatibility as `custom_name` is now auto-generated, but\n                # before it used to be `None`.\n                continue\n            elif key == \"parameters_meta_info\":\n                # this value is a dictionary where each key is a parameter name, containing another\n                # dictionary with keys specifying the parameter's 'description' and 'data_type'\n                # checking parameter descriptions can be ignored since that might change\n                # data type check can also be ignored if one of them is not defined, i.e., None\n                params1 = set(flow1.parameters_meta_info)\n                params2 = set(flow2.parameters_meta_info)\n                if params1 != params2:\n                    raise ValueError(\n                        \"Parameter list in meta info for parameters differ in the two flows.\",\n                    )\n                # iterating over the parameter's meta info list\n                for param in params1:\n                    if (\n                        isinstance(flow1.parameters_meta_info[param], Dict)\n                        and isinstance(flow2.parameters_meta_info[param], Dict)\n                        and \"data_type\" in flow1.parameters_meta_info[param]\n                        and \"data_type\" in flow2.parameters_meta_info[param]\n                    ):\n                        value1 = flow1.parameters_meta_info[param][\"data_type\"]\n                        value2 = flow2.parameters_meta_info[param][\"data_type\"]\n                    else:\n                        value1 = flow1.parameters_meta_info[param]\n                        value2 = flow2.parameters_meta_info[param]\n                    if value1 is None or value2 is None:\n                        continue\n\n                    if value1 != value2:\n                        raise ValueError(\n                            f\"Flow {flow1.name}: data type for parameter {param} in {key} differ \"\n                            f\"as {value1}\\nvs\\n{value2}\",\n                        )\n                # the continue is to avoid the 'attr != attr2' check at end of function\n                continue\n\n            if attr1 != attr2:\n                raise ValueError(\n                    f\"Flow {flow1.name!s}: values for attribute '{key!s}' differ: \"\n                    f\"'{attr1!s}'\\nvs\\n'{attr2!s}'.\",\n                )\n</code></pre>"},{"location":"reference/flows/#openml.flows.delete_flow","title":"<code>delete_flow(flow_id)</code>","text":"<p>Delete flow with id <code>flow_id</code> from the OpenML server.</p> <p>You can only delete flows which you uploaded and which which are not linked to runs.</p> <p>Parameters:</p> Name Type Description Default <code>flow_id</code> <code>int</code> <p>OpenML id of the flow</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/flows/functions.py</code> <pre><code>def delete_flow(flow_id: int) -&gt; bool:\n    \"\"\"Delete flow with id `flow_id` from the OpenML server.\n\n    You can only delete flows which you uploaded and which\n    which are not linked to runs.\n\n    Parameters\n    ----------\n    flow_id : int\n        OpenML id of the flow\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"flow\", flow_id)\n</code></pre>"},{"location":"reference/flows/#openml.flows.flow_exists","title":"<code>flow_exists(name, external_version)</code>","text":"<p>Retrieves the flow id.</p> <p>A flow is uniquely identified by name + external_version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>string</code> <p>Name of the flow</p> required <code>external_version</code> <code>string</code> <p>Version information associated with flow.</p> required <p>Returns:</p> Name Type Description <code>flow_exist</code> <code>int or bool</code> <p>flow id iff exists, False otherwise</p> Notes <p>see https://www.openml.org/api_docs/#!/flow/get_flow_exists_name_version</p> Source code in <code>openml/flows/functions.py</code> <pre><code>def flow_exists(name: str, external_version: str) -&gt; int | bool:\n    \"\"\"Retrieves the flow id.\n\n    A flow is uniquely identified by name + external_version.\n\n    Parameters\n    ----------\n    name : string\n        Name of the flow\n    external_version : string\n        Version information associated with flow.\n\n    Returns\n    -------\n    flow_exist : int or bool\n        flow id iff exists, False otherwise\n\n    Notes\n    -----\n    see https://www.openml.org/api_docs/#!/flow/get_flow_exists_name_version\n    \"\"\"\n    if not (isinstance(name, str) and len(name) &gt; 0):\n        raise ValueError(\"Argument 'name' should be a non-empty string\")\n    if not (isinstance(name, str) and len(external_version) &gt; 0):\n        raise ValueError(\"Argument 'version' should be a non-empty string\")\n\n    xml_response = openml._api_calls._perform_api_call(\n        \"flow/exists\",\n        \"post\",\n        data={\"name\": name, \"external_version\": external_version},\n    )\n\n    result_dict = xmltodict.parse(xml_response)\n    flow_id = int(result_dict[\"oml:flow_exists\"][\"oml:id\"])\n    return flow_id if flow_id &gt; 0 else False\n</code></pre>"},{"location":"reference/flows/#openml.flows.get_flow","title":"<code>get_flow(flow_id, reinstantiate=False, strict_version=True)</code>","text":"<p>Download the OpenML flow for a given flow ID.</p> <p>Parameters:</p> Name Type Description Default <code>flow_id</code> <code>int</code> <p>The OpenML flow id.</p> required <code>reinstantiate</code> <code>bool</code> <p>Whether to reinstantiate the flow to a model instance.</p> <code>False</code> <code>strict_version</code> <code>bool</code> <p>Whether to fail if version requirements are not fulfilled.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>flow</code> <code>OpenMLFlow</code> <p>the flow</p> Source code in <code>openml/flows/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_flow(flow_id: int, reinstantiate: bool = False, strict_version: bool = True) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n    \"\"\"Download the OpenML flow for a given flow ID.\n\n    Parameters\n    ----------\n    flow_id : int\n        The OpenML flow id.\n\n    reinstantiate: bool\n        Whether to reinstantiate the flow to a model instance.\n\n    strict_version : bool, default=True\n        Whether to fail if version requirements are not fulfilled.\n\n    Returns\n    -------\n    flow : OpenMLFlow\n        the flow\n    \"\"\"\n    flow_id = int(flow_id)\n    flow = _get_flow_description(flow_id)\n\n    if reinstantiate:\n        flow.model = flow.extension.flow_to_model(flow, strict_version=strict_version)\n        if not strict_version:\n            # check if we need to return a new flow b/c of version mismatch\n            new_flow = flow.extension.model_to_flow(flow.model)\n            if new_flow.dependencies != flow.dependencies:\n                return new_flow\n    return flow\n</code></pre>"},{"location":"reference/flows/#openml.flows.get_flow_id","title":"<code>get_flow_id(model=None, name=None, exact_version=True)</code>","text":"<p>Retrieves the flow id for a model or a flow name.</p> <p>Provide either a model or a name to this function. Depending on the input, it does</p> <ul> <li><code>model</code> and <code>exact_version == True</code>: This helper function first queries for the necessary   extension. Second, it uses that extension to convert the model into a flow. Third, it   executes <code>flow_exists</code> to potentially obtain the flow id the flow is published to the   server.</li> <li><code>model</code> and <code>exact_version == False</code>: This helper function first queries for the   necessary extension. Second, it uses that extension to convert the model into a flow. Third   it calls <code>list_flows</code> and filters the returned values based on the flow name.</li> <li><code>name</code>: Ignores <code>exact_version</code> and calls <code>list_flows</code>, then filters the returned   values based on the flow name.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>Any model. Must provide either <code>model</code> or <code>name</code>.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the flow. Must provide either <code>model</code> or <code>name</code>.</p> <code>None</code> <code>exact_version</code> <code>bool</code> <p>Whether to return the flow id of the exact version or all flow ids where the name of the flow matches. This is only taken into account for a model where a version number is available (requires <code>model</code> to be set).</p> <code>True</code> <p>Returns:</p> Type Description <code>(int or bool, List)</code> <p>flow id iff exists, <code>False</code> otherwise, List if <code>exact_version is False</code></p> Source code in <code>openml/flows/functions.py</code> <pre><code>def get_flow_id(\n    model: Any | None = None,\n    name: str | None = None,\n    exact_version: bool = True,  # noqa: FBT001, FBT002\n) -&gt; int | bool | list[int]:\n    \"\"\"Retrieves the flow id for a model or a flow name.\n\n    Provide either a model or a name to this function. Depending on the input, it does\n\n    * ``model`` and ``exact_version == True``: This helper function first queries for the necessary\n      extension. Second, it uses that extension to convert the model into a flow. Third, it\n      executes ``flow_exists`` to potentially obtain the flow id the flow is published to the\n      server.\n    * ``model`` and ``exact_version == False``: This helper function first queries for the\n      necessary extension. Second, it uses that extension to convert the model into a flow. Third\n      it calls ``list_flows`` and filters the returned values based on the flow name.\n    * ``name``: Ignores ``exact_version`` and calls ``list_flows``, then filters the returned\n      values based on the flow name.\n\n    Parameters\n    ----------\n    model : object\n        Any model. Must provide either ``model`` or ``name``.\n    name : str\n        Name of the flow. Must provide either ``model`` or ``name``.\n    exact_version : bool\n        Whether to return the flow id of the exact version or all flow ids where the name\n        of the flow matches. This is only taken into account for a model where a version number\n        is available (requires ``model`` to be set).\n\n    Returns\n    -------\n    int or bool, List\n        flow id iff exists, ``False`` otherwise, List if ``exact_version is False``\n    \"\"\"\n    if model is not None and name is not None:\n        raise ValueError(\"Must provide either argument `model` or argument `name`, but not both.\")\n\n    if model is not None:\n        extension = openml.extensions.get_extension_by_model(model, raise_if_no_extension=True)\n        if extension is None:\n            # This should never happen and is only here to please mypy will be gone soon once the\n            # whole function is removed\n            raise TypeError(extension)\n        flow = extension.model_to_flow(model)\n        flow_name = flow.name\n        external_version = flow.external_version\n    elif name is not None:\n        flow_name = name\n        exact_version = False\n        external_version = None\n    else:\n        raise ValueError(\n            \"Need to provide either argument `model` or argument `name`, but both are `None`.\"\n        )\n\n    if exact_version:\n        if external_version is None:\n            raise ValueError(\"exact_version should be False if model is None!\")\n        return flow_exists(name=flow_name, external_version=external_version)\n\n    flows = list_flows()\n    flows = flows.query(f'name == \"{flow_name}\"')\n    return flows[\"id\"].to_list()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"reference/flows/#openml.flows.list_flows","title":"<code>list_flows(offset=None, size=None, tag=None, uploader=None)</code>","text":"<p>Return a list of all flows which are on OpenML. (Supports large amount of results)</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>the number of flows to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of flows to return</p> <code>None</code> <code>tag</code> <code>str</code> <p>the tag to include</p> <code>None</code> <code>kwargs</code> <p>Legal filter operators: uploader.</p> required <p>Returns:</p> Name Type Description <code>flows</code> <code>dataframe</code> <p>Each row maps to a dataset Each column contains the following information: - flow id - full name - name - version - external version - uploader</p> Source code in <code>openml/flows/functions.py</code> <pre><code>def list_flows(\n    offset: int | None = None,\n    size: int | None = None,\n    tag: str | None = None,\n    uploader: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a list of all flows which are on OpenML.\n    (Supports large amount of results)\n\n    Parameters\n    ----------\n    offset : int, optional\n        the number of flows to skip, starting from the first\n    size : int, optional\n        the maximum number of flows to return\n    tag : str, optional\n        the tag to include\n    kwargs: dict, optional\n        Legal filter operators: uploader.\n\n    Returns\n    -------\n    flows : dataframe\n            Each row maps to a dataset\n            Each column contains the following information:\n            - flow id\n            - full name\n            - name\n            - version\n            - external version\n            - uploader\n    \"\"\"\n    listing_call = partial(_list_flows, tag=tag, uploader=uploader)\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/flows/flow/","title":"flow","text":""},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow","title":"<code>OpenMLFlow</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Flow. Stores machine learning models.</p> <p>Flows should not be generated manually, but by the function :meth:<code>openml.flows.create_flow_from_model</code>. Using this helper function ensures that all relevant fields are filled in.</p> <p>Implements <code>openml.implementation.upload.xsd &lt;https://github.com/openml/openml/blob/master/openml_OS/views/pages/api_new/v1/xsd/ openml.implementation.upload.xsd&gt;</code>_.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the flow. Is used together with the attribute <code>external_version</code> as a unique identifier of the flow.</p> required <code>description</code> <code>str</code> <p>Human-readable description of the flow (free text).</p> required <code>model</code> <code>object</code> <p>ML model which is described by this flow.</p> required <code>components</code> <code>OrderedDict</code> <p>Mapping from component identifier to an OpenMLFlow object. Components are usually subfunctions of an algorithm (e.g. kernels), base learners in ensemble algorithms (decision tree in adaboost) or building blocks of a machine learning pipeline. Components are modeled as independent flows and can be shared between flows (different pipelines can use the same components).</p> required <code>parameters</code> <code>OrderedDict</code> <p>Mapping from parameter name to the parameter default value. The parameter default value must be of type <code>str</code>, so that the respective toolbox plugin can take care of casting the parameter default value to the correct type.</p> required <code>parameters_meta_info</code> <code>OrderedDict</code> <p>Mapping from parameter name to <code>dict</code>. Stores additional information for each parameter. Required keys are <code>data_type</code> and <code>description</code>.</p> required <code>external_version</code> <code>str</code> <p>Version number of the software the flow is implemented in. Is used together with the attribute <code>name</code> as a uniquer identifier of the flow.</p> required <code>tags</code> <code>list</code> <p>List of tags. Created on the server by other API calls.</p> required <code>language</code> <code>str</code> <p>Natural language the flow is described in (not the programming language).</p> required <code>dependencies</code> <code>str</code> <p>A list of dependencies necessary to run the flow. This field should contain all libraries the flow depends on. To allow reproducibility it should also specify the exact version numbers.</p> required <code>class_name</code> <code>str</code> <p>The development language name of the class which is described by this flow.</p> <code>None</code> <code>custom_name</code> <code>str</code> <p>Custom name of the flow given by the owner.</p> <code>None</code> <code>binary_url</code> <code>str</code> <p>Url from which the binary can be downloaded. Added by the server. Ignored when uploaded manually. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>binary_format</code> <code>str</code> <p>Format in which the binary code was uploaded. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>binary_md5</code> <code>str</code> <p>MD5 checksum to check if the binary code was correctly downloaded. Will not be used by the python API because binaries aren't compatible across machines.</p> <code>None</code> <code>uploader</code> <code>str</code> <p>OpenML user ID of the uploader. Filled in by the server.</p> <code>None</code> <code>upload_date</code> <code>str</code> <p>Date the flow was uploaded. Filled in by the server.</p> <code>None</code> <code>flow_id</code> <code>int</code> <p>Flow ID. Assigned by the server.</p> <code>None</code> <code>extension</code> <code>Extension</code> <p>The extension for a flow (e.g., sklearn).</p> <code>None</code> <code>version</code> <code>str</code> <p>OpenML version of the flow. Assigned by the server.</p> <code>None</code> Source code in <code>openml/flows/flow.py</code> <pre><code>class OpenMLFlow(OpenMLBase):\n    \"\"\"OpenML Flow. Stores machine learning models.\n\n    Flows should not be generated manually, but by the function\n    :meth:`openml.flows.create_flow_from_model`. Using this helper function\n    ensures that all relevant fields are filled in.\n\n    Implements `openml.implementation.upload.xsd\n    &lt;https://github.com/openml/openml/blob/master/openml_OS/views/pages/api_new/v1/xsd/\n    openml.implementation.upload.xsd&gt;`_.\n\n    Parameters\n    ----------\n    name : str\n        Name of the flow. Is used together with the attribute\n        `external_version` as a unique identifier of the flow.\n    description : str\n        Human-readable description of the flow (free text).\n    model : object\n        ML model which is described by this flow.\n    components : OrderedDict\n        Mapping from component identifier to an OpenMLFlow object. Components\n        are usually subfunctions of an algorithm (e.g. kernels), base learners\n        in ensemble algorithms (decision tree in adaboost) or building blocks\n        of a machine learning pipeline. Components are modeled as independent\n        flows and can be shared between flows (different pipelines can use\n        the same components).\n    parameters : OrderedDict\n        Mapping from parameter name to the parameter default value. The\n        parameter default value must be of type `str`, so that the respective\n        toolbox plugin can take care of casting the parameter default value to\n        the correct type.\n    parameters_meta_info : OrderedDict\n        Mapping from parameter name to `dict`. Stores additional information\n        for each parameter. Required keys are `data_type` and `description`.\n    external_version : str\n        Version number of the software the flow is implemented in. Is used\n        together with the attribute `name` as a uniquer identifier of the flow.\n    tags : list\n        List of tags. Created on the server by other API calls.\n    language : str\n        Natural language the flow is described in (not the programming\n        language).\n    dependencies : str\n        A list of dependencies necessary to run the flow. This field should\n        contain all libraries the flow depends on. To allow reproducibility\n        it should also specify the exact version numbers.\n    class_name : str, optional\n        The development language name of the class which is described by this\n        flow.\n    custom_name : str, optional\n        Custom name of the flow given by the owner.\n    binary_url : str, optional\n        Url from which the binary can be downloaded. Added by the server.\n        Ignored when uploaded manually. Will not be used by the python API\n        because binaries aren't compatible across machines.\n    binary_format : str, optional\n        Format in which the binary code was uploaded. Will not be used by the\n        python API because binaries aren't compatible across machines.\n    binary_md5 : str, optional\n        MD5 checksum to check if the binary code was correctly downloaded. Will\n        not be used by the python API because binaries aren't compatible across\n        machines.\n    uploader : str, optional\n        OpenML user ID of the uploader. Filled in by the server.\n    upload_date : str, optional\n        Date the flow was uploaded. Filled in by the server.\n    flow_id : int, optional\n        Flow ID. Assigned by the server.\n    extension : Extension, optional\n        The extension for a flow (e.g., sklearn).\n    version : str, optional\n        OpenML version of the flow. Assigned by the server.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        name: str,\n        description: str,\n        model: object,\n        components: dict,\n        parameters: dict,\n        parameters_meta_info: dict,\n        external_version: str,\n        tags: list,\n        language: str,\n        dependencies: str,\n        class_name: str | None = None,\n        custom_name: str | None = None,\n        binary_url: str | None = None,\n        binary_format: str | None = None,\n        binary_md5: str | None = None,\n        uploader: str | None = None,\n        upload_date: str | None = None,\n        flow_id: int | None = None,\n        extension: Extension | None = None,\n        version: str | None = None,\n    ):\n        self.name = name\n        self.description = description\n        self.model = model\n\n        for variable, variable_name in [\n            [components, \"components\"],\n            [parameters, \"parameters\"],\n            [parameters_meta_info, \"parameters_meta_info\"],\n        ]:\n            if not isinstance(variable, (OrderedDict, dict)):\n                raise TypeError(\n                    f\"{variable_name} must be of type OrderedDict or dict, \"\n                    f\"but is {type(variable)}.\",\n                )\n\n        self.components = components\n        self.parameters = parameters\n        self.parameters_meta_info = parameters_meta_info\n        self.class_name = class_name\n\n        keys_parameters = set(parameters.keys())\n        keys_parameters_meta_info = set(parameters_meta_info.keys())\n        if len(keys_parameters.difference(keys_parameters_meta_info)) &gt; 0:\n            raise ValueError(\n                f\"Parameter {keys_parameters.difference(keys_parameters_meta_info)!s} only in \"\n                \"parameters, but not in parameters_meta_info.\",\n            )\n        if len(keys_parameters_meta_info.difference(keys_parameters)) &gt; 0:\n            raise ValueError(\n                f\"Parameter {keys_parameters_meta_info.difference(keys_parameters)!s} only in \"\n                \" parameters_meta_info, but not in parameters.\",\n            )\n\n        self.external_version = external_version\n        self.uploader = uploader\n\n        self.custom_name = custom_name\n        self.tags = tags if tags is not None else []\n        self.binary_url = binary_url\n        self.binary_format = binary_format\n        self.binary_md5 = binary_md5\n        self.version = version\n        self.upload_date = upload_date\n        self.language = language\n        self.dependencies = dependencies\n        self.flow_id = flow_id\n        if extension is None:\n            self._extension = get_extension_by_flow(self)\n        else:\n            self._extension = extension\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"The ID of the flow.\"\"\"\n        return self.flow_id\n\n    @property\n    def extension(self) -&gt; Extension:\n        \"\"\"The extension of the flow (e.g., sklearn).\"\"\"\n        if self._extension is not None:\n            return self._extension\n\n        raise RuntimeError(\n            f\"No extension could be found for flow {self.flow_id}: {self.name}\",\n        )\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        fields = {\n            \"Flow Name\": self.name,\n            \"Flow Description\": self.description,\n            \"Dependencies\": self.dependencies,\n        }\n        if self.flow_id is not None:\n            fields[\"Flow URL\"] = self.openml_url if self.openml_url is not None else \"None\"\n            fields[\"Flow ID\"] = str(self.flow_id)\n            if self.version is not None:\n                fields[\"Flow ID\"] += f\" (version {self.version})\"\n        if self.upload_date is not None:\n            fields[\"Upload Date\"] = self.upload_date.replace(\"T\", \" \")\n        if self.binary_url is not None:\n            fields[\"Binary URL\"] = self.binary_url\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Flow ID\",\n            \"Flow URL\",\n            \"Flow Name\",\n            \"Flow Description\",\n            \"Binary URL\",\n            \"Upload Date\",\n            \"Dependencies\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def _to_dict(self) -&gt; dict[str, dict]:  # noqa: C901, PLR0912\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        flow_container = OrderedDict()  # type: 'dict[str, dict]'\n        flow_dict = OrderedDict(\n            [(\"@xmlns:oml\", \"http://openml.org/openml\")],\n        )  # type: 'dict[str, list | str]'  # E501\n        flow_container[\"oml:flow\"] = flow_dict\n        _add_if_nonempty(flow_dict, \"oml:id\", self.flow_id)\n\n        for required in [\"name\", \"external_version\"]:\n            if getattr(self, required) is None:\n                raise ValueError(f\"self.{required} is required but None\")\n        for attribute in [\n            \"uploader\",\n            \"name\",\n            \"custom_name\",\n            \"class_name\",\n            \"version\",\n            \"external_version\",\n            \"description\",\n            \"upload_date\",\n            \"language\",\n            \"dependencies\",\n        ]:\n            _add_if_nonempty(flow_dict, f\"oml:{attribute}\", getattr(self, attribute))\n\n        if not self.description:\n            logger = logging.getLogger(__name__)\n            logger.warning(\"Flow % has empty description\", self.name)\n\n        flow_parameters = []\n        for key in self.parameters:\n            param_dict = OrderedDict()  # type: 'OrderedDict[str, str]'\n            param_dict[\"oml:name\"] = key\n            meta_info = self.parameters_meta_info[key]\n\n            _add_if_nonempty(param_dict, \"oml:data_type\", meta_info[\"data_type\"])\n            param_dict[\"oml:default_value\"] = self.parameters[key]\n            _add_if_nonempty(param_dict, \"oml:description\", meta_info[\"description\"])\n\n            for key_, value in param_dict.items():\n                if key_ is not None and not isinstance(key_, str):\n                    raise ValueError(\n                        f\"Parameter name {key_} cannot be serialized \"\n                        f\"because it is of type {type(key_)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n                if value is not None and not isinstance(value, str):\n                    raise ValueError(\n                        f\"Parameter value {value} cannot be serialized \"\n                        f\"because it is of type {type(value)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n\n            flow_parameters.append(param_dict)\n\n        flow_dict[\"oml:parameter\"] = flow_parameters\n\n        components = []\n        for key in self.components:\n            component_dict = OrderedDict()  # type: 'OrderedDict[str, dict]'\n            component_dict[\"oml:identifier\"] = key\n            if self.components[key] in [\"passthrough\", \"drop\"]:\n                component_dict[\"oml:flow\"] = {\n                    \"oml-python:serialized_object\": \"component_reference\",\n                    \"value\": {\"key\": self.components[key], \"step_name\": self.components[key]},\n                }\n            else:\n                component_dict[\"oml:flow\"] = self.components[key]._to_dict()[\"oml:flow\"]\n\n            for key_ in component_dict:\n                # We only need to check if the key is a string, because the\n                # value is a flow. The flow itself is valid by recursion\n                if key_ is not None and not isinstance(key_, str):\n                    raise ValueError(\n                        f\"Parameter name {key_} cannot be serialized \"\n                        f\"because it is of type {type(key_)}. Only strings \"\n                        \"can be serialized.\",\n                    )\n\n            components.append(component_dict)\n\n        flow_dict[\"oml:component\"] = components\n        flow_dict[\"oml:tag\"] = self.tags\n        for attribute in [\"binary_url\", \"binary_format\", \"binary_md5\"]:\n            _add_if_nonempty(flow_dict, f\"oml:{attribute}\", getattr(self, attribute))\n\n        return flow_container\n\n    @classmethod\n    def _from_dict(cls, xml_dict: dict) -&gt; OpenMLFlow:\n        \"\"\"Create a flow from an xml description.\n\n        Calls itself recursively to create :class:`OpenMLFlow` objects of\n        subflows (components).\n\n        XML definition of a flow is available at\n        https://github.com/openml/OpenML/blob/master/openml_OS/views/pages/api_new/v1/xsd/openml.implementation.upload.xsd\n\n        Parameters\n        ----------\n        xml_dict : dict\n            Dictionary representation of the flow as created by _to_dict()\n\n        Returns\n        -------\n            OpenMLFlow\n\n        \"\"\"  # E501\n        arguments = OrderedDict()\n        dic = xml_dict[\"oml:flow\"]\n\n        # Mandatory parts in the xml file\n        for key in [\"name\"]:\n            arguments[key] = dic[\"oml:\" + key]\n\n        # non-mandatory parts in the xml file\n        for key in [\n            \"external_version\",\n            \"uploader\",\n            \"description\",\n            \"upload_date\",\n            \"language\",\n            \"dependencies\",\n            \"version\",\n            \"binary_url\",\n            \"binary_format\",\n            \"binary_md5\",\n            \"class_name\",\n            \"custom_name\",\n        ]:\n            arguments[key] = dic.get(\"oml:\" + key)\n\n        # has to be converted to an int if present and cannot parsed in the\n        # two loops above\n        arguments[\"flow_id\"] = int(dic[\"oml:id\"]) if dic.get(\"oml:id\") is not None else None\n\n        # Now parse parts of a flow which can occur multiple times like\n        # parameters, components (subflows) and tags. These can't be tackled\n        # in the loops above because xmltodict returns a dict if such an\n        # entity occurs once, and a list if it occurs multiple times.\n        # Furthermore, they must be treated differently, for example\n        # for components this method is called recursively and\n        # for parameters the actual information is split into two dictionaries\n        # for easier access in python.\n\n        parameters = OrderedDict()\n        parameters_meta_info = OrderedDict()\n        if \"oml:parameter\" in dic:\n            # In case of a single parameter, xmltodict returns a dictionary,\n            # otherwise a list.\n            oml_parameters = extract_xml_tags(\"oml:parameter\", dic, allow_none=False)\n\n            for oml_parameter in oml_parameters:\n                parameter_name = oml_parameter[\"oml:name\"]\n                default_value = oml_parameter[\"oml:default_value\"]\n                parameters[parameter_name] = default_value\n\n                meta_info = OrderedDict()\n                meta_info[\"description\"] = oml_parameter.get(\"oml:description\")\n                meta_info[\"data_type\"] = oml_parameter.get(\"oml:data_type\")\n                parameters_meta_info[parameter_name] = meta_info\n        arguments[\"parameters\"] = parameters\n        arguments[\"parameters_meta_info\"] = parameters_meta_info\n\n        components = OrderedDict()\n        if \"oml:component\" in dic:\n            # In case of a single component xmltodict returns a dict,\n            # otherwise a list.\n            oml_components = extract_xml_tags(\"oml:component\", dic, allow_none=False)\n\n            for component in oml_components:\n                flow = OpenMLFlow._from_dict(component)\n                components[component[\"oml:identifier\"]] = flow\n        arguments[\"components\"] = components\n        arguments[\"tags\"] = extract_xml_tags(\"oml:tag\", dic)\n\n        arguments[\"model\"] = None\n        return cls(**arguments)\n\n    def to_filesystem(self, output_directory: str | Path) -&gt; None:\n        \"\"\"Write a flow to the filesystem as XML to output_directory.\"\"\"\n        output_directory = Path(output_directory)\n        output_directory.mkdir(parents=True, exist_ok=True)\n\n        output_path = output_directory / \"flow.xml\"\n        if output_path.exists():\n            raise ValueError(\"Output directory already contains a flow.xml file.\")\n\n        run_xml = self._to_xml()\n        with output_path.open(\"w\") as f:\n            f.write(run_xml)\n\n    @classmethod\n    def from_filesystem(cls, input_directory: str | Path) -&gt; OpenMLFlow:\n        \"\"\"Read a flow from an XML in input_directory on the filesystem.\"\"\"\n        input_directory = Path(input_directory) / \"flow.xml\"\n        with input_directory.open() as f:\n            xml_string = f.read()\n        return OpenMLFlow._from_dict(xmltodict.parse(xml_string))\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.flow_id = int(xml_response[\"oml:upload_flow\"][\"oml:id\"])\n\n    def publish(self, raise_error_if_exists: bool = False) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n        \"\"\"Publish this flow to OpenML server.\n\n        Raises a PyOpenMLError if the flow exists on the server, but\n        `self.flow_id` does not match the server known flow id.\n\n        Parameters\n        ----------\n        raise_error_if_exists : bool, optional (default=False)\n            If True, raise PyOpenMLError if the flow exists on the server.\n            If False, update the local flow to match the server flow.\n\n        Returns\n        -------\n        self : OpenMLFlow\n\n        \"\"\"\n        # Import at top not possible because of cyclic dependencies. In\n        # particular, flow.py tries to import functions.py in order to call\n        # get_flow(), while functions.py tries to import flow.py in order to\n        # instantiate an OpenMLFlow.\n        import openml.flows.functions\n\n        flow_id = openml.flows.functions.flow_exists(self.name, self.external_version)\n        if not flow_id:\n            if self.flow_id:\n                raise openml.exceptions.PyOpenMLError(\n                    \"Flow does not exist on the server, \" \"but 'flow.flow_id' is not None.\",\n                )\n            super().publish()\n            assert self.flow_id is not None  # for mypy\n            flow_id = self.flow_id\n        elif raise_error_if_exists:\n            error_message = f\"This OpenMLFlow already exists with id: {flow_id}.\"\n            raise openml.exceptions.PyOpenMLError(error_message)\n        elif self.flow_id is not None and self.flow_id != flow_id:\n            raise openml.exceptions.PyOpenMLError(\n                \"Local flow_id does not match server flow_id: \" f\"'{self.flow_id}' vs '{flow_id}'\",\n            )\n\n        flow = openml.flows.functions.get_flow(flow_id)\n        _copy_server_fields(flow, self)\n        try:\n            openml.flows.functions.assert_flows_equal(\n                self,\n                flow,\n                flow.upload_date,\n                ignore_parameter_values=True,\n                ignore_custom_name_if_none=True,\n            )\n        except ValueError as e:\n            message = e.args[0]\n            raise ValueError(\n                \"The flow on the server is inconsistent with the local flow. \"\n                f\"The server flow ID is {flow_id}. Please check manually and remove \"\n                f\"the flow if necessary! Error is:\\n'{message}'\",\n            ) from e\n        return self\n\n    def get_structure(self, key_item: str) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Returns for each sub-component of the flow the path of identifiers\n        that should be traversed to reach this component. The resulting dict\n        maps a key (identifying a flow by either its id, name or fullname) to\n        the parameter prefix.\n\n        Parameters\n        ----------\n        key_item: str\n            The flow attribute that will be used to identify flows in the\n            structure. Allowed values {flow_id, name}\n\n        Returns\n        -------\n        dict[str, List[str]]\n            The flow structure\n        \"\"\"\n        if key_item not in [\"flow_id\", \"name\"]:\n            raise ValueError(\"key_item should be in {flow_id, name}\")\n        structure = {}\n        for key, sub_flow in self.components.items():\n            sub_structure = sub_flow.get_structure(key_item)\n            for flow_name, flow_sub_structure in sub_structure.items():\n                structure[flow_name] = [key, *flow_sub_structure]\n        structure[getattr(self, key_item)] = []\n        return structure\n\n    def get_subflow(self, structure: list[str]) -&gt; OpenMLFlow:\n        \"\"\"\n        Returns a subflow from the tree of dependencies.\n\n        Parameters\n        ----------\n        structure: list[str]\n            A list of strings, indicating the location of the subflow\n\n        Returns\n        -------\n        OpenMLFlow\n            The OpenMLFlow that corresponds to the structure\n        \"\"\"\n        # make a copy of structure, as we don't want to change it in the\n        # outer scope\n        structure = list(structure)\n        if len(structure) &lt; 1:\n            raise ValueError(\"Please provide a structure list of size &gt;= 1\")\n        sub_identifier = structure[0]\n        if sub_identifier not in self.components:\n            raise ValueError(\n                f\"Flow {self.name} does not contain component with \" f\"identifier {sub_identifier}\",\n            )\n        if len(structure) == 1:\n            return self.components[sub_identifier]  # type: ignore\n\n        structure.pop(0)\n        return self.components[sub_identifier].get_subflow(structure)  # type: ignore\n</code></pre>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.extension","title":"<code>extension: Extension</code>  <code>property</code>","text":"<p>The extension of the flow (e.g., sklearn).</p>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>The ID of the flow.</p>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.from_filesystem","title":"<code>from_filesystem(input_directory)</code>  <code>classmethod</code>","text":"<p>Read a flow from an XML in input_directory on the filesystem.</p> Source code in <code>openml/flows/flow.py</code> <pre><code>@classmethod\ndef from_filesystem(cls, input_directory: str | Path) -&gt; OpenMLFlow:\n    \"\"\"Read a flow from an XML in input_directory on the filesystem.\"\"\"\n    input_directory = Path(input_directory) / \"flow.xml\"\n    with input_directory.open() as f:\n        xml_string = f.read()\n    return OpenMLFlow._from_dict(xmltodict.parse(xml_string))\n</code></pre>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.get_structure","title":"<code>get_structure(key_item)</code>","text":"<p>Returns for each sub-component of the flow the path of identifiers that should be traversed to reach this component. The resulting dict maps a key (identifying a flow by either its id, name or fullname) to the parameter prefix.</p> <p>Parameters:</p> Name Type Description Default <code>key_item</code> <code>str</code> <p>The flow attribute that will be used to identify flows in the structure. Allowed values {flow_id, name}</p> required <p>Returns:</p> Type Description <code>dict[str, List[str]]</code> <p>The flow structure</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def get_structure(self, key_item: str) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Returns for each sub-component of the flow the path of identifiers\n    that should be traversed to reach this component. The resulting dict\n    maps a key (identifying a flow by either its id, name or fullname) to\n    the parameter prefix.\n\n    Parameters\n    ----------\n    key_item: str\n        The flow attribute that will be used to identify flows in the\n        structure. Allowed values {flow_id, name}\n\n    Returns\n    -------\n    dict[str, List[str]]\n        The flow structure\n    \"\"\"\n    if key_item not in [\"flow_id\", \"name\"]:\n        raise ValueError(\"key_item should be in {flow_id, name}\")\n    structure = {}\n    for key, sub_flow in self.components.items():\n        sub_structure = sub_flow.get_structure(key_item)\n        for flow_name, flow_sub_structure in sub_structure.items():\n            structure[flow_name] = [key, *flow_sub_structure]\n    structure[getattr(self, key_item)] = []\n    return structure\n</code></pre>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.get_subflow","title":"<code>get_subflow(structure)</code>","text":"<p>Returns a subflow from the tree of dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>list[str]</code> <p>A list of strings, indicating the location of the subflow</p> required <p>Returns:</p> Type Description <code>OpenMLFlow</code> <p>The OpenMLFlow that corresponds to the structure</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def get_subflow(self, structure: list[str]) -&gt; OpenMLFlow:\n    \"\"\"\n    Returns a subflow from the tree of dependencies.\n\n    Parameters\n    ----------\n    structure: list[str]\n        A list of strings, indicating the location of the subflow\n\n    Returns\n    -------\n    OpenMLFlow\n        The OpenMLFlow that corresponds to the structure\n    \"\"\"\n    # make a copy of structure, as we don't want to change it in the\n    # outer scope\n    structure = list(structure)\n    if len(structure) &lt; 1:\n        raise ValueError(\"Please provide a structure list of size &gt;= 1\")\n    sub_identifier = structure[0]\n    if sub_identifier not in self.components:\n        raise ValueError(\n            f\"Flow {self.name} does not contain component with \" f\"identifier {sub_identifier}\",\n        )\n    if len(structure) == 1:\n        return self.components[sub_identifier]  # type: ignore\n\n    structure.pop(0)\n    return self.components[sub_identifier].get_subflow(structure)  # type: ignore\n</code></pre>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.publish","title":"<code>publish(raise_error_if_exists=False)</code>","text":"<p>Publish this flow to OpenML server.</p> <p>Raises a PyOpenMLError if the flow exists on the server, but <code>self.flow_id</code> does not match the server known flow id.</p> <p>Parameters:</p> Name Type Description Default <code>raise_error_if_exists</code> <code>(bool, optional(default=False))</code> <p>If True, raise PyOpenMLError if the flow exists on the server. If False, update the local flow to match the server flow.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>self</code> <code>OpenMLFlow</code> Source code in <code>openml/flows/flow.py</code> <pre><code>def publish(self, raise_error_if_exists: bool = False) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n    \"\"\"Publish this flow to OpenML server.\n\n    Raises a PyOpenMLError if the flow exists on the server, but\n    `self.flow_id` does not match the server known flow id.\n\n    Parameters\n    ----------\n    raise_error_if_exists : bool, optional (default=False)\n        If True, raise PyOpenMLError if the flow exists on the server.\n        If False, update the local flow to match the server flow.\n\n    Returns\n    -------\n    self : OpenMLFlow\n\n    \"\"\"\n    # Import at top not possible because of cyclic dependencies. In\n    # particular, flow.py tries to import functions.py in order to call\n    # get_flow(), while functions.py tries to import flow.py in order to\n    # instantiate an OpenMLFlow.\n    import openml.flows.functions\n\n    flow_id = openml.flows.functions.flow_exists(self.name, self.external_version)\n    if not flow_id:\n        if self.flow_id:\n            raise openml.exceptions.PyOpenMLError(\n                \"Flow does not exist on the server, \" \"but 'flow.flow_id' is not None.\",\n            )\n        super().publish()\n        assert self.flow_id is not None  # for mypy\n        flow_id = self.flow_id\n    elif raise_error_if_exists:\n        error_message = f\"This OpenMLFlow already exists with id: {flow_id}.\"\n        raise openml.exceptions.PyOpenMLError(error_message)\n    elif self.flow_id is not None and self.flow_id != flow_id:\n        raise openml.exceptions.PyOpenMLError(\n            \"Local flow_id does not match server flow_id: \" f\"'{self.flow_id}' vs '{flow_id}'\",\n        )\n\n    flow = openml.flows.functions.get_flow(flow_id)\n    _copy_server_fields(flow, self)\n    try:\n        openml.flows.functions.assert_flows_equal(\n            self,\n            flow,\n            flow.upload_date,\n            ignore_parameter_values=True,\n            ignore_custom_name_if_none=True,\n        )\n    except ValueError as e:\n        message = e.args[0]\n        raise ValueError(\n            \"The flow on the server is inconsistent with the local flow. \"\n            f\"The server flow ID is {flow_id}. Please check manually and remove \"\n            f\"the flow if necessary! Error is:\\n'{message}'\",\n        ) from e\n    return self\n</code></pre>"},{"location":"reference/flows/flow/#openml.flows.flow.OpenMLFlow.to_filesystem","title":"<code>to_filesystem(output_directory)</code>","text":"<p>Write a flow to the filesystem as XML to output_directory.</p> Source code in <code>openml/flows/flow.py</code> <pre><code>def to_filesystem(self, output_directory: str | Path) -&gt; None:\n    \"\"\"Write a flow to the filesystem as XML to output_directory.\"\"\"\n    output_directory = Path(output_directory)\n    output_directory.mkdir(parents=True, exist_ok=True)\n\n    output_path = output_directory / \"flow.xml\"\n    if output_path.exists():\n        raise ValueError(\"Output directory already contains a flow.xml file.\")\n\n    run_xml = self._to_xml()\n    with output_path.open(\"w\") as f:\n        f.write(run_xml)\n</code></pre>"},{"location":"reference/flows/functions/","title":"functions","text":""},{"location":"reference/flows/functions/#openml.flows.functions.__list_flows","title":"<code>__list_flows(api_call)</code>","text":"<p>Retrieve information about flows from OpenML API and parse it to a dictionary or a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>api_call</code> <code>str</code> <p>Retrieves the information about flows.</p> required <p>Returns:</p> Type Description <code>    The flows information in the specified output format.</code> Source code in <code>openml/flows/functions.py</code> <pre><code>def __list_flows(api_call: str) -&gt; pd.DataFrame:\n    \"\"\"Retrieve information about flows from OpenML API\n    and parse it to a dictionary or a Pandas DataFrame.\n\n    Parameters\n    ----------\n    api_call: str\n        Retrieves the information about flows.\n\n    Returns\n    -------\n        The flows information in the specified output format.\n    \"\"\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    flows_dict = xmltodict.parse(xml_string, force_list=(\"oml:flow\",))\n\n    # Minimalistic check if the XML is useful\n    assert isinstance(flows_dict[\"oml:flows\"][\"oml:flow\"], list), type(flows_dict[\"oml:flows\"])\n    assert flows_dict[\"oml:flows\"][\"@xmlns:oml\"] == \"http://openml.org/openml\", flows_dict[\n        \"oml:flows\"\n    ][\"@xmlns:oml\"]\n\n    flows = {}\n    for flow_ in flows_dict[\"oml:flows\"][\"oml:flow\"]:\n        fid = int(flow_[\"oml:id\"])\n        flow = {\n            \"id\": fid,\n            \"full_name\": flow_[\"oml:full_name\"],\n            \"name\": flow_[\"oml:name\"],\n            \"version\": flow_[\"oml:version\"],\n            \"external_version\": flow_[\"oml:external_version\"],\n            \"uploader\": flow_[\"oml:uploader\"],\n        }\n        flows[fid] = flow\n\n    return pd.DataFrame.from_dict(flows, orient=\"index\")\n</code></pre>"},{"location":"reference/flows/functions/#openml.flows.functions.assert_flows_equal","title":"<code>assert_flows_equal(flow1, flow2, ignore_parameter_values_on_older_children=None, ignore_parameter_values=False, ignore_custom_name_if_none=False, check_description=True)</code>","text":"<p>Check equality of two flows.</p> <p>Two flows are equal if their all keys which are not set by the server are equal, as well as all their parameters and components.</p> <p>Parameters:</p> Name Type Description Default <code>flow1</code> <code>OpenMLFlow</code> required <code>flow2</code> <code>OpenMLFlow</code> required <code>ignore_parameter_values_on_older_children</code> <code>str(optional)</code> <p>If set to <code>OpenMLFlow.upload_date</code>, ignores parameters in a child flow if it's upload date predates the upload date of the parent flow.</p> <code>None</code> <code>ignore_parameter_values</code> <code>bool</code> <p>Whether to ignore parameter values when comparing flows.</p> <code>False</code> <code>ignore_custom_name_if_none</code> <code>bool</code> <p>Whether to ignore the custom name field if either flow has <code>custom_name</code> equal to <code>None</code>.</p> <code>False</code> <code>check_description</code> <code>bool</code> <p>Whether to ignore matching of flow descriptions.</p> <code>True</code> Source code in <code>openml/flows/functions.py</code> <pre><code>def assert_flows_equal(  # noqa: C901, PLR0912, PLR0913, PLR0915\n    flow1: OpenMLFlow,\n    flow2: OpenMLFlow,\n    ignore_parameter_values_on_older_children: str | None = None,\n    ignore_parameter_values: bool = False,  # noqa: FBT001, FBT002\n    ignore_custom_name_if_none: bool = False,  # noqa:  FBT001, FBT002\n    check_description: bool = True,  # noqa:  FBT001, FBT002\n) -&gt; None:\n    \"\"\"Check equality of two flows.\n\n    Two flows are equal if their all keys which are not set by the server\n    are equal, as well as all their parameters and components.\n\n    Parameters\n    ----------\n    flow1 : OpenMLFlow\n\n    flow2 : OpenMLFlow\n\n    ignore_parameter_values_on_older_children : str (optional)\n        If set to ``OpenMLFlow.upload_date``, ignores parameters in a child\n        flow if it's upload date predates the upload date of the parent flow.\n\n    ignore_parameter_values : bool\n        Whether to ignore parameter values when comparing flows.\n\n    ignore_custom_name_if_none : bool\n        Whether to ignore the custom name field if either flow has `custom_name` equal to `None`.\n\n    check_description : bool\n        Whether to ignore matching of flow descriptions.\n    \"\"\"\n    if not isinstance(flow1, OpenMLFlow):\n        raise TypeError(f\"Argument 1 must be of type OpenMLFlow, but is {type(flow1)}\")\n\n    if not isinstance(flow2, OpenMLFlow):\n        raise TypeError(f\"Argument 2 must be of type OpenMLFlow, but is {type(flow2)}\")\n\n    # TODO as they are actually now saved during publish, it might be good to\n    # check for the equality of these as well.\n    generated_by_the_server = [\n        \"flow_id\",\n        \"uploader\",\n        \"version\",\n        \"upload_date\",\n        # Tags aren't directly created by the server,\n        # but the uploader has no control over them!\n        \"tags\",\n    ]\n    ignored_by_python_api = [\"binary_url\", \"binary_format\", \"binary_md5\", \"model\", \"_entity_id\"]\n\n    for key in set(flow1.__dict__.keys()).union(flow2.__dict__.keys()):\n        if key in generated_by_the_server + ignored_by_python_api:\n            continue\n        attr1 = getattr(flow1, key, None)\n        attr2 = getattr(flow2, key, None)\n        if key == \"components\":\n            if not (isinstance(attr1, Dict) and isinstance(attr2, Dict)):\n                raise TypeError(\"Cannot compare components because they are not dictionary.\")\n\n            for name in set(attr1.keys()).union(attr2.keys()):\n                if name not in attr1:\n                    raise ValueError(\n                        f\"Component {name} only available in argument2, but not in argument1.\",\n                    )\n                if name not in attr2:\n                    raise ValueError(\n                        f\"Component {name} only available in argument2, but not in argument1.\",\n                    )\n                assert_flows_equal(\n                    attr1[name],\n                    attr2[name],\n                    ignore_parameter_values_on_older_children,\n                    ignore_parameter_values,\n                    ignore_custom_name_if_none,\n                )\n        elif key == \"_extension\":\n            continue\n        elif check_description and key == \"description\":\n            # to ignore matching of descriptions since sklearn based flows may have\n            # altering docstrings and is not guaranteed to be consistent\n            continue\n        else:\n            if key == \"parameters\":\n                if ignore_parameter_values or ignore_parameter_values_on_older_children:\n                    params_flow_1 = set(flow1.parameters.keys())\n                    params_flow_2 = set(flow2.parameters.keys())\n                    symmetric_difference = params_flow_1 ^ params_flow_2\n                    if len(symmetric_difference) &gt; 0:\n                        raise ValueError(\n                            f\"Flow {flow1.name}: parameter set of flow \"\n                            \"differs from the parameters stored \"\n                            \"on the server.\",\n                        )\n\n                if ignore_parameter_values_on_older_children:\n                    assert (\n                        flow1.upload_date is not None\n                    ), \"Flow1 has no upload date that allows us to compare age of children.\"\n                    upload_date_current_flow = dateutil.parser.parse(flow1.upload_date)\n                    upload_date_parent_flow = dateutil.parser.parse(\n                        ignore_parameter_values_on_older_children,\n                    )\n                    if upload_date_current_flow &lt; upload_date_parent_flow:\n                        continue\n\n                if ignore_parameter_values:\n                    # Continue needs to be done here as the first if\n                    # statement triggers in both special cases\n                    continue\n            elif (\n                key == \"custom_name\"\n                and ignore_custom_name_if_none\n                and (attr1 is None or attr2 is None)\n            ):\n                # If specified, we allow `custom_name` inequality if one flow's name is None.\n                # Helps with backwards compatibility as `custom_name` is now auto-generated, but\n                # before it used to be `None`.\n                continue\n            elif key == \"parameters_meta_info\":\n                # this value is a dictionary where each key is a parameter name, containing another\n                # dictionary with keys specifying the parameter's 'description' and 'data_type'\n                # checking parameter descriptions can be ignored since that might change\n                # data type check can also be ignored if one of them is not defined, i.e., None\n                params1 = set(flow1.parameters_meta_info)\n                params2 = set(flow2.parameters_meta_info)\n                if params1 != params2:\n                    raise ValueError(\n                        \"Parameter list in meta info for parameters differ in the two flows.\",\n                    )\n                # iterating over the parameter's meta info list\n                for param in params1:\n                    if (\n                        isinstance(flow1.parameters_meta_info[param], Dict)\n                        and isinstance(flow2.parameters_meta_info[param], Dict)\n                        and \"data_type\" in flow1.parameters_meta_info[param]\n                        and \"data_type\" in flow2.parameters_meta_info[param]\n                    ):\n                        value1 = flow1.parameters_meta_info[param][\"data_type\"]\n                        value2 = flow2.parameters_meta_info[param][\"data_type\"]\n                    else:\n                        value1 = flow1.parameters_meta_info[param]\n                        value2 = flow2.parameters_meta_info[param]\n                    if value1 is None or value2 is None:\n                        continue\n\n                    if value1 != value2:\n                        raise ValueError(\n                            f\"Flow {flow1.name}: data type for parameter {param} in {key} differ \"\n                            f\"as {value1}\\nvs\\n{value2}\",\n                        )\n                # the continue is to avoid the 'attr != attr2' check at end of function\n                continue\n\n            if attr1 != attr2:\n                raise ValueError(\n                    f\"Flow {flow1.name!s}: values for attribute '{key!s}' differ: \"\n                    f\"'{attr1!s}'\\nvs\\n'{attr2!s}'.\",\n                )\n</code></pre>"},{"location":"reference/flows/functions/#openml.flows.functions.delete_flow","title":"<code>delete_flow(flow_id)</code>","text":"<p>Delete flow with id <code>flow_id</code> from the OpenML server.</p> <p>You can only delete flows which you uploaded and which which are not linked to runs.</p> <p>Parameters:</p> Name Type Description Default <code>flow_id</code> <code>int</code> <p>OpenML id of the flow</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/flows/functions.py</code> <pre><code>def delete_flow(flow_id: int) -&gt; bool:\n    \"\"\"Delete flow with id `flow_id` from the OpenML server.\n\n    You can only delete flows which you uploaded and which\n    which are not linked to runs.\n\n    Parameters\n    ----------\n    flow_id : int\n        OpenML id of the flow\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"flow\", flow_id)\n</code></pre>"},{"location":"reference/flows/functions/#openml.flows.functions.flow_exists","title":"<code>flow_exists(name, external_version)</code>","text":"<p>Retrieves the flow id.</p> <p>A flow is uniquely identified by name + external_version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>string</code> <p>Name of the flow</p> required <code>external_version</code> <code>string</code> <p>Version information associated with flow.</p> required <p>Returns:</p> Name Type Description <code>flow_exist</code> <code>int or bool</code> <p>flow id iff exists, False otherwise</p> Notes <p>see https://www.openml.org/api_docs/#!/flow/get_flow_exists_name_version</p> Source code in <code>openml/flows/functions.py</code> <pre><code>def flow_exists(name: str, external_version: str) -&gt; int | bool:\n    \"\"\"Retrieves the flow id.\n\n    A flow is uniquely identified by name + external_version.\n\n    Parameters\n    ----------\n    name : string\n        Name of the flow\n    external_version : string\n        Version information associated with flow.\n\n    Returns\n    -------\n    flow_exist : int or bool\n        flow id iff exists, False otherwise\n\n    Notes\n    -----\n    see https://www.openml.org/api_docs/#!/flow/get_flow_exists_name_version\n    \"\"\"\n    if not (isinstance(name, str) and len(name) &gt; 0):\n        raise ValueError(\"Argument 'name' should be a non-empty string\")\n    if not (isinstance(name, str) and len(external_version) &gt; 0):\n        raise ValueError(\"Argument 'version' should be a non-empty string\")\n\n    xml_response = openml._api_calls._perform_api_call(\n        \"flow/exists\",\n        \"post\",\n        data={\"name\": name, \"external_version\": external_version},\n    )\n\n    result_dict = xmltodict.parse(xml_response)\n    flow_id = int(result_dict[\"oml:flow_exists\"][\"oml:id\"])\n    return flow_id if flow_id &gt; 0 else False\n</code></pre>"},{"location":"reference/flows/functions/#openml.flows.functions.get_flow","title":"<code>get_flow(flow_id, reinstantiate=False, strict_version=True)</code>","text":"<p>Download the OpenML flow for a given flow ID.</p> <p>Parameters:</p> Name Type Description Default <code>flow_id</code> <code>int</code> <p>The OpenML flow id.</p> required <code>reinstantiate</code> <code>bool</code> <p>Whether to reinstantiate the flow to a model instance.</p> <code>False</code> <code>strict_version</code> <code>bool</code> <p>Whether to fail if version requirements are not fulfilled.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>flow</code> <code>OpenMLFlow</code> <p>the flow</p> Source code in <code>openml/flows/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_flow(flow_id: int, reinstantiate: bool = False, strict_version: bool = True) -&gt; OpenMLFlow:  # noqa: FBT001, FBT002\n    \"\"\"Download the OpenML flow for a given flow ID.\n\n    Parameters\n    ----------\n    flow_id : int\n        The OpenML flow id.\n\n    reinstantiate: bool\n        Whether to reinstantiate the flow to a model instance.\n\n    strict_version : bool, default=True\n        Whether to fail if version requirements are not fulfilled.\n\n    Returns\n    -------\n    flow : OpenMLFlow\n        the flow\n    \"\"\"\n    flow_id = int(flow_id)\n    flow = _get_flow_description(flow_id)\n\n    if reinstantiate:\n        flow.model = flow.extension.flow_to_model(flow, strict_version=strict_version)\n        if not strict_version:\n            # check if we need to return a new flow b/c of version mismatch\n            new_flow = flow.extension.model_to_flow(flow.model)\n            if new_flow.dependencies != flow.dependencies:\n                return new_flow\n    return flow\n</code></pre>"},{"location":"reference/flows/functions/#openml.flows.functions.get_flow_id","title":"<code>get_flow_id(model=None, name=None, exact_version=True)</code>","text":"<p>Retrieves the flow id for a model or a flow name.</p> <p>Provide either a model or a name to this function. Depending on the input, it does</p> <ul> <li><code>model</code> and <code>exact_version == True</code>: This helper function first queries for the necessary   extension. Second, it uses that extension to convert the model into a flow. Third, it   executes <code>flow_exists</code> to potentially obtain the flow id the flow is published to the   server.</li> <li><code>model</code> and <code>exact_version == False</code>: This helper function first queries for the   necessary extension. Second, it uses that extension to convert the model into a flow. Third   it calls <code>list_flows</code> and filters the returned values based on the flow name.</li> <li><code>name</code>: Ignores <code>exact_version</code> and calls <code>list_flows</code>, then filters the returned   values based on the flow name.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>Any model. Must provide either <code>model</code> or <code>name</code>.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the flow. Must provide either <code>model</code> or <code>name</code>.</p> <code>None</code> <code>exact_version</code> <code>bool</code> <p>Whether to return the flow id of the exact version or all flow ids where the name of the flow matches. This is only taken into account for a model where a version number is available (requires <code>model</code> to be set).</p> <code>True</code> <p>Returns:</p> Type Description <code>(int or bool, List)</code> <p>flow id iff exists, <code>False</code> otherwise, List if <code>exact_version is False</code></p> Source code in <code>openml/flows/functions.py</code> <pre><code>def get_flow_id(\n    model: Any | None = None,\n    name: str | None = None,\n    exact_version: bool = True,  # noqa: FBT001, FBT002\n) -&gt; int | bool | list[int]:\n    \"\"\"Retrieves the flow id for a model or a flow name.\n\n    Provide either a model or a name to this function. Depending on the input, it does\n\n    * ``model`` and ``exact_version == True``: This helper function first queries for the necessary\n      extension. Second, it uses that extension to convert the model into a flow. Third, it\n      executes ``flow_exists`` to potentially obtain the flow id the flow is published to the\n      server.\n    * ``model`` and ``exact_version == False``: This helper function first queries for the\n      necessary extension. Second, it uses that extension to convert the model into a flow. Third\n      it calls ``list_flows`` and filters the returned values based on the flow name.\n    * ``name``: Ignores ``exact_version`` and calls ``list_flows``, then filters the returned\n      values based on the flow name.\n\n    Parameters\n    ----------\n    model : object\n        Any model. Must provide either ``model`` or ``name``.\n    name : str\n        Name of the flow. Must provide either ``model`` or ``name``.\n    exact_version : bool\n        Whether to return the flow id of the exact version or all flow ids where the name\n        of the flow matches. This is only taken into account for a model where a version number\n        is available (requires ``model`` to be set).\n\n    Returns\n    -------\n    int or bool, List\n        flow id iff exists, ``False`` otherwise, List if ``exact_version is False``\n    \"\"\"\n    if model is not None and name is not None:\n        raise ValueError(\"Must provide either argument `model` or argument `name`, but not both.\")\n\n    if model is not None:\n        extension = openml.extensions.get_extension_by_model(model, raise_if_no_extension=True)\n        if extension is None:\n            # This should never happen and is only here to please mypy will be gone soon once the\n            # whole function is removed\n            raise TypeError(extension)\n        flow = extension.model_to_flow(model)\n        flow_name = flow.name\n        external_version = flow.external_version\n    elif name is not None:\n        flow_name = name\n        exact_version = False\n        external_version = None\n    else:\n        raise ValueError(\n            \"Need to provide either argument `model` or argument `name`, but both are `None`.\"\n        )\n\n    if exact_version:\n        if external_version is None:\n            raise ValueError(\"exact_version should be False if model is None!\")\n        return flow_exists(name=flow_name, external_version=external_version)\n\n    flows = list_flows()\n    flows = flows.query(f'name == \"{flow_name}\"')\n    return flows[\"id\"].to_list()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"reference/flows/functions/#openml.flows.functions.list_flows","title":"<code>list_flows(offset=None, size=None, tag=None, uploader=None)</code>","text":"<p>Return a list of all flows which are on OpenML. (Supports large amount of results)</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>the number of flows to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of flows to return</p> <code>None</code> <code>tag</code> <code>str</code> <p>the tag to include</p> <code>None</code> <code>kwargs</code> <p>Legal filter operators: uploader.</p> required <p>Returns:</p> Name Type Description <code>flows</code> <code>dataframe</code> <p>Each row maps to a dataset Each column contains the following information: - flow id - full name - name - version - external version - uploader</p> Source code in <code>openml/flows/functions.py</code> <pre><code>def list_flows(\n    offset: int | None = None,\n    size: int | None = None,\n    tag: str | None = None,\n    uploader: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a list of all flows which are on OpenML.\n    (Supports large amount of results)\n\n    Parameters\n    ----------\n    offset : int, optional\n        the number of flows to skip, starting from the first\n    size : int, optional\n        the maximum number of flows to return\n    tag : str, optional\n        the tag to include\n    kwargs: dict, optional\n        Legal filter operators: uploader.\n\n    Returns\n    -------\n    flows : dataframe\n            Each row maps to a dataset\n            Each column contains the following information:\n            - flow id\n            - full name\n            - name\n            - version\n            - external version\n            - uploader\n    \"\"\"\n    listing_call = partial(_list_flows, tag=tag, uploader=uploader)\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/runs/","title":"runs","text":""},{"location":"reference/runs/#openml.runs.OpenMLRun","title":"<code>OpenMLRun</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Run: result of running a model on an OpenML dataset.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The ID of the OpenML task associated with the run.</p> required <code>flow_id</code> <code>int | None</code> <p>The ID of the OpenML flow associated with the run.</p> required <code>dataset_id</code> <code>int | None</code> <p>The ID of the OpenML dataset used for the run.</p> required <code>setup_string</code> <code>str | None</code> <p>The setup string of the run.</p> <code>None</code> <code>output_files</code> <code>dict[str, int] | None</code> <p>Specifies where each related file can be found.</p> <code>None</code> <code>setup_id</code> <code>int | None</code> <p>An integer representing the ID of the setup used for the run.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Representing the tags associated with the run.</p> <code>None</code> <code>uploader</code> <code>int | None</code> <p>User ID of the uploader.</p> <code>None</code> <code>uploader_name</code> <code>str | None</code> <p>The name of the person who uploaded the run.</p> <code>None</code> <code>evaluations</code> <code>dict | None</code> <p>Representing the evaluations of the run.</p> <code>None</code> <code>fold_evaluations</code> <code>dict | None</code> <p>The evaluations of the run for each fold.</p> <code>None</code> <code>sample_evaluations</code> <code>dict | None</code> <p>The evaluations of the run for each sample.</p> <code>None</code> <code>data_content</code> <code>list[list] | None</code> <p>The predictions generated from executing this run.</p> <code>None</code> <code>trace</code> <code>OpenMLRunTrace | None</code> <p>The trace containing information on internal model evaluations of this run.</p> <code>None</code> <code>model</code> <code>object | None</code> <p>The untrained model that was evaluated in the run.</p> <code>None</code> <code>task_type</code> <code>str | None</code> <p>The type of the OpenML task associated with the run.</p> <code>None</code> <code>task_evaluation_measure</code> <code>str | None</code> <p>The evaluation measure used for the task.</p> <code>None</code> <code>flow_name</code> <code>str | None</code> <p>The name of the OpenML flow associated with the run.</p> <code>None</code> <code>parameter_settings</code> <code>list[dict[str, Any]] | None</code> <p>Representing the parameter settings used for the run.</p> <code>None</code> <code>predictions_url</code> <code>str | None</code> <p>The URL of the predictions file.</p> <code>None</code> <code>task</code> <code>OpenMLTask | None</code> <p>An instance of the OpenMLTask class, representing the OpenML task associated with the run.</p> <code>None</code> <code>flow</code> <code>OpenMLFlow | None</code> <p>An instance of the OpenMLFlow class, representing the OpenML flow associated with the run.</p> <code>None</code> <code>run_id</code> <code>int | None</code> <p>The ID of the run.</p> <code>None</code> <code>description_text</code> <code>str | None</code> <p>Description text to add to the predictions file. If left None, is set to the time the arff file is generated.</p> <code>None</code> <code>run_details</code> <code>str | None</code> <p>Description of the run stored in the run meta-data.</p> <code>None</code> Source code in <code>openml/runs/run.py</code> <pre><code>class OpenMLRun(OpenMLBase):\n    \"\"\"OpenML Run: result of running a model on an OpenML dataset.\n\n    Parameters\n    ----------\n    task_id: int\n        The ID of the OpenML task associated with the run.\n    flow_id: int\n        The ID of the OpenML flow associated with the run.\n    dataset_id: int\n        The ID of the OpenML dataset used for the run.\n    setup_string: str\n        The setup string of the run.\n    output_files: Dict[str, int]\n        Specifies where each related file can be found.\n    setup_id: int\n        An integer representing the ID of the setup used for the run.\n    tags: List[str]\n        Representing the tags associated with the run.\n    uploader: int\n        User ID of the uploader.\n    uploader_name: str\n        The name of the person who uploaded the run.\n    evaluations: Dict\n        Representing the evaluations of the run.\n    fold_evaluations: Dict\n        The evaluations of the run for each fold.\n    sample_evaluations: Dict\n        The evaluations of the run for each sample.\n    data_content: List[List]\n        The predictions generated from executing this run.\n    trace: OpenMLRunTrace\n        The trace containing information on internal model evaluations of this run.\n    model: object\n        The untrained model that was evaluated in the run.\n    task_type: str\n        The type of the OpenML task associated with the run.\n    task_evaluation_measure: str\n        The evaluation measure used for the task.\n    flow_name: str\n        The name of the OpenML flow associated with the run.\n    parameter_settings: list[OrderedDict]\n        Representing the parameter settings used for the run.\n    predictions_url: str\n        The URL of the predictions file.\n    task: OpenMLTask\n        An instance of the OpenMLTask class, representing the OpenML task associated\n        with the run.\n    flow: OpenMLFlow\n        An instance of the OpenMLFlow class, representing the OpenML flow associated\n        with the run.\n    run_id: int\n        The ID of the run.\n    description_text: str, optional\n        Description text to add to the predictions file. If left None, is set to the\n        time the arff file is generated.\n    run_details: str, optional (default=None)\n        Description of the run stored in the run meta-data.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_id: int,\n        flow_id: int | None,\n        dataset_id: int | None,\n        setup_string: str | None = None,\n        output_files: dict[str, int] | None = None,\n        setup_id: int | None = None,\n        tags: list[str] | None = None,\n        uploader: int | None = None,\n        uploader_name: str | None = None,\n        evaluations: dict | None = None,\n        fold_evaluations: dict | None = None,\n        sample_evaluations: dict | None = None,\n        data_content: list[list] | None = None,\n        trace: OpenMLRunTrace | None = None,\n        model: object | None = None,\n        task_type: str | None = None,\n        task_evaluation_measure: str | None = None,\n        flow_name: str | None = None,\n        parameter_settings: list[dict[str, Any]] | None = None,\n        predictions_url: str | None = None,\n        task: OpenMLTask | None = None,\n        flow: OpenMLFlow | None = None,\n        run_id: int | None = None,\n        description_text: str | None = None,\n        run_details: str | None = None,\n    ):\n        self.uploader = uploader\n        self.uploader_name = uploader_name\n        self.task_id = task_id\n        self.task_type = task_type\n        self.task_evaluation_measure = task_evaluation_measure\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.setup_id = setup_id\n        self.setup_string = setup_string\n        self.parameter_settings = parameter_settings\n        self.dataset_id = dataset_id\n        self.evaluations = evaluations\n        self.fold_evaluations = fold_evaluations\n        self.sample_evaluations = sample_evaluations\n        self.data_content = data_content\n        self.output_files = output_files\n        self.trace = trace\n        self.error_message = None\n        self.task = task\n        self.flow = flow\n        self.run_id = run_id\n        self.model = model\n        self.tags = tags\n        self.predictions_url = predictions_url\n        self.description_text = description_text\n        self.run_details = run_details\n        self._predictions = None\n\n    @property\n    def predictions(self) -&gt; pd.DataFrame:\n        \"\"\"Return a DataFrame with predictions for this run\"\"\"\n        if self._predictions is None:\n            if self.data_content:\n                arff_dict = self._generate_arff_dict()\n            elif self.predictions_url:\n                arff_text = openml._api_calls._download_text_file(self.predictions_url)\n                arff_dict = arff.loads(arff_text)\n            else:\n                raise RuntimeError(\"Run has no predictions.\")\n            self._predictions = pd.DataFrame(\n                arff_dict[\"data\"],\n                columns=[name for name, _ in arff_dict[\"attributes\"]],\n            )\n        return self._predictions\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"The ID of the run, None if not uploaded to the server yet.\"\"\"\n        return self.run_id\n\n    def _evaluation_summary(self, metric: str) -&gt; str:\n        \"\"\"Summarizes the evaluation of a metric over all folds.\n\n        The fold scores for the metric must exist already. During run creation,\n        by default, the MAE for OpenMLRegressionTask and the accuracy for\n        OpenMLClassificationTask/OpenMLLearningCurveTasktasks are computed.\n\n        If repetition exist, we take the mean over all repetitions.\n\n        Parameters\n        ----------\n        metric: str\n            Name of an evaluation metric that was used to compute fold scores.\n\n        Returns\n        -------\n        metric_summary: str\n            A formatted string that displays the metric's evaluation summary.\n            The summary consists of the mean and std.\n        \"\"\"\n        if self.fold_evaluations is None:\n            raise ValueError(\"No fold evaluations available.\")\n        fold_score_lists = self.fold_evaluations[metric].values()\n\n        # Get the mean and std over all repetitions\n        rep_means = [np.mean(list(x.values())) for x in fold_score_lists]\n        rep_stds = [np.std(list(x.values())) for x in fold_score_lists]\n\n        return f\"{np.mean(rep_means):.4f} +- {np.mean(rep_stds):.4f}\"\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        # Set up fields\n        fields = {\n            \"Uploader Name\": self.uploader_name,\n            \"Metric\": self.task_evaluation_measure,\n            \"Run ID\": self.run_id,\n            \"Task ID\": self.task_id,\n            \"Task Type\": self.task_type,\n            \"Task URL\": openml.tasks.OpenMLTask.url_for_id(self.task_id),\n            \"Flow ID\": self.flow_id,\n            \"Flow Name\": self.flow_name,\n            \"Flow URL\": (\n                openml.flows.OpenMLFlow.url_for_id(self.flow_id)\n                if self.flow_id is not None\n                else None\n            ),\n            \"Setup ID\": self.setup_id,\n            \"Setup String\": self.setup_string,\n            \"Dataset ID\": self.dataset_id,\n            \"Dataset URL\": (\n                openml.datasets.OpenMLDataset.url_for_id(self.dataset_id)\n                if self.dataset_id is not None\n                else None\n            ),\n        }\n\n        # determines the order of the initial fields in which the information will be printed\n        order = [\"Uploader Name\", \"Uploader Profile\", \"Metric\", \"Result\"]\n\n        if self.uploader is not None:\n            fields[\"Uploader Profile\"] = f\"{openml.config.get_server_base_url()}/u/{self.uploader}\"\n        if self.run_id is not None:\n            fields[\"Run URL\"] = self.openml_url\n        if self.evaluations is not None and self.task_evaluation_measure in self.evaluations:\n            fields[\"Result\"] = self.evaluations[self.task_evaluation_measure]\n        elif self.fold_evaluations is not None:\n            # -- Add locally computed summary values if possible\n            if \"predictive_accuracy\" in self.fold_evaluations:\n                # OpenMLClassificationTask; OpenMLLearningCurveTask\n                result_field = \"Local Result - Accuracy (+- STD)\"\n                fields[result_field] = self._evaluation_summary(\"predictive_accuracy\")\n                order.append(result_field)\n            elif \"mean_absolute_error\" in self.fold_evaluations:\n                # OpenMLRegressionTask\n                result_field = \"Local Result - MAE (+- STD)\"\n                fields[result_field] = self._evaluation_summary(\"mean_absolute_error\")\n                order.append(result_field)\n\n            if \"usercpu_time_millis\" in self.fold_evaluations:\n                # Runtime should be available for most tasks types\n                rt_field = \"Local Runtime - ms (+- STD)\"\n                fields[rt_field] = self._evaluation_summary(\"usercpu_time_millis\")\n                order.append(rt_field)\n\n        # determines the remaining order\n        order += [\n            \"Run ID\",\n            \"Run URL\",\n            \"Task ID\",\n            \"Task Type\",\n            \"Task URL\",\n            \"Flow ID\",\n            \"Flow Name\",\n            \"Flow URL\",\n            \"Setup ID\",\n            \"Setup String\",\n            \"Dataset ID\",\n            \"Dataset URL\",\n        ]\n        return [\n            (key, \"None\" if fields[key] is None else fields[key])  # type: ignore\n            for key in order\n            if key in fields\n        ]\n\n    @classmethod\n    def from_filesystem(cls, directory: str | Path, expect_model: bool = True) -&gt; OpenMLRun:  # noqa: FBT001, FBT002\n        \"\"\"\n        The inverse of the to_filesystem method. Instantiates an OpenMLRun\n        object based on files stored on the file system.\n\n        Parameters\n        ----------\n        directory : str\n            a path leading to the folder where the results\n            are stored\n\n        expect_model : bool\n            if True, it requires the model pickle to be present, and an error\n            will be thrown if not. Otherwise, the model might or might not\n            be present.\n\n        Returns\n        -------\n        run : OpenMLRun\n            the re-instantiated run object\n        \"\"\"\n        # Avoiding cyclic imports\n        import openml.runs.functions\n\n        directory = Path(directory)\n        if not directory.is_dir():\n            raise ValueError(\"Could not find folder\")\n\n        description_path = directory / \"description.xml\"\n        predictions_path = directory / \"predictions.arff\"\n        trace_path = directory / \"trace.arff\"\n        model_path = directory / \"model.pkl\"\n\n        if not description_path.is_file():\n            raise ValueError(\"Could not find description.xml\")\n        if not predictions_path.is_file():\n            raise ValueError(\"Could not find predictions.arff\")\n        if (not model_path.is_file()) and expect_model:\n            raise ValueError(\"Could not find model.pkl\")\n\n        with description_path.open() as fht:\n            xml_string = fht.read()\n        run = openml.runs.functions._create_run_from_xml(xml_string, from_server=False)\n\n        if run.flow_id is None:\n            flow = openml.flows.OpenMLFlow.from_filesystem(directory)\n            run.flow = flow\n            run.flow_name = flow.name\n\n        with predictions_path.open() as fht:\n            predictions = arff.load(fht)\n            run.data_content = predictions[\"data\"]\n\n        if model_path.is_file():\n            # note that it will load the model if the file exists, even if\n            # expect_model is False\n            with model_path.open(\"rb\") as fhb:\n                run.model = pickle.load(fhb)  # noqa: S301\n\n        if trace_path.is_file():\n            run.trace = openml.runs.OpenMLRunTrace._from_filesystem(trace_path)\n\n        return run\n\n    def to_filesystem(\n        self,\n        directory: str | Path,\n        store_model: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; None:\n        \"\"\"\n        The inverse of the from_filesystem method. Serializes a run\n        on the filesystem, to be uploaded later.\n\n        Parameters\n        ----------\n        directory : str\n            a path leading to the folder where the results\n            will be stored. Should be empty\n\n        store_model : bool, optional (default=True)\n            if True, a model will be pickled as well. As this is the most\n            storage expensive part, it is often desirable to not store the\n            model.\n        \"\"\"\n        if self.data_content is None or self.model is None:\n            raise ValueError(\"Run should have been executed (and contain \" \"model / predictions)\")\n        directory = Path(directory)\n        directory.mkdir(exist_ok=True, parents=True)\n\n        if any(directory.iterdir()):\n            raise ValueError(f\"Output directory {directory.expanduser().resolve()} should be empty\")\n\n        run_xml = self._to_xml()\n        predictions_arff = arff.dumps(self._generate_arff_dict())\n\n        # It seems like typing does not allow to define the same variable multiple times\n        with (directory / \"description.xml\").open(\"w\") as fh:\n            fh.write(run_xml)\n        with (directory / \"predictions.arff\").open(\"w\") as fh:\n            fh.write(predictions_arff)\n        if store_model:\n            with (directory / \"model.pkl\").open(\"wb\") as fh_b:\n                pickle.dump(self.model, fh_b)\n\n        if self.flow_id is None and self.flow is not None:\n            self.flow.to_filesystem(directory)\n\n        if self.trace is not None:\n            self.trace._to_filesystem(directory)\n\n    def _generate_arff_dict(self) -&gt; OrderedDict[str, Any]:\n        \"\"\"Generates the arff dictionary for uploading predictions to the\n        server.\n\n        Assumes that the run has been executed.\n\n        The order of the attributes follows the order defined by the Client API for R.\n\n        Returns\n        -------\n        arf_dict : dict\n            Dictionary representation of the ARFF file that will be uploaded.\n            Contains predictions and information about the run environment.\n        \"\"\"\n        if self.data_content is None:\n            raise ValueError(\"Run has not been executed.\")\n        if self.flow is None:\n            assert self.flow_id is not None, \"Run has no associated flow id!\"\n            self.flow = get_flow(self.flow_id)\n\n        if self.description_text is None:\n            self.description_text = time.strftime(\"%c\")\n        task = get_task(self.task_id)\n\n        arff_dict = OrderedDict()  # type: 'OrderedDict[str, Any]'\n        arff_dict[\"data\"] = self.data_content\n        arff_dict[\"description\"] = self.description_text\n        arff_dict[\"relation\"] = f\"openml_task_{task.task_id}_predictions\"\n\n        if isinstance(task, OpenMLLearningCurveTask):\n            class_labels = task.class_labels\n            instance_specifications = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"sample\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n            ]\n\n            arff_dict[\"attributes\"] = instance_specifications\n            if class_labels is not None:\n                arff_dict[\"attributes\"] = (\n                    arff_dict[\"attributes\"]\n                    + [(\"prediction\", class_labels), (\"correct\", class_labels)]\n                    + [\n                        (\"confidence.\" + class_labels[i], \"NUMERIC\")\n                        for i in range(len(class_labels))\n                    ]\n                )\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n        elif isinstance(task, OpenMLClassificationTask):\n            class_labels = task.class_labels\n            instance_specifications = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"sample\", \"NUMERIC\"),  # Legacy\n                (\"row_id\", \"NUMERIC\"),\n            ]\n\n            arff_dict[\"attributes\"] = instance_specifications\n            if class_labels is not None:\n                prediction_confidences = [\n                    (\"confidence.\" + class_labels[i], \"NUMERIC\") for i in range(len(class_labels))\n                ]\n                prediction_and_true = [(\"prediction\", class_labels), (\"correct\", class_labels)]\n                arff_dict[\"attributes\"] = (\n                    arff_dict[\"attributes\"] + prediction_and_true + prediction_confidences\n                )\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n        elif isinstance(task, OpenMLRegressionTask):\n            arff_dict[\"attributes\"] = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n                (\"prediction\", \"NUMERIC\"),\n                (\"truth\", \"NUMERIC\"),\n            ]\n\n        elif isinstance(task, OpenMLClusteringTask):\n            arff_dict[\"attributes\"] = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n                (\"cluster\", \"NUMERIC\"),\n            ]\n\n        else:\n            raise NotImplementedError(f\"Task type {task.task_type!s} is not yet supported.\")\n\n        return arff_dict\n\n    def get_metric_fn(self, sklearn_fn: Callable, kwargs: dict | None = None) -&gt; np.ndarray:  # noqa: PLR0915, PLR0912, C901\n        \"\"\"Calculates metric scores based on predicted values. Assumes the\n        run has been executed locally (and contains run_data). Furthermore,\n        it assumes that the 'correct' or 'truth' attribute is specified in\n        the arff (which is an optional field, but always the case for\n        openml-python runs)\n\n        Parameters\n        ----------\n        sklearn_fn : function\n            a function pointer to a sklearn function that\n            accepts ``y_true``, ``y_pred`` and ``**kwargs``\n        kwargs : dict\n            kwargs for the function\n\n        Returns\n        -------\n        scores : ndarray of scores of length num_folds * num_repeats\n            metric results\n        \"\"\"\n        kwargs = kwargs if kwargs else {}\n        if self.data_content is not None and self.task_id is not None:\n            predictions_arff = self._generate_arff_dict()\n        elif (self.output_files is not None) and (\"predictions\" in self.output_files):\n            predictions_file_url = openml._api_calls._file_id_to_url(\n                self.output_files[\"predictions\"],\n                \"predictions.arff\",\n            )\n            response = openml._api_calls._download_text_file(predictions_file_url)\n            predictions_arff = arff.loads(response)\n            # TODO: make this a stream reader\n        else:\n            raise ValueError(\n                \"Run should have been locally executed or \" \"contain outputfile reference.\",\n            )\n\n        # Need to know more about the task to compute scores correctly\n        task = get_task(self.task_id)\n\n        attribute_names = [att[0] for att in predictions_arff[\"attributes\"]]\n        if (\n            task.task_type_id in [TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE]\n            and \"correct\" not in attribute_names\n        ):\n            raise ValueError('Attribute \"correct\" should be set for ' \"classification task runs\")\n        if task.task_type_id == TaskType.SUPERVISED_REGRESSION and \"truth\" not in attribute_names:\n            raise ValueError('Attribute \"truth\" should be set for ' \"regression task runs\")\n        if task.task_type_id != TaskType.CLUSTERING and \"prediction\" not in attribute_names:\n            raise ValueError('Attribute \"predict\" should be set for ' \"supervised task runs\")\n\n        def _attribute_list_to_dict(attribute_list):  # type: ignore\n            # convenience function: Creates a mapping to map from the name of\n            # attributes present in the arff prediction file to their index.\n            # This is necessary because the number of classes can be different\n            # for different tasks.\n            res = OrderedDict()\n            for idx in range(len(attribute_list)):\n                res[attribute_list[idx][0]] = idx\n            return res\n\n        attribute_dict = _attribute_list_to_dict(predictions_arff[\"attributes\"])\n\n        repeat_idx = attribute_dict[\"repeat\"]\n        fold_idx = attribute_dict[\"fold\"]\n        predicted_idx = attribute_dict[\"prediction\"]  # Assume supervised task\n\n        if task.task_type_id in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n            correct_idx = attribute_dict[\"correct\"]\n        elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n            correct_idx = attribute_dict[\"truth\"]\n        has_samples = False\n        if \"sample\" in attribute_dict:\n            sample_idx = attribute_dict[\"sample\"]\n            has_samples = True\n\n        if (\n            predictions_arff[\"attributes\"][predicted_idx][1]\n            != predictions_arff[\"attributes\"][correct_idx][1]\n        ):\n            pred = predictions_arff[\"attributes\"][predicted_idx][1]\n            corr = predictions_arff[\"attributes\"][correct_idx][1]\n            raise ValueError(\n                \"Predicted and Correct do not have equal values:\" f\" {pred!s} Vs. {corr!s}\",\n            )\n\n        # TODO: these could be cached\n        values_predict: dict[int, dict[int, dict[int, list[float]]]] = {}\n        values_correct: dict[int, dict[int, dict[int, list[float]]]] = {}\n        for _line_idx, line in enumerate(predictions_arff[\"data\"]):\n            rep = line[repeat_idx]\n            fold = line[fold_idx]\n            samp = line[sample_idx] if has_samples else 0\n\n            if task.task_type_id in [\n                TaskType.SUPERVISED_CLASSIFICATION,\n                TaskType.LEARNING_CURVE,\n            ]:\n                prediction = predictions_arff[\"attributes\"][predicted_idx][1].index(\n                    line[predicted_idx],\n                )\n                correct = predictions_arff[\"attributes\"][predicted_idx][1].index(line[correct_idx])\n            elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n                prediction = line[predicted_idx]\n                correct = line[correct_idx]\n            if rep not in values_predict:\n                values_predict[rep] = OrderedDict()\n                values_correct[rep] = OrderedDict()\n            if fold not in values_predict[rep]:\n                values_predict[rep][fold] = OrderedDict()\n                values_correct[rep][fold] = OrderedDict()\n            if samp not in values_predict[rep][fold]:\n                values_predict[rep][fold][samp] = []\n                values_correct[rep][fold][samp] = []\n\n            values_predict[rep][fold][samp].append(prediction)\n            values_correct[rep][fold][samp].append(correct)\n\n        scores = []\n        for rep in values_predict:\n            for fold in values_predict[rep]:\n                last_sample = len(values_predict[rep][fold]) - 1\n                y_pred = values_predict[rep][fold][last_sample]\n                y_true = values_correct[rep][fold][last_sample]\n                scores.append(sklearn_fn(y_true, y_pred, **kwargs))\n        return np.array(scores)\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.run_id = int(xml_response[\"oml:upload_run\"][\"oml:run_id\"])\n\n    def _get_file_elements(self) -&gt; dict:\n        \"\"\"Get file_elements to upload to the server.\n\n        Derived child classes should overwrite this method as necessary.\n        The description field will be populated automatically if not provided.\n        \"\"\"\n        if self.parameter_settings is None and self.model is None:\n            raise PyOpenMLError(\n                \"OpenMLRun must contain a model or be initialized with parameter_settings.\",\n            )\n        if self.flow_id is None:\n            if self.flow is None:\n                raise PyOpenMLError(\n                    \"OpenMLRun object does not contain a flow id or reference to OpenMLFlow \"\n                    \"(these should have been added while executing the task). \",\n                )\n\n            # publish the linked Flow before publishing the run.\n            self.flow.publish()\n            self.flow_id = self.flow.flow_id\n\n        if self.parameter_settings is None:\n            if self.flow is None:\n                assert self.flow_id is not None  # for mypy\n                self.flow = openml.flows.get_flow(self.flow_id)\n            self.parameter_settings = self.flow.extension.obtain_parameter_values(\n                self.flow,\n                self.model,\n            )\n\n        file_elements = {\"description\": (\"description.xml\", self._to_xml())}\n\n        if self.error_message is None:\n            predictions = arff.dumps(self._generate_arff_dict())\n            file_elements[\"predictions\"] = (\"predictions.arff\", predictions)\n\n        if self.trace is not None:\n            trace_arff = arff.dumps(self.trace.trace_to_arff())\n            file_elements[\"trace\"] = (\"trace.arff\", trace_arff)\n        return file_elements\n\n    def _to_dict(self) -&gt; dict[str, dict]:  # noqa: PLR0912, C901\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        description = OrderedDict()  # type: 'OrderedDict'\n        description[\"oml:run\"] = OrderedDict()\n        description[\"oml:run\"][\"@xmlns:oml\"] = \"http://openml.org/openml\"\n        description[\"oml:run\"][\"oml:task_id\"] = self.task_id\n        description[\"oml:run\"][\"oml:flow_id\"] = self.flow_id\n        if self.setup_string is not None:\n            description[\"oml:run\"][\"oml:setup_string\"] = self.setup_string\n        if self.error_message is not None:\n            description[\"oml:run\"][\"oml:error_message\"] = self.error_message\n        if self.run_details is not None:\n            description[\"oml:run\"][\"oml:run_details\"] = self.run_details\n        description[\"oml:run\"][\"oml:parameter_setting\"] = self.parameter_settings\n        if self.tags is not None:\n            description[\"oml:run\"][\"oml:tag\"] = self.tags\n        if (self.fold_evaluations is not None and len(self.fold_evaluations) &gt; 0) or (\n            self.sample_evaluations is not None and len(self.sample_evaluations) &gt; 0\n        ):\n            description[\"oml:run\"][\"oml:output_data\"] = OrderedDict()\n            description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"] = []\n        if self.fold_evaluations is not None:\n            for measure in self.fold_evaluations:\n                for repeat in self.fold_evaluations[measure]:\n                    for fold, value in self.fold_evaluations[measure][repeat].items():\n                        current = OrderedDict(\n                            [\n                                (\"@repeat\", str(repeat)),\n                                (\"@fold\", str(fold)),\n                                (\"oml:name\", measure),\n                                (\"oml:value\", str(value)),\n                            ],\n                        )\n                        description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"].append(current)\n        if self.sample_evaluations is not None:\n            for measure in self.sample_evaluations:\n                for repeat in self.sample_evaluations[measure]:\n                    for fold in self.sample_evaluations[measure][repeat]:\n                        for sample, value in self.sample_evaluations[measure][repeat][fold].items():\n                            current = OrderedDict(\n                                [\n                                    (\"@repeat\", str(repeat)),\n                                    (\"@fold\", str(fold)),\n                                    (\"@sample\", str(sample)),\n                                    (\"oml:name\", measure),\n                                    (\"oml:value\", str(value)),\n                                ],\n                            )\n                            description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"].append(\n                                current,\n                            )\n        return description\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRun.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>The ID of the run, None if not uploaded to the server yet.</p>"},{"location":"reference/runs/#openml.runs.OpenMLRun.predictions","title":"<code>predictions: pd.DataFrame</code>  <code>property</code>","text":"<p>Return a DataFrame with predictions for this run</p>"},{"location":"reference/runs/#openml.runs.OpenMLRun.from_filesystem","title":"<code>from_filesystem(directory, expect_model=True)</code>  <code>classmethod</code>","text":"<p>The inverse of the to_filesystem method. Instantiates an OpenMLRun object based on files stored on the file system.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>a path leading to the folder where the results are stored</p> required <code>expect_model</code> <code>bool</code> <p>if True, it requires the model pickle to be present, and an error will be thrown if not. Otherwise, the model might or might not be present.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>the re-instantiated run object</p> Source code in <code>openml/runs/run.py</code> <pre><code>@classmethod\ndef from_filesystem(cls, directory: str | Path, expect_model: bool = True) -&gt; OpenMLRun:  # noqa: FBT001, FBT002\n    \"\"\"\n    The inverse of the to_filesystem method. Instantiates an OpenMLRun\n    object based on files stored on the file system.\n\n    Parameters\n    ----------\n    directory : str\n        a path leading to the folder where the results\n        are stored\n\n    expect_model : bool\n        if True, it requires the model pickle to be present, and an error\n        will be thrown if not. Otherwise, the model might or might not\n        be present.\n\n    Returns\n    -------\n    run : OpenMLRun\n        the re-instantiated run object\n    \"\"\"\n    # Avoiding cyclic imports\n    import openml.runs.functions\n\n    directory = Path(directory)\n    if not directory.is_dir():\n        raise ValueError(\"Could not find folder\")\n\n    description_path = directory / \"description.xml\"\n    predictions_path = directory / \"predictions.arff\"\n    trace_path = directory / \"trace.arff\"\n    model_path = directory / \"model.pkl\"\n\n    if not description_path.is_file():\n        raise ValueError(\"Could not find description.xml\")\n    if not predictions_path.is_file():\n        raise ValueError(\"Could not find predictions.arff\")\n    if (not model_path.is_file()) and expect_model:\n        raise ValueError(\"Could not find model.pkl\")\n\n    with description_path.open() as fht:\n        xml_string = fht.read()\n    run = openml.runs.functions._create_run_from_xml(xml_string, from_server=False)\n\n    if run.flow_id is None:\n        flow = openml.flows.OpenMLFlow.from_filesystem(directory)\n        run.flow = flow\n        run.flow_name = flow.name\n\n    with predictions_path.open() as fht:\n        predictions = arff.load(fht)\n        run.data_content = predictions[\"data\"]\n\n    if model_path.is_file():\n        # note that it will load the model if the file exists, even if\n        # expect_model is False\n        with model_path.open(\"rb\") as fhb:\n            run.model = pickle.load(fhb)  # noqa: S301\n\n    if trace_path.is_file():\n        run.trace = openml.runs.OpenMLRunTrace._from_filesystem(trace_path)\n\n    return run\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRun.get_metric_fn","title":"<code>get_metric_fn(sklearn_fn, kwargs=None)</code>","text":"<p>Calculates metric scores based on predicted values. Assumes the run has been executed locally (and contains run_data). Furthermore, it assumes that the 'correct' or 'truth' attribute is specified in the arff (which is an optional field, but always the case for openml-python runs)</p> <p>Parameters:</p> Name Type Description Default <code>sklearn_fn</code> <code>function</code> <p>a function pointer to a sklearn function that accepts <code>y_true</code>, <code>y_pred</code> and <code>**kwargs</code></p> required <code>kwargs</code> <code>dict</code> <p>kwargs for the function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>scores</code> <code>ndarray of scores of length num_folds * num_repeats</code> <p>metric results</p> Source code in <code>openml/runs/run.py</code> <pre><code>def get_metric_fn(self, sklearn_fn: Callable, kwargs: dict | None = None) -&gt; np.ndarray:  # noqa: PLR0915, PLR0912, C901\n    \"\"\"Calculates metric scores based on predicted values. Assumes the\n    run has been executed locally (and contains run_data). Furthermore,\n    it assumes that the 'correct' or 'truth' attribute is specified in\n    the arff (which is an optional field, but always the case for\n    openml-python runs)\n\n    Parameters\n    ----------\n    sklearn_fn : function\n        a function pointer to a sklearn function that\n        accepts ``y_true``, ``y_pred`` and ``**kwargs``\n    kwargs : dict\n        kwargs for the function\n\n    Returns\n    -------\n    scores : ndarray of scores of length num_folds * num_repeats\n        metric results\n    \"\"\"\n    kwargs = kwargs if kwargs else {}\n    if self.data_content is not None and self.task_id is not None:\n        predictions_arff = self._generate_arff_dict()\n    elif (self.output_files is not None) and (\"predictions\" in self.output_files):\n        predictions_file_url = openml._api_calls._file_id_to_url(\n            self.output_files[\"predictions\"],\n            \"predictions.arff\",\n        )\n        response = openml._api_calls._download_text_file(predictions_file_url)\n        predictions_arff = arff.loads(response)\n        # TODO: make this a stream reader\n    else:\n        raise ValueError(\n            \"Run should have been locally executed or \" \"contain outputfile reference.\",\n        )\n\n    # Need to know more about the task to compute scores correctly\n    task = get_task(self.task_id)\n\n    attribute_names = [att[0] for att in predictions_arff[\"attributes\"]]\n    if (\n        task.task_type_id in [TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE]\n        and \"correct\" not in attribute_names\n    ):\n        raise ValueError('Attribute \"correct\" should be set for ' \"classification task runs\")\n    if task.task_type_id == TaskType.SUPERVISED_REGRESSION and \"truth\" not in attribute_names:\n        raise ValueError('Attribute \"truth\" should be set for ' \"regression task runs\")\n    if task.task_type_id != TaskType.CLUSTERING and \"prediction\" not in attribute_names:\n        raise ValueError('Attribute \"predict\" should be set for ' \"supervised task runs\")\n\n    def _attribute_list_to_dict(attribute_list):  # type: ignore\n        # convenience function: Creates a mapping to map from the name of\n        # attributes present in the arff prediction file to their index.\n        # This is necessary because the number of classes can be different\n        # for different tasks.\n        res = OrderedDict()\n        for idx in range(len(attribute_list)):\n            res[attribute_list[idx][0]] = idx\n        return res\n\n    attribute_dict = _attribute_list_to_dict(predictions_arff[\"attributes\"])\n\n    repeat_idx = attribute_dict[\"repeat\"]\n    fold_idx = attribute_dict[\"fold\"]\n    predicted_idx = attribute_dict[\"prediction\"]  # Assume supervised task\n\n    if task.task_type_id in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n        correct_idx = attribute_dict[\"correct\"]\n    elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n        correct_idx = attribute_dict[\"truth\"]\n    has_samples = False\n    if \"sample\" in attribute_dict:\n        sample_idx = attribute_dict[\"sample\"]\n        has_samples = True\n\n    if (\n        predictions_arff[\"attributes\"][predicted_idx][1]\n        != predictions_arff[\"attributes\"][correct_idx][1]\n    ):\n        pred = predictions_arff[\"attributes\"][predicted_idx][1]\n        corr = predictions_arff[\"attributes\"][correct_idx][1]\n        raise ValueError(\n            \"Predicted and Correct do not have equal values:\" f\" {pred!s} Vs. {corr!s}\",\n        )\n\n    # TODO: these could be cached\n    values_predict: dict[int, dict[int, dict[int, list[float]]]] = {}\n    values_correct: dict[int, dict[int, dict[int, list[float]]]] = {}\n    for _line_idx, line in enumerate(predictions_arff[\"data\"]):\n        rep = line[repeat_idx]\n        fold = line[fold_idx]\n        samp = line[sample_idx] if has_samples else 0\n\n        if task.task_type_id in [\n            TaskType.SUPERVISED_CLASSIFICATION,\n            TaskType.LEARNING_CURVE,\n        ]:\n            prediction = predictions_arff[\"attributes\"][predicted_idx][1].index(\n                line[predicted_idx],\n            )\n            correct = predictions_arff[\"attributes\"][predicted_idx][1].index(line[correct_idx])\n        elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n            prediction = line[predicted_idx]\n            correct = line[correct_idx]\n        if rep not in values_predict:\n            values_predict[rep] = OrderedDict()\n            values_correct[rep] = OrderedDict()\n        if fold not in values_predict[rep]:\n            values_predict[rep][fold] = OrderedDict()\n            values_correct[rep][fold] = OrderedDict()\n        if samp not in values_predict[rep][fold]:\n            values_predict[rep][fold][samp] = []\n            values_correct[rep][fold][samp] = []\n\n        values_predict[rep][fold][samp].append(prediction)\n        values_correct[rep][fold][samp].append(correct)\n\n    scores = []\n    for rep in values_predict:\n        for fold in values_predict[rep]:\n            last_sample = len(values_predict[rep][fold]) - 1\n            y_pred = values_predict[rep][fold][last_sample]\n            y_true = values_correct[rep][fold][last_sample]\n            scores.append(sklearn_fn(y_true, y_pred, **kwargs))\n    return np.array(scores)\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRun.to_filesystem","title":"<code>to_filesystem(directory, store_model=True)</code>","text":"<p>The inverse of the from_filesystem method. Serializes a run on the filesystem, to be uploaded later.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>a path leading to the folder where the results will be stored. Should be empty</p> required <code>store_model</code> <code>(bool, optional(default=True))</code> <p>if True, a model will be pickled as well. As this is the most storage expensive part, it is often desirable to not store the model.</p> <code>True</code> Source code in <code>openml/runs/run.py</code> <pre><code>def to_filesystem(\n    self,\n    directory: str | Path,\n    store_model: bool = True,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    The inverse of the from_filesystem method. Serializes a run\n    on the filesystem, to be uploaded later.\n\n    Parameters\n    ----------\n    directory : str\n        a path leading to the folder where the results\n        will be stored. Should be empty\n\n    store_model : bool, optional (default=True)\n        if True, a model will be pickled as well. As this is the most\n        storage expensive part, it is often desirable to not store the\n        model.\n    \"\"\"\n    if self.data_content is None or self.model is None:\n        raise ValueError(\"Run should have been executed (and contain \" \"model / predictions)\")\n    directory = Path(directory)\n    directory.mkdir(exist_ok=True, parents=True)\n\n    if any(directory.iterdir()):\n        raise ValueError(f\"Output directory {directory.expanduser().resolve()} should be empty\")\n\n    run_xml = self._to_xml()\n    predictions_arff = arff.dumps(self._generate_arff_dict())\n\n    # It seems like typing does not allow to define the same variable multiple times\n    with (directory / \"description.xml\").open(\"w\") as fh:\n        fh.write(run_xml)\n    with (directory / \"predictions.arff\").open(\"w\") as fh:\n        fh.write(predictions_arff)\n    if store_model:\n        with (directory / \"model.pkl\").open(\"wb\") as fh_b:\n            pickle.dump(self.model, fh_b)\n\n    if self.flow_id is None and self.flow is not None:\n        self.flow.to_filesystem(directory)\n\n    if self.trace is not None:\n        self.trace._to_filesystem(directory)\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace","title":"<code>OpenMLRunTrace</code>","text":"<p>OpenML Run Trace: parsed output from Run Trace call</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>OpenML run id.</p> required <code>trace_iterations</code> <code>dict</code> <p>Mapping from key <code>(repeat, fold, iteration)</code> to an object of OpenMLTraceIteration.</p> required Source code in <code>openml/runs/trace.py</code> <pre><code>class OpenMLRunTrace:\n    \"\"\"OpenML Run Trace: parsed output from Run Trace call\n\n    Parameters\n    ----------\n    run_id : int\n        OpenML run id.\n\n    trace_iterations : dict\n        Mapping from key ``(repeat, fold, iteration)`` to an object of\n        OpenMLTraceIteration.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        run_id: int | None,\n        trace_iterations: dict[tuple[int, int, int], OpenMLTraceIteration],\n    ):\n        \"\"\"Object to hold the trace content of a run.\n\n        Parameters\n        ----------\n        run_id : int\n            Id for which the trace content is to be stored.\n        trace_iterations : List[List]\n            The trace content obtained by running a flow on a task.\n        \"\"\"\n        self.run_id = run_id\n        self.trace_iterations = trace_iterations\n\n    def get_selected_iteration(self, fold: int, repeat: int) -&gt; int:\n        \"\"\"\n        Returns the trace iteration that was marked as selected. In\n        case multiple are marked as selected (should not happen) the\n        first of these is returned\n\n        Parameters\n        ----------\n        fold: int\n\n        repeat: int\n\n        Returns\n        -------\n        int\n            The trace iteration from the given fold and repeat that was\n            selected as the best iteration by the search procedure\n        \"\"\"\n        for r, f, i in self.trace_iterations:\n            if r == repeat and f == fold and self.trace_iterations[(r, f, i)].selected is True:\n                return i\n        raise ValueError(\n            \"Could not find the selected iteration for rep/fold %d/%d\" % (repeat, fold),\n        )\n\n    @classmethod\n    def generate(\n        cls,\n        attributes: list[tuple[str, str]],\n        content: list[list[int | float | str]],\n    ) -&gt; OpenMLRunTrace:\n        \"\"\"Generates an OpenMLRunTrace.\n\n        Generates the trace object from the attributes and content extracted\n        while running the underlying flow.\n\n        Parameters\n        ----------\n        attributes : list\n            List of tuples describing the arff attributes.\n\n        content : list\n            List of lists containing information about the individual tuning\n            runs.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        if content is None:\n            raise ValueError(\"Trace content not available.\")\n        if attributes is None:\n            raise ValueError(\"Trace attributes not available.\")\n        if len(content) == 0:\n            raise ValueError(\"Trace content is empty.\")\n        if len(attributes) != len(content[0]):\n            raise ValueError(\n                \"Trace_attributes and trace_content not compatible:\"\n                f\" {attributes} vs {content[0]}\",\n            )\n\n        return cls._trace_from_arff_struct(\n            attributes=attributes,\n            content=content,\n            error_message=\"setup_string not allowed when constructing a \"\n            \"trace object from run results.\",\n        )\n\n    @classmethod\n    def _from_filesystem(cls, file_path: str | Path) -&gt; OpenMLRunTrace:\n        \"\"\"\n        Logic to deserialize the trace from the filesystem.\n\n        Parameters\n        ----------\n        file_path: str | Path\n            File path where the trace arff is stored.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        file_path = Path(file_path)\n\n        if not file_path.exists():\n            raise ValueError(\"Trace file doesn't exist\")\n\n        with file_path.open(\"r\") as fp:\n            trace_arff = arff.load(fp)\n\n        for trace_idx in range(len(trace_arff[\"data\"])):\n            # iterate over first three entrees of a trace row\n            # (fold, repeat, trace_iteration) these should be int\n            for line_idx in range(3):\n                trace_arff[\"data\"][trace_idx][line_idx] = int(\n                    trace_arff[\"data\"][trace_idx][line_idx],\n                )\n\n        return cls.trace_from_arff(trace_arff)\n\n    def _to_filesystem(self, file_path: str | Path) -&gt; None:\n        \"\"\"Serialize the trace object to the filesystem.\n\n        Serialize the trace object as an arff.\n\n        Parameters\n        ----------\n        file_path: str | Path\n            File path where the trace arff will be stored.\n        \"\"\"\n        trace_path = Path(file_path) / \"trace.arff\"\n\n        trace_arff = arff.dumps(self.trace_to_arff())\n        with trace_path.open(\"w\") as f:\n            f.write(trace_arff)\n\n    def trace_to_arff(self) -&gt; dict[str, Any]:\n        \"\"\"Generate the arff dictionary for uploading predictions to the server.\n\n        Uses the trace object to generate an arff dictionary representation.\n\n        Returns\n        -------\n        arff_dict : dict\n            Dictionary representation of the ARFF file that will be uploaded.\n            Contains information about the optimization trace.\n        \"\"\"\n        if self.trace_iterations is None:\n            raise ValueError(\"trace_iterations missing from the trace object\")\n\n        # attributes that will be in trace arff\n        trace_attributes = [\n            (\"repeat\", \"NUMERIC\"),\n            (\"fold\", \"NUMERIC\"),\n            (\"iteration\", \"NUMERIC\"),\n            (\"evaluation\", \"NUMERIC\"),\n            (\"selected\", [\"true\", \"false\"]),\n        ]\n        trace_attributes.extend(\n            [\n                (PREFIX + parameter, \"STRING\")\n                for parameter in next(iter(self.trace_iterations.values())).get_parameters()\n            ],\n        )\n\n        arff_dict: dict[str, Any] = {}\n        data = []\n        for trace_iteration in self.trace_iterations.values():\n            tmp_list = []\n            for _attr, _ in trace_attributes:\n                if _attr.startswith(PREFIX):\n                    attr = _attr[len(PREFIX) :]\n                    value = trace_iteration.get_parameters()[attr]\n                else:\n                    attr = _attr\n                    value = getattr(trace_iteration, attr)\n\n                if attr == \"selected\":\n                    tmp_list.append(\"true\" if value else \"false\")\n                else:\n                    tmp_list.append(value)\n            data.append(tmp_list)\n\n        arff_dict[\"attributes\"] = trace_attributes\n        arff_dict[\"data\"] = data\n        # TODO allow to pass a trace description when running a flow\n        arff_dict[\"relation\"] = \"Trace\"\n        return arff_dict\n\n    @classmethod\n    def trace_from_arff(cls, arff_obj: dict[str, Any]) -&gt; OpenMLRunTrace:\n        \"\"\"Generate trace from arff trace.\n\n        Creates a trace file from arff object (for example, generated by a\n        local run).\n\n        Parameters\n        ----------\n        arff_obj : dict\n            LIAC arff obj, dict containing attributes, relation, data.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        attributes = arff_obj[\"attributes\"]\n        content = arff_obj[\"data\"]\n        return cls._trace_from_arff_struct(\n            attributes=attributes,\n            content=content,\n            error_message=\"setup_string not supported for arff serialization\",\n        )\n\n    @classmethod\n    def _trace_from_arff_struct(\n        cls,\n        attributes: list[tuple[str, str]],\n        content: list[list[int | float | str]],\n        error_message: str,\n    ) -&gt; Self:\n        \"\"\"Generate a trace dictionary from ARFF structure.\n\n        Parameters\n        ----------\n        cls : type\n            The trace object to be created.\n        attributes : list[tuple[str, str]]\n            Attribute descriptions.\n        content : list[list[int | float | str]]]\n            List of instances.\n        error_message : str\n            Error message to raise if `setup_string` is in `attributes`.\n\n        Returns\n        -------\n        OrderedDict\n            A dictionary representing the trace.\n        \"\"\"\n        trace = OrderedDict()\n        attribute_idx = {att[0]: idx for idx, att in enumerate(attributes)}\n\n        for required_attribute in REQUIRED_ATTRIBUTES:\n            if required_attribute not in attribute_idx:\n                raise ValueError(f\"arff misses required attribute: {required_attribute}\")\n        if \"setup_string\" in attribute_idx:\n            raise ValueError(error_message)\n\n        # note that the required attributes can not be duplicated because\n        # they are not parameters\n        parameter_attributes = []\n        for attribute in attribute_idx:\n            if attribute in REQUIRED_ATTRIBUTES or attribute == \"setup_string\":\n                continue\n\n            if not attribute.startswith(PREFIX):\n                raise ValueError(\n                    f\"Encountered unknown attribute {attribute} that does not start \"\n                    f\"with prefix {PREFIX}\",\n                )\n\n            parameter_attributes.append(attribute)\n\n        for itt in content:\n            repeat = int(itt[attribute_idx[\"repeat\"]])\n            fold = int(itt[attribute_idx[\"fold\"]])\n            iteration = int(itt[attribute_idx[\"iteration\"]])\n            evaluation = float(itt[attribute_idx[\"evaluation\"]])\n            selected_value = itt[attribute_idx[\"selected\"]]\n            if selected_value == \"true\":\n                selected = True\n            elif selected_value == \"false\":\n                selected = False\n            else:\n                raise ValueError(\n                    'expected {\"true\", \"false\"} value for selected field, '\n                    f\"received: {selected_value}\",\n                )\n\n            parameters = {\n                attribute: itt[attribute_idx[attribute]] for attribute in parameter_attributes\n            }\n\n            current = OpenMLTraceIteration(\n                repeat=repeat,\n                fold=fold,\n                iteration=iteration,\n                setup_string=None,\n                evaluation=evaluation,\n                selected=selected,\n                parameters=parameters,\n            )\n            trace[(repeat, fold, iteration)] = current\n\n        return cls(None, trace)\n\n    @classmethod\n    def trace_from_xml(cls, xml: str | Path | IO) -&gt; OpenMLRunTrace:\n        \"\"\"Generate trace from xml.\n\n        Creates a trace file from the xml description.\n\n        Parameters\n        ----------\n        xml : string | file-like object\n            An xml description that can be either a `string` or a file-like\n            object.\n\n        Returns\n        -------\n        run : OpenMLRunTrace\n            Object containing the run id and a dict containing the trace\n            iterations.\n        \"\"\"\n        if isinstance(xml, Path):\n            xml = str(xml.absolute())\n\n        result_dict = xmltodict.parse(xml, force_list=(\"oml:trace_iteration\",))[\"oml:trace\"]\n\n        run_id = result_dict[\"oml:run_id\"]\n        trace = OrderedDict()\n\n        if \"oml:trace_iteration\" not in result_dict:\n            raise ValueError(\"Run does not contain valid trace. \")\n        if not isinstance(result_dict[\"oml:trace_iteration\"], list):\n            raise TypeError(type(result_dict[\"oml:trace_iteration\"]))\n\n        for itt in result_dict[\"oml:trace_iteration\"]:\n            repeat = int(itt[\"oml:repeat\"])\n            fold = int(itt[\"oml:fold\"])\n            iteration = int(itt[\"oml:iteration\"])\n            setup_string = json.loads(itt[\"oml:setup_string\"])\n            evaluation = float(itt[\"oml:evaluation\"])\n            selected_value = itt[\"oml:selected\"]\n            if selected_value == \"true\":\n                selected = True\n            elif selected_value == \"false\":\n                selected = False\n            else:\n                raise ValueError(\n                    'expected {\"true\", \"false\"} value for '\n                    f\"selected field, received: {selected_value}\",\n                )\n\n            current = OpenMLTraceIteration(\n                repeat=repeat,\n                fold=fold,\n                iteration=iteration,\n                setup_string=setup_string,\n                evaluation=evaluation,\n                selected=selected,\n            )\n            trace[(repeat, fold, iteration)] = current\n\n        return cls(run_id, trace)\n\n    @classmethod\n    def merge_traces(cls, traces: list[OpenMLRunTrace]) -&gt; OpenMLRunTrace:\n        \"\"\"Merge multiple traces into a single trace.\n\n        Parameters\n        ----------\n        cls : type\n            Type of the trace object to be created.\n        traces : List[OpenMLRunTrace]\n            List of traces to merge.\n\n        Returns\n        -------\n        OpenMLRunTrace\n            A trace object representing the merged traces.\n\n        Raises\n        ------\n        ValueError\n            If the parameters in the iterations of the traces being merged are not equal.\n            If a key (repeat, fold, iteration) is encountered twice while merging the traces.\n        \"\"\"\n        merged_trace: dict[tuple[int, int, int], OpenMLTraceIteration] = {}\n\n        previous_iteration = None\n        for trace in traces:\n            for iteration in trace:\n                key = (iteration.repeat, iteration.fold, iteration.iteration)\n\n                assert iteration.parameters is not None\n                param_keys = iteration.parameters.keys()\n\n                if previous_iteration is not None:\n                    trace_itr = merged_trace[previous_iteration]\n\n                    assert trace_itr.parameters is not None\n                    trace_itr_keys = trace_itr.parameters.keys()\n\n                    if list(param_keys) != list(trace_itr_keys):\n                        raise ValueError(\n                            \"Cannot merge traces because the parameters are not equal: \"\n                            f\"{list(trace_itr.parameters.keys())} vs \"\n                            f\"{list(iteration.parameters.keys())}\",\n                        )\n\n                if key in merged_trace:\n                    raise ValueError(\n                        f\"Cannot merge traces because key '{key}' was encountered twice\",\n                    )\n\n                merged_trace[key] = iteration\n                previous_iteration = key\n\n        return cls(None, merged_trace)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"[Run id: {-1 if self.run_id is None else self.run_id}, \"\n            f\"{len(self.trace_iterations)} trace iterations]\"\n        )\n\n    def __iter__(self) -&gt; Iterator[OpenMLTraceIteration]:\n        yield from self.trace_iterations.values()\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.__init__","title":"<code>__init__(run_id, trace_iterations)</code>","text":"<p>Object to hold the trace content of a run.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>Id for which the trace content is to be stored.</p> required <code>trace_iterations</code> <code>List[List]</code> <p>The trace content obtained by running a flow on a task.</p> required Source code in <code>openml/runs/trace.py</code> <pre><code>def __init__(\n    self,\n    run_id: int | None,\n    trace_iterations: dict[tuple[int, int, int], OpenMLTraceIteration],\n):\n    \"\"\"Object to hold the trace content of a run.\n\n    Parameters\n    ----------\n    run_id : int\n        Id for which the trace content is to be stored.\n    trace_iterations : List[List]\n        The trace content obtained by running a flow on a task.\n    \"\"\"\n    self.run_id = run_id\n    self.trace_iterations = trace_iterations\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.generate","title":"<code>generate(attributes, content)</code>  <code>classmethod</code>","text":"<p>Generates an OpenMLRunTrace.</p> <p>Generates the trace object from the attributes and content extracted while running the underlying flow.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>list</code> <p>List of tuples describing the arff attributes.</p> required <code>content</code> <code>list</code> <p>List of lists containing information about the individual tuning runs.</p> required <p>Returns:</p> Type Description <code>OpenMLRunTrace</code> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef generate(\n    cls,\n    attributes: list[tuple[str, str]],\n    content: list[list[int | float | str]],\n) -&gt; OpenMLRunTrace:\n    \"\"\"Generates an OpenMLRunTrace.\n\n    Generates the trace object from the attributes and content extracted\n    while running the underlying flow.\n\n    Parameters\n    ----------\n    attributes : list\n        List of tuples describing the arff attributes.\n\n    content : list\n        List of lists containing information about the individual tuning\n        runs.\n\n    Returns\n    -------\n    OpenMLRunTrace\n    \"\"\"\n    if content is None:\n        raise ValueError(\"Trace content not available.\")\n    if attributes is None:\n        raise ValueError(\"Trace attributes not available.\")\n    if len(content) == 0:\n        raise ValueError(\"Trace content is empty.\")\n    if len(attributes) != len(content[0]):\n        raise ValueError(\n            \"Trace_attributes and trace_content not compatible:\"\n            f\" {attributes} vs {content[0]}\",\n        )\n\n    return cls._trace_from_arff_struct(\n        attributes=attributes,\n        content=content,\n        error_message=\"setup_string not allowed when constructing a \"\n        \"trace object from run results.\",\n    )\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.get_selected_iteration","title":"<code>get_selected_iteration(fold, repeat)</code>","text":"<p>Returns the trace iteration that was marked as selected. In case multiple are marked as selected (should not happen) the first of these is returned</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>int</code> required <code>repeat</code> <code>int</code> required <p>Returns:</p> Type Description <code>int</code> <p>The trace iteration from the given fold and repeat that was selected as the best iteration by the search procedure</p> Source code in <code>openml/runs/trace.py</code> <pre><code>def get_selected_iteration(self, fold: int, repeat: int) -&gt; int:\n    \"\"\"\n    Returns the trace iteration that was marked as selected. In\n    case multiple are marked as selected (should not happen) the\n    first of these is returned\n\n    Parameters\n    ----------\n    fold: int\n\n    repeat: int\n\n    Returns\n    -------\n    int\n        The trace iteration from the given fold and repeat that was\n        selected as the best iteration by the search procedure\n    \"\"\"\n    for r, f, i in self.trace_iterations:\n        if r == repeat and f == fold and self.trace_iterations[(r, f, i)].selected is True:\n            return i\n    raise ValueError(\n        \"Could not find the selected iteration for rep/fold %d/%d\" % (repeat, fold),\n    )\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.merge_traces","title":"<code>merge_traces(traces)</code>  <code>classmethod</code>","text":"<p>Merge multiple traces into a single trace.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Type of the trace object to be created.</p> required <code>traces</code> <code>List[OpenMLRunTrace]</code> <p>List of traces to merge.</p> required <p>Returns:</p> Type Description <code>OpenMLRunTrace</code> <p>A trace object representing the merged traces.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the parameters in the iterations of the traces being merged are not equal. If a key (repeat, fold, iteration) is encountered twice while merging the traces.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef merge_traces(cls, traces: list[OpenMLRunTrace]) -&gt; OpenMLRunTrace:\n    \"\"\"Merge multiple traces into a single trace.\n\n    Parameters\n    ----------\n    cls : type\n        Type of the trace object to be created.\n    traces : List[OpenMLRunTrace]\n        List of traces to merge.\n\n    Returns\n    -------\n    OpenMLRunTrace\n        A trace object representing the merged traces.\n\n    Raises\n    ------\n    ValueError\n        If the parameters in the iterations of the traces being merged are not equal.\n        If a key (repeat, fold, iteration) is encountered twice while merging the traces.\n    \"\"\"\n    merged_trace: dict[tuple[int, int, int], OpenMLTraceIteration] = {}\n\n    previous_iteration = None\n    for trace in traces:\n        for iteration in trace:\n            key = (iteration.repeat, iteration.fold, iteration.iteration)\n\n            assert iteration.parameters is not None\n            param_keys = iteration.parameters.keys()\n\n            if previous_iteration is not None:\n                trace_itr = merged_trace[previous_iteration]\n\n                assert trace_itr.parameters is not None\n                trace_itr_keys = trace_itr.parameters.keys()\n\n                if list(param_keys) != list(trace_itr_keys):\n                    raise ValueError(\n                        \"Cannot merge traces because the parameters are not equal: \"\n                        f\"{list(trace_itr.parameters.keys())} vs \"\n                        f\"{list(iteration.parameters.keys())}\",\n                    )\n\n            if key in merged_trace:\n                raise ValueError(\n                    f\"Cannot merge traces because key '{key}' was encountered twice\",\n                )\n\n            merged_trace[key] = iteration\n            previous_iteration = key\n\n    return cls(None, merged_trace)\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.trace_from_arff","title":"<code>trace_from_arff(arff_obj)</code>  <code>classmethod</code>","text":"<p>Generate trace from arff trace.</p> <p>Creates a trace file from arff object (for example, generated by a local run).</p> <p>Parameters:</p> Name Type Description Default <code>arff_obj</code> <code>dict</code> <p>LIAC arff obj, dict containing attributes, relation, data.</p> required <p>Returns:</p> Type Description <code>OpenMLRunTrace</code> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef trace_from_arff(cls, arff_obj: dict[str, Any]) -&gt; OpenMLRunTrace:\n    \"\"\"Generate trace from arff trace.\n\n    Creates a trace file from arff object (for example, generated by a\n    local run).\n\n    Parameters\n    ----------\n    arff_obj : dict\n        LIAC arff obj, dict containing attributes, relation, data.\n\n    Returns\n    -------\n    OpenMLRunTrace\n    \"\"\"\n    attributes = arff_obj[\"attributes\"]\n    content = arff_obj[\"data\"]\n    return cls._trace_from_arff_struct(\n        attributes=attributes,\n        content=content,\n        error_message=\"setup_string not supported for arff serialization\",\n    )\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.trace_from_xml","title":"<code>trace_from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Generate trace from xml.</p> <p>Creates a trace file from the xml description.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>string | file-like object</code> <p>An xml description that can be either a <code>string</code> or a file-like object.</p> required <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRunTrace</code> <p>Object containing the run id and a dict containing the trace iterations.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef trace_from_xml(cls, xml: str | Path | IO) -&gt; OpenMLRunTrace:\n    \"\"\"Generate trace from xml.\n\n    Creates a trace file from the xml description.\n\n    Parameters\n    ----------\n    xml : string | file-like object\n        An xml description that can be either a `string` or a file-like\n        object.\n\n    Returns\n    -------\n    run : OpenMLRunTrace\n        Object containing the run id and a dict containing the trace\n        iterations.\n    \"\"\"\n    if isinstance(xml, Path):\n        xml = str(xml.absolute())\n\n    result_dict = xmltodict.parse(xml, force_list=(\"oml:trace_iteration\",))[\"oml:trace\"]\n\n    run_id = result_dict[\"oml:run_id\"]\n    trace = OrderedDict()\n\n    if \"oml:trace_iteration\" not in result_dict:\n        raise ValueError(\"Run does not contain valid trace. \")\n    if not isinstance(result_dict[\"oml:trace_iteration\"], list):\n        raise TypeError(type(result_dict[\"oml:trace_iteration\"]))\n\n    for itt in result_dict[\"oml:trace_iteration\"]:\n        repeat = int(itt[\"oml:repeat\"])\n        fold = int(itt[\"oml:fold\"])\n        iteration = int(itt[\"oml:iteration\"])\n        setup_string = json.loads(itt[\"oml:setup_string\"])\n        evaluation = float(itt[\"oml:evaluation\"])\n        selected_value = itt[\"oml:selected\"]\n        if selected_value == \"true\":\n            selected = True\n        elif selected_value == \"false\":\n            selected = False\n        else:\n            raise ValueError(\n                'expected {\"true\", \"false\"} value for '\n                f\"selected field, received: {selected_value}\",\n            )\n\n        current = OpenMLTraceIteration(\n            repeat=repeat,\n            fold=fold,\n            iteration=iteration,\n            setup_string=setup_string,\n            evaluation=evaluation,\n            selected=selected,\n        )\n        trace[(repeat, fold, iteration)] = current\n\n    return cls(run_id, trace)\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLRunTrace.trace_to_arff","title":"<code>trace_to_arff()</code>","text":"<p>Generate the arff dictionary for uploading predictions to the server.</p> <p>Uses the trace object to generate an arff dictionary representation.</p> <p>Returns:</p> Name Type Description <code>arff_dict</code> <code>dict</code> <p>Dictionary representation of the ARFF file that will be uploaded. Contains information about the optimization trace.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>def trace_to_arff(self) -&gt; dict[str, Any]:\n    \"\"\"Generate the arff dictionary for uploading predictions to the server.\n\n    Uses the trace object to generate an arff dictionary representation.\n\n    Returns\n    -------\n    arff_dict : dict\n        Dictionary representation of the ARFF file that will be uploaded.\n        Contains information about the optimization trace.\n    \"\"\"\n    if self.trace_iterations is None:\n        raise ValueError(\"trace_iterations missing from the trace object\")\n\n    # attributes that will be in trace arff\n    trace_attributes = [\n        (\"repeat\", \"NUMERIC\"),\n        (\"fold\", \"NUMERIC\"),\n        (\"iteration\", \"NUMERIC\"),\n        (\"evaluation\", \"NUMERIC\"),\n        (\"selected\", [\"true\", \"false\"]),\n    ]\n    trace_attributes.extend(\n        [\n            (PREFIX + parameter, \"STRING\")\n            for parameter in next(iter(self.trace_iterations.values())).get_parameters()\n        ],\n    )\n\n    arff_dict: dict[str, Any] = {}\n    data = []\n    for trace_iteration in self.trace_iterations.values():\n        tmp_list = []\n        for _attr, _ in trace_attributes:\n            if _attr.startswith(PREFIX):\n                attr = _attr[len(PREFIX) :]\n                value = trace_iteration.get_parameters()[attr]\n            else:\n                attr = _attr\n                value = getattr(trace_iteration, attr)\n\n            if attr == \"selected\":\n                tmp_list.append(\"true\" if value else \"false\")\n            else:\n                tmp_list.append(value)\n        data.append(tmp_list)\n\n    arff_dict[\"attributes\"] = trace_attributes\n    arff_dict[\"data\"] = data\n    # TODO allow to pass a trace description when running a flow\n    arff_dict[\"relation\"] = \"Trace\"\n    return arff_dict\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLTraceIteration","title":"<code>OpenMLTraceIteration</code>  <code>dataclass</code>","text":"<p>OpenML Trace Iteration: parsed output from Run Trace call Exactly one of <code>setup_string</code> or <code>parameters</code> must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>repeat</code> <code>int</code> <p>repeat number (in case of no repeats: 0)</p> required <code>fold</code> <code>int</code> <p>fold number (in case of no folds: 0)</p> required <code>iteration</code> <code>int</code> <p>iteration number of optimization procedure</p> required <code>setup_string</code> <code>str</code> <p>json string representing the parameters If not provided, <code>parameters</code> should be set.</p> <code>None</code> <code>evaluation</code> <code>double</code> <p>The evaluation that was awarded to this trace iteration. Measure is defined by the task</p> required <code>selected</code> <code>bool</code> <p>Whether this was the best of all iterations, and hence selected for making predictions. Per fold/repeat there should be only one iteration selected</p> required <code>parameters</code> <code>OrderedDict</code> <p>Dictionary specifying parameter names and their values. If not provided, <code>setup_string</code> should be set.</p> <code>None</code> Source code in <code>openml/runs/trace.py</code> <pre><code>@dataclass\nclass OpenMLTraceIteration:\n    \"\"\"\n    OpenML Trace Iteration: parsed output from Run Trace call\n    Exactly one of `setup_string` or `parameters` must be provided.\n\n    Parameters\n    ----------\n    repeat : int\n        repeat number (in case of no repeats: 0)\n\n    fold : int\n        fold number (in case of no folds: 0)\n\n    iteration : int\n        iteration number of optimization procedure\n\n    setup_string : str, optional\n        json string representing the parameters\n        If not provided, ``parameters`` should be set.\n\n    evaluation : double\n        The evaluation that was awarded to this trace iteration.\n        Measure is defined by the task\n\n    selected : bool\n        Whether this was the best of all iterations, and hence\n        selected for making predictions. Per fold/repeat there\n        should be only one iteration selected\n\n    parameters : OrderedDict, optional\n        Dictionary specifying parameter names and their values.\n        If not provided, ``setup_string`` should be set.\n    \"\"\"\n\n    repeat: int\n    fold: int\n    iteration: int\n\n    evaluation: float\n    selected: bool\n\n    setup_string: dict[str, str] | None = None\n    parameters: dict[str, str | int | float] | None = None\n\n    def __post_init__(self) -&gt; None:\n        # TODO: refactor into one argument of type &lt;str | OrderedDict&gt;\n        if self.setup_string and self.parameters:\n            raise ValueError(\n                \"Can only be instantiated with either `setup_string` or `parameters` argument.\",\n            )\n\n        if not (self.setup_string or self.parameters):\n            raise ValueError(\n                \"Either `setup_string` or `parameters` needs to be passed as argument.\",\n            )\n\n        if self.parameters is not None and not isinstance(self.parameters, dict):\n            raise TypeError(\n                f\"argument parameters is not an instance of OrderedDict, but\"\n                f\" {type(self.parameters)!s}\",\n            )\n\n    def get_parameters(self) -&gt; dict[str, Any]:\n        \"\"\"Get the parameters of this trace iteration.\"\"\"\n        # parameters have prefix 'parameter_'\n        if self.setup_string:\n            return {\n                param[len(PREFIX) :]: json.loads(value)\n                for param, value in self.setup_string.items()\n            }\n\n        assert self.parameters is not None\n        return {param[len(PREFIX) :]: value for param, value in self.parameters.items()}\n</code></pre>"},{"location":"reference/runs/#openml.runs.OpenMLTraceIteration.get_parameters","title":"<code>get_parameters()</code>","text":"<p>Get the parameters of this trace iteration.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>def get_parameters(self) -&gt; dict[str, Any]:\n    \"\"\"Get the parameters of this trace iteration.\"\"\"\n    # parameters have prefix 'parameter_'\n    if self.setup_string:\n        return {\n            param[len(PREFIX) :]: json.loads(value)\n            for param, value in self.setup_string.items()\n        }\n\n    assert self.parameters is not None\n    return {param[len(PREFIX) :]: value for param, value in self.parameters.items()}\n</code></pre>"},{"location":"reference/runs/#openml.runs.delete_run","title":"<code>delete_run(run_id)</code>","text":"<p>Delete run with id <code>run_id</code> from the OpenML server.</p> <p>You can only delete runs which you uploaded.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>OpenML id of the run</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def delete_run(run_id: int) -&gt; bool:\n    \"\"\"Delete run with id `run_id` from the OpenML server.\n\n    You can only delete runs which you uploaded.\n\n    Parameters\n    ----------\n    run_id : int\n        OpenML id of the run\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"run\", run_id)\n</code></pre>"},{"location":"reference/runs/#openml.runs.get_run","title":"<code>get_run(run_id, ignore_cache=False)</code>","text":"<p>Gets run corresponding to run_id.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> required <code>ignore_cache</code> <code>bool</code> <p>Whether to ignore the cache. If <code>true</code> this will download and overwrite the run xml even if the requested run is already cached.</p> <code>False</code> <code>ignore_cache</code> <code>bool</code> <code>False</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>Run corresponding to ID, fetched from the server.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_run(run_id: int, ignore_cache: bool = False) -&gt; OpenMLRun:  # noqa: FBT002, FBT001\n    \"\"\"Gets run corresponding to run_id.\n\n    Parameters\n    ----------\n    run_id : int\n\n    ignore_cache : bool\n        Whether to ignore the cache. If ``true`` this will download and overwrite the run xml\n        even if the requested run is already cached.\n\n    ignore_cache\n\n    Returns\n    -------\n    run : OpenMLRun\n        Run corresponding to ID, fetched from the server.\n    \"\"\"\n    run_dir = Path(openml.utils._create_cache_directory_for_id(RUNS_CACHE_DIR_NAME, run_id))\n    run_file = run_dir / \"description.xml\"\n\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    try:\n        if not ignore_cache:\n            return _get_cached_run(run_id)\n\n        raise OpenMLCacheException(message=\"dummy\")\n\n    except OpenMLCacheException:\n        run_xml = openml._api_calls._perform_api_call(\"run/%d\" % run_id, \"get\")\n        with run_file.open(\"w\", encoding=\"utf8\") as fh:\n            fh.write(run_xml)\n\n    return _create_run_from_xml(run_xml)\n</code></pre>"},{"location":"reference/runs/#openml.runs.get_run_trace","title":"<code>get_run_trace(run_id)</code>","text":"<p>Get the optimization trace object for a given run id.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>OpenMLTrace</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def get_run_trace(run_id: int) -&gt; OpenMLRunTrace:\n    \"\"\"\n    Get the optimization trace object for a given run id.\n\n    Parameters\n    ----------\n    run_id : int\n\n    Returns\n    -------\n    openml.runs.OpenMLTrace\n    \"\"\"\n    trace_xml = openml._api_calls._perform_api_call(\"run/trace/%d\" % run_id, \"get\")\n    return OpenMLRunTrace.trace_from_xml(trace_xml)\n</code></pre>"},{"location":"reference/runs/#openml.runs.get_runs","title":"<code>get_runs(run_ids)</code>","text":"<p>Gets all runs in run_ids list.</p> <p>Parameters:</p> Name Type Description Default <code>run_ids</code> <code>list of ints</code> required <p>Returns:</p> Name Type Description <code>runs</code> <code>list of OpenMLRun</code> <p>List of runs corresponding to IDs, fetched from the server.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def get_runs(run_ids: list[int]) -&gt; list[OpenMLRun]:\n    \"\"\"Gets all runs in run_ids list.\n\n    Parameters\n    ----------\n    run_ids : list of ints\n\n    Returns\n    -------\n    runs : list of OpenMLRun\n        List of runs corresponding to IDs, fetched from the server.\n    \"\"\"\n    runs = []\n    for run_id in run_ids:\n        runs.append(get_run(run_id))\n    return runs\n</code></pre>"},{"location":"reference/runs/#openml.runs.initialize_model_from_run","title":"<code>initialize_model_from_run(run_id, *, strict_version=True)</code>","text":"<p>Initialized a model based on a run_id (i.e., using the exact same parameter settings)</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The Openml run_id</p> required <code>strict_version</code> <code>bool</code> <p>See <code>flow_to_model</code> strict_version.</p> <code>True</code> <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def initialize_model_from_run(run_id: int, *, strict_version: bool = True) -&gt; Any:\n    \"\"\"\n    Initialized a model based on a run_id (i.e., using the exact\n    same parameter settings)\n\n    Parameters\n    ----------\n    run_id : int\n        The Openml run_id\n    strict_version: bool (default=True)\n        See `flow_to_model` strict_version.\n\n    Returns\n    -------\n    model\n    \"\"\"\n    run = get_run(run_id)\n    # TODO(eddiebergman): I imagine this is None if it's not published,\n    # might need to raise an explicit error for that\n    assert run.setup_id is not None\n    return initialize_model(setup_id=run.setup_id, strict_version=strict_version)\n</code></pre>"},{"location":"reference/runs/#openml.runs.initialize_model_from_trace","title":"<code>initialize_model_from_trace(run_id, repeat, fold, iteration=None)</code>","text":"<p>Initialize a model based on the parameters that were set by an optimization procedure (i.e., using the exact same parameter settings)</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The Openml run_id. Should contain a trace file, otherwise a OpenMLServerException is raised</p> required <code>repeat</code> <code>int</code> <p>The repeat nr (column in trace file)</p> required <code>fold</code> <code>int</code> <p>The fold nr (column in trace file)</p> required <code>iteration</code> <code>int</code> <p>The iteration nr (column in trace file). If None, the best (selected) iteration will be searched (slow), according to the selection criteria implemented in OpenMLRunTrace.get_selected_iteration</p> <code>None</code> <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def initialize_model_from_trace(\n    run_id: int,\n    repeat: int,\n    fold: int,\n    iteration: int | None = None,\n) -&gt; Any:\n    \"\"\"\n    Initialize a model based on the parameters that were set\n    by an optimization procedure (i.e., using the exact same\n    parameter settings)\n\n    Parameters\n    ----------\n    run_id : int\n        The Openml run_id. Should contain a trace file,\n        otherwise a OpenMLServerException is raised\n\n    repeat : int\n        The repeat nr (column in trace file)\n\n    fold : int\n        The fold nr (column in trace file)\n\n    iteration : int\n        The iteration nr (column in trace file). If None, the\n        best (selected) iteration will be searched (slow),\n        according to the selection criteria implemented in\n        OpenMLRunTrace.get_selected_iteration\n\n    Returns\n    -------\n    model\n    \"\"\"\n    run = get_run(run_id)\n    # TODO(eddiebergman): I imagine this is None if it's not published,\n    # might need to raise an explicit error for that\n    assert run.flow_id is not None\n\n    flow = get_flow(run.flow_id)\n    run_trace = get_run_trace(run_id)\n\n    if iteration is None:\n        iteration = run_trace.get_selected_iteration(repeat, fold)\n\n    request = (repeat, fold, iteration)\n    if request not in run_trace.trace_iterations:\n        raise ValueError(\"Combination repeat, fold, iteration not available\")\n    current = run_trace.trace_iterations[(repeat, fold, iteration)]\n\n    search_model = initialize_model_from_run(run_id)\n    return flow.extension.instantiate_model_from_hpo_class(search_model, current)\n</code></pre>"},{"location":"reference/runs/#openml.runs.list_runs","title":"<code>list_runs(offset=None, size=None, id=None, task=None, setup=None, flow=None, uploader=None, tag=None, study=None, display_errors=False, task_type=None)</code>","text":"<p>List all runs matching all of the given filters. (Supports large amount of results)</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>the number of runs to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of runs to show</p> <code>None</code> <code>id</code> <code>list</code> <code>None</code> <code>task</code> <code>list</code> <code>None</code> <code>setup</code> <code>list | None</code> <code>None</code> <code>flow</code> <code>list</code> <code>None</code> <code>uploader</code> <code>list</code> <code>None</code> <code>tag</code> <code>str</code> <code>None</code> <code>study</code> <code>int</code> <code>None</code> <code>display_errors</code> <code>(bool, optional(default=None))</code> <p>Whether to list runs which have an error (for example a missing prediction file).</p> <code>False</code> <code>task_type</code> <code>str</code> <code>None</code> <p>Returns:</p> Type Description <code>dataframe</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def list_runs(  # noqa: PLR0913\n    offset: int | None = None,\n    size: int | None = None,\n    id: list | None = None,  # noqa: A002\n    task: list[int] | None = None,\n    setup: list | None = None,\n    flow: list | None = None,\n    uploader: list | None = None,\n    tag: str | None = None,\n    study: int | None = None,\n    display_errors: bool = False,  # noqa: FBT001, FBT002\n    task_type: TaskType | int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    List all runs matching all of the given filters.\n    (Supports large amount of results)\n\n    Parameters\n    ----------\n    offset : int, optional\n        the number of runs to skip, starting from the first\n    size : int, optional\n        the maximum number of runs to show\n\n    id : list, optional\n\n    task : list, optional\n\n    setup: list, optional\n\n    flow : list, optional\n\n    uploader : list, optional\n\n    tag : str, optional\n\n    study : int, optional\n\n    display_errors : bool, optional (default=None)\n        Whether to list runs which have an error (for example a missing\n        prediction file).\n\n    task_type : str, optional\n\n    Returns\n    -------\n    dataframe\n    \"\"\"\n    if id is not None and (not isinstance(id, list)):\n        raise TypeError(\"id must be of type list.\")\n    if task is not None and (not isinstance(task, list)):\n        raise TypeError(\"task must be of type list.\")\n    if setup is not None and (not isinstance(setup, list)):\n        raise TypeError(\"setup must be of type list.\")\n    if flow is not None and (not isinstance(flow, list)):\n        raise TypeError(\"flow must be of type list.\")\n    if uploader is not None and (not isinstance(uploader, list)):\n        raise TypeError(\"uploader must be of type list.\")\n\n    listing_call = partial(\n        _list_runs,\n        id=id,\n        task=task,\n        setup=setup,\n        flow=flow,\n        uploader=uploader,\n        tag=tag,\n        study=study,\n        display_errors=display_errors,\n        task_type=task_type,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/runs/#openml.runs.run_exists","title":"<code>run_exists(task_id, setup_id)</code>","text":"<p>Checks whether a task/setup combination is already present on the server.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> required <code>setup_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>    Set run ids for runs where flow setup_id was run on task_id. Empty</code> <p>set if it wasn't run yet.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def run_exists(task_id: int, setup_id: int) -&gt; set[int]:\n    \"\"\"Checks whether a task/setup combination is already present on the\n    server.\n\n    Parameters\n    ----------\n    task_id : int\n\n    setup_id : int\n\n    Returns\n    -------\n        Set run ids for runs where flow setup_id was run on task_id. Empty\n        set if it wasn't run yet.\n    \"\"\"\n    if setup_id &lt;= 0:\n        # openml setups are in range 1-inf\n        return set()\n\n    try:\n        result = list_runs(task=[task_id], setup=[setup_id])\n        return set() if result.empty else set(result[\"run_id\"])\n    except OpenMLServerException as exception:\n        # error code implies no results. The run does not exist yet\n        if exception.code != ERROR_CODE:\n            raise exception\n        return set()\n</code></pre>"},{"location":"reference/runs/#openml.runs.run_flow_on_task","title":"<code>run_flow_on_task(flow, task, avoid_duplicate_runs=True, flow_tags=None, seed=None, add_local_measures=True, upload_flow=False, n_jobs=None)</code>","text":"<p>Run the model provided by the flow on the dataset defined by task.</p> <p>Takes the flow and repeat information into account. The Flow may optionally be published.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>A flow wraps a machine learning model together with relevant information. The model has a function fit(X,Y) and predict(X), all supervised estimators of scikit learn follow this definition of a model.</p> required <code>task</code> <code>OpenMLTask</code> <p>Task to perform. This may be an OpenMLFlow instead if the first argument is an OpenMLTask.</p> required <code>avoid_duplicate_runs</code> <code>(bool, optional(default=True))</code> <p>If True, the run will throw an error if the setup/task combination is already present on the server. This feature requires an internet connection.</p> <code>True</code> <code>flow_tags</code> <code>(List[str], optional(default=None))</code> <p>A list of tags that the flow should have at creation.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>Models that are not seeded will get this seed.</p> <code>None</code> <code>add_local_measures</code> <code>(bool, optional(default=True))</code> <p>Determines whether to calculate a set of evaluation measures locally, to later verify server behaviour.</p> <code>True</code> <code>upload_flow</code> <code>bool(default=False)</code> <p>If True, upload the flow to OpenML if it does not exist yet. If False, do not upload the flow to OpenML.</p> <code>False</code> <code>n_jobs</code> <code>int(default=None)</code> <p>The number of processes/threads to distribute the evaluation asynchronously. If <code>None</code> or <code>1</code>, then the evaluation is treated as synchronous and processed sequentially. If <code>-1</code>, then the job uses as many cores available.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>Result of the run.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def run_flow_on_task(  # noqa: C901, PLR0912, PLR0915, PLR0913\n    flow: OpenMLFlow,\n    task: OpenMLTask,\n    avoid_duplicate_runs: bool = True,  # noqa: FBT002, FBT001\n    flow_tags: list[str] | None = None,\n    seed: int | None = None,\n    add_local_measures: bool = True,  # noqa: FBT001, FBT002\n    upload_flow: bool = False,  # noqa: FBT001, FBT002\n    n_jobs: int | None = None,\n) -&gt; OpenMLRun:\n    \"\"\"Run the model provided by the flow on the dataset defined by task.\n\n    Takes the flow and repeat information into account.\n    The Flow may optionally be published.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        A flow wraps a machine learning model together with relevant information.\n        The model has a function fit(X,Y) and predict(X),\n        all supervised estimators of scikit learn follow this definition of a model.\n    task : OpenMLTask\n        Task to perform. This may be an OpenMLFlow instead if the first argument is an OpenMLTask.\n    avoid_duplicate_runs : bool, optional (default=True)\n        If True, the run will throw an error if the setup/task combination is already present on\n        the server. This feature requires an internet connection.\n    flow_tags : List[str], optional (default=None)\n        A list of tags that the flow should have at creation.\n    seed: int, optional (default=None)\n        Models that are not seeded will get this seed.\n    add_local_measures : bool, optional (default=True)\n        Determines whether to calculate a set of evaluation measures locally,\n        to later verify server behaviour.\n    upload_flow : bool (default=False)\n        If True, upload the flow to OpenML if it does not exist yet.\n        If False, do not upload the flow to OpenML.\n    n_jobs : int (default=None)\n        The number of processes/threads to distribute the evaluation asynchronously.\n        If `None` or `1`, then the evaluation is treated as synchronous and processed sequentially.\n        If `-1`, then the job uses as many cores available.\n\n    Returns\n    -------\n    run : OpenMLRun\n        Result of the run.\n    \"\"\"\n    if flow_tags is not None and not isinstance(flow_tags, list):\n        raise ValueError(\"flow_tags should be a list\")\n\n    # TODO: At some point in the future do not allow for arguments in old order (changed 6-2018).\n    # Flexibility currently still allowed due to code-snippet in OpenML100 paper (3-2019).\n    if isinstance(flow, OpenMLTask) and isinstance(task, OpenMLFlow):\n        # We want to allow either order of argument (to avoid confusion).\n        warnings.warn(\n            \"The old argument order (Flow, model) is deprecated and \"\n            \"will not be supported in the future. Please use the \"\n            \"order (model, Flow).\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        task, flow = flow, task\n\n    if task.task_id is None:\n        raise ValueError(\"The task should be published at OpenML\")\n\n    if flow.model is None:\n        flow.model = flow.extension.flow_to_model(flow)\n\n    flow.model = flow.extension.seed_model(flow.model, seed=seed)\n\n    # We only need to sync with the server right now if we want to upload the flow,\n    # or ensure no duplicate runs exist. Otherwise it can be synced at upload time.\n    flow_id = None\n    if upload_flow or avoid_duplicate_runs:\n        flow_id = flow_exists(flow.name, flow.external_version)\n        if isinstance(flow.flow_id, int) and flow_id != flow.flow_id:\n            if flow_id is not False:\n                raise PyOpenMLError(\n                    f\"Local flow_id does not match server flow_id: '{flow.flow_id}' vs '{flow_id}'\",\n                )\n            raise PyOpenMLError(\n                \"Flow does not exist on the server, but 'flow.flow_id' is not None.\"\n            )\n        if upload_flow and flow_id is False:\n            flow.publish()\n            flow_id = flow.flow_id\n        elif flow_id:\n            flow_from_server = get_flow(flow_id)\n            _copy_server_fields(flow_from_server, flow)\n            if avoid_duplicate_runs:\n                flow_from_server.model = flow.model\n                setup_id = setup_exists(flow_from_server)\n                ids = run_exists(task.task_id, setup_id)\n                if ids:\n                    error_message = (\n                        \"One or more runs of this setup were already performed on the task.\"\n                    )\n                    raise OpenMLRunsExistError(ids, error_message)\n        else:\n            # Flow does not exist on server and we do not want to upload it.\n            # No sync with the server happens.\n            flow_id = None\n\n    dataset = task.get_dataset()\n\n    run_environment = flow.extension.get_version_information()\n    tags = [\"openml-python\", run_environment[1]]\n\n    if flow.extension.check_if_model_fitted(flow.model):\n        warnings.warn(\n            \"The model is already fitted! This might cause inconsistency in comparison of results.\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n\n    # execute the run\n    res = _run_task_get_arffcontent(\n        model=flow.model,\n        task=task,\n        extension=flow.extension,\n        add_local_measures=add_local_measures,\n        n_jobs=n_jobs,\n    )\n\n    data_content, trace, fold_evaluations, sample_evaluations = res\n    fields = [*run_environment, time.strftime(\"%c\"), \"Created by run_flow_on_task\"]\n    generated_description = \"\\n\".join(fields)\n    run = OpenMLRun(\n        task_id=task.task_id,\n        flow_id=flow_id,\n        dataset_id=dataset.dataset_id,\n        model=flow.model,\n        flow_name=flow.name,\n        tags=tags,\n        trace=trace,\n        data_content=data_content,\n        flow=flow,\n        setup_string=flow.extension.create_setup_string(flow.model),\n        description_text=generated_description,\n    )\n\n    if (upload_flow or avoid_duplicate_runs) and flow.flow_id is not None:\n        # We only extract the parameter settings if a sync happened with the server.\n        # I.e. when the flow was uploaded or we found it in the avoid_duplicate check.\n        # Otherwise, we will do this at upload time.\n        run.parameter_settings = flow.extension.obtain_parameter_values(flow)\n\n    # now we need to attach the detailed evaluations\n    if task.task_type_id == TaskType.LEARNING_CURVE:\n        run.sample_evaluations = sample_evaluations\n    else:\n        run.fold_evaluations = fold_evaluations\n\n    if flow_id:\n        message = f\"Executed Task {task.task_id} with Flow id:{run.flow_id}\"\n    else:\n        message = f\"Executed Task {task.task_id} on local Flow with name {flow.name}.\"\n    config.logger.info(message)\n\n    return run\n</code></pre>"},{"location":"reference/runs/#openml.runs.run_model_on_task","title":"<code>run_model_on_task(model, task, avoid_duplicate_runs=True, flow_tags=None, seed=None, add_local_measures=True, upload_flow=False, return_flow=False, n_jobs=None)</code>","text":"<p>Run the model on the dataset defined by the task.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>sklearn model</code> <p>A model which has a function fit(X,Y) and predict(X), all supervised estimators of scikit learn follow this definition of a model.</p> required <code>task</code> <code>OpenMLTask or int or str</code> <p>Task to perform or Task id. This may be a model instead if the first argument is an OpenMLTask.</p> required <code>avoid_duplicate_runs</code> <code>(bool, optional(default=True))</code> <p>If True, the run will throw an error if the setup/task combination is already present on the server. This feature requires an internet connection.</p> <code>True</code> <code>flow_tags</code> <code>(List[str], optional(default=None))</code> <p>A list of tags that the flow should have at creation.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>Models that are not seeded will get this seed.</p> <code>None</code> <code>add_local_measures</code> <code>(bool, optional(default=True))</code> <p>Determines whether to calculate a set of evaluation measures locally, to later verify server behaviour.</p> <code>True</code> <code>upload_flow</code> <code>bool(default=False)</code> <p>If True, upload the flow to OpenML if it does not exist yet. If False, do not upload the flow to OpenML.</p> <code>False</code> <code>return_flow</code> <code>bool(default=False)</code> <p>If True, returns the OpenMLFlow generated from the model in addition to the OpenMLRun.</p> <code>False</code> <code>n_jobs</code> <code>int(default=None)</code> <p>The number of processes/threads to distribute the evaluation asynchronously. If <code>None</code> or <code>1</code>, then the evaluation is treated as synchronous and processed sequentially. If <code>-1</code>, then the job uses as many cores available.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>Result of the run.</p> <code>flow</code> <code>OpenMLFlow (optional, only if `return_flow` is True).</code> <p>Flow generated from the model.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def run_model_on_task(  # noqa: PLR0913\n    model: Any,\n    task: int | str | OpenMLTask,\n    avoid_duplicate_runs: bool = True,  # noqa: FBT001, FBT002\n    flow_tags: list[str] | None = None,\n    seed: int | None = None,\n    add_local_measures: bool = True,  # noqa: FBT001, FBT002\n    upload_flow: bool = False,  # noqa: FBT001, FBT002\n    return_flow: bool = False,  # noqa: FBT001, FBT002\n    n_jobs: int | None = None,\n) -&gt; OpenMLRun | tuple[OpenMLRun, OpenMLFlow]:\n    \"\"\"Run the model on the dataset defined by the task.\n\n    Parameters\n    ----------\n    model : sklearn model\n        A model which has a function fit(X,Y) and predict(X),\n        all supervised estimators of scikit learn follow this definition of a model.\n    task : OpenMLTask or int or str\n        Task to perform or Task id.\n        This may be a model instead if the first argument is an OpenMLTask.\n    avoid_duplicate_runs : bool, optional (default=True)\n        If True, the run will throw an error if the setup/task combination is already present on\n        the server. This feature requires an internet connection.\n    flow_tags : List[str], optional (default=None)\n        A list of tags that the flow should have at creation.\n    seed: int, optional (default=None)\n        Models that are not seeded will get this seed.\n    add_local_measures : bool, optional (default=True)\n        Determines whether to calculate a set of evaluation measures locally,\n        to later verify server behaviour.\n    upload_flow : bool (default=False)\n        If True, upload the flow to OpenML if it does not exist yet.\n        If False, do not upload the flow to OpenML.\n    return_flow : bool (default=False)\n        If True, returns the OpenMLFlow generated from the model in addition to the OpenMLRun.\n    n_jobs : int (default=None)\n        The number of processes/threads to distribute the evaluation asynchronously.\n        If `None` or `1`, then the evaluation is treated as synchronous and processed sequentially.\n        If `-1`, then the job uses as many cores available.\n\n    Returns\n    -------\n    run : OpenMLRun\n        Result of the run.\n    flow : OpenMLFlow (optional, only if `return_flow` is True).\n        Flow generated from the model.\n    \"\"\"\n    if avoid_duplicate_runs and not config.apikey:\n        warnings.warn(\n            \"avoid_duplicate_runs is set to True, but no API key is set. \"\n            \"Please set your API key in the OpenML configuration file, see\"\n            \"https://openml.github.io/openml-python/main/examples/20_basic/introduction_tutorial\"\n            \".html#authentication for more information on authentication.\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n\n    # TODO: At some point in the future do not allow for arguments in old order (6-2018).\n    # Flexibility currently still allowed due to code-snippet in OpenML100 paper (3-2019).\n    # When removing this please also remove the method `is_estimator` from the extension\n    # interface as it is only used here (MF, 3-2019)\n    if isinstance(model, (int, str, OpenMLTask)):\n        warnings.warn(\n            \"The old argument order (task, model) is deprecated and \"\n            \"will not be supported in the future. Please use the \"\n            \"order (model, task).\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        task, model = model, task\n\n    extension = get_extension_by_model(model, raise_if_no_extension=True)\n    if extension is None:\n        # This should never happen and is only here to please mypy will be gone soon once the\n        # whole function is removed\n        raise TypeError(extension)\n\n    flow = extension.model_to_flow(model)\n\n    def get_task_and_type_conversion(_task: int | str | OpenMLTask) -&gt; OpenMLTask:\n        \"\"\"Retrieve an OpenMLTask object from either an integer or string ID,\n        or directly from an OpenMLTask object.\n\n        Parameters\n        ----------\n        _task : Union[int, str, OpenMLTask]\n            The task ID or the OpenMLTask object.\n\n        Returns\n        -------\n        OpenMLTask\n            The OpenMLTask object.\n        \"\"\"\n        if isinstance(_task, (int, str)):\n            return get_task(int(_task))  # type: ignore\n\n        return _task\n\n    task = get_task_and_type_conversion(task)\n\n    run = run_flow_on_task(\n        task=task,\n        flow=flow,\n        avoid_duplicate_runs=avoid_duplicate_runs,\n        flow_tags=flow_tags,\n        seed=seed,\n        add_local_measures=add_local_measures,\n        upload_flow=upload_flow,\n        n_jobs=n_jobs,\n    )\n    if return_flow:\n        return run, flow\n    return run\n</code></pre>"},{"location":"reference/runs/functions/","title":"functions","text":""},{"location":"reference/runs/functions/#openml.runs.functions.__list_runs","title":"<code>__list_runs(api_call)</code>","text":"<p>Helper function to parse API calls which are lists of runs</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def __list_runs(api_call: str) -&gt; pd.DataFrame:\n    \"\"\"Helper function to parse API calls which are lists of runs\"\"\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    runs_dict = xmltodict.parse(xml_string, force_list=(\"oml:run\",))\n    # Minimalistic check if the XML is useful\n    if \"oml:runs\" not in runs_dict:\n        raise ValueError(f'Error in return XML, does not contain \"oml:runs\": {runs_dict}')\n\n    if \"@xmlns:oml\" not in runs_dict[\"oml:runs\"]:\n        raise ValueError(\n            f'Error in return XML, does not contain \"oml:runs\"/@xmlns:oml: {runs_dict}'\n        )\n\n    if runs_dict[\"oml:runs\"][\"@xmlns:oml\"] != \"http://openml.org/openml\":\n        raise ValueError(\n            \"Error in return XML, value of  \"\n            '\"oml:runs\"/@xmlns:oml is not '\n            f'\"http://openml.org/openml\": {runs_dict}',\n        )\n\n    assert isinstance(runs_dict[\"oml:runs\"][\"oml:run\"], list), type(runs_dict[\"oml:runs\"])\n\n    runs = {\n        int(r[\"oml:run_id\"]): {\n            \"run_id\": int(r[\"oml:run_id\"]),\n            \"task_id\": int(r[\"oml:task_id\"]),\n            \"setup_id\": int(r[\"oml:setup_id\"]),\n            \"flow_id\": int(r[\"oml:flow_id\"]),\n            \"uploader\": int(r[\"oml:uploader\"]),\n            \"task_type\": TaskType(int(r[\"oml:task_type_id\"])),\n            \"upload_time\": str(r[\"oml:upload_time\"]),\n            \"error_message\": str((r[\"oml:error_message\"]) or \"\"),\n        }\n        for r in runs_dict[\"oml:runs\"][\"oml:run\"]\n    }\n    return pd.DataFrame.from_dict(runs, orient=\"index\")\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.delete_run","title":"<code>delete_run(run_id)</code>","text":"<p>Delete run with id <code>run_id</code> from the OpenML server.</p> <p>You can only delete runs which you uploaded.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>OpenML id of the run</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def delete_run(run_id: int) -&gt; bool:\n    \"\"\"Delete run with id `run_id` from the OpenML server.\n\n    You can only delete runs which you uploaded.\n\n    Parameters\n    ----------\n    run_id : int\n        OpenML id of the run\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"run\", run_id)\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.format_prediction","title":"<code>format_prediction(task, repeat, fold, index, prediction, truth, sample=None, proba=None)</code>","text":"<p>Format the predictions in the specific order as required for the run results.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>OpenMLSupervisedTask</code> <p>Task for which to format the predictions.</p> required <code>repeat</code> <code>int</code> <p>From which repeat this predictions is made.</p> required <code>fold</code> <code>int</code> <p>From which fold this prediction is made.</p> required <code>index</code> <code>int</code> <p>For which index this prediction is made.</p> required <code>prediction</code> <code>str | int | float</code> <p>The predicted class label or value.</p> required <code>truth</code> <code>str | int | float</code> <p>The true class label or value.</p> required <code>sample</code> <code>int | None</code> <p>From which sample set this prediction is made. Required only for LearningCurve tasks.</p> <code>None</code> <code>proba</code> <code>dict[str, float] | None</code> <p>For classification tasks only. A mapping from each class label to their predicted probability. The dictionary should contain an entry for each of the <code>task.class_labels</code>. E.g.: {\"Iris-Setosa\": 0.2, \"Iris-Versicolor\": 0.7, \"Iris-Virginica\": 0.1}</p> <code>None</code> <p>Returns:</p> Type Description <code>A list with elements for the prediction results of a run.</code> <code>The returned order of the elements is (if available):</code> <p>[repeat, fold, sample, index, prediction, truth, *probabilities]</p> <code>This order follows the R Client API.</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def format_prediction(  # noqa: PLR0913\n    task: OpenMLSupervisedTask,\n    repeat: int,\n    fold: int,\n    index: int,\n    prediction: str | int | float,\n    truth: str | int | float,\n    sample: int | None = None,\n    proba: dict[str, float] | None = None,\n) -&gt; list[str | int | float]:\n    \"\"\"Format the predictions in the specific order as required for the run results.\n\n    Parameters\n    ----------\n    task: OpenMLSupervisedTask\n        Task for which to format the predictions.\n    repeat: int\n        From which repeat this predictions is made.\n    fold: int\n        From which fold this prediction is made.\n    index: int\n        For which index this prediction is made.\n    prediction: str, int or float\n        The predicted class label or value.\n    truth: str, int or float\n        The true class label or value.\n    sample: int, optional (default=None)\n        From which sample set this prediction is made.\n        Required only for LearningCurve tasks.\n    proba: Dict[str, float], optional (default=None)\n        For classification tasks only.\n        A mapping from each class label to their predicted probability.\n        The dictionary should contain an entry for each of the `task.class_labels`.\n        E.g.: {\"Iris-Setosa\": 0.2, \"Iris-Versicolor\": 0.7, \"Iris-Virginica\": 0.1}\n\n    Returns\n    -------\n    A list with elements for the prediction results of a run.\n\n    The returned order of the elements is (if available):\n        [repeat, fold, sample, index, prediction, truth, *probabilities]\n\n    This order follows the R Client API.\n    \"\"\"\n    if isinstance(task, OpenMLClassificationTask):\n        if proba is None:\n            raise ValueError(\"`proba` is required for classification task\")\n        if task.class_labels is None:\n            raise ValueError(\"The classification task must have class labels set\")\n        if not set(task.class_labels) == set(proba):\n            raise ValueError(\"Each class should have a predicted probability\")\n        if sample is None:\n            if isinstance(task, OpenMLLearningCurveTask):\n                raise ValueError(\"`sample` can not be none for LearningCurveTask\")\n\n            sample = 0\n        probabilities = [proba[c] for c in task.class_labels]\n        return [repeat, fold, sample, index, prediction, truth, *probabilities]\n\n    if isinstance(task, OpenMLRegressionTask):\n        return [repeat, fold, index, prediction, truth]\n\n    raise NotImplementedError(f\"Formatting for {type(task)} is not supported.\")\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.get_run","title":"<code>get_run(run_id, ignore_cache=False)</code>","text":"<p>Gets run corresponding to run_id.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> required <code>ignore_cache</code> <code>bool</code> <p>Whether to ignore the cache. If <code>true</code> this will download and overwrite the run xml even if the requested run is already cached.</p> <code>False</code> <code>ignore_cache</code> <code>bool</code> <code>False</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>Run corresponding to ID, fetched from the server.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_run(run_id: int, ignore_cache: bool = False) -&gt; OpenMLRun:  # noqa: FBT002, FBT001\n    \"\"\"Gets run corresponding to run_id.\n\n    Parameters\n    ----------\n    run_id : int\n\n    ignore_cache : bool\n        Whether to ignore the cache. If ``true`` this will download and overwrite the run xml\n        even if the requested run is already cached.\n\n    ignore_cache\n\n    Returns\n    -------\n    run : OpenMLRun\n        Run corresponding to ID, fetched from the server.\n    \"\"\"\n    run_dir = Path(openml.utils._create_cache_directory_for_id(RUNS_CACHE_DIR_NAME, run_id))\n    run_file = run_dir / \"description.xml\"\n\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    try:\n        if not ignore_cache:\n            return _get_cached_run(run_id)\n\n        raise OpenMLCacheException(message=\"dummy\")\n\n    except OpenMLCacheException:\n        run_xml = openml._api_calls._perform_api_call(\"run/%d\" % run_id, \"get\")\n        with run_file.open(\"w\", encoding=\"utf8\") as fh:\n            fh.write(run_xml)\n\n    return _create_run_from_xml(run_xml)\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.get_run_trace","title":"<code>get_run_trace(run_id)</code>","text":"<p>Get the optimization trace object for a given run id.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>OpenMLTrace</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def get_run_trace(run_id: int) -&gt; OpenMLRunTrace:\n    \"\"\"\n    Get the optimization trace object for a given run id.\n\n    Parameters\n    ----------\n    run_id : int\n\n    Returns\n    -------\n    openml.runs.OpenMLTrace\n    \"\"\"\n    trace_xml = openml._api_calls._perform_api_call(\"run/trace/%d\" % run_id, \"get\")\n    return OpenMLRunTrace.trace_from_xml(trace_xml)\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.get_runs","title":"<code>get_runs(run_ids)</code>","text":"<p>Gets all runs in run_ids list.</p> <p>Parameters:</p> Name Type Description Default <code>run_ids</code> <code>list of ints</code> required <p>Returns:</p> Name Type Description <code>runs</code> <code>list of OpenMLRun</code> <p>List of runs corresponding to IDs, fetched from the server.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def get_runs(run_ids: list[int]) -&gt; list[OpenMLRun]:\n    \"\"\"Gets all runs in run_ids list.\n\n    Parameters\n    ----------\n    run_ids : list of ints\n\n    Returns\n    -------\n    runs : list of OpenMLRun\n        List of runs corresponding to IDs, fetched from the server.\n    \"\"\"\n    runs = []\n    for run_id in run_ids:\n        runs.append(get_run(run_id))\n    return runs\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.initialize_model_from_run","title":"<code>initialize_model_from_run(run_id, *, strict_version=True)</code>","text":"<p>Initialized a model based on a run_id (i.e., using the exact same parameter settings)</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The Openml run_id</p> required <code>strict_version</code> <code>bool</code> <p>See <code>flow_to_model</code> strict_version.</p> <code>True</code> <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def initialize_model_from_run(run_id: int, *, strict_version: bool = True) -&gt; Any:\n    \"\"\"\n    Initialized a model based on a run_id (i.e., using the exact\n    same parameter settings)\n\n    Parameters\n    ----------\n    run_id : int\n        The Openml run_id\n    strict_version: bool (default=True)\n        See `flow_to_model` strict_version.\n\n    Returns\n    -------\n    model\n    \"\"\"\n    run = get_run(run_id)\n    # TODO(eddiebergman): I imagine this is None if it's not published,\n    # might need to raise an explicit error for that\n    assert run.setup_id is not None\n    return initialize_model(setup_id=run.setup_id, strict_version=strict_version)\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.initialize_model_from_trace","title":"<code>initialize_model_from_trace(run_id, repeat, fold, iteration=None)</code>","text":"<p>Initialize a model based on the parameters that were set by an optimization procedure (i.e., using the exact same parameter settings)</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>The Openml run_id. Should contain a trace file, otherwise a OpenMLServerException is raised</p> required <code>repeat</code> <code>int</code> <p>The repeat nr (column in trace file)</p> required <code>fold</code> <code>int</code> <p>The fold nr (column in trace file)</p> required <code>iteration</code> <code>int</code> <p>The iteration nr (column in trace file). If None, the best (selected) iteration will be searched (slow), according to the selection criteria implemented in OpenMLRunTrace.get_selected_iteration</p> <code>None</code> <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def initialize_model_from_trace(\n    run_id: int,\n    repeat: int,\n    fold: int,\n    iteration: int | None = None,\n) -&gt; Any:\n    \"\"\"\n    Initialize a model based on the parameters that were set\n    by an optimization procedure (i.e., using the exact same\n    parameter settings)\n\n    Parameters\n    ----------\n    run_id : int\n        The Openml run_id. Should contain a trace file,\n        otherwise a OpenMLServerException is raised\n\n    repeat : int\n        The repeat nr (column in trace file)\n\n    fold : int\n        The fold nr (column in trace file)\n\n    iteration : int\n        The iteration nr (column in trace file). If None, the\n        best (selected) iteration will be searched (slow),\n        according to the selection criteria implemented in\n        OpenMLRunTrace.get_selected_iteration\n\n    Returns\n    -------\n    model\n    \"\"\"\n    run = get_run(run_id)\n    # TODO(eddiebergman): I imagine this is None if it's not published,\n    # might need to raise an explicit error for that\n    assert run.flow_id is not None\n\n    flow = get_flow(run.flow_id)\n    run_trace = get_run_trace(run_id)\n\n    if iteration is None:\n        iteration = run_trace.get_selected_iteration(repeat, fold)\n\n    request = (repeat, fold, iteration)\n    if request not in run_trace.trace_iterations:\n        raise ValueError(\"Combination repeat, fold, iteration not available\")\n    current = run_trace.trace_iterations[(repeat, fold, iteration)]\n\n    search_model = initialize_model_from_run(run_id)\n    return flow.extension.instantiate_model_from_hpo_class(search_model, current)\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.list_runs","title":"<code>list_runs(offset=None, size=None, id=None, task=None, setup=None, flow=None, uploader=None, tag=None, study=None, display_errors=False, task_type=None)</code>","text":"<p>List all runs matching all of the given filters. (Supports large amount of results)</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>the number of runs to skip, starting from the first</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of runs to show</p> <code>None</code> <code>id</code> <code>list</code> <code>None</code> <code>task</code> <code>list</code> <code>None</code> <code>setup</code> <code>list | None</code> <code>None</code> <code>flow</code> <code>list</code> <code>None</code> <code>uploader</code> <code>list</code> <code>None</code> <code>tag</code> <code>str</code> <code>None</code> <code>study</code> <code>int</code> <code>None</code> <code>display_errors</code> <code>(bool, optional(default=None))</code> <p>Whether to list runs which have an error (for example a missing prediction file).</p> <code>False</code> <code>task_type</code> <code>str</code> <code>None</code> <p>Returns:</p> Type Description <code>dataframe</code> Source code in <code>openml/runs/functions.py</code> <pre><code>def list_runs(  # noqa: PLR0913\n    offset: int | None = None,\n    size: int | None = None,\n    id: list | None = None,  # noqa: A002\n    task: list[int] | None = None,\n    setup: list | None = None,\n    flow: list | None = None,\n    uploader: list | None = None,\n    tag: str | None = None,\n    study: int | None = None,\n    display_errors: bool = False,  # noqa: FBT001, FBT002\n    task_type: TaskType | int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    List all runs matching all of the given filters.\n    (Supports large amount of results)\n\n    Parameters\n    ----------\n    offset : int, optional\n        the number of runs to skip, starting from the first\n    size : int, optional\n        the maximum number of runs to show\n\n    id : list, optional\n\n    task : list, optional\n\n    setup: list, optional\n\n    flow : list, optional\n\n    uploader : list, optional\n\n    tag : str, optional\n\n    study : int, optional\n\n    display_errors : bool, optional (default=None)\n        Whether to list runs which have an error (for example a missing\n        prediction file).\n\n    task_type : str, optional\n\n    Returns\n    -------\n    dataframe\n    \"\"\"\n    if id is not None and (not isinstance(id, list)):\n        raise TypeError(\"id must be of type list.\")\n    if task is not None and (not isinstance(task, list)):\n        raise TypeError(\"task must be of type list.\")\n    if setup is not None and (not isinstance(setup, list)):\n        raise TypeError(\"setup must be of type list.\")\n    if flow is not None and (not isinstance(flow, list)):\n        raise TypeError(\"flow must be of type list.\")\n    if uploader is not None and (not isinstance(uploader, list)):\n        raise TypeError(\"uploader must be of type list.\")\n\n    listing_call = partial(\n        _list_runs,\n        id=id,\n        task=task,\n        setup=setup,\n        flow=flow,\n        uploader=uploader,\n        tag=tag,\n        study=study,\n        display_errors=display_errors,\n        task_type=task_type,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.run_exists","title":"<code>run_exists(task_id, setup_id)</code>","text":"<p>Checks whether a task/setup combination is already present on the server.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> required <code>setup_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>    Set run ids for runs where flow setup_id was run on task_id. Empty</code> <p>set if it wasn't run yet.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def run_exists(task_id: int, setup_id: int) -&gt; set[int]:\n    \"\"\"Checks whether a task/setup combination is already present on the\n    server.\n\n    Parameters\n    ----------\n    task_id : int\n\n    setup_id : int\n\n    Returns\n    -------\n        Set run ids for runs where flow setup_id was run on task_id. Empty\n        set if it wasn't run yet.\n    \"\"\"\n    if setup_id &lt;= 0:\n        # openml setups are in range 1-inf\n        return set()\n\n    try:\n        result = list_runs(task=[task_id], setup=[setup_id])\n        return set() if result.empty else set(result[\"run_id\"])\n    except OpenMLServerException as exception:\n        # error code implies no results. The run does not exist yet\n        if exception.code != ERROR_CODE:\n            raise exception\n        return set()\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.run_flow_on_task","title":"<code>run_flow_on_task(flow, task, avoid_duplicate_runs=True, flow_tags=None, seed=None, add_local_measures=True, upload_flow=False, n_jobs=None)</code>","text":"<p>Run the model provided by the flow on the dataset defined by task.</p> <p>Takes the flow and repeat information into account. The Flow may optionally be published.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>A flow wraps a machine learning model together with relevant information. The model has a function fit(X,Y) and predict(X), all supervised estimators of scikit learn follow this definition of a model.</p> required <code>task</code> <code>OpenMLTask</code> <p>Task to perform. This may be an OpenMLFlow instead if the first argument is an OpenMLTask.</p> required <code>avoid_duplicate_runs</code> <code>(bool, optional(default=True))</code> <p>If True, the run will throw an error if the setup/task combination is already present on the server. This feature requires an internet connection.</p> <code>True</code> <code>flow_tags</code> <code>(List[str], optional(default=None))</code> <p>A list of tags that the flow should have at creation.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>Models that are not seeded will get this seed.</p> <code>None</code> <code>add_local_measures</code> <code>(bool, optional(default=True))</code> <p>Determines whether to calculate a set of evaluation measures locally, to later verify server behaviour.</p> <code>True</code> <code>upload_flow</code> <code>bool(default=False)</code> <p>If True, upload the flow to OpenML if it does not exist yet. If False, do not upload the flow to OpenML.</p> <code>False</code> <code>n_jobs</code> <code>int(default=None)</code> <p>The number of processes/threads to distribute the evaluation asynchronously. If <code>None</code> or <code>1</code>, then the evaluation is treated as synchronous and processed sequentially. If <code>-1</code>, then the job uses as many cores available.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>Result of the run.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def run_flow_on_task(  # noqa: C901, PLR0912, PLR0915, PLR0913\n    flow: OpenMLFlow,\n    task: OpenMLTask,\n    avoid_duplicate_runs: bool = True,  # noqa: FBT002, FBT001\n    flow_tags: list[str] | None = None,\n    seed: int | None = None,\n    add_local_measures: bool = True,  # noqa: FBT001, FBT002\n    upload_flow: bool = False,  # noqa: FBT001, FBT002\n    n_jobs: int | None = None,\n) -&gt; OpenMLRun:\n    \"\"\"Run the model provided by the flow on the dataset defined by task.\n\n    Takes the flow and repeat information into account.\n    The Flow may optionally be published.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        A flow wraps a machine learning model together with relevant information.\n        The model has a function fit(X,Y) and predict(X),\n        all supervised estimators of scikit learn follow this definition of a model.\n    task : OpenMLTask\n        Task to perform. This may be an OpenMLFlow instead if the first argument is an OpenMLTask.\n    avoid_duplicate_runs : bool, optional (default=True)\n        If True, the run will throw an error if the setup/task combination is already present on\n        the server. This feature requires an internet connection.\n    flow_tags : List[str], optional (default=None)\n        A list of tags that the flow should have at creation.\n    seed: int, optional (default=None)\n        Models that are not seeded will get this seed.\n    add_local_measures : bool, optional (default=True)\n        Determines whether to calculate a set of evaluation measures locally,\n        to later verify server behaviour.\n    upload_flow : bool (default=False)\n        If True, upload the flow to OpenML if it does not exist yet.\n        If False, do not upload the flow to OpenML.\n    n_jobs : int (default=None)\n        The number of processes/threads to distribute the evaluation asynchronously.\n        If `None` or `1`, then the evaluation is treated as synchronous and processed sequentially.\n        If `-1`, then the job uses as many cores available.\n\n    Returns\n    -------\n    run : OpenMLRun\n        Result of the run.\n    \"\"\"\n    if flow_tags is not None and not isinstance(flow_tags, list):\n        raise ValueError(\"flow_tags should be a list\")\n\n    # TODO: At some point in the future do not allow for arguments in old order (changed 6-2018).\n    # Flexibility currently still allowed due to code-snippet in OpenML100 paper (3-2019).\n    if isinstance(flow, OpenMLTask) and isinstance(task, OpenMLFlow):\n        # We want to allow either order of argument (to avoid confusion).\n        warnings.warn(\n            \"The old argument order (Flow, model) is deprecated and \"\n            \"will not be supported in the future. Please use the \"\n            \"order (model, Flow).\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        task, flow = flow, task\n\n    if task.task_id is None:\n        raise ValueError(\"The task should be published at OpenML\")\n\n    if flow.model is None:\n        flow.model = flow.extension.flow_to_model(flow)\n\n    flow.model = flow.extension.seed_model(flow.model, seed=seed)\n\n    # We only need to sync with the server right now if we want to upload the flow,\n    # or ensure no duplicate runs exist. Otherwise it can be synced at upload time.\n    flow_id = None\n    if upload_flow or avoid_duplicate_runs:\n        flow_id = flow_exists(flow.name, flow.external_version)\n        if isinstance(flow.flow_id, int) and flow_id != flow.flow_id:\n            if flow_id is not False:\n                raise PyOpenMLError(\n                    f\"Local flow_id does not match server flow_id: '{flow.flow_id}' vs '{flow_id}'\",\n                )\n            raise PyOpenMLError(\n                \"Flow does not exist on the server, but 'flow.flow_id' is not None.\"\n            )\n        if upload_flow and flow_id is False:\n            flow.publish()\n            flow_id = flow.flow_id\n        elif flow_id:\n            flow_from_server = get_flow(flow_id)\n            _copy_server_fields(flow_from_server, flow)\n            if avoid_duplicate_runs:\n                flow_from_server.model = flow.model\n                setup_id = setup_exists(flow_from_server)\n                ids = run_exists(task.task_id, setup_id)\n                if ids:\n                    error_message = (\n                        \"One or more runs of this setup were already performed on the task.\"\n                    )\n                    raise OpenMLRunsExistError(ids, error_message)\n        else:\n            # Flow does not exist on server and we do not want to upload it.\n            # No sync with the server happens.\n            flow_id = None\n\n    dataset = task.get_dataset()\n\n    run_environment = flow.extension.get_version_information()\n    tags = [\"openml-python\", run_environment[1]]\n\n    if flow.extension.check_if_model_fitted(flow.model):\n        warnings.warn(\n            \"The model is already fitted! This might cause inconsistency in comparison of results.\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n\n    # execute the run\n    res = _run_task_get_arffcontent(\n        model=flow.model,\n        task=task,\n        extension=flow.extension,\n        add_local_measures=add_local_measures,\n        n_jobs=n_jobs,\n    )\n\n    data_content, trace, fold_evaluations, sample_evaluations = res\n    fields = [*run_environment, time.strftime(\"%c\"), \"Created by run_flow_on_task\"]\n    generated_description = \"\\n\".join(fields)\n    run = OpenMLRun(\n        task_id=task.task_id,\n        flow_id=flow_id,\n        dataset_id=dataset.dataset_id,\n        model=flow.model,\n        flow_name=flow.name,\n        tags=tags,\n        trace=trace,\n        data_content=data_content,\n        flow=flow,\n        setup_string=flow.extension.create_setup_string(flow.model),\n        description_text=generated_description,\n    )\n\n    if (upload_flow or avoid_duplicate_runs) and flow.flow_id is not None:\n        # We only extract the parameter settings if a sync happened with the server.\n        # I.e. when the flow was uploaded or we found it in the avoid_duplicate check.\n        # Otherwise, we will do this at upload time.\n        run.parameter_settings = flow.extension.obtain_parameter_values(flow)\n\n    # now we need to attach the detailed evaluations\n    if task.task_type_id == TaskType.LEARNING_CURVE:\n        run.sample_evaluations = sample_evaluations\n    else:\n        run.fold_evaluations = fold_evaluations\n\n    if flow_id:\n        message = f\"Executed Task {task.task_id} with Flow id:{run.flow_id}\"\n    else:\n        message = f\"Executed Task {task.task_id} on local Flow with name {flow.name}.\"\n    config.logger.info(message)\n\n    return run\n</code></pre>"},{"location":"reference/runs/functions/#openml.runs.functions.run_model_on_task","title":"<code>run_model_on_task(model, task, avoid_duplicate_runs=True, flow_tags=None, seed=None, add_local_measures=True, upload_flow=False, return_flow=False, n_jobs=None)</code>","text":"<p>Run the model on the dataset defined by the task.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>sklearn model</code> <p>A model which has a function fit(X,Y) and predict(X), all supervised estimators of scikit learn follow this definition of a model.</p> required <code>task</code> <code>OpenMLTask or int or str</code> <p>Task to perform or Task id. This may be a model instead if the first argument is an OpenMLTask.</p> required <code>avoid_duplicate_runs</code> <code>(bool, optional(default=True))</code> <p>If True, the run will throw an error if the setup/task combination is already present on the server. This feature requires an internet connection.</p> <code>True</code> <code>flow_tags</code> <code>(List[str], optional(default=None))</code> <p>A list of tags that the flow should have at creation.</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>Models that are not seeded will get this seed.</p> <code>None</code> <code>add_local_measures</code> <code>(bool, optional(default=True))</code> <p>Determines whether to calculate a set of evaluation measures locally, to later verify server behaviour.</p> <code>True</code> <code>upload_flow</code> <code>bool(default=False)</code> <p>If True, upload the flow to OpenML if it does not exist yet. If False, do not upload the flow to OpenML.</p> <code>False</code> <code>return_flow</code> <code>bool(default=False)</code> <p>If True, returns the OpenMLFlow generated from the model in addition to the OpenMLRun.</p> <code>False</code> <code>n_jobs</code> <code>int(default=None)</code> <p>The number of processes/threads to distribute the evaluation asynchronously. If <code>None</code> or <code>1</code>, then the evaluation is treated as synchronous and processed sequentially. If <code>-1</code>, then the job uses as many cores available.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>Result of the run.</p> <code>flow</code> <code>OpenMLFlow (optional, only if `return_flow` is True).</code> <p>Flow generated from the model.</p> Source code in <code>openml/runs/functions.py</code> <pre><code>def run_model_on_task(  # noqa: PLR0913\n    model: Any,\n    task: int | str | OpenMLTask,\n    avoid_duplicate_runs: bool = True,  # noqa: FBT001, FBT002\n    flow_tags: list[str] | None = None,\n    seed: int | None = None,\n    add_local_measures: bool = True,  # noqa: FBT001, FBT002\n    upload_flow: bool = False,  # noqa: FBT001, FBT002\n    return_flow: bool = False,  # noqa: FBT001, FBT002\n    n_jobs: int | None = None,\n) -&gt; OpenMLRun | tuple[OpenMLRun, OpenMLFlow]:\n    \"\"\"Run the model on the dataset defined by the task.\n\n    Parameters\n    ----------\n    model : sklearn model\n        A model which has a function fit(X,Y) and predict(X),\n        all supervised estimators of scikit learn follow this definition of a model.\n    task : OpenMLTask or int or str\n        Task to perform or Task id.\n        This may be a model instead if the first argument is an OpenMLTask.\n    avoid_duplicate_runs : bool, optional (default=True)\n        If True, the run will throw an error if the setup/task combination is already present on\n        the server. This feature requires an internet connection.\n    flow_tags : List[str], optional (default=None)\n        A list of tags that the flow should have at creation.\n    seed: int, optional (default=None)\n        Models that are not seeded will get this seed.\n    add_local_measures : bool, optional (default=True)\n        Determines whether to calculate a set of evaluation measures locally,\n        to later verify server behaviour.\n    upload_flow : bool (default=False)\n        If True, upload the flow to OpenML if it does not exist yet.\n        If False, do not upload the flow to OpenML.\n    return_flow : bool (default=False)\n        If True, returns the OpenMLFlow generated from the model in addition to the OpenMLRun.\n    n_jobs : int (default=None)\n        The number of processes/threads to distribute the evaluation asynchronously.\n        If `None` or `1`, then the evaluation is treated as synchronous and processed sequentially.\n        If `-1`, then the job uses as many cores available.\n\n    Returns\n    -------\n    run : OpenMLRun\n        Result of the run.\n    flow : OpenMLFlow (optional, only if `return_flow` is True).\n        Flow generated from the model.\n    \"\"\"\n    if avoid_duplicate_runs and not config.apikey:\n        warnings.warn(\n            \"avoid_duplicate_runs is set to True, but no API key is set. \"\n            \"Please set your API key in the OpenML configuration file, see\"\n            \"https://openml.github.io/openml-python/main/examples/20_basic/introduction_tutorial\"\n            \".html#authentication for more information on authentication.\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n\n    # TODO: At some point in the future do not allow for arguments in old order (6-2018).\n    # Flexibility currently still allowed due to code-snippet in OpenML100 paper (3-2019).\n    # When removing this please also remove the method `is_estimator` from the extension\n    # interface as it is only used here (MF, 3-2019)\n    if isinstance(model, (int, str, OpenMLTask)):\n        warnings.warn(\n            \"The old argument order (task, model) is deprecated and \"\n            \"will not be supported in the future. Please use the \"\n            \"order (model, task).\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        task, model = model, task\n\n    extension = get_extension_by_model(model, raise_if_no_extension=True)\n    if extension is None:\n        # This should never happen and is only here to please mypy will be gone soon once the\n        # whole function is removed\n        raise TypeError(extension)\n\n    flow = extension.model_to_flow(model)\n\n    def get_task_and_type_conversion(_task: int | str | OpenMLTask) -&gt; OpenMLTask:\n        \"\"\"Retrieve an OpenMLTask object from either an integer or string ID,\n        or directly from an OpenMLTask object.\n\n        Parameters\n        ----------\n        _task : Union[int, str, OpenMLTask]\n            The task ID or the OpenMLTask object.\n\n        Returns\n        -------\n        OpenMLTask\n            The OpenMLTask object.\n        \"\"\"\n        if isinstance(_task, (int, str)):\n            return get_task(int(_task))  # type: ignore\n\n        return _task\n\n    task = get_task_and_type_conversion(task)\n\n    run = run_flow_on_task(\n        task=task,\n        flow=flow,\n        avoid_duplicate_runs=avoid_duplicate_runs,\n        flow_tags=flow_tags,\n        seed=seed,\n        add_local_measures=add_local_measures,\n        upload_flow=upload_flow,\n        n_jobs=n_jobs,\n    )\n    if return_flow:\n        return run, flow\n    return run\n</code></pre>"},{"location":"reference/runs/run/","title":"run","text":""},{"location":"reference/runs/run/#openml.runs.run.OpenMLRun","title":"<code>OpenMLRun</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Run: result of running a model on an OpenML dataset.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The ID of the OpenML task associated with the run.</p> required <code>flow_id</code> <code>int | None</code> <p>The ID of the OpenML flow associated with the run.</p> required <code>dataset_id</code> <code>int | None</code> <p>The ID of the OpenML dataset used for the run.</p> required <code>setup_string</code> <code>str | None</code> <p>The setup string of the run.</p> <code>None</code> <code>output_files</code> <code>dict[str, int] | None</code> <p>Specifies where each related file can be found.</p> <code>None</code> <code>setup_id</code> <code>int | None</code> <p>An integer representing the ID of the setup used for the run.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Representing the tags associated with the run.</p> <code>None</code> <code>uploader</code> <code>int | None</code> <p>User ID of the uploader.</p> <code>None</code> <code>uploader_name</code> <code>str | None</code> <p>The name of the person who uploaded the run.</p> <code>None</code> <code>evaluations</code> <code>dict | None</code> <p>Representing the evaluations of the run.</p> <code>None</code> <code>fold_evaluations</code> <code>dict | None</code> <p>The evaluations of the run for each fold.</p> <code>None</code> <code>sample_evaluations</code> <code>dict | None</code> <p>The evaluations of the run for each sample.</p> <code>None</code> <code>data_content</code> <code>list[list] | None</code> <p>The predictions generated from executing this run.</p> <code>None</code> <code>trace</code> <code>OpenMLRunTrace | None</code> <p>The trace containing information on internal model evaluations of this run.</p> <code>None</code> <code>model</code> <code>object | None</code> <p>The untrained model that was evaluated in the run.</p> <code>None</code> <code>task_type</code> <code>str | None</code> <p>The type of the OpenML task associated with the run.</p> <code>None</code> <code>task_evaluation_measure</code> <code>str | None</code> <p>The evaluation measure used for the task.</p> <code>None</code> <code>flow_name</code> <code>str | None</code> <p>The name of the OpenML flow associated with the run.</p> <code>None</code> <code>parameter_settings</code> <code>list[dict[str, Any]] | None</code> <p>Representing the parameter settings used for the run.</p> <code>None</code> <code>predictions_url</code> <code>str | None</code> <p>The URL of the predictions file.</p> <code>None</code> <code>task</code> <code>OpenMLTask | None</code> <p>An instance of the OpenMLTask class, representing the OpenML task associated with the run.</p> <code>None</code> <code>flow</code> <code>OpenMLFlow | None</code> <p>An instance of the OpenMLFlow class, representing the OpenML flow associated with the run.</p> <code>None</code> <code>run_id</code> <code>int | None</code> <p>The ID of the run.</p> <code>None</code> <code>description_text</code> <code>str | None</code> <p>Description text to add to the predictions file. If left None, is set to the time the arff file is generated.</p> <code>None</code> <code>run_details</code> <code>str | None</code> <p>Description of the run stored in the run meta-data.</p> <code>None</code> Source code in <code>openml/runs/run.py</code> <pre><code>class OpenMLRun(OpenMLBase):\n    \"\"\"OpenML Run: result of running a model on an OpenML dataset.\n\n    Parameters\n    ----------\n    task_id: int\n        The ID of the OpenML task associated with the run.\n    flow_id: int\n        The ID of the OpenML flow associated with the run.\n    dataset_id: int\n        The ID of the OpenML dataset used for the run.\n    setup_string: str\n        The setup string of the run.\n    output_files: Dict[str, int]\n        Specifies where each related file can be found.\n    setup_id: int\n        An integer representing the ID of the setup used for the run.\n    tags: List[str]\n        Representing the tags associated with the run.\n    uploader: int\n        User ID of the uploader.\n    uploader_name: str\n        The name of the person who uploaded the run.\n    evaluations: Dict\n        Representing the evaluations of the run.\n    fold_evaluations: Dict\n        The evaluations of the run for each fold.\n    sample_evaluations: Dict\n        The evaluations of the run for each sample.\n    data_content: List[List]\n        The predictions generated from executing this run.\n    trace: OpenMLRunTrace\n        The trace containing information on internal model evaluations of this run.\n    model: object\n        The untrained model that was evaluated in the run.\n    task_type: str\n        The type of the OpenML task associated with the run.\n    task_evaluation_measure: str\n        The evaluation measure used for the task.\n    flow_name: str\n        The name of the OpenML flow associated with the run.\n    parameter_settings: list[OrderedDict]\n        Representing the parameter settings used for the run.\n    predictions_url: str\n        The URL of the predictions file.\n    task: OpenMLTask\n        An instance of the OpenMLTask class, representing the OpenML task associated\n        with the run.\n    flow: OpenMLFlow\n        An instance of the OpenMLFlow class, representing the OpenML flow associated\n        with the run.\n    run_id: int\n        The ID of the run.\n    description_text: str, optional\n        Description text to add to the predictions file. If left None, is set to the\n        time the arff file is generated.\n    run_details: str, optional (default=None)\n        Description of the run stored in the run meta-data.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_id: int,\n        flow_id: int | None,\n        dataset_id: int | None,\n        setup_string: str | None = None,\n        output_files: dict[str, int] | None = None,\n        setup_id: int | None = None,\n        tags: list[str] | None = None,\n        uploader: int | None = None,\n        uploader_name: str | None = None,\n        evaluations: dict | None = None,\n        fold_evaluations: dict | None = None,\n        sample_evaluations: dict | None = None,\n        data_content: list[list] | None = None,\n        trace: OpenMLRunTrace | None = None,\n        model: object | None = None,\n        task_type: str | None = None,\n        task_evaluation_measure: str | None = None,\n        flow_name: str | None = None,\n        parameter_settings: list[dict[str, Any]] | None = None,\n        predictions_url: str | None = None,\n        task: OpenMLTask | None = None,\n        flow: OpenMLFlow | None = None,\n        run_id: int | None = None,\n        description_text: str | None = None,\n        run_details: str | None = None,\n    ):\n        self.uploader = uploader\n        self.uploader_name = uploader_name\n        self.task_id = task_id\n        self.task_type = task_type\n        self.task_evaluation_measure = task_evaluation_measure\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.setup_id = setup_id\n        self.setup_string = setup_string\n        self.parameter_settings = parameter_settings\n        self.dataset_id = dataset_id\n        self.evaluations = evaluations\n        self.fold_evaluations = fold_evaluations\n        self.sample_evaluations = sample_evaluations\n        self.data_content = data_content\n        self.output_files = output_files\n        self.trace = trace\n        self.error_message = None\n        self.task = task\n        self.flow = flow\n        self.run_id = run_id\n        self.model = model\n        self.tags = tags\n        self.predictions_url = predictions_url\n        self.description_text = description_text\n        self.run_details = run_details\n        self._predictions = None\n\n    @property\n    def predictions(self) -&gt; pd.DataFrame:\n        \"\"\"Return a DataFrame with predictions for this run\"\"\"\n        if self._predictions is None:\n            if self.data_content:\n                arff_dict = self._generate_arff_dict()\n            elif self.predictions_url:\n                arff_text = openml._api_calls._download_text_file(self.predictions_url)\n                arff_dict = arff.loads(arff_text)\n            else:\n                raise RuntimeError(\"Run has no predictions.\")\n            self._predictions = pd.DataFrame(\n                arff_dict[\"data\"],\n                columns=[name for name, _ in arff_dict[\"attributes\"]],\n            )\n        return self._predictions\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"The ID of the run, None if not uploaded to the server yet.\"\"\"\n        return self.run_id\n\n    def _evaluation_summary(self, metric: str) -&gt; str:\n        \"\"\"Summarizes the evaluation of a metric over all folds.\n\n        The fold scores for the metric must exist already. During run creation,\n        by default, the MAE for OpenMLRegressionTask and the accuracy for\n        OpenMLClassificationTask/OpenMLLearningCurveTasktasks are computed.\n\n        If repetition exist, we take the mean over all repetitions.\n\n        Parameters\n        ----------\n        metric: str\n            Name of an evaluation metric that was used to compute fold scores.\n\n        Returns\n        -------\n        metric_summary: str\n            A formatted string that displays the metric's evaluation summary.\n            The summary consists of the mean and std.\n        \"\"\"\n        if self.fold_evaluations is None:\n            raise ValueError(\"No fold evaluations available.\")\n        fold_score_lists = self.fold_evaluations[metric].values()\n\n        # Get the mean and std over all repetitions\n        rep_means = [np.mean(list(x.values())) for x in fold_score_lists]\n        rep_stds = [np.std(list(x.values())) for x in fold_score_lists]\n\n        return f\"{np.mean(rep_means):.4f} +- {np.mean(rep_stds):.4f}\"\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        # Set up fields\n        fields = {\n            \"Uploader Name\": self.uploader_name,\n            \"Metric\": self.task_evaluation_measure,\n            \"Run ID\": self.run_id,\n            \"Task ID\": self.task_id,\n            \"Task Type\": self.task_type,\n            \"Task URL\": openml.tasks.OpenMLTask.url_for_id(self.task_id),\n            \"Flow ID\": self.flow_id,\n            \"Flow Name\": self.flow_name,\n            \"Flow URL\": (\n                openml.flows.OpenMLFlow.url_for_id(self.flow_id)\n                if self.flow_id is not None\n                else None\n            ),\n            \"Setup ID\": self.setup_id,\n            \"Setup String\": self.setup_string,\n            \"Dataset ID\": self.dataset_id,\n            \"Dataset URL\": (\n                openml.datasets.OpenMLDataset.url_for_id(self.dataset_id)\n                if self.dataset_id is not None\n                else None\n            ),\n        }\n\n        # determines the order of the initial fields in which the information will be printed\n        order = [\"Uploader Name\", \"Uploader Profile\", \"Metric\", \"Result\"]\n\n        if self.uploader is not None:\n            fields[\"Uploader Profile\"] = f\"{openml.config.get_server_base_url()}/u/{self.uploader}\"\n        if self.run_id is not None:\n            fields[\"Run URL\"] = self.openml_url\n        if self.evaluations is not None and self.task_evaluation_measure in self.evaluations:\n            fields[\"Result\"] = self.evaluations[self.task_evaluation_measure]\n        elif self.fold_evaluations is not None:\n            # -- Add locally computed summary values if possible\n            if \"predictive_accuracy\" in self.fold_evaluations:\n                # OpenMLClassificationTask; OpenMLLearningCurveTask\n                result_field = \"Local Result - Accuracy (+- STD)\"\n                fields[result_field] = self._evaluation_summary(\"predictive_accuracy\")\n                order.append(result_field)\n            elif \"mean_absolute_error\" in self.fold_evaluations:\n                # OpenMLRegressionTask\n                result_field = \"Local Result - MAE (+- STD)\"\n                fields[result_field] = self._evaluation_summary(\"mean_absolute_error\")\n                order.append(result_field)\n\n            if \"usercpu_time_millis\" in self.fold_evaluations:\n                # Runtime should be available for most tasks types\n                rt_field = \"Local Runtime - ms (+- STD)\"\n                fields[rt_field] = self._evaluation_summary(\"usercpu_time_millis\")\n                order.append(rt_field)\n\n        # determines the remaining order\n        order += [\n            \"Run ID\",\n            \"Run URL\",\n            \"Task ID\",\n            \"Task Type\",\n            \"Task URL\",\n            \"Flow ID\",\n            \"Flow Name\",\n            \"Flow URL\",\n            \"Setup ID\",\n            \"Setup String\",\n            \"Dataset ID\",\n            \"Dataset URL\",\n        ]\n        return [\n            (key, \"None\" if fields[key] is None else fields[key])  # type: ignore\n            for key in order\n            if key in fields\n        ]\n\n    @classmethod\n    def from_filesystem(cls, directory: str | Path, expect_model: bool = True) -&gt; OpenMLRun:  # noqa: FBT001, FBT002\n        \"\"\"\n        The inverse of the to_filesystem method. Instantiates an OpenMLRun\n        object based on files stored on the file system.\n\n        Parameters\n        ----------\n        directory : str\n            a path leading to the folder where the results\n            are stored\n\n        expect_model : bool\n            if True, it requires the model pickle to be present, and an error\n            will be thrown if not. Otherwise, the model might or might not\n            be present.\n\n        Returns\n        -------\n        run : OpenMLRun\n            the re-instantiated run object\n        \"\"\"\n        # Avoiding cyclic imports\n        import openml.runs.functions\n\n        directory = Path(directory)\n        if not directory.is_dir():\n            raise ValueError(\"Could not find folder\")\n\n        description_path = directory / \"description.xml\"\n        predictions_path = directory / \"predictions.arff\"\n        trace_path = directory / \"trace.arff\"\n        model_path = directory / \"model.pkl\"\n\n        if not description_path.is_file():\n            raise ValueError(\"Could not find description.xml\")\n        if not predictions_path.is_file():\n            raise ValueError(\"Could not find predictions.arff\")\n        if (not model_path.is_file()) and expect_model:\n            raise ValueError(\"Could not find model.pkl\")\n\n        with description_path.open() as fht:\n            xml_string = fht.read()\n        run = openml.runs.functions._create_run_from_xml(xml_string, from_server=False)\n\n        if run.flow_id is None:\n            flow = openml.flows.OpenMLFlow.from_filesystem(directory)\n            run.flow = flow\n            run.flow_name = flow.name\n\n        with predictions_path.open() as fht:\n            predictions = arff.load(fht)\n            run.data_content = predictions[\"data\"]\n\n        if model_path.is_file():\n            # note that it will load the model if the file exists, even if\n            # expect_model is False\n            with model_path.open(\"rb\") as fhb:\n                run.model = pickle.load(fhb)  # noqa: S301\n\n        if trace_path.is_file():\n            run.trace = openml.runs.OpenMLRunTrace._from_filesystem(trace_path)\n\n        return run\n\n    def to_filesystem(\n        self,\n        directory: str | Path,\n        store_model: bool = True,  # noqa: FBT001, FBT002\n    ) -&gt; None:\n        \"\"\"\n        The inverse of the from_filesystem method. Serializes a run\n        on the filesystem, to be uploaded later.\n\n        Parameters\n        ----------\n        directory : str\n            a path leading to the folder where the results\n            will be stored. Should be empty\n\n        store_model : bool, optional (default=True)\n            if True, a model will be pickled as well. As this is the most\n            storage expensive part, it is often desirable to not store the\n            model.\n        \"\"\"\n        if self.data_content is None or self.model is None:\n            raise ValueError(\"Run should have been executed (and contain \" \"model / predictions)\")\n        directory = Path(directory)\n        directory.mkdir(exist_ok=True, parents=True)\n\n        if any(directory.iterdir()):\n            raise ValueError(f\"Output directory {directory.expanduser().resolve()} should be empty\")\n\n        run_xml = self._to_xml()\n        predictions_arff = arff.dumps(self._generate_arff_dict())\n\n        # It seems like typing does not allow to define the same variable multiple times\n        with (directory / \"description.xml\").open(\"w\") as fh:\n            fh.write(run_xml)\n        with (directory / \"predictions.arff\").open(\"w\") as fh:\n            fh.write(predictions_arff)\n        if store_model:\n            with (directory / \"model.pkl\").open(\"wb\") as fh_b:\n                pickle.dump(self.model, fh_b)\n\n        if self.flow_id is None and self.flow is not None:\n            self.flow.to_filesystem(directory)\n\n        if self.trace is not None:\n            self.trace._to_filesystem(directory)\n\n    def _generate_arff_dict(self) -&gt; OrderedDict[str, Any]:\n        \"\"\"Generates the arff dictionary for uploading predictions to the\n        server.\n\n        Assumes that the run has been executed.\n\n        The order of the attributes follows the order defined by the Client API for R.\n\n        Returns\n        -------\n        arf_dict : dict\n            Dictionary representation of the ARFF file that will be uploaded.\n            Contains predictions and information about the run environment.\n        \"\"\"\n        if self.data_content is None:\n            raise ValueError(\"Run has not been executed.\")\n        if self.flow is None:\n            assert self.flow_id is not None, \"Run has no associated flow id!\"\n            self.flow = get_flow(self.flow_id)\n\n        if self.description_text is None:\n            self.description_text = time.strftime(\"%c\")\n        task = get_task(self.task_id)\n\n        arff_dict = OrderedDict()  # type: 'OrderedDict[str, Any]'\n        arff_dict[\"data\"] = self.data_content\n        arff_dict[\"description\"] = self.description_text\n        arff_dict[\"relation\"] = f\"openml_task_{task.task_id}_predictions\"\n\n        if isinstance(task, OpenMLLearningCurveTask):\n            class_labels = task.class_labels\n            instance_specifications = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"sample\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n            ]\n\n            arff_dict[\"attributes\"] = instance_specifications\n            if class_labels is not None:\n                arff_dict[\"attributes\"] = (\n                    arff_dict[\"attributes\"]\n                    + [(\"prediction\", class_labels), (\"correct\", class_labels)]\n                    + [\n                        (\"confidence.\" + class_labels[i], \"NUMERIC\")\n                        for i in range(len(class_labels))\n                    ]\n                )\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n        elif isinstance(task, OpenMLClassificationTask):\n            class_labels = task.class_labels\n            instance_specifications = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"sample\", \"NUMERIC\"),  # Legacy\n                (\"row_id\", \"NUMERIC\"),\n            ]\n\n            arff_dict[\"attributes\"] = instance_specifications\n            if class_labels is not None:\n                prediction_confidences = [\n                    (\"confidence.\" + class_labels[i], \"NUMERIC\") for i in range(len(class_labels))\n                ]\n                prediction_and_true = [(\"prediction\", class_labels), (\"correct\", class_labels)]\n                arff_dict[\"attributes\"] = (\n                    arff_dict[\"attributes\"] + prediction_and_true + prediction_confidences\n                )\n            else:\n                raise ValueError(\"The task has no class labels\")\n\n        elif isinstance(task, OpenMLRegressionTask):\n            arff_dict[\"attributes\"] = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n                (\"prediction\", \"NUMERIC\"),\n                (\"truth\", \"NUMERIC\"),\n            ]\n\n        elif isinstance(task, OpenMLClusteringTask):\n            arff_dict[\"attributes\"] = [\n                (\"repeat\", \"NUMERIC\"),\n                (\"fold\", \"NUMERIC\"),\n                (\"row_id\", \"NUMERIC\"),\n                (\"cluster\", \"NUMERIC\"),\n            ]\n\n        else:\n            raise NotImplementedError(f\"Task type {task.task_type!s} is not yet supported.\")\n\n        return arff_dict\n\n    def get_metric_fn(self, sklearn_fn: Callable, kwargs: dict | None = None) -&gt; np.ndarray:  # noqa: PLR0915, PLR0912, C901\n        \"\"\"Calculates metric scores based on predicted values. Assumes the\n        run has been executed locally (and contains run_data). Furthermore,\n        it assumes that the 'correct' or 'truth' attribute is specified in\n        the arff (which is an optional field, but always the case for\n        openml-python runs)\n\n        Parameters\n        ----------\n        sklearn_fn : function\n            a function pointer to a sklearn function that\n            accepts ``y_true``, ``y_pred`` and ``**kwargs``\n        kwargs : dict\n            kwargs for the function\n\n        Returns\n        -------\n        scores : ndarray of scores of length num_folds * num_repeats\n            metric results\n        \"\"\"\n        kwargs = kwargs if kwargs else {}\n        if self.data_content is not None and self.task_id is not None:\n            predictions_arff = self._generate_arff_dict()\n        elif (self.output_files is not None) and (\"predictions\" in self.output_files):\n            predictions_file_url = openml._api_calls._file_id_to_url(\n                self.output_files[\"predictions\"],\n                \"predictions.arff\",\n            )\n            response = openml._api_calls._download_text_file(predictions_file_url)\n            predictions_arff = arff.loads(response)\n            # TODO: make this a stream reader\n        else:\n            raise ValueError(\n                \"Run should have been locally executed or \" \"contain outputfile reference.\",\n            )\n\n        # Need to know more about the task to compute scores correctly\n        task = get_task(self.task_id)\n\n        attribute_names = [att[0] for att in predictions_arff[\"attributes\"]]\n        if (\n            task.task_type_id in [TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE]\n            and \"correct\" not in attribute_names\n        ):\n            raise ValueError('Attribute \"correct\" should be set for ' \"classification task runs\")\n        if task.task_type_id == TaskType.SUPERVISED_REGRESSION and \"truth\" not in attribute_names:\n            raise ValueError('Attribute \"truth\" should be set for ' \"regression task runs\")\n        if task.task_type_id != TaskType.CLUSTERING and \"prediction\" not in attribute_names:\n            raise ValueError('Attribute \"predict\" should be set for ' \"supervised task runs\")\n\n        def _attribute_list_to_dict(attribute_list):  # type: ignore\n            # convenience function: Creates a mapping to map from the name of\n            # attributes present in the arff prediction file to their index.\n            # This is necessary because the number of classes can be different\n            # for different tasks.\n            res = OrderedDict()\n            for idx in range(len(attribute_list)):\n                res[attribute_list[idx][0]] = idx\n            return res\n\n        attribute_dict = _attribute_list_to_dict(predictions_arff[\"attributes\"])\n\n        repeat_idx = attribute_dict[\"repeat\"]\n        fold_idx = attribute_dict[\"fold\"]\n        predicted_idx = attribute_dict[\"prediction\"]  # Assume supervised task\n\n        if task.task_type_id in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n            correct_idx = attribute_dict[\"correct\"]\n        elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n            correct_idx = attribute_dict[\"truth\"]\n        has_samples = False\n        if \"sample\" in attribute_dict:\n            sample_idx = attribute_dict[\"sample\"]\n            has_samples = True\n\n        if (\n            predictions_arff[\"attributes\"][predicted_idx][1]\n            != predictions_arff[\"attributes\"][correct_idx][1]\n        ):\n            pred = predictions_arff[\"attributes\"][predicted_idx][1]\n            corr = predictions_arff[\"attributes\"][correct_idx][1]\n            raise ValueError(\n                \"Predicted and Correct do not have equal values:\" f\" {pred!s} Vs. {corr!s}\",\n            )\n\n        # TODO: these could be cached\n        values_predict: dict[int, dict[int, dict[int, list[float]]]] = {}\n        values_correct: dict[int, dict[int, dict[int, list[float]]]] = {}\n        for _line_idx, line in enumerate(predictions_arff[\"data\"]):\n            rep = line[repeat_idx]\n            fold = line[fold_idx]\n            samp = line[sample_idx] if has_samples else 0\n\n            if task.task_type_id in [\n                TaskType.SUPERVISED_CLASSIFICATION,\n                TaskType.LEARNING_CURVE,\n            ]:\n                prediction = predictions_arff[\"attributes\"][predicted_idx][1].index(\n                    line[predicted_idx],\n                )\n                correct = predictions_arff[\"attributes\"][predicted_idx][1].index(line[correct_idx])\n            elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n                prediction = line[predicted_idx]\n                correct = line[correct_idx]\n            if rep not in values_predict:\n                values_predict[rep] = OrderedDict()\n                values_correct[rep] = OrderedDict()\n            if fold not in values_predict[rep]:\n                values_predict[rep][fold] = OrderedDict()\n                values_correct[rep][fold] = OrderedDict()\n            if samp not in values_predict[rep][fold]:\n                values_predict[rep][fold][samp] = []\n                values_correct[rep][fold][samp] = []\n\n            values_predict[rep][fold][samp].append(prediction)\n            values_correct[rep][fold][samp].append(correct)\n\n        scores = []\n        for rep in values_predict:\n            for fold in values_predict[rep]:\n                last_sample = len(values_predict[rep][fold]) - 1\n                y_pred = values_predict[rep][fold][last_sample]\n                y_true = values_correct[rep][fold][last_sample]\n                scores.append(sklearn_fn(y_true, y_pred, **kwargs))\n        return np.array(scores)\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.run_id = int(xml_response[\"oml:upload_run\"][\"oml:run_id\"])\n\n    def _get_file_elements(self) -&gt; dict:\n        \"\"\"Get file_elements to upload to the server.\n\n        Derived child classes should overwrite this method as necessary.\n        The description field will be populated automatically if not provided.\n        \"\"\"\n        if self.parameter_settings is None and self.model is None:\n            raise PyOpenMLError(\n                \"OpenMLRun must contain a model or be initialized with parameter_settings.\",\n            )\n        if self.flow_id is None:\n            if self.flow is None:\n                raise PyOpenMLError(\n                    \"OpenMLRun object does not contain a flow id or reference to OpenMLFlow \"\n                    \"(these should have been added while executing the task). \",\n                )\n\n            # publish the linked Flow before publishing the run.\n            self.flow.publish()\n            self.flow_id = self.flow.flow_id\n\n        if self.parameter_settings is None:\n            if self.flow is None:\n                assert self.flow_id is not None  # for mypy\n                self.flow = openml.flows.get_flow(self.flow_id)\n            self.parameter_settings = self.flow.extension.obtain_parameter_values(\n                self.flow,\n                self.model,\n            )\n\n        file_elements = {\"description\": (\"description.xml\", self._to_xml())}\n\n        if self.error_message is None:\n            predictions = arff.dumps(self._generate_arff_dict())\n            file_elements[\"predictions\"] = (\"predictions.arff\", predictions)\n\n        if self.trace is not None:\n            trace_arff = arff.dumps(self.trace.trace_to_arff())\n            file_elements[\"trace\"] = (\"trace.arff\", trace_arff)\n        return file_elements\n\n    def _to_dict(self) -&gt; dict[str, dict]:  # noqa: PLR0912, C901\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        description = OrderedDict()  # type: 'OrderedDict'\n        description[\"oml:run\"] = OrderedDict()\n        description[\"oml:run\"][\"@xmlns:oml\"] = \"http://openml.org/openml\"\n        description[\"oml:run\"][\"oml:task_id\"] = self.task_id\n        description[\"oml:run\"][\"oml:flow_id\"] = self.flow_id\n        if self.setup_string is not None:\n            description[\"oml:run\"][\"oml:setup_string\"] = self.setup_string\n        if self.error_message is not None:\n            description[\"oml:run\"][\"oml:error_message\"] = self.error_message\n        if self.run_details is not None:\n            description[\"oml:run\"][\"oml:run_details\"] = self.run_details\n        description[\"oml:run\"][\"oml:parameter_setting\"] = self.parameter_settings\n        if self.tags is not None:\n            description[\"oml:run\"][\"oml:tag\"] = self.tags\n        if (self.fold_evaluations is not None and len(self.fold_evaluations) &gt; 0) or (\n            self.sample_evaluations is not None and len(self.sample_evaluations) &gt; 0\n        ):\n            description[\"oml:run\"][\"oml:output_data\"] = OrderedDict()\n            description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"] = []\n        if self.fold_evaluations is not None:\n            for measure in self.fold_evaluations:\n                for repeat in self.fold_evaluations[measure]:\n                    for fold, value in self.fold_evaluations[measure][repeat].items():\n                        current = OrderedDict(\n                            [\n                                (\"@repeat\", str(repeat)),\n                                (\"@fold\", str(fold)),\n                                (\"oml:name\", measure),\n                                (\"oml:value\", str(value)),\n                            ],\n                        )\n                        description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"].append(current)\n        if self.sample_evaluations is not None:\n            for measure in self.sample_evaluations:\n                for repeat in self.sample_evaluations[measure]:\n                    for fold in self.sample_evaluations[measure][repeat]:\n                        for sample, value in self.sample_evaluations[measure][repeat][fold].items():\n                            current = OrderedDict(\n                                [\n                                    (\"@repeat\", str(repeat)),\n                                    (\"@fold\", str(fold)),\n                                    (\"@sample\", str(sample)),\n                                    (\"oml:name\", measure),\n                                    (\"oml:value\", str(value)),\n                                ],\n                            )\n                            description[\"oml:run\"][\"oml:output_data\"][\"oml:evaluation\"].append(\n                                current,\n                            )\n        return description\n</code></pre>"},{"location":"reference/runs/run/#openml.runs.run.OpenMLRun.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>The ID of the run, None if not uploaded to the server yet.</p>"},{"location":"reference/runs/run/#openml.runs.run.OpenMLRun.predictions","title":"<code>predictions: pd.DataFrame</code>  <code>property</code>","text":"<p>Return a DataFrame with predictions for this run</p>"},{"location":"reference/runs/run/#openml.runs.run.OpenMLRun.from_filesystem","title":"<code>from_filesystem(directory, expect_model=True)</code>  <code>classmethod</code>","text":"<p>The inverse of the to_filesystem method. Instantiates an OpenMLRun object based on files stored on the file system.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>a path leading to the folder where the results are stored</p> required <code>expect_model</code> <code>bool</code> <p>if True, it requires the model pickle to be present, and an error will be thrown if not. Otherwise, the model might or might not be present.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRun</code> <p>the re-instantiated run object</p> Source code in <code>openml/runs/run.py</code> <pre><code>@classmethod\ndef from_filesystem(cls, directory: str | Path, expect_model: bool = True) -&gt; OpenMLRun:  # noqa: FBT001, FBT002\n    \"\"\"\n    The inverse of the to_filesystem method. Instantiates an OpenMLRun\n    object based on files stored on the file system.\n\n    Parameters\n    ----------\n    directory : str\n        a path leading to the folder where the results\n        are stored\n\n    expect_model : bool\n        if True, it requires the model pickle to be present, and an error\n        will be thrown if not. Otherwise, the model might or might not\n        be present.\n\n    Returns\n    -------\n    run : OpenMLRun\n        the re-instantiated run object\n    \"\"\"\n    # Avoiding cyclic imports\n    import openml.runs.functions\n\n    directory = Path(directory)\n    if not directory.is_dir():\n        raise ValueError(\"Could not find folder\")\n\n    description_path = directory / \"description.xml\"\n    predictions_path = directory / \"predictions.arff\"\n    trace_path = directory / \"trace.arff\"\n    model_path = directory / \"model.pkl\"\n\n    if not description_path.is_file():\n        raise ValueError(\"Could not find description.xml\")\n    if not predictions_path.is_file():\n        raise ValueError(\"Could not find predictions.arff\")\n    if (not model_path.is_file()) and expect_model:\n        raise ValueError(\"Could not find model.pkl\")\n\n    with description_path.open() as fht:\n        xml_string = fht.read()\n    run = openml.runs.functions._create_run_from_xml(xml_string, from_server=False)\n\n    if run.flow_id is None:\n        flow = openml.flows.OpenMLFlow.from_filesystem(directory)\n        run.flow = flow\n        run.flow_name = flow.name\n\n    with predictions_path.open() as fht:\n        predictions = arff.load(fht)\n        run.data_content = predictions[\"data\"]\n\n    if model_path.is_file():\n        # note that it will load the model if the file exists, even if\n        # expect_model is False\n        with model_path.open(\"rb\") as fhb:\n            run.model = pickle.load(fhb)  # noqa: S301\n\n    if trace_path.is_file():\n        run.trace = openml.runs.OpenMLRunTrace._from_filesystem(trace_path)\n\n    return run\n</code></pre>"},{"location":"reference/runs/run/#openml.runs.run.OpenMLRun.get_metric_fn","title":"<code>get_metric_fn(sklearn_fn, kwargs=None)</code>","text":"<p>Calculates metric scores based on predicted values. Assumes the run has been executed locally (and contains run_data). Furthermore, it assumes that the 'correct' or 'truth' attribute is specified in the arff (which is an optional field, but always the case for openml-python runs)</p> <p>Parameters:</p> Name Type Description Default <code>sklearn_fn</code> <code>function</code> <p>a function pointer to a sklearn function that accepts <code>y_true</code>, <code>y_pred</code> and <code>**kwargs</code></p> required <code>kwargs</code> <code>dict</code> <p>kwargs for the function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>scores</code> <code>ndarray of scores of length num_folds * num_repeats</code> <p>metric results</p> Source code in <code>openml/runs/run.py</code> <pre><code>def get_metric_fn(self, sklearn_fn: Callable, kwargs: dict | None = None) -&gt; np.ndarray:  # noqa: PLR0915, PLR0912, C901\n    \"\"\"Calculates metric scores based on predicted values. Assumes the\n    run has been executed locally (and contains run_data). Furthermore,\n    it assumes that the 'correct' or 'truth' attribute is specified in\n    the arff (which is an optional field, but always the case for\n    openml-python runs)\n\n    Parameters\n    ----------\n    sklearn_fn : function\n        a function pointer to a sklearn function that\n        accepts ``y_true``, ``y_pred`` and ``**kwargs``\n    kwargs : dict\n        kwargs for the function\n\n    Returns\n    -------\n    scores : ndarray of scores of length num_folds * num_repeats\n        metric results\n    \"\"\"\n    kwargs = kwargs if kwargs else {}\n    if self.data_content is not None and self.task_id is not None:\n        predictions_arff = self._generate_arff_dict()\n    elif (self.output_files is not None) and (\"predictions\" in self.output_files):\n        predictions_file_url = openml._api_calls._file_id_to_url(\n            self.output_files[\"predictions\"],\n            \"predictions.arff\",\n        )\n        response = openml._api_calls._download_text_file(predictions_file_url)\n        predictions_arff = arff.loads(response)\n        # TODO: make this a stream reader\n    else:\n        raise ValueError(\n            \"Run should have been locally executed or \" \"contain outputfile reference.\",\n        )\n\n    # Need to know more about the task to compute scores correctly\n    task = get_task(self.task_id)\n\n    attribute_names = [att[0] for att in predictions_arff[\"attributes\"]]\n    if (\n        task.task_type_id in [TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE]\n        and \"correct\" not in attribute_names\n    ):\n        raise ValueError('Attribute \"correct\" should be set for ' \"classification task runs\")\n    if task.task_type_id == TaskType.SUPERVISED_REGRESSION and \"truth\" not in attribute_names:\n        raise ValueError('Attribute \"truth\" should be set for ' \"regression task runs\")\n    if task.task_type_id != TaskType.CLUSTERING and \"prediction\" not in attribute_names:\n        raise ValueError('Attribute \"predict\" should be set for ' \"supervised task runs\")\n\n    def _attribute_list_to_dict(attribute_list):  # type: ignore\n        # convenience function: Creates a mapping to map from the name of\n        # attributes present in the arff prediction file to their index.\n        # This is necessary because the number of classes can be different\n        # for different tasks.\n        res = OrderedDict()\n        for idx in range(len(attribute_list)):\n            res[attribute_list[idx][0]] = idx\n        return res\n\n    attribute_dict = _attribute_list_to_dict(predictions_arff[\"attributes\"])\n\n    repeat_idx = attribute_dict[\"repeat\"]\n    fold_idx = attribute_dict[\"fold\"]\n    predicted_idx = attribute_dict[\"prediction\"]  # Assume supervised task\n\n    if task.task_type_id in (TaskType.SUPERVISED_CLASSIFICATION, TaskType.LEARNING_CURVE):\n        correct_idx = attribute_dict[\"correct\"]\n    elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n        correct_idx = attribute_dict[\"truth\"]\n    has_samples = False\n    if \"sample\" in attribute_dict:\n        sample_idx = attribute_dict[\"sample\"]\n        has_samples = True\n\n    if (\n        predictions_arff[\"attributes\"][predicted_idx][1]\n        != predictions_arff[\"attributes\"][correct_idx][1]\n    ):\n        pred = predictions_arff[\"attributes\"][predicted_idx][1]\n        corr = predictions_arff[\"attributes\"][correct_idx][1]\n        raise ValueError(\n            \"Predicted and Correct do not have equal values:\" f\" {pred!s} Vs. {corr!s}\",\n        )\n\n    # TODO: these could be cached\n    values_predict: dict[int, dict[int, dict[int, list[float]]]] = {}\n    values_correct: dict[int, dict[int, dict[int, list[float]]]] = {}\n    for _line_idx, line in enumerate(predictions_arff[\"data\"]):\n        rep = line[repeat_idx]\n        fold = line[fold_idx]\n        samp = line[sample_idx] if has_samples else 0\n\n        if task.task_type_id in [\n            TaskType.SUPERVISED_CLASSIFICATION,\n            TaskType.LEARNING_CURVE,\n        ]:\n            prediction = predictions_arff[\"attributes\"][predicted_idx][1].index(\n                line[predicted_idx],\n            )\n            correct = predictions_arff[\"attributes\"][predicted_idx][1].index(line[correct_idx])\n        elif task.task_type_id == TaskType.SUPERVISED_REGRESSION:\n            prediction = line[predicted_idx]\n            correct = line[correct_idx]\n        if rep not in values_predict:\n            values_predict[rep] = OrderedDict()\n            values_correct[rep] = OrderedDict()\n        if fold not in values_predict[rep]:\n            values_predict[rep][fold] = OrderedDict()\n            values_correct[rep][fold] = OrderedDict()\n        if samp not in values_predict[rep][fold]:\n            values_predict[rep][fold][samp] = []\n            values_correct[rep][fold][samp] = []\n\n        values_predict[rep][fold][samp].append(prediction)\n        values_correct[rep][fold][samp].append(correct)\n\n    scores = []\n    for rep in values_predict:\n        for fold in values_predict[rep]:\n            last_sample = len(values_predict[rep][fold]) - 1\n            y_pred = values_predict[rep][fold][last_sample]\n            y_true = values_correct[rep][fold][last_sample]\n            scores.append(sklearn_fn(y_true, y_pred, **kwargs))\n    return np.array(scores)\n</code></pre>"},{"location":"reference/runs/run/#openml.runs.run.OpenMLRun.to_filesystem","title":"<code>to_filesystem(directory, store_model=True)</code>","text":"<p>The inverse of the from_filesystem method. Serializes a run on the filesystem, to be uploaded later.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>a path leading to the folder where the results will be stored. Should be empty</p> required <code>store_model</code> <code>(bool, optional(default=True))</code> <p>if True, a model will be pickled as well. As this is the most storage expensive part, it is often desirable to not store the model.</p> <code>True</code> Source code in <code>openml/runs/run.py</code> <pre><code>def to_filesystem(\n    self,\n    directory: str | Path,\n    store_model: bool = True,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    The inverse of the from_filesystem method. Serializes a run\n    on the filesystem, to be uploaded later.\n\n    Parameters\n    ----------\n    directory : str\n        a path leading to the folder where the results\n        will be stored. Should be empty\n\n    store_model : bool, optional (default=True)\n        if True, a model will be pickled as well. As this is the most\n        storage expensive part, it is often desirable to not store the\n        model.\n    \"\"\"\n    if self.data_content is None or self.model is None:\n        raise ValueError(\"Run should have been executed (and contain \" \"model / predictions)\")\n    directory = Path(directory)\n    directory.mkdir(exist_ok=True, parents=True)\n\n    if any(directory.iterdir()):\n        raise ValueError(f\"Output directory {directory.expanduser().resolve()} should be empty\")\n\n    run_xml = self._to_xml()\n    predictions_arff = arff.dumps(self._generate_arff_dict())\n\n    # It seems like typing does not allow to define the same variable multiple times\n    with (directory / \"description.xml\").open(\"w\") as fh:\n        fh.write(run_xml)\n    with (directory / \"predictions.arff\").open(\"w\") as fh:\n        fh.write(predictions_arff)\n    if store_model:\n        with (directory / \"model.pkl\").open(\"wb\") as fh_b:\n            pickle.dump(self.model, fh_b)\n\n    if self.flow_id is None and self.flow is not None:\n        self.flow.to_filesystem(directory)\n\n    if self.trace is not None:\n        self.trace._to_filesystem(directory)\n</code></pre>"},{"location":"reference/runs/trace/","title":"trace","text":""},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace","title":"<code>OpenMLRunTrace</code>","text":"<p>OpenML Run Trace: parsed output from Run Trace call</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>OpenML run id.</p> required <code>trace_iterations</code> <code>dict</code> <p>Mapping from key <code>(repeat, fold, iteration)</code> to an object of OpenMLTraceIteration.</p> required Source code in <code>openml/runs/trace.py</code> <pre><code>class OpenMLRunTrace:\n    \"\"\"OpenML Run Trace: parsed output from Run Trace call\n\n    Parameters\n    ----------\n    run_id : int\n        OpenML run id.\n\n    trace_iterations : dict\n        Mapping from key ``(repeat, fold, iteration)`` to an object of\n        OpenMLTraceIteration.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        run_id: int | None,\n        trace_iterations: dict[tuple[int, int, int], OpenMLTraceIteration],\n    ):\n        \"\"\"Object to hold the trace content of a run.\n\n        Parameters\n        ----------\n        run_id : int\n            Id for which the trace content is to be stored.\n        trace_iterations : List[List]\n            The trace content obtained by running a flow on a task.\n        \"\"\"\n        self.run_id = run_id\n        self.trace_iterations = trace_iterations\n\n    def get_selected_iteration(self, fold: int, repeat: int) -&gt; int:\n        \"\"\"\n        Returns the trace iteration that was marked as selected. In\n        case multiple are marked as selected (should not happen) the\n        first of these is returned\n\n        Parameters\n        ----------\n        fold: int\n\n        repeat: int\n\n        Returns\n        -------\n        int\n            The trace iteration from the given fold and repeat that was\n            selected as the best iteration by the search procedure\n        \"\"\"\n        for r, f, i in self.trace_iterations:\n            if r == repeat and f == fold and self.trace_iterations[(r, f, i)].selected is True:\n                return i\n        raise ValueError(\n            \"Could not find the selected iteration for rep/fold %d/%d\" % (repeat, fold),\n        )\n\n    @classmethod\n    def generate(\n        cls,\n        attributes: list[tuple[str, str]],\n        content: list[list[int | float | str]],\n    ) -&gt; OpenMLRunTrace:\n        \"\"\"Generates an OpenMLRunTrace.\n\n        Generates the trace object from the attributes and content extracted\n        while running the underlying flow.\n\n        Parameters\n        ----------\n        attributes : list\n            List of tuples describing the arff attributes.\n\n        content : list\n            List of lists containing information about the individual tuning\n            runs.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        if content is None:\n            raise ValueError(\"Trace content not available.\")\n        if attributes is None:\n            raise ValueError(\"Trace attributes not available.\")\n        if len(content) == 0:\n            raise ValueError(\"Trace content is empty.\")\n        if len(attributes) != len(content[0]):\n            raise ValueError(\n                \"Trace_attributes and trace_content not compatible:\"\n                f\" {attributes} vs {content[0]}\",\n            )\n\n        return cls._trace_from_arff_struct(\n            attributes=attributes,\n            content=content,\n            error_message=\"setup_string not allowed when constructing a \"\n            \"trace object from run results.\",\n        )\n\n    @classmethod\n    def _from_filesystem(cls, file_path: str | Path) -&gt; OpenMLRunTrace:\n        \"\"\"\n        Logic to deserialize the trace from the filesystem.\n\n        Parameters\n        ----------\n        file_path: str | Path\n            File path where the trace arff is stored.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        file_path = Path(file_path)\n\n        if not file_path.exists():\n            raise ValueError(\"Trace file doesn't exist\")\n\n        with file_path.open(\"r\") as fp:\n            trace_arff = arff.load(fp)\n\n        for trace_idx in range(len(trace_arff[\"data\"])):\n            # iterate over first three entrees of a trace row\n            # (fold, repeat, trace_iteration) these should be int\n            for line_idx in range(3):\n                trace_arff[\"data\"][trace_idx][line_idx] = int(\n                    trace_arff[\"data\"][trace_idx][line_idx],\n                )\n\n        return cls.trace_from_arff(trace_arff)\n\n    def _to_filesystem(self, file_path: str | Path) -&gt; None:\n        \"\"\"Serialize the trace object to the filesystem.\n\n        Serialize the trace object as an arff.\n\n        Parameters\n        ----------\n        file_path: str | Path\n            File path where the trace arff will be stored.\n        \"\"\"\n        trace_path = Path(file_path) / \"trace.arff\"\n\n        trace_arff = arff.dumps(self.trace_to_arff())\n        with trace_path.open(\"w\") as f:\n            f.write(trace_arff)\n\n    def trace_to_arff(self) -&gt; dict[str, Any]:\n        \"\"\"Generate the arff dictionary for uploading predictions to the server.\n\n        Uses the trace object to generate an arff dictionary representation.\n\n        Returns\n        -------\n        arff_dict : dict\n            Dictionary representation of the ARFF file that will be uploaded.\n            Contains information about the optimization trace.\n        \"\"\"\n        if self.trace_iterations is None:\n            raise ValueError(\"trace_iterations missing from the trace object\")\n\n        # attributes that will be in trace arff\n        trace_attributes = [\n            (\"repeat\", \"NUMERIC\"),\n            (\"fold\", \"NUMERIC\"),\n            (\"iteration\", \"NUMERIC\"),\n            (\"evaluation\", \"NUMERIC\"),\n            (\"selected\", [\"true\", \"false\"]),\n        ]\n        trace_attributes.extend(\n            [\n                (PREFIX + parameter, \"STRING\")\n                for parameter in next(iter(self.trace_iterations.values())).get_parameters()\n            ],\n        )\n\n        arff_dict: dict[str, Any] = {}\n        data = []\n        for trace_iteration in self.trace_iterations.values():\n            tmp_list = []\n            for _attr, _ in trace_attributes:\n                if _attr.startswith(PREFIX):\n                    attr = _attr[len(PREFIX) :]\n                    value = trace_iteration.get_parameters()[attr]\n                else:\n                    attr = _attr\n                    value = getattr(trace_iteration, attr)\n\n                if attr == \"selected\":\n                    tmp_list.append(\"true\" if value else \"false\")\n                else:\n                    tmp_list.append(value)\n            data.append(tmp_list)\n\n        arff_dict[\"attributes\"] = trace_attributes\n        arff_dict[\"data\"] = data\n        # TODO allow to pass a trace description when running a flow\n        arff_dict[\"relation\"] = \"Trace\"\n        return arff_dict\n\n    @classmethod\n    def trace_from_arff(cls, arff_obj: dict[str, Any]) -&gt; OpenMLRunTrace:\n        \"\"\"Generate trace from arff trace.\n\n        Creates a trace file from arff object (for example, generated by a\n        local run).\n\n        Parameters\n        ----------\n        arff_obj : dict\n            LIAC arff obj, dict containing attributes, relation, data.\n\n        Returns\n        -------\n        OpenMLRunTrace\n        \"\"\"\n        attributes = arff_obj[\"attributes\"]\n        content = arff_obj[\"data\"]\n        return cls._trace_from_arff_struct(\n            attributes=attributes,\n            content=content,\n            error_message=\"setup_string not supported for arff serialization\",\n        )\n\n    @classmethod\n    def _trace_from_arff_struct(\n        cls,\n        attributes: list[tuple[str, str]],\n        content: list[list[int | float | str]],\n        error_message: str,\n    ) -&gt; Self:\n        \"\"\"Generate a trace dictionary from ARFF structure.\n\n        Parameters\n        ----------\n        cls : type\n            The trace object to be created.\n        attributes : list[tuple[str, str]]\n            Attribute descriptions.\n        content : list[list[int | float | str]]]\n            List of instances.\n        error_message : str\n            Error message to raise if `setup_string` is in `attributes`.\n\n        Returns\n        -------\n        OrderedDict\n            A dictionary representing the trace.\n        \"\"\"\n        trace = OrderedDict()\n        attribute_idx = {att[0]: idx for idx, att in enumerate(attributes)}\n\n        for required_attribute in REQUIRED_ATTRIBUTES:\n            if required_attribute not in attribute_idx:\n                raise ValueError(f\"arff misses required attribute: {required_attribute}\")\n        if \"setup_string\" in attribute_idx:\n            raise ValueError(error_message)\n\n        # note that the required attributes can not be duplicated because\n        # they are not parameters\n        parameter_attributes = []\n        for attribute in attribute_idx:\n            if attribute in REQUIRED_ATTRIBUTES or attribute == \"setup_string\":\n                continue\n\n            if not attribute.startswith(PREFIX):\n                raise ValueError(\n                    f\"Encountered unknown attribute {attribute} that does not start \"\n                    f\"with prefix {PREFIX}\",\n                )\n\n            parameter_attributes.append(attribute)\n\n        for itt in content:\n            repeat = int(itt[attribute_idx[\"repeat\"]])\n            fold = int(itt[attribute_idx[\"fold\"]])\n            iteration = int(itt[attribute_idx[\"iteration\"]])\n            evaluation = float(itt[attribute_idx[\"evaluation\"]])\n            selected_value = itt[attribute_idx[\"selected\"]]\n            if selected_value == \"true\":\n                selected = True\n            elif selected_value == \"false\":\n                selected = False\n            else:\n                raise ValueError(\n                    'expected {\"true\", \"false\"} value for selected field, '\n                    f\"received: {selected_value}\",\n                )\n\n            parameters = {\n                attribute: itt[attribute_idx[attribute]] for attribute in parameter_attributes\n            }\n\n            current = OpenMLTraceIteration(\n                repeat=repeat,\n                fold=fold,\n                iteration=iteration,\n                setup_string=None,\n                evaluation=evaluation,\n                selected=selected,\n                parameters=parameters,\n            )\n            trace[(repeat, fold, iteration)] = current\n\n        return cls(None, trace)\n\n    @classmethod\n    def trace_from_xml(cls, xml: str | Path | IO) -&gt; OpenMLRunTrace:\n        \"\"\"Generate trace from xml.\n\n        Creates a trace file from the xml description.\n\n        Parameters\n        ----------\n        xml : string | file-like object\n            An xml description that can be either a `string` or a file-like\n            object.\n\n        Returns\n        -------\n        run : OpenMLRunTrace\n            Object containing the run id and a dict containing the trace\n            iterations.\n        \"\"\"\n        if isinstance(xml, Path):\n            xml = str(xml.absolute())\n\n        result_dict = xmltodict.parse(xml, force_list=(\"oml:trace_iteration\",))[\"oml:trace\"]\n\n        run_id = result_dict[\"oml:run_id\"]\n        trace = OrderedDict()\n\n        if \"oml:trace_iteration\" not in result_dict:\n            raise ValueError(\"Run does not contain valid trace. \")\n        if not isinstance(result_dict[\"oml:trace_iteration\"], list):\n            raise TypeError(type(result_dict[\"oml:trace_iteration\"]))\n\n        for itt in result_dict[\"oml:trace_iteration\"]:\n            repeat = int(itt[\"oml:repeat\"])\n            fold = int(itt[\"oml:fold\"])\n            iteration = int(itt[\"oml:iteration\"])\n            setup_string = json.loads(itt[\"oml:setup_string\"])\n            evaluation = float(itt[\"oml:evaluation\"])\n            selected_value = itt[\"oml:selected\"]\n            if selected_value == \"true\":\n                selected = True\n            elif selected_value == \"false\":\n                selected = False\n            else:\n                raise ValueError(\n                    'expected {\"true\", \"false\"} value for '\n                    f\"selected field, received: {selected_value}\",\n                )\n\n            current = OpenMLTraceIteration(\n                repeat=repeat,\n                fold=fold,\n                iteration=iteration,\n                setup_string=setup_string,\n                evaluation=evaluation,\n                selected=selected,\n            )\n            trace[(repeat, fold, iteration)] = current\n\n        return cls(run_id, trace)\n\n    @classmethod\n    def merge_traces(cls, traces: list[OpenMLRunTrace]) -&gt; OpenMLRunTrace:\n        \"\"\"Merge multiple traces into a single trace.\n\n        Parameters\n        ----------\n        cls : type\n            Type of the trace object to be created.\n        traces : List[OpenMLRunTrace]\n            List of traces to merge.\n\n        Returns\n        -------\n        OpenMLRunTrace\n            A trace object representing the merged traces.\n\n        Raises\n        ------\n        ValueError\n            If the parameters in the iterations of the traces being merged are not equal.\n            If a key (repeat, fold, iteration) is encountered twice while merging the traces.\n        \"\"\"\n        merged_trace: dict[tuple[int, int, int], OpenMLTraceIteration] = {}\n\n        previous_iteration = None\n        for trace in traces:\n            for iteration in trace:\n                key = (iteration.repeat, iteration.fold, iteration.iteration)\n\n                assert iteration.parameters is not None\n                param_keys = iteration.parameters.keys()\n\n                if previous_iteration is not None:\n                    trace_itr = merged_trace[previous_iteration]\n\n                    assert trace_itr.parameters is not None\n                    trace_itr_keys = trace_itr.parameters.keys()\n\n                    if list(param_keys) != list(trace_itr_keys):\n                        raise ValueError(\n                            \"Cannot merge traces because the parameters are not equal: \"\n                            f\"{list(trace_itr.parameters.keys())} vs \"\n                            f\"{list(iteration.parameters.keys())}\",\n                        )\n\n                if key in merged_trace:\n                    raise ValueError(\n                        f\"Cannot merge traces because key '{key}' was encountered twice\",\n                    )\n\n                merged_trace[key] = iteration\n                previous_iteration = key\n\n        return cls(None, merged_trace)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"[Run id: {-1 if self.run_id is None else self.run_id}, \"\n            f\"{len(self.trace_iterations)} trace iterations]\"\n        )\n\n    def __iter__(self) -&gt; Iterator[OpenMLTraceIteration]:\n        yield from self.trace_iterations.values()\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.__init__","title":"<code>__init__(run_id, trace_iterations)</code>","text":"<p>Object to hold the trace content of a run.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>int</code> <p>Id for which the trace content is to be stored.</p> required <code>trace_iterations</code> <code>List[List]</code> <p>The trace content obtained by running a flow on a task.</p> required Source code in <code>openml/runs/trace.py</code> <pre><code>def __init__(\n    self,\n    run_id: int | None,\n    trace_iterations: dict[tuple[int, int, int], OpenMLTraceIteration],\n):\n    \"\"\"Object to hold the trace content of a run.\n\n    Parameters\n    ----------\n    run_id : int\n        Id for which the trace content is to be stored.\n    trace_iterations : List[List]\n        The trace content obtained by running a flow on a task.\n    \"\"\"\n    self.run_id = run_id\n    self.trace_iterations = trace_iterations\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.generate","title":"<code>generate(attributes, content)</code>  <code>classmethod</code>","text":"<p>Generates an OpenMLRunTrace.</p> <p>Generates the trace object from the attributes and content extracted while running the underlying flow.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>list</code> <p>List of tuples describing the arff attributes.</p> required <code>content</code> <code>list</code> <p>List of lists containing information about the individual tuning runs.</p> required <p>Returns:</p> Type Description <code>OpenMLRunTrace</code> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef generate(\n    cls,\n    attributes: list[tuple[str, str]],\n    content: list[list[int | float | str]],\n) -&gt; OpenMLRunTrace:\n    \"\"\"Generates an OpenMLRunTrace.\n\n    Generates the trace object from the attributes and content extracted\n    while running the underlying flow.\n\n    Parameters\n    ----------\n    attributes : list\n        List of tuples describing the arff attributes.\n\n    content : list\n        List of lists containing information about the individual tuning\n        runs.\n\n    Returns\n    -------\n    OpenMLRunTrace\n    \"\"\"\n    if content is None:\n        raise ValueError(\"Trace content not available.\")\n    if attributes is None:\n        raise ValueError(\"Trace attributes not available.\")\n    if len(content) == 0:\n        raise ValueError(\"Trace content is empty.\")\n    if len(attributes) != len(content[0]):\n        raise ValueError(\n            \"Trace_attributes and trace_content not compatible:\"\n            f\" {attributes} vs {content[0]}\",\n        )\n\n    return cls._trace_from_arff_struct(\n        attributes=attributes,\n        content=content,\n        error_message=\"setup_string not allowed when constructing a \"\n        \"trace object from run results.\",\n    )\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.get_selected_iteration","title":"<code>get_selected_iteration(fold, repeat)</code>","text":"<p>Returns the trace iteration that was marked as selected. In case multiple are marked as selected (should not happen) the first of these is returned</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>int</code> required <code>repeat</code> <code>int</code> required <p>Returns:</p> Type Description <code>int</code> <p>The trace iteration from the given fold and repeat that was selected as the best iteration by the search procedure</p> Source code in <code>openml/runs/trace.py</code> <pre><code>def get_selected_iteration(self, fold: int, repeat: int) -&gt; int:\n    \"\"\"\n    Returns the trace iteration that was marked as selected. In\n    case multiple are marked as selected (should not happen) the\n    first of these is returned\n\n    Parameters\n    ----------\n    fold: int\n\n    repeat: int\n\n    Returns\n    -------\n    int\n        The trace iteration from the given fold and repeat that was\n        selected as the best iteration by the search procedure\n    \"\"\"\n    for r, f, i in self.trace_iterations:\n        if r == repeat and f == fold and self.trace_iterations[(r, f, i)].selected is True:\n            return i\n    raise ValueError(\n        \"Could not find the selected iteration for rep/fold %d/%d\" % (repeat, fold),\n    )\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.merge_traces","title":"<code>merge_traces(traces)</code>  <code>classmethod</code>","text":"<p>Merge multiple traces into a single trace.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Type of the trace object to be created.</p> required <code>traces</code> <code>List[OpenMLRunTrace]</code> <p>List of traces to merge.</p> required <p>Returns:</p> Type Description <code>OpenMLRunTrace</code> <p>A trace object representing the merged traces.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the parameters in the iterations of the traces being merged are not equal. If a key (repeat, fold, iteration) is encountered twice while merging the traces.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef merge_traces(cls, traces: list[OpenMLRunTrace]) -&gt; OpenMLRunTrace:\n    \"\"\"Merge multiple traces into a single trace.\n\n    Parameters\n    ----------\n    cls : type\n        Type of the trace object to be created.\n    traces : List[OpenMLRunTrace]\n        List of traces to merge.\n\n    Returns\n    -------\n    OpenMLRunTrace\n        A trace object representing the merged traces.\n\n    Raises\n    ------\n    ValueError\n        If the parameters in the iterations of the traces being merged are not equal.\n        If a key (repeat, fold, iteration) is encountered twice while merging the traces.\n    \"\"\"\n    merged_trace: dict[tuple[int, int, int], OpenMLTraceIteration] = {}\n\n    previous_iteration = None\n    for trace in traces:\n        for iteration in trace:\n            key = (iteration.repeat, iteration.fold, iteration.iteration)\n\n            assert iteration.parameters is not None\n            param_keys = iteration.parameters.keys()\n\n            if previous_iteration is not None:\n                trace_itr = merged_trace[previous_iteration]\n\n                assert trace_itr.parameters is not None\n                trace_itr_keys = trace_itr.parameters.keys()\n\n                if list(param_keys) != list(trace_itr_keys):\n                    raise ValueError(\n                        \"Cannot merge traces because the parameters are not equal: \"\n                        f\"{list(trace_itr.parameters.keys())} vs \"\n                        f\"{list(iteration.parameters.keys())}\",\n                    )\n\n            if key in merged_trace:\n                raise ValueError(\n                    f\"Cannot merge traces because key '{key}' was encountered twice\",\n                )\n\n            merged_trace[key] = iteration\n            previous_iteration = key\n\n    return cls(None, merged_trace)\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.trace_from_arff","title":"<code>trace_from_arff(arff_obj)</code>  <code>classmethod</code>","text":"<p>Generate trace from arff trace.</p> <p>Creates a trace file from arff object (for example, generated by a local run).</p> <p>Parameters:</p> Name Type Description Default <code>arff_obj</code> <code>dict</code> <p>LIAC arff obj, dict containing attributes, relation, data.</p> required <p>Returns:</p> Type Description <code>OpenMLRunTrace</code> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef trace_from_arff(cls, arff_obj: dict[str, Any]) -&gt; OpenMLRunTrace:\n    \"\"\"Generate trace from arff trace.\n\n    Creates a trace file from arff object (for example, generated by a\n    local run).\n\n    Parameters\n    ----------\n    arff_obj : dict\n        LIAC arff obj, dict containing attributes, relation, data.\n\n    Returns\n    -------\n    OpenMLRunTrace\n    \"\"\"\n    attributes = arff_obj[\"attributes\"]\n    content = arff_obj[\"data\"]\n    return cls._trace_from_arff_struct(\n        attributes=attributes,\n        content=content,\n        error_message=\"setup_string not supported for arff serialization\",\n    )\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.trace_from_xml","title":"<code>trace_from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Generate trace from xml.</p> <p>Creates a trace file from the xml description.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>string | file-like object</code> <p>An xml description that can be either a <code>string</code> or a file-like object.</p> required <p>Returns:</p> Name Type Description <code>run</code> <code>OpenMLRunTrace</code> <p>Object containing the run id and a dict containing the trace iterations.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>@classmethod\ndef trace_from_xml(cls, xml: str | Path | IO) -&gt; OpenMLRunTrace:\n    \"\"\"Generate trace from xml.\n\n    Creates a trace file from the xml description.\n\n    Parameters\n    ----------\n    xml : string | file-like object\n        An xml description that can be either a `string` or a file-like\n        object.\n\n    Returns\n    -------\n    run : OpenMLRunTrace\n        Object containing the run id and a dict containing the trace\n        iterations.\n    \"\"\"\n    if isinstance(xml, Path):\n        xml = str(xml.absolute())\n\n    result_dict = xmltodict.parse(xml, force_list=(\"oml:trace_iteration\",))[\"oml:trace\"]\n\n    run_id = result_dict[\"oml:run_id\"]\n    trace = OrderedDict()\n\n    if \"oml:trace_iteration\" not in result_dict:\n        raise ValueError(\"Run does not contain valid trace. \")\n    if not isinstance(result_dict[\"oml:trace_iteration\"], list):\n        raise TypeError(type(result_dict[\"oml:trace_iteration\"]))\n\n    for itt in result_dict[\"oml:trace_iteration\"]:\n        repeat = int(itt[\"oml:repeat\"])\n        fold = int(itt[\"oml:fold\"])\n        iteration = int(itt[\"oml:iteration\"])\n        setup_string = json.loads(itt[\"oml:setup_string\"])\n        evaluation = float(itt[\"oml:evaluation\"])\n        selected_value = itt[\"oml:selected\"]\n        if selected_value == \"true\":\n            selected = True\n        elif selected_value == \"false\":\n            selected = False\n        else:\n            raise ValueError(\n                'expected {\"true\", \"false\"} value for '\n                f\"selected field, received: {selected_value}\",\n            )\n\n        current = OpenMLTraceIteration(\n            repeat=repeat,\n            fold=fold,\n            iteration=iteration,\n            setup_string=setup_string,\n            evaluation=evaluation,\n            selected=selected,\n        )\n        trace[(repeat, fold, iteration)] = current\n\n    return cls(run_id, trace)\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLRunTrace.trace_to_arff","title":"<code>trace_to_arff()</code>","text":"<p>Generate the arff dictionary for uploading predictions to the server.</p> <p>Uses the trace object to generate an arff dictionary representation.</p> <p>Returns:</p> Name Type Description <code>arff_dict</code> <code>dict</code> <p>Dictionary representation of the ARFF file that will be uploaded. Contains information about the optimization trace.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>def trace_to_arff(self) -&gt; dict[str, Any]:\n    \"\"\"Generate the arff dictionary for uploading predictions to the server.\n\n    Uses the trace object to generate an arff dictionary representation.\n\n    Returns\n    -------\n    arff_dict : dict\n        Dictionary representation of the ARFF file that will be uploaded.\n        Contains information about the optimization trace.\n    \"\"\"\n    if self.trace_iterations is None:\n        raise ValueError(\"trace_iterations missing from the trace object\")\n\n    # attributes that will be in trace arff\n    trace_attributes = [\n        (\"repeat\", \"NUMERIC\"),\n        (\"fold\", \"NUMERIC\"),\n        (\"iteration\", \"NUMERIC\"),\n        (\"evaluation\", \"NUMERIC\"),\n        (\"selected\", [\"true\", \"false\"]),\n    ]\n    trace_attributes.extend(\n        [\n            (PREFIX + parameter, \"STRING\")\n            for parameter in next(iter(self.trace_iterations.values())).get_parameters()\n        ],\n    )\n\n    arff_dict: dict[str, Any] = {}\n    data = []\n    for trace_iteration in self.trace_iterations.values():\n        tmp_list = []\n        for _attr, _ in trace_attributes:\n            if _attr.startswith(PREFIX):\n                attr = _attr[len(PREFIX) :]\n                value = trace_iteration.get_parameters()[attr]\n            else:\n                attr = _attr\n                value = getattr(trace_iteration, attr)\n\n            if attr == \"selected\":\n                tmp_list.append(\"true\" if value else \"false\")\n            else:\n                tmp_list.append(value)\n        data.append(tmp_list)\n\n    arff_dict[\"attributes\"] = trace_attributes\n    arff_dict[\"data\"] = data\n    # TODO allow to pass a trace description when running a flow\n    arff_dict[\"relation\"] = \"Trace\"\n    return arff_dict\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLTraceIteration","title":"<code>OpenMLTraceIteration</code>  <code>dataclass</code>","text":"<p>OpenML Trace Iteration: parsed output from Run Trace call Exactly one of <code>setup_string</code> or <code>parameters</code> must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>repeat</code> <code>int</code> <p>repeat number (in case of no repeats: 0)</p> required <code>fold</code> <code>int</code> <p>fold number (in case of no folds: 0)</p> required <code>iteration</code> <code>int</code> <p>iteration number of optimization procedure</p> required <code>setup_string</code> <code>str</code> <p>json string representing the parameters If not provided, <code>parameters</code> should be set.</p> <code>None</code> <code>evaluation</code> <code>double</code> <p>The evaluation that was awarded to this trace iteration. Measure is defined by the task</p> required <code>selected</code> <code>bool</code> <p>Whether this was the best of all iterations, and hence selected for making predictions. Per fold/repeat there should be only one iteration selected</p> required <code>parameters</code> <code>OrderedDict</code> <p>Dictionary specifying parameter names and their values. If not provided, <code>setup_string</code> should be set.</p> <code>None</code> Source code in <code>openml/runs/trace.py</code> <pre><code>@dataclass\nclass OpenMLTraceIteration:\n    \"\"\"\n    OpenML Trace Iteration: parsed output from Run Trace call\n    Exactly one of `setup_string` or `parameters` must be provided.\n\n    Parameters\n    ----------\n    repeat : int\n        repeat number (in case of no repeats: 0)\n\n    fold : int\n        fold number (in case of no folds: 0)\n\n    iteration : int\n        iteration number of optimization procedure\n\n    setup_string : str, optional\n        json string representing the parameters\n        If not provided, ``parameters`` should be set.\n\n    evaluation : double\n        The evaluation that was awarded to this trace iteration.\n        Measure is defined by the task\n\n    selected : bool\n        Whether this was the best of all iterations, and hence\n        selected for making predictions. Per fold/repeat there\n        should be only one iteration selected\n\n    parameters : OrderedDict, optional\n        Dictionary specifying parameter names and their values.\n        If not provided, ``setup_string`` should be set.\n    \"\"\"\n\n    repeat: int\n    fold: int\n    iteration: int\n\n    evaluation: float\n    selected: bool\n\n    setup_string: dict[str, str] | None = None\n    parameters: dict[str, str | int | float] | None = None\n\n    def __post_init__(self) -&gt; None:\n        # TODO: refactor into one argument of type &lt;str | OrderedDict&gt;\n        if self.setup_string and self.parameters:\n            raise ValueError(\n                \"Can only be instantiated with either `setup_string` or `parameters` argument.\",\n            )\n\n        if not (self.setup_string or self.parameters):\n            raise ValueError(\n                \"Either `setup_string` or `parameters` needs to be passed as argument.\",\n            )\n\n        if self.parameters is not None and not isinstance(self.parameters, dict):\n            raise TypeError(\n                f\"argument parameters is not an instance of OrderedDict, but\"\n                f\" {type(self.parameters)!s}\",\n            )\n\n    def get_parameters(self) -&gt; dict[str, Any]:\n        \"\"\"Get the parameters of this trace iteration.\"\"\"\n        # parameters have prefix 'parameter_'\n        if self.setup_string:\n            return {\n                param[len(PREFIX) :]: json.loads(value)\n                for param, value in self.setup_string.items()\n            }\n\n        assert self.parameters is not None\n        return {param[len(PREFIX) :]: value for param, value in self.parameters.items()}\n</code></pre>"},{"location":"reference/runs/trace/#openml.runs.trace.OpenMLTraceIteration.get_parameters","title":"<code>get_parameters()</code>","text":"<p>Get the parameters of this trace iteration.</p> Source code in <code>openml/runs/trace.py</code> <pre><code>def get_parameters(self) -&gt; dict[str, Any]:\n    \"\"\"Get the parameters of this trace iteration.\"\"\"\n    # parameters have prefix 'parameter_'\n    if self.setup_string:\n        return {\n            param[len(PREFIX) :]: json.loads(value)\n            for param, value in self.setup_string.items()\n        }\n\n    assert self.parameters is not None\n    return {param[len(PREFIX) :]: value for param, value in self.parameters.items()}\n</code></pre>"},{"location":"reference/setups/","title":"setups","text":""},{"location":"reference/setups/#openml.setups.OpenMLParameter","title":"<code>OpenMLParameter</code>","text":"<p>Parameter object (used in setup).</p> <p>Parameters:</p> Name Type Description Default <code>input_id</code> <code>int</code> <p>The input id from the openml database</p> required <code>flow</code> <p>The flow to which this parameter is associated</p> required <code>flow</code> <p>The name of the flow (no version number) to which this parameter is associated</p> required <code>full_name</code> <code>str</code> <p>The name of the flow and parameter combined</p> required <code>parameter_name</code> <code>str</code> <p>The name of the parameter</p> required <code>data_type</code> <code>str</code> <p>The datatype of the parameter. generally unused for sklearn flows</p> required <code>default_value</code> <code>str</code> <p>The default value. For sklearn parameters, this is unknown and a default value is selected arbitrarily</p> required <code>value</code> <code>str</code> <p>If the parameter was set, the value that it was set to.</p> required Source code in <code>openml/setups/setup.py</code> <pre><code>class OpenMLParameter:\n    \"\"\"Parameter object (used in setup).\n\n    Parameters\n    ----------\n    input_id : int\n        The input id from the openml database\n    flow id : int\n        The flow to which this parameter is associated\n    flow name : str\n        The name of the flow (no version number) to which this parameter\n        is associated\n    full_name : str\n        The name of the flow and parameter combined\n    parameter_name : str\n        The name of the parameter\n    data_type : str\n        The datatype of the parameter. generally unused for sklearn flows\n    default_value : str\n        The default value. For sklearn parameters, this is unknown and a\n        default value is selected arbitrarily\n    value : str\n        If the parameter was set, the value that it was set to.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        input_id: int,\n        flow_id: int,\n        flow_name: str,\n        full_name: str,\n        parameter_name: str,\n        data_type: str,\n        default_value: str,\n        value: str,\n    ):\n        self.id = input_id\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.full_name = full_name\n        self.parameter_name = parameter_name\n        self.data_type = data_type\n        self.default_value = default_value\n        self.value = value\n\n    def _to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"flow_id\": self.flow_id,\n            \"flow_name\": self.flow_name,\n            \"full_name\": self.full_name,\n            \"parameter_name\": self.parameter_name,\n            \"data_type\": self.data_type,\n            \"default_value\": self.default_value,\n            \"value\": self.value,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Parameter\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"ID\": self.id,\n            \"Flow ID\": self.flow_id,\n            # \"Flow Name\": self.flow_name,\n            \"Flow Name\": self.full_name,\n            \"Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"Parameter Name\": self.parameter_name,\n        }\n        # indented prints for parameter attributes\n        # indention = 2 spaces + 1 | + 2 underscores\n        indent = f\"{' ' * 2}|{'_' * 2}\"\n        parameter_data_type = f\"{indent}Data Type\"\n        fields[parameter_data_type] = self.data_type\n        parameter_default = f\"{indent}Default\"\n        fields[parameter_default] = self.default_value\n        parameter_value = f\"{indent}Value\"\n        fields[parameter_value] = self.value\n\n        # determines the order in which the information will be printed\n        order = [\n            \"ID\",\n            \"Flow ID\",\n            \"Flow Name\",\n            \"Flow URL\",\n            \"Parameter Name\",\n            parameter_data_type,\n            parameter_default,\n            parameter_value,\n        ]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/setups/#openml.setups.OpenMLSetup","title":"<code>OpenMLSetup</code>","text":"<p>Setup object (a.k.a. Configuration).</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The OpenML setup id</p> required <code>flow_id</code> <code>int</code> <p>The flow that it is build upon</p> required <code>parameters</code> <code>dict</code> <p>The setting of the parameters</p> required Source code in <code>openml/setups/setup.py</code> <pre><code>class OpenMLSetup:\n    \"\"\"Setup object (a.k.a. Configuration).\n\n    Parameters\n    ----------\n    setup_id : int\n        The OpenML setup id\n    flow_id : int\n        The flow that it is build upon\n    parameters : dict\n        The setting of the parameters\n    \"\"\"\n\n    def __init__(self, setup_id: int, flow_id: int, parameters: dict[int, Any] | None):\n        if not isinstance(setup_id, int):\n            raise ValueError(\"setup id should be int\")\n\n        if not isinstance(flow_id, int):\n            raise ValueError(\"flow id should be int\")\n\n        if parameters is not None and not isinstance(parameters, dict):\n            raise ValueError(\"parameters should be dict\")\n\n        self.setup_id = setup_id\n        self.flow_id = flow_id\n        self.parameters = parameters\n\n    def _to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"setup_id\": self.setup_id,\n            \"flow_id\": self.flow_id,\n            \"parameters\": {p.id: p._to_dict() for p in self.parameters.values()}\n            if self.parameters is not None\n            else None,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Setup\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"Setup ID\": self.setup_id,\n            \"Flow ID\": self.flow_id,\n            \"Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"# of Parameters\": (\n                len(self.parameters) if self.parameters is not None else float(\"nan\")\n            ),\n        }\n\n        # determines the order in which the information will be printed\n        order = [\"Setup ID\", \"Flow ID\", \"Flow URL\", \"# of Parameters\"]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/setups/#openml.setups.get_setup","title":"<code>get_setup(setup_id)</code>","text":"<p>Downloads the setup (configuration) description from OpenML  and returns a structured object</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The Openml setup_id</p> required <p>Returns:</p> Type Description <code>OpenMLSetup (an initialized openml setup object)</code> Source code in <code>openml/setups/functions.py</code> <pre><code>def get_setup(setup_id: int) -&gt; OpenMLSetup:\n    \"\"\"\n     Downloads the setup (configuration) description from OpenML\n     and returns a structured object\n\n    Parameters\n    ----------\n    setup_id : int\n        The Openml setup_id\n\n    Returns\n    -------\n    OpenMLSetup (an initialized openml setup object)\n    \"\"\"\n    setup_dir = Path(config.get_cache_directory()) / \"setups\" / str(setup_id)\n    setup_dir.mkdir(exist_ok=True, parents=True)\n\n    setup_file = setup_dir / \"description.xml\"\n\n    try:\n        return _get_cached_setup(setup_id)\n    except openml.exceptions.OpenMLCacheException:\n        url_suffix = f\"/setup/{setup_id}\"\n        setup_xml = openml._api_calls._perform_api_call(url_suffix, \"get\")\n        with setup_file.open(\"w\", encoding=\"utf8\") as fh:\n            fh.write(setup_xml)\n\n    result_dict = xmltodict.parse(setup_xml)\n    return _create_setup_from_xml(result_dict)\n</code></pre>"},{"location":"reference/setups/#openml.setups.initialize_model","title":"<code>initialize_model(setup_id, *, strict_version=True)</code>","text":"<p>Initialized a model based on a setup_id (i.e., using the exact same parameter settings)</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The Openml setup_id</p> required <code>strict_version</code> <code>bool</code> <p>See <code>flow_to_model</code> strict_version.</p> <code>True</code> <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/setups/functions.py</code> <pre><code>def initialize_model(setup_id: int, *, strict_version: bool = True) -&gt; Any:\n    \"\"\"\n    Initialized a model based on a setup_id (i.e., using the exact\n    same parameter settings)\n\n    Parameters\n    ----------\n    setup_id : int\n        The Openml setup_id\n    strict_version: bool (default=True)\n        See `flow_to_model` strict_version.\n\n    Returns\n    -------\n    model\n    \"\"\"\n    setup = get_setup(setup_id)\n    flow = openml.flows.get_flow(setup.flow_id)\n\n    # instead of using scikit-learns or any other library's \"set_params\" function, we override the\n    # OpenMLFlow objects default parameter value so we can utilize the\n    # Extension.flow_to_model() function to reinitialize the flow with the set defaults.\n    if setup.parameters is not None:\n        for hyperparameter in setup.parameters.values():\n            structure = flow.get_structure(\"flow_id\")\n            if len(structure[hyperparameter.flow_id]) &gt; 0:\n                subflow = flow.get_subflow(structure[hyperparameter.flow_id])\n            else:\n                subflow = flow\n            subflow.parameters[hyperparameter.parameter_name] = hyperparameter.value\n\n    return flow.extension.flow_to_model(flow, strict_version=strict_version)\n</code></pre>"},{"location":"reference/setups/#openml.setups.list_setups","title":"<code>list_setups(offset=None, size=None, flow=None, tag=None, setup=None, output_format='object')</code>","text":"<p>List all setups matching all of the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <code>None</code> <code>size</code> <code>int</code> <code>None</code> <code>flow</code> <code>int</code> <code>None</code> <code>tag</code> <code>str</code> <code>None</code> <code>setup</code> <code>Iterable[int]</code> <code>None</code> <code>output_format</code> <code>Literal['object', 'dataframe']</code> <p>The parameter decides the format of the output. - If 'dataframe' the output is a pandas DataFrame - If 'object' the output is a dictionary of OpenMLSetup objects</p> <code>'object'</code> <p>Returns:</p> Type Description <code>dict or dataframe</code> Source code in <code>openml/setups/functions.py</code> <pre><code>def list_setups(  # noqa: PLR0913\n    offset: int | None = None,\n    size: int | None = None,\n    flow: int | None = None,\n    tag: str | None = None,\n    setup: Iterable[int] | None = None,\n    output_format: Literal[\"object\", \"dataframe\"] = \"object\",\n) -&gt; dict[int, OpenMLSetup] | pd.DataFrame:\n    \"\"\"\n    List all setups matching all of the given filters.\n\n    Parameters\n    ----------\n    offset : int, optional\n    size : int, optional\n    flow : int, optional\n    tag : str, optional\n    setup : Iterable[int], optional\n    output_format: str, optional (default='object')\n        The parameter decides the format of the output.\n        - If 'dataframe' the output is a pandas DataFrame\n        - If 'object' the output is a dictionary of OpenMLSetup objects\n\n    Returns\n    -------\n    dict or dataframe\n    \"\"\"\n    if output_format not in [\"dataframe\", \"object\"]:\n        raise ValueError(\n            \"Invalid output format selected. Only 'object', or 'dataframe' applicable.\",\n        )\n\n    listing_call = partial(_list_setups, flow=flow, tag=tag, setup=setup)\n    batches = openml.utils._list_all(\n        listing_call,\n        batch_size=1_000,  # batch size for setups is lower\n        offset=offset,\n        limit=size,\n    )\n    flattened = list(chain.from_iterable(batches))\n    if output_format == \"object\":\n        return {setup.setup_id: setup for setup in flattened}\n\n    records = [setup._to_dict() for setup in flattened]\n    return pd.DataFrame.from_records(records, index=\"setup_id\")\n</code></pre>"},{"location":"reference/setups/#openml.setups.setup_exists","title":"<code>setup_exists(flow)</code>","text":"<p>Checks whether a hyperparameter configuration already exists on the server.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>The openml flow object. Should have flow id present for the main flow and all subflows (i.e., it should be downloaded from the server by means of flow.get, and not instantiated locally)</p> required <p>Returns:</p> Name Type Description <code>setup_id</code> <code>int</code> <p>setup id iff exists, False otherwise</p> Source code in <code>openml/setups/functions.py</code> <pre><code>def setup_exists(flow: OpenMLFlow) -&gt; int:\n    \"\"\"\n    Checks whether a hyperparameter configuration already exists on the server.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        The openml flow object. Should have flow id present for the main flow\n        and all subflows (i.e., it should be downloaded from the server by\n        means of flow.get, and not instantiated locally)\n\n    Returns\n    -------\n    setup_id : int\n        setup id iff exists, False otherwise\n    \"\"\"\n    # sadly, this api call relies on a run object\n    openml.flows.functions._check_flow_for_server_id(flow)\n    if flow.model is None:\n        raise ValueError(\"Flow should have model field set with the actual model.\")\n    if flow.extension is None:\n        raise ValueError(\"Flow should have model field set with the correct extension.\")\n\n    # checks whether the flow exists on the server and flow ids align\n    exists = flow_exists(flow.name, flow.external_version)\n    if exists != flow.flow_id:\n        raise ValueError(\n            f\"Local flow id ({flow.id}) differs from server id ({exists}). \"\n            \"If this issue persists, please contact the developers.\",\n        )\n\n    openml_param_settings = flow.extension.obtain_parameter_values(flow)\n    description = xmltodict.unparse(_to_dict(flow.flow_id, openml_param_settings), pretty=True)\n    file_elements = {\n        \"description\": (\"description.arff\", description),\n    }  # type: openml._api_calls.FILE_ELEMENTS_TYPE\n    result = openml._api_calls._perform_api_call(\n        \"/setup/exists/\",\n        \"post\",\n        file_elements=file_elements,\n    )\n    result_dict = xmltodict.parse(result)\n    setup_id = int(result_dict[\"oml:setup_exists\"][\"oml:id\"])\n    return setup_id if setup_id &gt; 0 else False\n</code></pre>"},{"location":"reference/setups/functions/","title":"functions","text":""},{"location":"reference/setups/functions/#openml.setups.functions.__list_setups","title":"<code>__list_setups(api_call)</code>","text":"<p>Helper function to parse API calls which are lists of setups</p> Source code in <code>openml/setups/functions.py</code> <pre><code>def __list_setups(api_call: str) -&gt; list[OpenMLSetup]:\n    \"\"\"Helper function to parse API calls which are lists of setups\"\"\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    setups_dict = xmltodict.parse(xml_string, force_list=(\"oml:setup\",))\n    openml_uri = \"http://openml.org/openml\"\n    # Minimalistic check if the XML is useful\n    if \"oml:setups\" not in setups_dict:\n        raise ValueError(\n            f'Error in return XML, does not contain \"oml:setups\": {setups_dict!s}',\n        )\n\n    if \"@xmlns:oml\" not in setups_dict[\"oml:setups\"]:\n        raise ValueError(\n            f'Error in return XML, does not contain \"oml:setups\"/@xmlns:oml: {setups_dict!s}',\n        )\n\n    if setups_dict[\"oml:setups\"][\"@xmlns:oml\"] != openml_uri:\n        raise ValueError(\n            \"Error in return XML, value of  \"\n            '\"oml:seyups\"/@xmlns:oml is not '\n            f'\"{openml_uri}\": {setups_dict!s}',\n        )\n\n    assert isinstance(setups_dict[\"oml:setups\"][\"oml:setup\"], list), type(setups_dict[\"oml:setups\"])\n\n    return [\n        _create_setup_from_xml({\"oml:setup_parameters\": setup_})\n        for setup_ in setups_dict[\"oml:setups\"][\"oml:setup\"]\n    ]\n</code></pre>"},{"location":"reference/setups/functions/#openml.setups.functions.get_setup","title":"<code>get_setup(setup_id)</code>","text":"<p>Downloads the setup (configuration) description from OpenML  and returns a structured object</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The Openml setup_id</p> required <p>Returns:</p> Type Description <code>OpenMLSetup (an initialized openml setup object)</code> Source code in <code>openml/setups/functions.py</code> <pre><code>def get_setup(setup_id: int) -&gt; OpenMLSetup:\n    \"\"\"\n     Downloads the setup (configuration) description from OpenML\n     and returns a structured object\n\n    Parameters\n    ----------\n    setup_id : int\n        The Openml setup_id\n\n    Returns\n    -------\n    OpenMLSetup (an initialized openml setup object)\n    \"\"\"\n    setup_dir = Path(config.get_cache_directory()) / \"setups\" / str(setup_id)\n    setup_dir.mkdir(exist_ok=True, parents=True)\n\n    setup_file = setup_dir / \"description.xml\"\n\n    try:\n        return _get_cached_setup(setup_id)\n    except openml.exceptions.OpenMLCacheException:\n        url_suffix = f\"/setup/{setup_id}\"\n        setup_xml = openml._api_calls._perform_api_call(url_suffix, \"get\")\n        with setup_file.open(\"w\", encoding=\"utf8\") as fh:\n            fh.write(setup_xml)\n\n    result_dict = xmltodict.parse(setup_xml)\n    return _create_setup_from_xml(result_dict)\n</code></pre>"},{"location":"reference/setups/functions/#openml.setups.functions.initialize_model","title":"<code>initialize_model(setup_id, *, strict_version=True)</code>","text":"<p>Initialized a model based on a setup_id (i.e., using the exact same parameter settings)</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The Openml setup_id</p> required <code>strict_version</code> <code>bool</code> <p>See <code>flow_to_model</code> strict_version.</p> <code>True</code> <p>Returns:</p> Type Description <code>model</code> Source code in <code>openml/setups/functions.py</code> <pre><code>def initialize_model(setup_id: int, *, strict_version: bool = True) -&gt; Any:\n    \"\"\"\n    Initialized a model based on a setup_id (i.e., using the exact\n    same parameter settings)\n\n    Parameters\n    ----------\n    setup_id : int\n        The Openml setup_id\n    strict_version: bool (default=True)\n        See `flow_to_model` strict_version.\n\n    Returns\n    -------\n    model\n    \"\"\"\n    setup = get_setup(setup_id)\n    flow = openml.flows.get_flow(setup.flow_id)\n\n    # instead of using scikit-learns or any other library's \"set_params\" function, we override the\n    # OpenMLFlow objects default parameter value so we can utilize the\n    # Extension.flow_to_model() function to reinitialize the flow with the set defaults.\n    if setup.parameters is not None:\n        for hyperparameter in setup.parameters.values():\n            structure = flow.get_structure(\"flow_id\")\n            if len(structure[hyperparameter.flow_id]) &gt; 0:\n                subflow = flow.get_subflow(structure[hyperparameter.flow_id])\n            else:\n                subflow = flow\n            subflow.parameters[hyperparameter.parameter_name] = hyperparameter.value\n\n    return flow.extension.flow_to_model(flow, strict_version=strict_version)\n</code></pre>"},{"location":"reference/setups/functions/#openml.setups.functions.list_setups","title":"<code>list_setups(offset=None, size=None, flow=None, tag=None, setup=None, output_format='object')</code>","text":"<p>List all setups matching all of the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <code>None</code> <code>size</code> <code>int</code> <code>None</code> <code>flow</code> <code>int</code> <code>None</code> <code>tag</code> <code>str</code> <code>None</code> <code>setup</code> <code>Iterable[int]</code> <code>None</code> <code>output_format</code> <code>Literal['object', 'dataframe']</code> <p>The parameter decides the format of the output. - If 'dataframe' the output is a pandas DataFrame - If 'object' the output is a dictionary of OpenMLSetup objects</p> <code>'object'</code> <p>Returns:</p> Type Description <code>dict or dataframe</code> Source code in <code>openml/setups/functions.py</code> <pre><code>def list_setups(  # noqa: PLR0913\n    offset: int | None = None,\n    size: int | None = None,\n    flow: int | None = None,\n    tag: str | None = None,\n    setup: Iterable[int] | None = None,\n    output_format: Literal[\"object\", \"dataframe\"] = \"object\",\n) -&gt; dict[int, OpenMLSetup] | pd.DataFrame:\n    \"\"\"\n    List all setups matching all of the given filters.\n\n    Parameters\n    ----------\n    offset : int, optional\n    size : int, optional\n    flow : int, optional\n    tag : str, optional\n    setup : Iterable[int], optional\n    output_format: str, optional (default='object')\n        The parameter decides the format of the output.\n        - If 'dataframe' the output is a pandas DataFrame\n        - If 'object' the output is a dictionary of OpenMLSetup objects\n\n    Returns\n    -------\n    dict or dataframe\n    \"\"\"\n    if output_format not in [\"dataframe\", \"object\"]:\n        raise ValueError(\n            \"Invalid output format selected. Only 'object', or 'dataframe' applicable.\",\n        )\n\n    listing_call = partial(_list_setups, flow=flow, tag=tag, setup=setup)\n    batches = openml.utils._list_all(\n        listing_call,\n        batch_size=1_000,  # batch size for setups is lower\n        offset=offset,\n        limit=size,\n    )\n    flattened = list(chain.from_iterable(batches))\n    if output_format == \"object\":\n        return {setup.setup_id: setup for setup in flattened}\n\n    records = [setup._to_dict() for setup in flattened]\n    return pd.DataFrame.from_records(records, index=\"setup_id\")\n</code></pre>"},{"location":"reference/setups/functions/#openml.setups.functions.setup_exists","title":"<code>setup_exists(flow)</code>","text":"<p>Checks whether a hyperparameter configuration already exists on the server.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>OpenMLFlow</code> <p>The openml flow object. Should have flow id present for the main flow and all subflows (i.e., it should be downloaded from the server by means of flow.get, and not instantiated locally)</p> required <p>Returns:</p> Name Type Description <code>setup_id</code> <code>int</code> <p>setup id iff exists, False otherwise</p> Source code in <code>openml/setups/functions.py</code> <pre><code>def setup_exists(flow: OpenMLFlow) -&gt; int:\n    \"\"\"\n    Checks whether a hyperparameter configuration already exists on the server.\n\n    Parameters\n    ----------\n    flow : OpenMLFlow\n        The openml flow object. Should have flow id present for the main flow\n        and all subflows (i.e., it should be downloaded from the server by\n        means of flow.get, and not instantiated locally)\n\n    Returns\n    -------\n    setup_id : int\n        setup id iff exists, False otherwise\n    \"\"\"\n    # sadly, this api call relies on a run object\n    openml.flows.functions._check_flow_for_server_id(flow)\n    if flow.model is None:\n        raise ValueError(\"Flow should have model field set with the actual model.\")\n    if flow.extension is None:\n        raise ValueError(\"Flow should have model field set with the correct extension.\")\n\n    # checks whether the flow exists on the server and flow ids align\n    exists = flow_exists(flow.name, flow.external_version)\n    if exists != flow.flow_id:\n        raise ValueError(\n            f\"Local flow id ({flow.id}) differs from server id ({exists}). \"\n            \"If this issue persists, please contact the developers.\",\n        )\n\n    openml_param_settings = flow.extension.obtain_parameter_values(flow)\n    description = xmltodict.unparse(_to_dict(flow.flow_id, openml_param_settings), pretty=True)\n    file_elements = {\n        \"description\": (\"description.arff\", description),\n    }  # type: openml._api_calls.FILE_ELEMENTS_TYPE\n    result = openml._api_calls._perform_api_call(\n        \"/setup/exists/\",\n        \"post\",\n        file_elements=file_elements,\n    )\n    result_dict = xmltodict.parse(result)\n    setup_id = int(result_dict[\"oml:setup_exists\"][\"oml:id\"])\n    return setup_id if setup_id &gt; 0 else False\n</code></pre>"},{"location":"reference/setups/setup/","title":"setup","text":""},{"location":"reference/setups/setup/#openml.setups.setup.OpenMLParameter","title":"<code>OpenMLParameter</code>","text":"<p>Parameter object (used in setup).</p> <p>Parameters:</p> Name Type Description Default <code>input_id</code> <code>int</code> <p>The input id from the openml database</p> required <code>flow</code> <p>The flow to which this parameter is associated</p> required <code>flow</code> <p>The name of the flow (no version number) to which this parameter is associated</p> required <code>full_name</code> <code>str</code> <p>The name of the flow and parameter combined</p> required <code>parameter_name</code> <code>str</code> <p>The name of the parameter</p> required <code>data_type</code> <code>str</code> <p>The datatype of the parameter. generally unused for sklearn flows</p> required <code>default_value</code> <code>str</code> <p>The default value. For sklearn parameters, this is unknown and a default value is selected arbitrarily</p> required <code>value</code> <code>str</code> <p>If the parameter was set, the value that it was set to.</p> required Source code in <code>openml/setups/setup.py</code> <pre><code>class OpenMLParameter:\n    \"\"\"Parameter object (used in setup).\n\n    Parameters\n    ----------\n    input_id : int\n        The input id from the openml database\n    flow id : int\n        The flow to which this parameter is associated\n    flow name : str\n        The name of the flow (no version number) to which this parameter\n        is associated\n    full_name : str\n        The name of the flow and parameter combined\n    parameter_name : str\n        The name of the parameter\n    data_type : str\n        The datatype of the parameter. generally unused for sklearn flows\n    default_value : str\n        The default value. For sklearn parameters, this is unknown and a\n        default value is selected arbitrarily\n    value : str\n        If the parameter was set, the value that it was set to.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        input_id: int,\n        flow_id: int,\n        flow_name: str,\n        full_name: str,\n        parameter_name: str,\n        data_type: str,\n        default_value: str,\n        value: str,\n    ):\n        self.id = input_id\n        self.flow_id = flow_id\n        self.flow_name = flow_name\n        self.full_name = full_name\n        self.parameter_name = parameter_name\n        self.data_type = data_type\n        self.default_value = default_value\n        self.value = value\n\n    def _to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"flow_id\": self.flow_id,\n            \"flow_name\": self.flow_name,\n            \"full_name\": self.full_name,\n            \"parameter_name\": self.parameter_name,\n            \"data_type\": self.data_type,\n            \"default_value\": self.default_value,\n            \"value\": self.value,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Parameter\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"ID\": self.id,\n            \"Flow ID\": self.flow_id,\n            # \"Flow Name\": self.flow_name,\n            \"Flow Name\": self.full_name,\n            \"Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"Parameter Name\": self.parameter_name,\n        }\n        # indented prints for parameter attributes\n        # indention = 2 spaces + 1 | + 2 underscores\n        indent = f\"{' ' * 2}|{'_' * 2}\"\n        parameter_data_type = f\"{indent}Data Type\"\n        fields[parameter_data_type] = self.data_type\n        parameter_default = f\"{indent}Default\"\n        fields[parameter_default] = self.default_value\n        parameter_value = f\"{indent}Value\"\n        fields[parameter_value] = self.value\n\n        # determines the order in which the information will be printed\n        order = [\n            \"ID\",\n            \"Flow ID\",\n            \"Flow Name\",\n            \"Flow URL\",\n            \"Parameter Name\",\n            parameter_data_type,\n            parameter_default,\n            parameter_value,\n        ]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/setups/setup/#openml.setups.setup.OpenMLSetup","title":"<code>OpenMLSetup</code>","text":"<p>Setup object (a.k.a. Configuration).</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>The OpenML setup id</p> required <code>flow_id</code> <code>int</code> <p>The flow that it is build upon</p> required <code>parameters</code> <code>dict</code> <p>The setting of the parameters</p> required Source code in <code>openml/setups/setup.py</code> <pre><code>class OpenMLSetup:\n    \"\"\"Setup object (a.k.a. Configuration).\n\n    Parameters\n    ----------\n    setup_id : int\n        The OpenML setup id\n    flow_id : int\n        The flow that it is build upon\n    parameters : dict\n        The setting of the parameters\n    \"\"\"\n\n    def __init__(self, setup_id: int, flow_id: int, parameters: dict[int, Any] | None):\n        if not isinstance(setup_id, int):\n            raise ValueError(\"setup id should be int\")\n\n        if not isinstance(flow_id, int):\n            raise ValueError(\"flow id should be int\")\n\n        if parameters is not None and not isinstance(parameters, dict):\n            raise ValueError(\"parameters should be dict\")\n\n        self.setup_id = setup_id\n        self.flow_id = flow_id\n        self.parameters = parameters\n\n    def _to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"setup_id\": self.setup_id,\n            \"flow_id\": self.flow_id,\n            \"parameters\": {p.id: p._to_dict() for p in self.parameters.values()}\n            if self.parameters is not None\n            else None,\n        }\n\n    def __repr__(self) -&gt; str:\n        header = \"OpenML Setup\"\n        header = f\"{header}\\n{'=' * len(header)}\\n\"\n\n        fields = {\n            \"Setup ID\": self.setup_id,\n            \"Flow ID\": self.flow_id,\n            \"Flow URL\": openml.flows.OpenMLFlow.url_for_id(self.flow_id),\n            \"# of Parameters\": (\n                len(self.parameters) if self.parameters is not None else float(\"nan\")\n            ),\n        }\n\n        # determines the order in which the information will be printed\n        order = [\"Setup ID\", \"Flow ID\", \"Flow URL\", \"# of Parameters\"]\n        _fields = [(key, fields[key]) for key in order if key in fields]\n\n        longest_field_name_length = max(len(name) for name, _ in _fields)\n        field_line_format = f\"{{:.&lt;{longest_field_name_length}}}: {{}}\"\n        body = \"\\n\".join(field_line_format.format(name, value) for name, value in _fields)\n        return header + body\n</code></pre>"},{"location":"reference/study/","title":"study","text":""},{"location":"reference/study/#openml.study.OpenMLBenchmarkSuite","title":"<code>OpenMLBenchmarkSuite</code>","text":"<p>               Bases: <code>BaseStudy</code></p> <p>An OpenMLBenchmarkSuite represents the OpenML concept of a suite (a collection of tasks).</p> <p>It contains the following information: name, id, description, creation date, creator id and the task ids.</p> <p>According to this list of task ids, the suite object receives a list of OpenML object ids (datasets).</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>main_entity_type</code> <code>str</code> <p>the entity type (e.g., task, run) that is core in this study. only entities of this type can be added explicitly</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class OpenMLBenchmarkSuite(BaseStudy):\n    \"\"\"\n    An OpenMLBenchmarkSuite represents the OpenML concept of a suite (a collection of tasks).\n\n    It contains the following information: name, id, description, creation date,\n    creator id and the task ids.\n\n    According to this list of task ids, the suite object receives a list of\n    OpenML object ids (datasets).\n\n    Parameters\n    ----------\n    suite_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    main_entity_type : str\n        the entity type (e.g., task, run) that is core in this study.\n        only entities of this type can be added explicitly\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        suite_id: int | None,\n        alias: str | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n    ):\n        super().__init__(\n            study_id=suite_id,\n            alias=alias,\n            main_entity_type=\"task\",\n            benchmark_suite=None,\n            name=name,\n            description=description,\n            status=status,\n            creation_date=creation_date,\n            creator=creator,\n            tags=tags,\n            data=data,\n            tasks=tasks,\n            flows=None,\n            runs=None,\n            setups=None,\n        )\n</code></pre>"},{"location":"reference/study/#openml.study.OpenMLStudy","title":"<code>OpenMLStudy</code>","text":"<p>               Bases: <code>BaseStudy</code></p> <p>An OpenMLStudy represents the OpenML concept of a study (a collection of runs).</p> <p>It contains the following information: name, id, description, creation date, creator id and a list of run ids.</p> <p>According to this list of run ids, the study object receives a list of OpenML object ids (datasets, flows, tasks and setups).</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>benchmark_suite</code> <code>int(optional)</code> <p>the benchmark suite (another study) upon which this study is ran. can only be active if main entity type is runs.</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required <code>flows</code> <code>list</code> <p>a list of flow ids associated with this study</p> required <code>runs</code> <code>list</code> <p>a list of run ids associated with this study</p> required <code>setups</code> <code>list</code> <p>a list of setup ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class OpenMLStudy(BaseStudy):\n    \"\"\"\n    An OpenMLStudy represents the OpenML concept of a study (a collection of runs).\n\n    It contains the following information: name, id, description, creation date,\n    creator id and a list of run ids.\n\n    According to this list of run ids, the study object receives a list of\n    OpenML object ids (datasets, flows, tasks and setups).\n\n    Parameters\n    ----------\n    study_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    benchmark_suite : int (optional)\n        the benchmark suite (another study) upon which this study is ran.\n        can only be active if main entity type is runs.\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    flows : list\n        a list of flow ids associated with this study\n    runs : list\n        a list of run ids associated with this study\n    setups : list\n        a list of setup ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        study_id: int | None,\n        alias: str | None,\n        benchmark_suite: int | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n        flows: list[int] | None,\n        runs: list[int] | None,\n        setups: list[int] | None,\n    ):\n        super().__init__(\n            study_id=study_id,\n            alias=alias,\n            main_entity_type=\"run\",\n            benchmark_suite=benchmark_suite,\n            name=name,\n            description=description,\n            status=status,\n            creation_date=creation_date,\n            creator=creator,\n            tags=tags,\n            data=data,\n            tasks=tasks,\n            flows=flows,\n            runs=runs,\n            setups=setups,\n        )\n</code></pre>"},{"location":"reference/study/#openml.study.attach_to_study","title":"<code>attach_to_study(study_id, run_ids)</code>","text":"<p>Attaches a set of runs to a study.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>run_ids</code> <code>list(int)</code> <p>List of entities to link to the collection</p> required <p>Returns:</p> Type Description <code>int</code> <p>new size of the study (in terms of explicitly linked entities)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def attach_to_study(study_id: int, run_ids: list[int]) -&gt; int:\n    \"\"\"Attaches a set of runs to a study.\n\n    Parameters\n    ----------\n    study_id : int\n        OpenML id of the study\n\n    run_ids : list (int)\n        List of entities to link to the collection\n\n    Returns\n    -------\n    int\n        new size of the study (in terms of explicitly linked entities)\n    \"\"\"\n    # Interestingly, there's no need to tell the server about the entity type, it knows by itself\n    result_xml = openml._api_calls._perform_api_call(\n        call=f\"study/{study_id}/attach\",\n        request_method=\"post\",\n        data={\"ids\": \",\".join(str(x) for x in run_ids)},\n    )\n    result = xmltodict.parse(result_xml)[\"oml:study_attach\"]\n    return int(result[\"oml:linked_entities\"])\n</code></pre>"},{"location":"reference/study/#openml.study.attach_to_suite","title":"<code>attach_to_suite(suite_id, task_ids)</code>","text":"<p>Attaches a set of tasks to a benchmarking suite.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>task_ids</code> <code>list(int)</code> <p>List of entities to link to the collection</p> required <p>Returns:</p> Type Description <code>int</code> <p>new size of the suite (in terms of explicitly linked entities)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def attach_to_suite(suite_id: int, task_ids: list[int]) -&gt; int:\n    \"\"\"Attaches a set of tasks to a benchmarking suite.\n\n    Parameters\n    ----------\n    suite_id : int\n        OpenML id of the study\n\n    task_ids : list (int)\n        List of entities to link to the collection\n\n    Returns\n    -------\n    int\n        new size of the suite (in terms of explicitly linked entities)\n    \"\"\"\n    return attach_to_study(suite_id, task_ids)\n</code></pre>"},{"location":"reference/study/#openml.study.create_benchmark_suite","title":"<code>create_benchmark_suite(name, description, task_ids, alias=None)</code>","text":"<p>Creates an OpenML benchmark suite (collection of entity types, where the tasks are the linked entity)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>task_ids</code> <code>list</code> <p>a list of task ids associated with this study more can be added later with <code>attach_to_suite</code>.</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> <code>None</code> <p>Returns:</p> Type Description <code>OpenMLStudy</code> <p>A local OpenML study object (call publish method to upload to server)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def create_benchmark_suite(\n    name: str,\n    description: str,\n    task_ids: list[int],\n    alias: str | None = None,\n) -&gt; OpenMLBenchmarkSuite:\n    \"\"\"\n    Creates an OpenML benchmark suite (collection of entity types, where\n    the tasks are the linked entity)\n\n    Parameters\n    ----------\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    task_ids : list\n        a list of task ids associated with this study\n        more can be added later with ``attach_to_suite``.\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n\n    Returns\n    -------\n    OpenMLStudy\n        A local OpenML study object (call publish method to upload to server)\n    \"\"\"\n    return OpenMLBenchmarkSuite(\n        suite_id=None,\n        alias=alias,\n        name=name,\n        description=description,\n        status=None,\n        creation_date=None,\n        creator=None,\n        tags=None,\n        data=None,\n        tasks=task_ids,\n    )\n</code></pre>"},{"location":"reference/study/#openml.study.create_study","title":"<code>create_study(name, description, run_ids=None, alias=None, benchmark_suite=None)</code>","text":"<p>Creates an OpenML study (collection of data, tasks, flows, setups and run), where the runs are the main entity (collection consists of runs and all entities (flows, tasks, etc) that are related to these runs)</p> <p>Parameters:</p> Name Type Description Default <code>benchmark_suite</code> <code>int(optional)</code> <p>the benchmark suite (another study) upon which this study is ran.</p> <code>None</code> <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>run_ids</code> <code>list</code> <p>a list of run ids associated with this study, these can also be added later with <code>attach_to_study</code>.</p> <code>None</code> <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> <code>None</code> <code>benchmark_suite</code> <code>int | None</code> <p>the ID of the suite for which this study contains run results</p> <code>None</code> <p>Returns:</p> Type Description <code>OpenMLStudy</code> <p>A local OpenML study object (call publish method to upload to server)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def create_study(\n    name: str,\n    description: str,\n    run_ids: list[int] | None = None,\n    alias: str | None = None,\n    benchmark_suite: int | None = None,\n) -&gt; OpenMLStudy:\n    \"\"\"\n    Creates an OpenML study (collection of data, tasks, flows, setups and run),\n    where the runs are the main entity (collection consists of runs and all\n    entities (flows, tasks, etc) that are related to these runs)\n\n    Parameters\n    ----------\n    benchmark_suite : int (optional)\n        the benchmark suite (another study) upon which this study is ran.\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    run_ids : list, optional\n        a list of run ids associated with this study,\n        these can also be added later with ``attach_to_study``.\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    benchmark_suite: int (optional)\n        the ID of the suite for which this study contains run results\n\n    Returns\n    -------\n    OpenMLStudy\n        A local OpenML study object (call publish method to upload to server)\n    \"\"\"\n    return OpenMLStudy(\n        study_id=None,\n        alias=alias,\n        benchmark_suite=benchmark_suite,\n        name=name,\n        description=description,\n        status=None,\n        creation_date=None,\n        creator=None,\n        tags=None,\n        data=None,\n        tasks=None,\n        flows=None,\n        runs=run_ids if run_ids != [] else None,\n        setups=None,\n    )\n</code></pre>"},{"location":"reference/study/#openml.study.delete_study","title":"<code>delete_study(study_id)</code>","text":"<p>Deletes a study from the OpenML server.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>OpenML id of the study</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True iff the deletion was successful. False otherwise</p> Source code in <code>openml/study/functions.py</code> <pre><code>def delete_study(study_id: int) -&gt; bool:\n    \"\"\"Deletes a study from the OpenML server.\n\n    Parameters\n    ----------\n    study_id : int\n        OpenML id of the study\n\n    Returns\n    -------\n    bool\n        True iff the deletion was successful. False otherwise\n    \"\"\"\n    return openml.utils._delete_entity(\"study\", study_id)\n</code></pre>"},{"location":"reference/study/#openml.study.delete_suite","title":"<code>delete_suite(suite_id)</code>","text":"<p>Deletes a study from the OpenML server.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>OpenML id of the study</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True iff the deletion was successful. False otherwise</p> Source code in <code>openml/study/functions.py</code> <pre><code>def delete_suite(suite_id: int) -&gt; bool:\n    \"\"\"Deletes a study from the OpenML server.\n\n    Parameters\n    ----------\n    suite_id : int\n        OpenML id of the study\n\n    Returns\n    -------\n    bool\n        True iff the deletion was successful. False otherwise\n    \"\"\"\n    return delete_study(suite_id)\n</code></pre>"},{"location":"reference/study/#openml.study.detach_from_study","title":"<code>detach_from_study(study_id, run_ids)</code>","text":"<p>Detaches a set of run ids from a study.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>run_ids</code> <code>list(int)</code> <p>List of entities to unlink from the collection</p> required <p>Returns:</p> Type Description <code>int</code> <p>new size of the study (in terms of explicitly linked entities)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def detach_from_study(study_id: int, run_ids: list[int]) -&gt; int:\n    \"\"\"Detaches a set of run ids from a study.\n\n    Parameters\n    ----------\n    study_id : int\n        OpenML id of the study\n\n    run_ids : list (int)\n        List of entities to unlink from the collection\n\n    Returns\n    -------\n    int\n        new size of the study (in terms of explicitly linked entities)\n    \"\"\"\n    # Interestingly, there's no need to tell the server about the entity type, it knows by itself\n    uri = \"study/%d/detach\" % study_id\n    post_variables = {\"ids\": \",\".join(str(x) for x in run_ids)}  # type: openml._api_calls.DATA_TYPE\n    result_xml = openml._api_calls._perform_api_call(\n        call=uri,\n        request_method=\"post\",\n        data=post_variables,\n    )\n    result = xmltodict.parse(result_xml)[\"oml:study_detach\"]\n    return int(result[\"oml:linked_entities\"])\n</code></pre>"},{"location":"reference/study/#openml.study.detach_from_suite","title":"<code>detach_from_suite(suite_id, task_ids)</code>","text":"<p>Detaches a set of task ids from a suite.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>task_ids</code> <code>list(int)</code> <p>List of entities to unlink from the collection</p> required <p>Returns:</p> Type Description <code>int</code> <code>new size of the study (in terms of explicitly linked entities)</code> Source code in <code>openml/study/functions.py</code> <pre><code>def detach_from_suite(suite_id: int, task_ids: list[int]) -&gt; int:\n    \"\"\"Detaches a set of task ids from a suite.\n\n    Parameters\n    ----------\n    suite_id : int\n        OpenML id of the study\n\n    task_ids : list (int)\n        List of entities to unlink from the collection\n\n    Returns\n    -------\n    int\n    new size of the study (in terms of explicitly linked entities)\n    \"\"\"\n    return detach_from_study(suite_id, task_ids)\n</code></pre>"},{"location":"reference/study/#openml.study.get_study","title":"<code>get_study(study_id, arg_for_backwards_compat=None)</code>","text":"<p>Retrieves all relevant information of an OpenML study from the server.</p> <p>Parameters:</p> Name Type Description Default <code>study</code> <p>study id (numeric or alias)</p> required <code>arg_for_backwards_compat</code> <code>str</code> <p>The example given in https://arxiv.org/pdf/1708.03731.pdf uses an older version of the API which required specifying the type of study, i.e. tasks. We changed the implementation of studies since then and split them up into suites (collections of tasks) and studies (collections of runs) so this argument is no longer needed.</p> <code>None</code> <p>Returns:</p> Type Description <code>OpenMLStudy</code> <p>The OpenML study object</p> Source code in <code>openml/study/functions.py</code> <pre><code>def get_study(\n    study_id: int | str,\n    arg_for_backwards_compat: str | None = None,  # noqa: ARG001\n) -&gt; OpenMLStudy:  # F401\n    \"\"\"\n    Retrieves all relevant information of an OpenML study from the server.\n\n    Parameters\n    ----------\n    study id : int, str\n        study id (numeric or alias)\n\n    arg_for_backwards_compat : str, optional\n        The example given in https://arxiv.org/pdf/1708.03731.pdf uses an older version of the\n        API which required specifying the type of study, i.e. tasks. We changed the\n        implementation of studies since then and split them up into suites (collections of tasks)\n        and studies (collections of runs) so this argument is no longer needed.\n\n    Returns\n    -------\n    OpenMLStudy\n        The OpenML study object\n    \"\"\"\n    if study_id == \"OpenML100\":\n        message = (\n            \"It looks like you are running code from the OpenML100 paper. It still works, but lots \"\n            \"of things have changed since then. Please use `get_suite('OpenML100')` instead.\"\n        )\n        warnings.warn(message, DeprecationWarning, stacklevel=2)\n        openml.config.logger.warning(message)\n        study = _get_study(study_id, entity_type=\"task\")\n        assert isinstance(study, OpenMLBenchmarkSuite)\n\n        return study  # type: ignore\n\n    study = _get_study(study_id, entity_type=\"run\")\n    assert isinstance(study, OpenMLStudy)\n    return study\n</code></pre>"},{"location":"reference/study/#openml.study.get_suite","title":"<code>get_suite(suite_id)</code>","text":"<p>Retrieves all relevant information of an OpenML benchmarking suite from the server.</p> <p>Parameters:</p> Name Type Description Default <code>study</code> <p>study id (numeric or alias)</p> required <p>Returns:</p> Type Description <code>OpenMLSuite</code> <p>The OpenML suite object</p> Source code in <code>openml/study/functions.py</code> <pre><code>def get_suite(suite_id: int | str) -&gt; OpenMLBenchmarkSuite:\n    \"\"\"\n    Retrieves all relevant information of an OpenML benchmarking suite from the server.\n\n    Parameters\n    ----------\n    study id : int, str\n        study id (numeric or alias)\n\n    Returns\n    -------\n    OpenMLSuite\n        The OpenML suite object\n    \"\"\"\n    study = _get_study(suite_id, entity_type=\"task\")\n    assert isinstance(study, OpenMLBenchmarkSuite)\n\n    return study\n</code></pre>"},{"location":"reference/study/#openml.study.list_studies","title":"<code>list_studies(offset=None, size=None, status=None, uploader=None, benchmark_suite=None)</code>","text":"<p>Return a list of all studies which are on OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The number of studies to skip, starting from the first.</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of studies to show.</p> <code>None</code> <code>status</code> <code>str</code> <p>Should be {active, in_preparation, deactivated, all}. By default active studies are returned.</p> <code>None</code> <code>uploader</code> <code>list(int)</code> <p>Result filter. Will only return studies created by these users.</p> <code>None</code> <code>benchmark_suite</code> <code>int</code> <code>None</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>dataframe</code> <p>Every dataset is represented by a dictionary containing the following information: - id - alias (optional) - name - benchmark_suite (optional) - status - creator - creation_date If qualities are calculated for the dataset, some of these are also returned.</p> Source code in <code>openml/study/functions.py</code> <pre><code>def list_studies(\n    offset: int | None = None,\n    size: int | None = None,\n    status: str | None = None,\n    uploader: list[str] | None = None,\n    benchmark_suite: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a list of all studies which are on OpenML.\n\n    Parameters\n    ----------\n    offset : int, optional\n        The number of studies to skip, starting from the first.\n    size : int, optional\n        The maximum number of studies to show.\n    status : str, optional\n        Should be {active, in_preparation, deactivated, all}. By default active\n        studies are returned.\n    uploader : list (int), optional\n        Result filter. Will only return studies created by these users.\n    benchmark_suite : int, optional\n\n    Returns\n    -------\n    datasets : dataframe\n        Every dataset is represented by a dictionary containing\n        the following information:\n        - id\n        - alias (optional)\n        - name\n        - benchmark_suite (optional)\n        - status\n        - creator\n        - creation_date\n        If qualities are calculated for the dataset, some of\n        these are also returned.\n    \"\"\"\n    listing_call = partial(\n        _list_studies,\n        main_entity_type=\"run\",\n        status=status,\n        uploader=uploader,\n        benchmark_suite=benchmark_suite,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/study/#openml.study.list_suites","title":"<code>list_suites(offset=None, size=None, status=None, uploader=None)</code>","text":"<p>Return a list of all suites which are on OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The number of suites to skip, starting from the first.</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of suites to show.</p> <code>None</code> <code>status</code> <code>str</code> <p>Should be {active, in_preparation, deactivated, all}. By default active suites are returned.</p> <code>None</code> <code>uploader</code> <code>list(int)</code> <p>Result filter. Will only return suites created by these users.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>dataframe</code> <p>Every row is represented by a dictionary containing the following information: - id - alias (optional) - name - main_entity_type - status - creator - creation_date</p> Source code in <code>openml/study/functions.py</code> <pre><code>def list_suites(\n    offset: int | None = None,\n    size: int | None = None,\n    status: str | None = None,\n    uploader: list[int] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a list of all suites which are on OpenML.\n\n    Parameters\n    ----------\n    offset : int, optional\n        The number of suites to skip, starting from the first.\n    size : int, optional\n        The maximum number of suites to show.\n    status : str, optional\n        Should be {active, in_preparation, deactivated, all}. By default active\n        suites are returned.\n    uploader : list (int), optional\n        Result filter. Will only return suites created by these users.\n\n    Returns\n    -------\n    datasets : dataframe\n        Every row is represented by a dictionary containing the following information:\n        - id\n        - alias (optional)\n        - name\n        - main_entity_type\n        - status\n        - creator\n        - creation_date\n    \"\"\"\n    listing_call = partial(\n        _list_studies,\n        main_entity_type=\"task\",\n        status=status,\n        uploader=uploader,\n    )\n    batches = openml.utils._list_all(listing_call, limit=size, offset=offset)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/study/#openml.study.update_study_status","title":"<code>update_study_status(study_id, status)</code>","text":"<p>Updates the status of a study to either 'active' or 'deactivated'.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>The data id of the dataset</p> required <code>status</code> <code>(str)</code> <p>'active' or 'deactivated'</p> required Source code in <code>openml/study/functions.py</code> <pre><code>def update_study_status(study_id: int, status: str) -&gt; None:\n    \"\"\"\n    Updates the status of a study to either 'active' or 'deactivated'.\n\n    Parameters\n    ----------\n    study_id : int\n        The data id of the dataset\n    status : str,\n        'active' or 'deactivated'\n    \"\"\"\n    legal_status = {\"active\", \"deactivated\"}\n    if status not in legal_status:\n        raise ValueError(f\"Illegal status value. Legal values: {legal_status}\")\n    data = {\"study_id\": study_id, \"status\": status}  # type: openml._api_calls.DATA_TYPE\n    result_xml = openml._api_calls._perform_api_call(\"study/status/update\", \"post\", data=data)\n    result = xmltodict.parse(result_xml)\n    server_study_id = result[\"oml:study_status_update\"][\"oml:id\"]\n    server_status = result[\"oml:study_status_update\"][\"oml:status\"]\n    if status != server_status or int(study_id) != int(server_study_id):\n        # This should never happen\n        raise ValueError(\"Study id/status does not collide\")\n</code></pre>"},{"location":"reference/study/#openml.study.update_suite_status","title":"<code>update_suite_status(suite_id, status)</code>","text":"<p>Updates the status of a study to either 'active' or 'deactivated'.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>The data id of the dataset</p> required <code>status</code> <code>(str)</code> <p>'active' or 'deactivated'</p> required Source code in <code>openml/study/functions.py</code> <pre><code>def update_suite_status(suite_id: int, status: str) -&gt; None:\n    \"\"\"\n    Updates the status of a study to either 'active' or 'deactivated'.\n\n    Parameters\n    ----------\n    suite_id : int\n        The data id of the dataset\n    status : str,\n        'active' or 'deactivated'\n    \"\"\"\n    return update_study_status(suite_id, status)\n</code></pre>"},{"location":"reference/study/functions/","title":"functions","text":""},{"location":"reference/study/functions/#openml.study.functions.__list_studies","title":"<code>__list_studies(api_call)</code>","text":"<p>Retrieves the list of OpenML studies and returns it in a dictionary or a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>api_call</code> <code>str</code> <p>The API call for retrieving the list of OpenML studies.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Pandas DataFrame of OpenML studies</p> Source code in <code>openml/study/functions.py</code> <pre><code>def __list_studies(api_call: str) -&gt; pd.DataFrame:\n    \"\"\"Retrieves the list of OpenML studies and\n    returns it in a dictionary or a Pandas DataFrame.\n\n    Parameters\n    ----------\n    api_call : str\n        The API call for retrieving the list of OpenML studies.\n\n    Returns\n    -------\n    pd.DataFrame\n        A Pandas DataFrame of OpenML studies\n    \"\"\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    study_dict = xmltodict.parse(xml_string, force_list=(\"oml:study\",))\n\n    # Minimalistic check if the XML is useful\n    assert isinstance(study_dict[\"oml:study_list\"][\"oml:study\"], list), type(\n        study_dict[\"oml:study_list\"],\n    )\n    assert study_dict[\"oml:study_list\"][\"@xmlns:oml\"] == \"http://openml.org/openml\", study_dict[\n        \"oml:study_list\"\n    ][\"@xmlns:oml\"]\n\n    studies = {}\n    for study_ in study_dict[\"oml:study_list\"][\"oml:study\"]:\n        # maps from xml name to a tuple of (dict name, casting fn)\n        expected_fields = {\n            \"oml:id\": (\"id\", int),\n            \"oml:alias\": (\"alias\", str),\n            \"oml:main_entity_type\": (\"main_entity_type\", str),\n            \"oml:benchmark_suite\": (\"benchmark_suite\", int),\n            \"oml:name\": (\"name\", str),\n            \"oml:status\": (\"status\", str),\n            \"oml:creation_date\": (\"creation_date\", str),\n            \"oml:creator\": (\"creator\", int),\n        }\n        study_id = int(study_[\"oml:id\"])\n        current_study = {}\n        for oml_field_name, (real_field_name, cast_fn) in expected_fields.items():\n            if oml_field_name in study_:\n                current_study[real_field_name] = cast_fn(study_[oml_field_name])\n        current_study[\"id\"] = int(current_study[\"id\"])\n        studies[study_id] = current_study\n\n    return pd.DataFrame.from_dict(studies, orient=\"index\")\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.attach_to_study","title":"<code>attach_to_study(study_id, run_ids)</code>","text":"<p>Attaches a set of runs to a study.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>run_ids</code> <code>list(int)</code> <p>List of entities to link to the collection</p> required <p>Returns:</p> Type Description <code>int</code> <p>new size of the study (in terms of explicitly linked entities)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def attach_to_study(study_id: int, run_ids: list[int]) -&gt; int:\n    \"\"\"Attaches a set of runs to a study.\n\n    Parameters\n    ----------\n    study_id : int\n        OpenML id of the study\n\n    run_ids : list (int)\n        List of entities to link to the collection\n\n    Returns\n    -------\n    int\n        new size of the study (in terms of explicitly linked entities)\n    \"\"\"\n    # Interestingly, there's no need to tell the server about the entity type, it knows by itself\n    result_xml = openml._api_calls._perform_api_call(\n        call=f\"study/{study_id}/attach\",\n        request_method=\"post\",\n        data={\"ids\": \",\".join(str(x) for x in run_ids)},\n    )\n    result = xmltodict.parse(result_xml)[\"oml:study_attach\"]\n    return int(result[\"oml:linked_entities\"])\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.attach_to_suite","title":"<code>attach_to_suite(suite_id, task_ids)</code>","text":"<p>Attaches a set of tasks to a benchmarking suite.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>task_ids</code> <code>list(int)</code> <p>List of entities to link to the collection</p> required <p>Returns:</p> Type Description <code>int</code> <p>new size of the suite (in terms of explicitly linked entities)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def attach_to_suite(suite_id: int, task_ids: list[int]) -&gt; int:\n    \"\"\"Attaches a set of tasks to a benchmarking suite.\n\n    Parameters\n    ----------\n    suite_id : int\n        OpenML id of the study\n\n    task_ids : list (int)\n        List of entities to link to the collection\n\n    Returns\n    -------\n    int\n        new size of the suite (in terms of explicitly linked entities)\n    \"\"\"\n    return attach_to_study(suite_id, task_ids)\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.create_benchmark_suite","title":"<code>create_benchmark_suite(name, description, task_ids, alias=None)</code>","text":"<p>Creates an OpenML benchmark suite (collection of entity types, where the tasks are the linked entity)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>task_ids</code> <code>list</code> <p>a list of task ids associated with this study more can be added later with <code>attach_to_suite</code>.</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> <code>None</code> <p>Returns:</p> Type Description <code>OpenMLStudy</code> <p>A local OpenML study object (call publish method to upload to server)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def create_benchmark_suite(\n    name: str,\n    description: str,\n    task_ids: list[int],\n    alias: str | None = None,\n) -&gt; OpenMLBenchmarkSuite:\n    \"\"\"\n    Creates an OpenML benchmark suite (collection of entity types, where\n    the tasks are the linked entity)\n\n    Parameters\n    ----------\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    task_ids : list\n        a list of task ids associated with this study\n        more can be added later with ``attach_to_suite``.\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n\n    Returns\n    -------\n    OpenMLStudy\n        A local OpenML study object (call publish method to upload to server)\n    \"\"\"\n    return OpenMLBenchmarkSuite(\n        suite_id=None,\n        alias=alias,\n        name=name,\n        description=description,\n        status=None,\n        creation_date=None,\n        creator=None,\n        tags=None,\n        data=None,\n        tasks=task_ids,\n    )\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.create_study","title":"<code>create_study(name, description, run_ids=None, alias=None, benchmark_suite=None)</code>","text":"<p>Creates an OpenML study (collection of data, tasks, flows, setups and run), where the runs are the main entity (collection consists of runs and all entities (flows, tasks, etc) that are related to these runs)</p> <p>Parameters:</p> Name Type Description Default <code>benchmark_suite</code> <code>int(optional)</code> <p>the benchmark suite (another study) upon which this study is ran.</p> <code>None</code> <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>run_ids</code> <code>list</code> <p>a list of run ids associated with this study, these can also be added later with <code>attach_to_study</code>.</p> <code>None</code> <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> <code>None</code> <code>benchmark_suite</code> <code>int | None</code> <p>the ID of the suite for which this study contains run results</p> <code>None</code> <p>Returns:</p> Type Description <code>OpenMLStudy</code> <p>A local OpenML study object (call publish method to upload to server)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def create_study(\n    name: str,\n    description: str,\n    run_ids: list[int] | None = None,\n    alias: str | None = None,\n    benchmark_suite: int | None = None,\n) -&gt; OpenMLStudy:\n    \"\"\"\n    Creates an OpenML study (collection of data, tasks, flows, setups and run),\n    where the runs are the main entity (collection consists of runs and all\n    entities (flows, tasks, etc) that are related to these runs)\n\n    Parameters\n    ----------\n    benchmark_suite : int (optional)\n        the benchmark suite (another study) upon which this study is ran.\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    run_ids : list, optional\n        a list of run ids associated with this study,\n        these can also be added later with ``attach_to_study``.\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    benchmark_suite: int (optional)\n        the ID of the suite for which this study contains run results\n\n    Returns\n    -------\n    OpenMLStudy\n        A local OpenML study object (call publish method to upload to server)\n    \"\"\"\n    return OpenMLStudy(\n        study_id=None,\n        alias=alias,\n        benchmark_suite=benchmark_suite,\n        name=name,\n        description=description,\n        status=None,\n        creation_date=None,\n        creator=None,\n        tags=None,\n        data=None,\n        tasks=None,\n        flows=None,\n        runs=run_ids if run_ids != [] else None,\n        setups=None,\n    )\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.delete_study","title":"<code>delete_study(study_id)</code>","text":"<p>Deletes a study from the OpenML server.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>OpenML id of the study</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True iff the deletion was successful. False otherwise</p> Source code in <code>openml/study/functions.py</code> <pre><code>def delete_study(study_id: int) -&gt; bool:\n    \"\"\"Deletes a study from the OpenML server.\n\n    Parameters\n    ----------\n    study_id : int\n        OpenML id of the study\n\n    Returns\n    -------\n    bool\n        True iff the deletion was successful. False otherwise\n    \"\"\"\n    return openml.utils._delete_entity(\"study\", study_id)\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.delete_suite","title":"<code>delete_suite(suite_id)</code>","text":"<p>Deletes a study from the OpenML server.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>OpenML id of the study</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True iff the deletion was successful. False otherwise</p> Source code in <code>openml/study/functions.py</code> <pre><code>def delete_suite(suite_id: int) -&gt; bool:\n    \"\"\"Deletes a study from the OpenML server.\n\n    Parameters\n    ----------\n    suite_id : int\n        OpenML id of the study\n\n    Returns\n    -------\n    bool\n        True iff the deletion was successful. False otherwise\n    \"\"\"\n    return delete_study(suite_id)\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.detach_from_study","title":"<code>detach_from_study(study_id, run_ids)</code>","text":"<p>Detaches a set of run ids from a study.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>run_ids</code> <code>list(int)</code> <p>List of entities to unlink from the collection</p> required <p>Returns:</p> Type Description <code>int</code> <p>new size of the study (in terms of explicitly linked entities)</p> Source code in <code>openml/study/functions.py</code> <pre><code>def detach_from_study(study_id: int, run_ids: list[int]) -&gt; int:\n    \"\"\"Detaches a set of run ids from a study.\n\n    Parameters\n    ----------\n    study_id : int\n        OpenML id of the study\n\n    run_ids : list (int)\n        List of entities to unlink from the collection\n\n    Returns\n    -------\n    int\n        new size of the study (in terms of explicitly linked entities)\n    \"\"\"\n    # Interestingly, there's no need to tell the server about the entity type, it knows by itself\n    uri = \"study/%d/detach\" % study_id\n    post_variables = {\"ids\": \",\".join(str(x) for x in run_ids)}  # type: openml._api_calls.DATA_TYPE\n    result_xml = openml._api_calls._perform_api_call(\n        call=uri,\n        request_method=\"post\",\n        data=post_variables,\n    )\n    result = xmltodict.parse(result_xml)[\"oml:study_detach\"]\n    return int(result[\"oml:linked_entities\"])\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.detach_from_suite","title":"<code>detach_from_suite(suite_id, task_ids)</code>","text":"<p>Detaches a set of task ids from a suite.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>OpenML id of the study</p> required <code>task_ids</code> <code>list(int)</code> <p>List of entities to unlink from the collection</p> required <p>Returns:</p> Type Description <code>int</code> <code>new size of the study (in terms of explicitly linked entities)</code> Source code in <code>openml/study/functions.py</code> <pre><code>def detach_from_suite(suite_id: int, task_ids: list[int]) -&gt; int:\n    \"\"\"Detaches a set of task ids from a suite.\n\n    Parameters\n    ----------\n    suite_id : int\n        OpenML id of the study\n\n    task_ids : list (int)\n        List of entities to unlink from the collection\n\n    Returns\n    -------\n    int\n    new size of the study (in terms of explicitly linked entities)\n    \"\"\"\n    return detach_from_study(suite_id, task_ids)\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.get_study","title":"<code>get_study(study_id, arg_for_backwards_compat=None)</code>","text":"<p>Retrieves all relevant information of an OpenML study from the server.</p> <p>Parameters:</p> Name Type Description Default <code>study</code> <p>study id (numeric or alias)</p> required <code>arg_for_backwards_compat</code> <code>str</code> <p>The example given in https://arxiv.org/pdf/1708.03731.pdf uses an older version of the API which required specifying the type of study, i.e. tasks. We changed the implementation of studies since then and split them up into suites (collections of tasks) and studies (collections of runs) so this argument is no longer needed.</p> <code>None</code> <p>Returns:</p> Type Description <code>OpenMLStudy</code> <p>The OpenML study object</p> Source code in <code>openml/study/functions.py</code> <pre><code>def get_study(\n    study_id: int | str,\n    arg_for_backwards_compat: str | None = None,  # noqa: ARG001\n) -&gt; OpenMLStudy:  # F401\n    \"\"\"\n    Retrieves all relevant information of an OpenML study from the server.\n\n    Parameters\n    ----------\n    study id : int, str\n        study id (numeric or alias)\n\n    arg_for_backwards_compat : str, optional\n        The example given in https://arxiv.org/pdf/1708.03731.pdf uses an older version of the\n        API which required specifying the type of study, i.e. tasks. We changed the\n        implementation of studies since then and split them up into suites (collections of tasks)\n        and studies (collections of runs) so this argument is no longer needed.\n\n    Returns\n    -------\n    OpenMLStudy\n        The OpenML study object\n    \"\"\"\n    if study_id == \"OpenML100\":\n        message = (\n            \"It looks like you are running code from the OpenML100 paper. It still works, but lots \"\n            \"of things have changed since then. Please use `get_suite('OpenML100')` instead.\"\n        )\n        warnings.warn(message, DeprecationWarning, stacklevel=2)\n        openml.config.logger.warning(message)\n        study = _get_study(study_id, entity_type=\"task\")\n        assert isinstance(study, OpenMLBenchmarkSuite)\n\n        return study  # type: ignore\n\n    study = _get_study(study_id, entity_type=\"run\")\n    assert isinstance(study, OpenMLStudy)\n    return study\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.get_suite","title":"<code>get_suite(suite_id)</code>","text":"<p>Retrieves all relevant information of an OpenML benchmarking suite from the server.</p> <p>Parameters:</p> Name Type Description Default <code>study</code> <p>study id (numeric or alias)</p> required <p>Returns:</p> Type Description <code>OpenMLSuite</code> <p>The OpenML suite object</p> Source code in <code>openml/study/functions.py</code> <pre><code>def get_suite(suite_id: int | str) -&gt; OpenMLBenchmarkSuite:\n    \"\"\"\n    Retrieves all relevant information of an OpenML benchmarking suite from the server.\n\n    Parameters\n    ----------\n    study id : int, str\n        study id (numeric or alias)\n\n    Returns\n    -------\n    OpenMLSuite\n        The OpenML suite object\n    \"\"\"\n    study = _get_study(suite_id, entity_type=\"task\")\n    assert isinstance(study, OpenMLBenchmarkSuite)\n\n    return study\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.list_studies","title":"<code>list_studies(offset=None, size=None, status=None, uploader=None, benchmark_suite=None)</code>","text":"<p>Return a list of all studies which are on OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The number of studies to skip, starting from the first.</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of studies to show.</p> <code>None</code> <code>status</code> <code>str</code> <p>Should be {active, in_preparation, deactivated, all}. By default active studies are returned.</p> <code>None</code> <code>uploader</code> <code>list(int)</code> <p>Result filter. Will only return studies created by these users.</p> <code>None</code> <code>benchmark_suite</code> <code>int</code> <code>None</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>dataframe</code> <p>Every dataset is represented by a dictionary containing the following information: - id - alias (optional) - name - benchmark_suite (optional) - status - creator - creation_date If qualities are calculated for the dataset, some of these are also returned.</p> Source code in <code>openml/study/functions.py</code> <pre><code>def list_studies(\n    offset: int | None = None,\n    size: int | None = None,\n    status: str | None = None,\n    uploader: list[str] | None = None,\n    benchmark_suite: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a list of all studies which are on OpenML.\n\n    Parameters\n    ----------\n    offset : int, optional\n        The number of studies to skip, starting from the first.\n    size : int, optional\n        The maximum number of studies to show.\n    status : str, optional\n        Should be {active, in_preparation, deactivated, all}. By default active\n        studies are returned.\n    uploader : list (int), optional\n        Result filter. Will only return studies created by these users.\n    benchmark_suite : int, optional\n\n    Returns\n    -------\n    datasets : dataframe\n        Every dataset is represented by a dictionary containing\n        the following information:\n        - id\n        - alias (optional)\n        - name\n        - benchmark_suite (optional)\n        - status\n        - creator\n        - creation_date\n        If qualities are calculated for the dataset, some of\n        these are also returned.\n    \"\"\"\n    listing_call = partial(\n        _list_studies,\n        main_entity_type=\"run\",\n        status=status,\n        uploader=uploader,\n        benchmark_suite=benchmark_suite,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.list_suites","title":"<code>list_suites(offset=None, size=None, status=None, uploader=None)</code>","text":"<p>Return a list of all suites which are on OpenML.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The number of suites to skip, starting from the first.</p> <code>None</code> <code>size</code> <code>int</code> <p>The maximum number of suites to show.</p> <code>None</code> <code>status</code> <code>str</code> <p>Should be {active, in_preparation, deactivated, all}. By default active suites are returned.</p> <code>None</code> <code>uploader</code> <code>list(int)</code> <p>Result filter. Will only return suites created by these users.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datasets</code> <code>dataframe</code> <p>Every row is represented by a dictionary containing the following information: - id - alias (optional) - name - main_entity_type - status - creator - creation_date</p> Source code in <code>openml/study/functions.py</code> <pre><code>def list_suites(\n    offset: int | None = None,\n    size: int | None = None,\n    status: str | None = None,\n    uploader: list[int] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a list of all suites which are on OpenML.\n\n    Parameters\n    ----------\n    offset : int, optional\n        The number of suites to skip, starting from the first.\n    size : int, optional\n        The maximum number of suites to show.\n    status : str, optional\n        Should be {active, in_preparation, deactivated, all}. By default active\n        suites are returned.\n    uploader : list (int), optional\n        Result filter. Will only return suites created by these users.\n\n    Returns\n    -------\n    datasets : dataframe\n        Every row is represented by a dictionary containing the following information:\n        - id\n        - alias (optional)\n        - name\n        - main_entity_type\n        - status\n        - creator\n        - creation_date\n    \"\"\"\n    listing_call = partial(\n        _list_studies,\n        main_entity_type=\"task\",\n        status=status,\n        uploader=uploader,\n    )\n    batches = openml.utils._list_all(listing_call, limit=size, offset=offset)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.update_study_status","title":"<code>update_study_status(study_id, status)</code>","text":"<p>Updates the status of a study to either 'active' or 'deactivated'.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>The data id of the dataset</p> required <code>status</code> <code>(str)</code> <p>'active' or 'deactivated'</p> required Source code in <code>openml/study/functions.py</code> <pre><code>def update_study_status(study_id: int, status: str) -&gt; None:\n    \"\"\"\n    Updates the status of a study to either 'active' or 'deactivated'.\n\n    Parameters\n    ----------\n    study_id : int\n        The data id of the dataset\n    status : str,\n        'active' or 'deactivated'\n    \"\"\"\n    legal_status = {\"active\", \"deactivated\"}\n    if status not in legal_status:\n        raise ValueError(f\"Illegal status value. Legal values: {legal_status}\")\n    data = {\"study_id\": study_id, \"status\": status}  # type: openml._api_calls.DATA_TYPE\n    result_xml = openml._api_calls._perform_api_call(\"study/status/update\", \"post\", data=data)\n    result = xmltodict.parse(result_xml)\n    server_study_id = result[\"oml:study_status_update\"][\"oml:id\"]\n    server_status = result[\"oml:study_status_update\"][\"oml:status\"]\n    if status != server_status or int(study_id) != int(server_study_id):\n        # This should never happen\n        raise ValueError(\"Study id/status does not collide\")\n</code></pre>"},{"location":"reference/study/functions/#openml.study.functions.update_suite_status","title":"<code>update_suite_status(suite_id, status)</code>","text":"<p>Updates the status of a study to either 'active' or 'deactivated'.</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>The data id of the dataset</p> required <code>status</code> <code>(str)</code> <p>'active' or 'deactivated'</p> required Source code in <code>openml/study/functions.py</code> <pre><code>def update_suite_status(suite_id: int, status: str) -&gt; None:\n    \"\"\"\n    Updates the status of a study to either 'active' or 'deactivated'.\n\n    Parameters\n    ----------\n    suite_id : int\n        The data id of the dataset\n    status : str,\n        'active' or 'deactivated'\n    \"\"\"\n    return update_study_status(suite_id, status)\n</code></pre>"},{"location":"reference/study/study/","title":"study","text":""},{"location":"reference/study/study/#openml.study.study.BaseStudy","title":"<code>BaseStudy</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>An OpenMLStudy represents the OpenML concept of a study. It contains the following information: name, id, description, creation date, creator id and a set of tags.</p> <p>According to this list of tags, the study object receives a list of OpenML object ids (datasets, flows, tasks and setups).</p> <p>Can be used to obtain all relevant information from a study at once.</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>main_entity_type</code> <code>str</code> <p>the entity type (e.g., task, run) that is core in this study. only entities of this type can be added explicitly</p> required <code>benchmark_suite</code> <code>int(optional)</code> <p>the benchmark suite (another study) upon which this study is ran. can only be active if main entity type is runs.</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required <code>flows</code> <code>list</code> <p>a list of flow ids associated with this study</p> required <code>runs</code> <code>list</code> <p>a list of run ids associated with this study</p> required <code>setups</code> <code>list</code> <p>a list of setup ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class BaseStudy(OpenMLBase):\n    \"\"\"\n    An OpenMLStudy represents the OpenML concept of a study. It contains\n    the following information: name, id, description, creation date,\n    creator id and a set of tags.\n\n    According to this list of tags, the study object receives a list of\n    OpenML object ids (datasets, flows, tasks and setups).\n\n    Can be used to obtain all relevant information from a study at once.\n\n    Parameters\n    ----------\n    study_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    main_entity_type : str\n        the entity type (e.g., task, run) that is core in this study.\n        only entities of this type can be added explicitly\n    benchmark_suite : int (optional)\n        the benchmark suite (another study) upon which this study is ran.\n        can only be active if main entity type is runs.\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    flows : list\n        a list of flow ids associated with this study\n    runs : list\n        a list of run ids associated with this study\n    setups : list\n        a list of setup ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        study_id: int | None,\n        alias: str | None,\n        main_entity_type: str,\n        benchmark_suite: int | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n        flows: list[int] | None,\n        runs: list[int] | None,\n        setups: list[int] | None,\n    ):\n        self.study_id = study_id\n        self.alias = alias\n        self.main_entity_type = main_entity_type\n        self.benchmark_suite = benchmark_suite\n        self.name = name\n        self.description = description\n        self.status = status\n        self.creation_date = creation_date\n        self.creator = creator\n        self.tags = tags  # LEGACY. Can be removed soon\n        self.data = data\n        self.tasks = tasks\n        self.flows = flows\n        self.setups = setups\n        self.runs = runs\n\n    @classmethod\n    def _entity_letter(cls) -&gt; str:\n        return \"s\"\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Return the id of the study.\"\"\"\n        return self.study_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        fields: dict[str, Any] = {\n            \"Name\": self.name,\n            \"Status\": self.status,\n            \"Main Entity Type\": self.main_entity_type,\n        }\n        if self.study_id is not None:\n            fields[\"ID\"] = self.study_id\n            fields[\"Study URL\"] = self.openml_url\n        if self.creator is not None:\n            fields[\"Creator\"] = f\"{get_server_base_url()}/u/{self.creator}\"\n        if self.creation_date is not None:\n            fields[\"Upload Time\"] = self.creation_date.replace(\"T\", \" \")\n        if self.data is not None:\n            fields[\"# of Data\"] = len(self.data)\n        if self.tasks is not None:\n            fields[\"# of Tasks\"] = len(self.tasks)\n        if self.flows is not None:\n            fields[\"# of Flows\"] = len(self.flows)\n        if self.runs is not None:\n            fields[\"# of Runs\"] = len(self.runs)\n\n        # determines the order in which the information will be printed\n        order = [\n            \"ID\",\n            \"Name\",\n            \"Status\",\n            \"Main Entity Type\",\n            \"Study URL\",\n            \"# of Data\",\n            \"# of Tasks\",\n            \"# of Flows\",\n            \"# of Runs\",\n            \"Creator\",\n            \"Upload Time\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.study_id = int(xml_response[\"oml:study_upload\"][\"oml:id\"])\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        \"\"\"Creates a dictionary representation of self.\"\"\"\n        # some can not be uploaded, e.g., id, creator, creation_date\n        simple_props = [\"alias\", \"main_entity_type\", \"name\", \"description\"]\n\n        # TODO(eddiebergman): Begging for a walrus if we can drop 3.7\n        simple_prop_values = {}\n        for prop_name in simple_props:\n            content = getattr(self, prop_name, None)\n            if content is not None:\n                simple_prop_values[\"oml:\" + prop_name] = content\n\n        # maps from attribute name (which is used as outer tag name) to immer\n        # tag name e.g., self.tasks -&gt; &lt;oml:tasks&gt;&lt;oml:task_id&gt;1987&lt;/oml:task_id&gt;&lt;/oml:tasks&gt;\n        complex_props = {\"tasks\": \"task_id\", \"runs\": \"run_id\"}\n\n        # TODO(eddiebergman): Begging for a walrus if we can drop 3.7\n        complex_prop_values = {}\n        for prop_name, inner_name in complex_props.items():\n            content = getattr(self, prop_name, None)\n            if content is not None:\n                complex_prop_values[\"oml:\" + prop_name] = {\"oml:\" + inner_name: content}\n\n        return {\n            \"oml:study\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                **simple_prop_values,\n                **complex_prop_values,\n            }\n        }\n\n    def push_tag(self, tag: str) -&gt; None:\n        \"\"\"Add a tag to the study.\"\"\"\n        raise NotImplementedError(\"Tags for studies is not (yet) supported.\")\n\n    def remove_tag(self, tag: str) -&gt; None:\n        \"\"\"Remove a tag from the study.\"\"\"\n        raise NotImplementedError(\"Tags for studies is not (yet) supported.\")\n</code></pre>"},{"location":"reference/study/study/#openml.study.study.BaseStudy.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Return the id of the study.</p>"},{"location":"reference/study/study/#openml.study.study.BaseStudy.push_tag","title":"<code>push_tag(tag)</code>","text":"<p>Add a tag to the study.</p> Source code in <code>openml/study/study.py</code> <pre><code>def push_tag(self, tag: str) -&gt; None:\n    \"\"\"Add a tag to the study.\"\"\"\n    raise NotImplementedError(\"Tags for studies is not (yet) supported.\")\n</code></pre>"},{"location":"reference/study/study/#openml.study.study.BaseStudy.remove_tag","title":"<code>remove_tag(tag)</code>","text":"<p>Remove a tag from the study.</p> Source code in <code>openml/study/study.py</code> <pre><code>def remove_tag(self, tag: str) -&gt; None:\n    \"\"\"Remove a tag from the study.\"\"\"\n    raise NotImplementedError(\"Tags for studies is not (yet) supported.\")\n</code></pre>"},{"location":"reference/study/study/#openml.study.study.OpenMLBenchmarkSuite","title":"<code>OpenMLBenchmarkSuite</code>","text":"<p>               Bases: <code>BaseStudy</code></p> <p>An OpenMLBenchmarkSuite represents the OpenML concept of a suite (a collection of tasks).</p> <p>It contains the following information: name, id, description, creation date, creator id and the task ids.</p> <p>According to this list of task ids, the suite object receives a list of OpenML object ids (datasets).</p> <p>Parameters:</p> Name Type Description Default <code>suite_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>main_entity_type</code> <code>str</code> <p>the entity type (e.g., task, run) that is core in this study. only entities of this type can be added explicitly</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class OpenMLBenchmarkSuite(BaseStudy):\n    \"\"\"\n    An OpenMLBenchmarkSuite represents the OpenML concept of a suite (a collection of tasks).\n\n    It contains the following information: name, id, description, creation date,\n    creator id and the task ids.\n\n    According to this list of task ids, the suite object receives a list of\n    OpenML object ids (datasets).\n\n    Parameters\n    ----------\n    suite_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    main_entity_type : str\n        the entity type (e.g., task, run) that is core in this study.\n        only entities of this type can be added explicitly\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        suite_id: int | None,\n        alias: str | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n    ):\n        super().__init__(\n            study_id=suite_id,\n            alias=alias,\n            main_entity_type=\"task\",\n            benchmark_suite=None,\n            name=name,\n            description=description,\n            status=status,\n            creation_date=creation_date,\n            creator=creator,\n            tags=tags,\n            data=data,\n            tasks=tasks,\n            flows=None,\n            runs=None,\n            setups=None,\n        )\n</code></pre>"},{"location":"reference/study/study/#openml.study.study.OpenMLStudy","title":"<code>OpenMLStudy</code>","text":"<p>               Bases: <code>BaseStudy</code></p> <p>An OpenMLStudy represents the OpenML concept of a study (a collection of runs).</p> <p>It contains the following information: name, id, description, creation date, creator id and a list of run ids.</p> <p>According to this list of run ids, the study object receives a list of OpenML object ids (datasets, flows, tasks and setups).</p> <p>Parameters:</p> Name Type Description Default <code>study_id</code> <code>int</code> <p>the study id</p> required <code>alias</code> <code>str(optional)</code> <p>a string ID, unique on server (url-friendly)</p> required <code>benchmark_suite</code> <code>int(optional)</code> <p>the benchmark suite (another study) upon which this study is ran. can only be active if main entity type is runs.</p> required <code>name</code> <code>str</code> <p>the name of the study (meta-info)</p> required <code>description</code> <code>str</code> <p>brief description (meta-info)</p> required <code>status</code> <code>str</code> <p>Whether the study is in preparation, active or deactivated</p> required <code>creation_date</code> <code>str</code> <p>date of creation (meta-info)</p> required <code>creator</code> <code>int</code> <p>openml user id of the owner / creator</p> required <code>tags</code> <code>list(dict)</code> <p>The list of tags shows which tags are associated with the study. Each tag is a dict of (tag) name, window_start and write_access.</p> required <code>data</code> <code>list</code> <p>a list of data ids associated with this study</p> required <code>tasks</code> <code>list</code> <p>a list of task ids associated with this study</p> required <code>flows</code> <code>list</code> <p>a list of flow ids associated with this study</p> required <code>runs</code> <code>list</code> <p>a list of run ids associated with this study</p> required <code>setups</code> <code>list</code> <p>a list of setup ids associated with this study</p> required Source code in <code>openml/study/study.py</code> <pre><code>class OpenMLStudy(BaseStudy):\n    \"\"\"\n    An OpenMLStudy represents the OpenML concept of a study (a collection of runs).\n\n    It contains the following information: name, id, description, creation date,\n    creator id and a list of run ids.\n\n    According to this list of run ids, the study object receives a list of\n    OpenML object ids (datasets, flows, tasks and setups).\n\n    Parameters\n    ----------\n    study_id : int\n        the study id\n    alias : str (optional)\n        a string ID, unique on server (url-friendly)\n    benchmark_suite : int (optional)\n        the benchmark suite (another study) upon which this study is ran.\n        can only be active if main entity type is runs.\n    name : str\n        the name of the study (meta-info)\n    description : str\n        brief description (meta-info)\n    status : str\n        Whether the study is in preparation, active or deactivated\n    creation_date : str\n        date of creation (meta-info)\n    creator : int\n        openml user id of the owner / creator\n    tags : list(dict)\n        The list of tags shows which tags are associated with the study.\n        Each tag is a dict of (tag) name, window_start and write_access.\n    data : list\n        a list of data ids associated with this study\n    tasks : list\n        a list of task ids associated with this study\n    flows : list\n        a list of flow ids associated with this study\n    runs : list\n        a list of run ids associated with this study\n    setups : list\n        a list of setup ids associated with this study\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        study_id: int | None,\n        alias: str | None,\n        benchmark_suite: int | None,\n        name: str,\n        description: str,\n        status: str | None,\n        creation_date: str | None,\n        creator: int | None,\n        tags: list[dict] | None,\n        data: list[int] | None,\n        tasks: list[int] | None,\n        flows: list[int] | None,\n        runs: list[int] | None,\n        setups: list[int] | None,\n    ):\n        super().__init__(\n            study_id=study_id,\n            alias=alias,\n            main_entity_type=\"run\",\n            benchmark_suite=benchmark_suite,\n            name=name,\n            description=description,\n            status=status,\n            creation_date=creation_date,\n            creator=creator,\n            tags=tags,\n            data=data,\n            tasks=tasks,\n            flows=flows,\n            runs=runs,\n            setups=setups,\n        )\n</code></pre>"},{"location":"reference/tasks/","title":"tasks","text":""},{"location":"reference/tasks/#openml.tasks.OpenMLClassificationTask","title":"<code>OpenMLClassificationTask</code>","text":"<p>               Bases: <code>OpenMLSupervisedTask</code></p> <p>OpenML Classification object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the Classification task type.</p> required <code>task_type</code> <code>str</code> <p>Name of the Classification task type.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset associated with the Classification task.</p> required <code>target_name</code> <code>str</code> <p>Name of the target variable.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure for the Classification task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Estimation parameters for the Classification task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the data splits for the Classification task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the Classification task (if it already exists on OpenML).</p> <code>None</code> <code>class_labels</code> <code>List of str</code> <p>A list of class labels (for classification tasks).</p> <code>None</code> <code>cost_matrix</code> <code>array</code> <p>A cost matrix (for classification tasks).</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLClassificationTask(OpenMLSupervisedTask):\n    \"\"\"OpenML Classification object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the Classification task type.\n    task_type : str\n        Name of the Classification task type.\n    data_set_id : int\n        ID of the OpenML dataset associated with the Classification task.\n    target_name : str\n        Name of the target variable.\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure for the Classification task.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure.\n    estimation_parameters : dict, default=None\n        Estimation parameters for the Classification task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure.\n    data_splits_url : str, default=None\n        URL of the data splits for the Classification task.\n    task_id : Union[int, None]\n        ID of the Classification task (if it already exists on OpenML).\n    class_labels : List of str, default=None\n        A list of class labels (for classification tasks).\n    cost_matrix : array, default=None\n        A cost matrix (for classification tasks).\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        class_labels: list[str] | None = None,\n        cost_matrix: np.ndarray | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n        )\n        self.class_labels = class_labels\n        self.cost_matrix = cost_matrix\n\n        if cost_matrix is not None:\n            raise NotImplementedError(\"Costmatrix\")\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLClusteringTask","title":"<code>OpenMLClusteringTask</code>","text":"<p>               Bases: <code>OpenMLTask</code></p> <p>OpenML Clustering object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>Task type ID of the OpenML clustering task.</p> required <code>task_type</code> <code>str</code> <p>Task type of the OpenML clustering task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset used in clustering the task.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the OpenML estimation procedure.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the OpenML clustering task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the OpenML estimation procedure used in the clustering task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Parameters used by the OpenML estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the OpenML data splits for the clustering task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Evaluation measure used in the clustering task.</p> <code>None</code> <code>target_name</code> <code>str</code> <p>Name of the target feature (class) that is not part of the feature set for the clustering task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLClusteringTask(OpenMLTask):\n    \"\"\"OpenML Clustering object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        Task type ID of the OpenML clustering task.\n    task_type : str\n        Task type of the OpenML clustering task.\n    data_set_id : int\n        ID of the OpenML dataset used in clustering the task.\n    estimation_procedure_id : int, default=None\n        ID of the OpenML estimation procedure.\n    task_id : Union[int, None]\n        ID of the OpenML clustering task.\n    estimation_procedure_type : str, default=None\n        Type of the OpenML estimation procedure used in the clustering task.\n    estimation_parameters : dict, default=None\n        Parameters used by the OpenML estimation procedure.\n    data_splits_url : str, default=None\n        URL of the OpenML data splits for the clustering task.\n    evaluation_measure : str, default=None\n        Evaluation measure used in the clustering task.\n    target_name : str, default=None\n        Name of the target feature (class) that is not part of the\n        feature set for the clustering task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        estimation_procedure_id: int = 17,\n        task_id: int | None = None,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        evaluation_measure: str | None = None,\n        target_name: str | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            evaluation_measure=evaluation_measure,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            data_splits_url=data_splits_url,\n        )\n\n        self.target_name = target_name\n\n    def get_X(self) -&gt; pd.DataFrame:\n        \"\"\"Get data associated with the current task.\n\n        Returns\n        -------\n        The X data as a dataframe\n        \"\"\"\n        dataset = self.get_dataset()\n        data, *_ = dataset.get_data(target=None)\n        return data\n\n    def _to_dict(self) -&gt; dict[str, dict[str, int | str | list[dict[str, Any]]]]:\n        # Right now, it is not supported as a feature.\n        # Uncomment if it is supported on the server\n        # in the future.\n        # https://github.com/openml/OpenML/issues/925\n        \"\"\"\n        task_dict = task_container['oml:task_inputs']\n        if self.target_name is not None:\n            task_dict['oml:input'].append(\n                OrderedDict([\n                    ('@name', 'target_feature'),\n                    ('#text', self.target_name)\n                ])\n            )\n        \"\"\"\n        return super()._to_dict()\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLClusteringTask.get_X","title":"<code>get_X()</code>","text":"<p>Get data associated with the current task.</p> <p>Returns:</p> Type Description <code>The X data as a dataframe</code> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_X(self) -&gt; pd.DataFrame:\n    \"\"\"Get data associated with the current task.\n\n    Returns\n    -------\n    The X data as a dataframe\n    \"\"\"\n    dataset = self.get_dataset()\n    data, *_ = dataset.get_data(target=None)\n    return data\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLLearningCurveTask","title":"<code>OpenMLLearningCurveTask</code>","text":"<p>               Bases: <code>OpenMLClassificationTask</code></p> <p>OpenML Learning Curve object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the Learning Curve task.</p> required <code>task_type</code> <code>str</code> <p>Name of the Learning Curve task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the dataset that this task is associated with.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature in the dataset.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure to use for evaluating models.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Additional parameters for the estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the file containing the data splits for Learning Curve task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the Learning Curve task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure to use for evaluating models.</p> <code>None</code> <code>class_labels</code> <code>list of str</code> <p>Class labels for Learning Curve tasks.</p> <code>None</code> <code>cost_matrix</code> <code>numpy array</code> <p>Cost matrix for Learning Curve tasks.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLLearningCurveTask(OpenMLClassificationTask):\n    \"\"\"OpenML Learning Curve object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the Learning Curve task.\n    task_type : str\n        Name of the Learning Curve task.\n    data_set_id : int\n        ID of the dataset that this task is associated with.\n    target_name : str\n        Name of the target feature in the dataset.\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure to use for evaluating models.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure.\n    estimation_parameters : dict, default=None\n        Additional parameters for the estimation procedure.\n    data_splits_url : str, default=None\n        URL of the file containing the data splits for Learning Curve task.\n    task_id : Union[int, None]\n        ID of the Learning Curve task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure to use for evaluating models.\n    class_labels : list of str, default=None\n        Class labels for Learning Curve tasks.\n    cost_matrix : numpy array, default=None\n        Cost matrix for Learning Curve tasks.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 13,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        evaluation_measure: str | None = None,\n        class_labels: list[str] | None = None,\n        cost_matrix: np.ndarray | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n            class_labels=class_labels,\n            cost_matrix=cost_matrix,\n        )\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLRegressionTask","title":"<code>OpenMLRegressionTask</code>","text":"<p>               Bases: <code>OpenMLSupervisedTask</code></p> <p>OpenML Regression object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>Task type ID of the OpenML Regression task.</p> required <code>task_type</code> <code>str</code> <p>Task type of the OpenML Regression task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature used in the Regression task.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the OpenML estimation procedure.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the OpenML estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Parameters used by the OpenML estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the OpenML data splits for the Regression task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the OpenML Regression task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Evaluation measure used in the Regression task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLRegressionTask(OpenMLSupervisedTask):\n    \"\"\"OpenML Regression object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        Task type ID of the OpenML Regression task.\n    task_type : str\n        Task type of the OpenML Regression task.\n    data_set_id : int\n        ID of the OpenML dataset.\n    target_name : str\n        Name of the target feature used in the Regression task.\n    estimation_procedure_id : int, default=None\n        ID of the OpenML estimation procedure.\n    estimation_procedure_type : str, default=None\n        Type of the OpenML estimation procedure.\n    estimation_parameters : dict, default=None\n        Parameters used by the OpenML estimation procedure.\n    data_splits_url : str, default=None\n        URL of the OpenML data splits for the Regression task.\n    task_id : Union[int, None]\n        ID of the OpenML Regression task.\n    evaluation_measure : str, default=None\n        Evaluation measure used in the Regression task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 7,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        evaluation_measure: str | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n        )\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLSplit","title":"<code>OpenMLSplit</code>","text":"<p>OpenML Split object.</p> <p>This class manages train-test splits for a dataset across multiple repetitions, folds, and samples.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>int or str</code> <p>The name or ID of the split.</p> required <code>description</code> <code>str</code> <p>A description of the split.</p> required <code>split</code> <code>dict</code> <p>A dictionary containing the splits organized by repetition, fold, and sample.</p> required Source code in <code>openml/tasks/split.py</code> <pre><code>class OpenMLSplit:\n    \"\"\"OpenML Split object.\n\n    This class manages train-test splits for a dataset across multiple\n    repetitions, folds, and samples.\n\n    Parameters\n    ----------\n    name : int or str\n        The name or ID of the split.\n    description : str\n        A description of the split.\n    split : dict\n        A dictionary containing the splits organized by repetition, fold,\n        and sample.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: int | str,\n        description: str,\n        split: dict[int, dict[int, dict[int, tuple[np.ndarray, np.ndarray]]]],\n    ):\n        self.description = description\n        self.name = name\n        self.split: dict[int, dict[int, dict[int, tuple[np.ndarray, np.ndarray]]]] = {}\n\n        # Add splits according to repetition\n        for repetition in split:\n            _rep = int(repetition)\n            self.split[_rep] = OrderedDict()\n            for fold in split[_rep]:\n                self.split[_rep][fold] = OrderedDict()\n                for sample in split[_rep][fold]:\n                    self.split[_rep][fold][sample] = split[_rep][fold][sample]\n\n        self.repeats = len(self.split)\n\n        # TODO(eddiebergman): Better error message\n        if any(len(self.split[0]) != len(self.split[i]) for i in range(self.repeats)):\n            raise ValueError(\"\")\n\n        self.folds = len(self.split[0])\n        self.samples = len(self.split[0][0])\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if (\n            (not isinstance(self, type(other)))\n            or self.name != other.name\n            or self.description != other.description\n            or self.split.keys() != other.split.keys()\n            or any(\n                self.split[repetition].keys() != other.split[repetition].keys()\n                for repetition in self.split\n            )\n        ):\n            return False\n\n        samples = [\n            (repetition, fold, sample)\n            for repetition in self.split\n            for fold in self.split[repetition]\n            for sample in self.split[repetition][fold]\n        ]\n\n        for repetition, fold, sample in samples:\n            self_train, self_test = self.split[repetition][fold][sample]\n            other_train, other_test = other.split[repetition][fold][sample]\n            if not (np.all(self_train == other_train) and np.all(self_test == other_test)):\n                return False\n        return True\n\n    @classmethod\n    def _from_arff_file(cls, filename: Path) -&gt; OpenMLSplit:  # noqa: C901, PLR0912\n        repetitions = None\n        name = None\n\n        pkl_filename = filename.with_suffix(\".pkl.py3\")\n\n        if pkl_filename.exists():\n            with pkl_filename.open(\"rb\") as fh:\n                # TODO(eddiebergman): Would be good to figure out what _split is and assert it is\n                _split = pickle.load(fh)  # noqa: S301\n            repetitions = _split[\"repetitions\"]\n            name = _split[\"name\"]\n\n        # Cache miss\n        if repetitions is None:\n            # Faster than liac-arff and sufficient in this situation!\n            if not filename.exists():\n                raise FileNotFoundError(f\"Split arff {filename} does not exist!\")\n\n            file_data = arff.load(filename.open(\"r\"), return_type=arff.DENSE_GEN)\n            splits = file_data[\"data\"]\n            name = file_data[\"relation\"]\n            attrnames = [attr[0] for attr in file_data[\"attributes\"]]\n\n            repetitions = OrderedDict()\n\n            type_idx = attrnames.index(\"type\")\n            rowid_idx = attrnames.index(\"rowid\")\n            repeat_idx = attrnames.index(\"repeat\")\n            fold_idx = attrnames.index(\"fold\")\n            sample_idx = attrnames.index(\"sample\") if \"sample\" in attrnames else None\n\n            for line in splits:\n                # A line looks like type, rowid, repeat, fold\n                repetition = int(line[repeat_idx])\n                fold = int(line[fold_idx])\n                sample = 0\n                if sample_idx is not None:\n                    sample = int(line[sample_idx])\n\n                if repetition not in repetitions:\n                    repetitions[repetition] = OrderedDict()\n                if fold not in repetitions[repetition]:\n                    repetitions[repetition][fold] = OrderedDict()\n                if sample not in repetitions[repetition][fold]:\n                    repetitions[repetition][fold][sample] = ([], [])\n                split = repetitions[repetition][fold][sample]\n\n                type_ = line[type_idx]\n                if type_ == \"TRAIN\":\n                    split[0].append(line[rowid_idx])\n                elif type_ == \"TEST\":\n                    split[1].append(line[rowid_idx])\n                else:\n                    raise ValueError(type_)\n\n            for repetition in repetitions:\n                for fold in repetitions[repetition]:\n                    for sample in repetitions[repetition][fold]:\n                        repetitions[repetition][fold][sample] = Split(\n                            np.array(repetitions[repetition][fold][sample][0], dtype=np.int32),\n                            np.array(repetitions[repetition][fold][sample][1], dtype=np.int32),\n                        )\n\n            with pkl_filename.open(\"wb\") as fh:\n                pickle.dump({\"name\": name, \"repetitions\": repetitions}, fh, protocol=2)\n\n        assert name is not None\n        return cls(name, \"\", repetitions)\n\n    def get(self, repeat: int = 0, fold: int = 0, sample: int = 0) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Returns the specified data split from the CrossValidationSplit object.\n\n        Parameters\n        ----------\n        repeat : int\n            Index of the repeat to retrieve.\n        fold : int\n            Index of the fold to retrieve.\n        sample : int\n            Index of the sample to retrieve.\n\n        Returns\n        -------\n        numpy.ndarray\n            The data split for the specified repeat, fold, and sample.\n\n        Raises\n        ------\n        ValueError\n            If the specified repeat, fold, or sample is not known.\n        \"\"\"\n        if repeat not in self.split:\n            raise ValueError(f\"Repeat {repeat!s} not known\")\n        if fold not in self.split[repeat]:\n            raise ValueError(f\"Fold {fold!s} not known\")\n        if sample not in self.split[repeat][fold]:\n            raise ValueError(f\"Sample {sample!s} not known\")\n        return self.split[repeat][fold][sample]\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLSplit.get","title":"<code>get(repeat=0, fold=0, sample=0)</code>","text":"<p>Returns the specified data split from the CrossValidationSplit object.</p> <p>Parameters:</p> Name Type Description Default <code>repeat</code> <code>int</code> <p>Index of the repeat to retrieve.</p> <code>0</code> <code>fold</code> <code>int</code> <p>Index of the fold to retrieve.</p> <code>0</code> <code>sample</code> <code>int</code> <p>Index of the sample to retrieve.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data split for the specified repeat, fold, and sample.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified repeat, fold, or sample is not known.</p> Source code in <code>openml/tasks/split.py</code> <pre><code>def get(self, repeat: int = 0, fold: int = 0, sample: int = 0) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Returns the specified data split from the CrossValidationSplit object.\n\n    Parameters\n    ----------\n    repeat : int\n        Index of the repeat to retrieve.\n    fold : int\n        Index of the fold to retrieve.\n    sample : int\n        Index of the sample to retrieve.\n\n    Returns\n    -------\n    numpy.ndarray\n        The data split for the specified repeat, fold, and sample.\n\n    Raises\n    ------\n    ValueError\n        If the specified repeat, fold, or sample is not known.\n    \"\"\"\n    if repeat not in self.split:\n        raise ValueError(f\"Repeat {repeat!s} not known\")\n    if fold not in self.split[repeat]:\n        raise ValueError(f\"Fold {fold!s} not known\")\n    if sample not in self.split[repeat][fold]:\n        raise ValueError(f\"Sample {sample!s} not known\")\n    return self.split[repeat][fold][sample]\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLSupervisedTask","title":"<code>OpenMLSupervisedTask</code>","text":"<p>               Bases: <code>OpenMLTask</code>, <code>ABC</code></p> <p>OpenML Supervised Classification object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the task type.</p> required <code>task_type</code> <code>str</code> <p>Name of the task type.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset associated with the task.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature (the class variable).</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure for the task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure for the task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Estimation parameters for the task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure for the task.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the data splits for the task.</p> <code>None</code> <code>task_id</code> <code>int | None</code> <p>Refers to the unique identifier of task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLSupervisedTask(OpenMLTask, ABC):\n    \"\"\"OpenML Supervised Classification object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the task type.\n    task_type : str\n        Name of the task type.\n    data_set_id : int\n        ID of the OpenML dataset associated with the task.\n    target_name : str\n        Name of the target feature (the class variable).\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure for the task.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure for the task.\n    estimation_parameters : dict, default=None\n        Estimation parameters for the task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure for the task.\n    data_splits_url : str, default=None\n        URL of the data splits for the task.\n    task_id: Union[int, None]\n        Refers to the unique identifier of task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            data_splits_url=data_splits_url,\n        )\n\n        self.target_name = target_name\n\n    def get_X_and_y(self) -&gt; tuple[pd.DataFrame, pd.Series | pd.DataFrame | None]:\n        \"\"\"Get data associated with the current task.\n\n        Returns\n        -------\n        tuple - X and y\n\n        \"\"\"\n        dataset = self.get_dataset()\n        if self.task_type_id not in (\n            TaskType.SUPERVISED_CLASSIFICATION,\n            TaskType.SUPERVISED_REGRESSION,\n            TaskType.LEARNING_CURVE,\n        ):\n            raise NotImplementedError(self.task_type)\n\n        X, y, _, _ = dataset.get_data(target=self.target_name)\n        return X, y\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        task_container = super()._to_dict()\n        oml_input = task_container[\"oml:task_inputs\"][\"oml:input\"]  # type: ignore\n        assert isinstance(oml_input, list)\n\n        oml_input.append({\"@name\": \"target_feature\", \"#text\": self.target_name})\n        return task_container\n\n    @property\n    def estimation_parameters(self) -&gt; dict[str, str] | None:\n        \"\"\"Return the estimation parameters for the task.\"\"\"\n        warnings.warn(\n            \"The estimation_parameters attribute will be \"\n            \"deprecated in the future, please use \"\n            \"estimation_procedure['parameters'] instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.estimation_procedure[\"parameters\"]\n\n    @estimation_parameters.setter\n    def estimation_parameters(self, est_parameters: dict[str, str] | None) -&gt; None:\n        self.estimation_procedure[\"parameters\"] = est_parameters\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLSupervisedTask.estimation_parameters","title":"<code>estimation_parameters: dict[str, str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the estimation parameters for the task.</p>"},{"location":"reference/tasks/#openml.tasks.OpenMLSupervisedTask.get_X_and_y","title":"<code>get_X_and_y()</code>","text":"<p>Get data associated with the current task.</p> <p>Returns:</p> Type Description <code>tuple - X and y</code> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_X_and_y(self) -&gt; tuple[pd.DataFrame, pd.Series | pd.DataFrame | None]:\n    \"\"\"Get data associated with the current task.\n\n    Returns\n    -------\n    tuple - X and y\n\n    \"\"\"\n    dataset = self.get_dataset()\n    if self.task_type_id not in (\n        TaskType.SUPERVISED_CLASSIFICATION,\n        TaskType.SUPERVISED_REGRESSION,\n        TaskType.LEARNING_CURVE,\n    ):\n        raise NotImplementedError(self.task_type)\n\n    X, y, _, _ = dataset.get_data(target=self.target_name)\n    return X, y\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLTask","title":"<code>OpenMLTask</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Task object.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int | None</code> <p>Refers to the unique identifier of OpenML task.</p> required <code>task_type_id</code> <code>TaskType</code> <p>Refers to the type of OpenML task.</p> required <code>task_type</code> <code>str</code> <p>Refers to the OpenML task.</p> required <code>data_set_id</code> <code>int</code> <p>Refers to the data.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>Refers to the type of estimates used.</p> <code>1</code> <code>estimation_procedure_type</code> <code>str | None</code> <p>Refers to the type of estimation procedure used for the OpenML task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict[str, str] | None</code> <p>Estimation parameters used for the OpenML task.</p> <code>None</code> <code>evaluation_measure</code> <code>str | None</code> <p>Refers to the evaluation measure.</p> <code>None</code> <code>data_splits_url</code> <code>str | None</code> <p>Refers to the URL of the data splits used for the OpenML task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLTask(OpenMLBase):\n    \"\"\"OpenML Task object.\n\n    Parameters\n    ----------\n    task_id: Union[int, None]\n        Refers to the unique identifier of OpenML task.\n    task_type_id: TaskType\n        Refers to the type of OpenML task.\n    task_type: str\n        Refers to the OpenML task.\n    data_set_id: int\n        Refers to the data.\n    estimation_procedure_id: int\n        Refers to the type of estimates used.\n    estimation_procedure_type: str, default=None\n        Refers to the type of estimation procedure used for the OpenML task.\n    estimation_parameters: [Dict[str, str]], default=None\n        Estimation parameters used for the OpenML task.\n    evaluation_measure: str, default=None\n        Refers to the evaluation measure.\n    data_splits_url: str, default=None\n        Refers to the URL of the data splits used for the OpenML task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_id: int | None,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n    ):\n        self.task_id = int(task_id) if task_id is not None else None\n        self.task_type_id = task_type_id\n        self.task_type = task_type\n        self.dataset_id = int(data_set_id)\n        self.evaluation_measure = evaluation_measure\n        self.estimation_procedure: _EstimationProcedure = {\n            \"type\": estimation_procedure_type,\n            \"parameters\": estimation_parameters,\n            \"data_splits_url\": data_splits_url,\n        }\n        self.estimation_procedure_id = estimation_procedure_id\n        self.split: OpenMLSplit | None = None\n\n    @classmethod\n    def _entity_letter(cls) -&gt; str:\n        return \"t\"\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Return the OpenML ID of this task.\"\"\"\n        return self.task_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        base_server_url = openml.config.get_server_base_url()\n        fields: dict[str, Any] = {\n            \"Task Type Description\": f\"{base_server_url}/tt/{self.task_type_id}\"\n        }\n        if self.task_id is not None:\n            fields[\"Task ID\"] = self.task_id\n            fields[\"Task URL\"] = self.openml_url\n        if self.evaluation_measure is not None:\n            fields[\"Evaluation Measure\"] = self.evaluation_measure\n        if self.estimation_procedure is not None:\n            fields[\"Estimation Procedure\"] = self.estimation_procedure[\"type\"]\n\n        # TODO(eddiebergman): Subclasses could advertise/provide this, instead of having to\n        # have the base class know about it's subclasses.\n        target_name = getattr(self, \"target_name\", None)\n        if target_name is not None:\n            fields[\"Target Feature\"] = target_name\n\n            class_labels = getattr(self, \"class_labels\", None)\n            if class_labels is not None:\n                fields[\"# of Classes\"] = len(class_labels)\n\n            if hasattr(self, \"cost_matrix\"):\n                fields[\"Cost Matrix\"] = \"Available\"\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Task Type Description\",\n            \"Task ID\",\n            \"Task URL\",\n            \"Estimation Procedure\",\n            \"Evaluation Measure\",\n            \"Target Feature\",\n            \"# of Classes\",\n            \"Cost Matrix\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def get_dataset(self, **kwargs: Any) -&gt; datasets.OpenMLDataset:\n        \"\"\"Download dataset associated with task.\n\n        Accepts the same keyword arguments as the `openml.datasets.get_dataset`.\n        \"\"\"\n        return datasets.get_dataset(self.dataset_id, **kwargs)\n\n    def get_train_test_split_indices(\n        self,\n        fold: int = 0,\n        repeat: int = 0,\n        sample: int = 0,\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Get the indices of the train and test splits for a given task.\"\"\"\n        # Replace with retrieve from cache\n        if self.split is None:\n            self.split = self.download_split()\n\n        return self.split.get(repeat=repeat, fold=fold, sample=sample)\n\n    def _download_split(self, cache_file: Path) -&gt; None:\n        # TODO(eddiebergman): Not sure about this try to read and error approach\n        try:\n            with cache_file.open(encoding=\"utf8\"):\n                pass\n        except OSError:\n            split_url = self.estimation_procedure[\"data_splits_url\"]\n            openml._api_calls._download_text_file(\n                source=str(split_url),\n                output_path=str(cache_file),\n            )\n\n    def download_split(self) -&gt; OpenMLSplit:\n        \"\"\"Download the OpenML split for a given task.\"\"\"\n        # TODO(eddiebergman): Can this every be `None`?\n        assert self.task_id is not None\n        cache_dir = _create_cache_directory_for_id(\"tasks\", self.task_id)\n        cached_split_file = cache_dir / \"datasplits.arff\"\n\n        try:\n            split = OpenMLSplit._from_arff_file(cached_split_file)\n        except OSError:\n            # Next, download and cache the associated split file\n            self._download_split(cached_split_file)\n            split = OpenMLSplit._from_arff_file(cached_split_file)\n\n        return split\n\n    def get_split_dimensions(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get the (repeats, folds, samples) of the split for a given task.\"\"\"\n        if self.split is None:\n            self.split = self.download_split()\n\n        return self.split.repeats, self.split.folds, self.split.samples\n\n    # TODO(eddiebergman): Really need some better typing on all this\n    def _to_dict(self) -&gt; dict[str, dict[str, int | str | list[dict[str, Any]]]]:\n        \"\"\"Creates a dictionary representation of self in a string format (for XML parsing).\"\"\"\n        oml_input = [\n            {\"@name\": \"source_data\", \"#text\": str(self.dataset_id)},\n            {\"@name\": \"estimation_procedure\", \"#text\": str(self.estimation_procedure_id)},\n        ]\n        if self.evaluation_measure is not None:\n            oml_input.append({\"@name\": \"evaluation_measures\", \"#text\": self.evaluation_measure})\n\n        return {\n            \"oml:task_inputs\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                \"oml:task_type_id\": self.task_type_id.value,  # This is an int from the enum?\n                \"oml:input\": oml_input,\n            }\n        }\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.task_id = int(xml_response[\"oml:upload_task\"][\"oml:id\"])\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLTask.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Return the OpenML ID of this task.</p>"},{"location":"reference/tasks/#openml.tasks.OpenMLTask.download_split","title":"<code>download_split()</code>","text":"<p>Download the OpenML split for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def download_split(self) -&gt; OpenMLSplit:\n    \"\"\"Download the OpenML split for a given task.\"\"\"\n    # TODO(eddiebergman): Can this every be `None`?\n    assert self.task_id is not None\n    cache_dir = _create_cache_directory_for_id(\"tasks\", self.task_id)\n    cached_split_file = cache_dir / \"datasplits.arff\"\n\n    try:\n        split = OpenMLSplit._from_arff_file(cached_split_file)\n    except OSError:\n        # Next, download and cache the associated split file\n        self._download_split(cached_split_file)\n        split = OpenMLSplit._from_arff_file(cached_split_file)\n\n    return split\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLTask.get_dataset","title":"<code>get_dataset(**kwargs)</code>","text":"<p>Download dataset associated with task.</p> <p>Accepts the same keyword arguments as the <code>openml.datasets.get_dataset</code>.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_dataset(self, **kwargs: Any) -&gt; datasets.OpenMLDataset:\n    \"\"\"Download dataset associated with task.\n\n    Accepts the same keyword arguments as the `openml.datasets.get_dataset`.\n    \"\"\"\n    return datasets.get_dataset(self.dataset_id, **kwargs)\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLTask.get_split_dimensions","title":"<code>get_split_dimensions()</code>","text":"<p>Get the (repeats, folds, samples) of the split for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_split_dimensions(self) -&gt; tuple[int, int, int]:\n    \"\"\"Get the (repeats, folds, samples) of the split for a given task.\"\"\"\n    if self.split is None:\n        self.split = self.download_split()\n\n    return self.split.repeats, self.split.folds, self.split.samples\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.OpenMLTask.get_train_test_split_indices","title":"<code>get_train_test_split_indices(fold=0, repeat=0, sample=0)</code>","text":"<p>Get the indices of the train and test splits for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_train_test_split_indices(\n    self,\n    fold: int = 0,\n    repeat: int = 0,\n    sample: int = 0,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Get the indices of the train and test splits for a given task.\"\"\"\n    # Replace with retrieve from cache\n    if self.split is None:\n        self.split = self.download_split()\n\n    return self.split.get(repeat=repeat, fold=fold, sample=sample)\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.TaskType","title":"<code>TaskType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Possible task types as defined in OpenML.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>class TaskType(Enum):\n    \"\"\"Possible task types as defined in OpenML.\"\"\"\n\n    SUPERVISED_CLASSIFICATION = 1\n    SUPERVISED_REGRESSION = 2\n    LEARNING_CURVE = 3\n    SUPERVISED_DATASTREAM_CLASSIFICATION = 4\n    CLUSTERING = 5\n    MACHINE_LEARNING_CHALLENGE = 6\n    SURVIVAL_ANALYSIS = 7\n    SUBGROUP_DISCOVERY = 8\n    MULTITASK_REGRESSION = 9\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.create_task","title":"<code>create_task(task_type, dataset_id, estimation_procedure_id, target_name=None, evaluation_measure=None, **kwargs)</code>","text":"<p>Create a task based on different given attributes.</p> <p>Builds a task object with the function arguments as attributes. The type of the task object built is determined from the task type id. More information on how the arguments (task attributes), relate to the different possible tasks can be found in the individual task objects at the openml.tasks.task module.</p> <p>Parameters:</p> Name Type Description Default <code>task_type</code> <code>TaskType</code> <p>Id of the task type.</p> required <code>dataset_id</code> <code>int</code> <p>The id of the dataset for the task.</p> required <code>target_name</code> <code>str</code> <p>The name of the feature used as a target. At the moment, only optional for the clustering tasks.</p> <code>None</code> <code>estimation_procedure_id</code> <code>int</code> <p>The id of the estimation procedure.</p> required <code>evaluation_measure</code> <code>str</code> <p>The name of the evaluation measure.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>Other task attributes that are not mandatory for task upload.</p> <code>{}</code> <p>Returns:</p> Type Description <code>(OpenMLClassificationTask, OpenMLRegressionTask)</code> <code>(OpenMLLearningCurveTask, OpenMLClusteringTask)</code> Source code in <code>openml/tasks/functions.py</code> <pre><code>def create_task(\n    task_type: TaskType,\n    dataset_id: int,\n    estimation_procedure_id: int,\n    target_name: str | None = None,\n    evaluation_measure: str | None = None,\n    **kwargs: Any,\n) -&gt; (\n    OpenMLClassificationTask | OpenMLRegressionTask | OpenMLLearningCurveTask | OpenMLClusteringTask\n):\n    \"\"\"Create a task based on different given attributes.\n\n    Builds a task object with the function arguments as\n    attributes. The type of the task object built is\n    determined from the task type id.\n    More information on how the arguments (task attributes),\n    relate to the different possible tasks can be found in\n    the individual task objects at the openml.tasks.task\n    module.\n\n    Parameters\n    ----------\n    task_type : TaskType\n        Id of the task type.\n    dataset_id : int\n        The id of the dataset for the task.\n    target_name : str, optional\n        The name of the feature used as a target.\n        At the moment, only optional for the clustering tasks.\n    estimation_procedure_id : int\n        The id of the estimation procedure.\n    evaluation_measure : str, optional\n        The name of the evaluation measure.\n    kwargs : dict, optional\n        Other task attributes that are not mandatory\n        for task upload.\n\n    Returns\n    -------\n    OpenMLClassificationTask, OpenMLRegressionTask,\n    OpenMLLearningCurveTask, OpenMLClusteringTask\n    \"\"\"\n    if task_type == TaskType.CLUSTERING:\n        task_cls = OpenMLClusteringTask\n    elif task_type == TaskType.LEARNING_CURVE:\n        task_cls = OpenMLLearningCurveTask  # type: ignore\n    elif task_type == TaskType.SUPERVISED_CLASSIFICATION:\n        task_cls = OpenMLClassificationTask  # type: ignore\n    elif task_type == TaskType.SUPERVISED_REGRESSION:\n        task_cls = OpenMLRegressionTask  # type: ignore\n    else:\n        raise NotImplementedError(f\"Task type {task_type:d} not supported.\")\n\n    return task_cls(\n        task_type_id=task_type,\n        task_type=\"None\",  # TODO: refactor to get task type string from ID.\n        data_set_id=dataset_id,\n        target_name=target_name,  # type: ignore\n        estimation_procedure_id=estimation_procedure_id,\n        evaluation_measure=evaluation_measure,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.delete_task","title":"<code>delete_task(task_id)</code>","text":"<p>Delete task with id <code>task_id</code> from the OpenML server.</p> <p>You can only delete tasks which you created and have no runs associated with them.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>OpenML id of the task</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/tasks/functions.py</code> <pre><code>def delete_task(task_id: int) -&gt; bool:\n    \"\"\"Delete task with id `task_id` from the OpenML server.\n\n    You can only delete tasks which you created and have\n    no runs associated with them.\n\n    Parameters\n    ----------\n    task_id : int\n        OpenML id of the task\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"task\", task_id)\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.get_task","title":"<code>get_task(task_id, download_splits=False, **get_dataset_kwargs)</code>","text":"<p>Download OpenML task for a given task ID.</p> <p>Downloads the task representation.</p> <p>Use the <code>download_splits</code> parameter to control whether the splits are downloaded. Moreover, you may pass additional parameter (args or kwargs) that are passed to :meth:<code>openml.datasets.get_dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The OpenML task id of the task to download.</p> required <code>download_splits</code> <code>bool</code> <p>Whether to download the splits as well.</p> <code>False</code> <code>get_dataset_kwargs</code> <code>Any</code> <p>Args and kwargs can be used pass optional parameters to :meth:<code>openml.datasets.get_dataset</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>task</code> <code>OpenMLTask</code> Source code in <code>openml/tasks/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_task(\n    task_id: int,\n    download_splits: bool = False,  # noqa: FBT001, FBT002\n    **get_dataset_kwargs: Any,\n) -&gt; OpenMLTask:\n    \"\"\"Download OpenML task for a given task ID.\n\n    Downloads the task representation.\n\n    Use the `download_splits` parameter to control whether the splits are downloaded.\n    Moreover, you may pass additional parameter (args or kwargs) that are passed to\n    :meth:`openml.datasets.get_dataset`.\n\n    Parameters\n    ----------\n    task_id : int\n        The OpenML task id of the task to download.\n    download_splits: bool (default=False)\n        Whether to download the splits as well.\n    get_dataset_kwargs :\n        Args and kwargs can be used pass optional parameters to :meth:`openml.datasets.get_dataset`.\n\n    Returns\n    -------\n    task: OpenMLTask\n    \"\"\"\n    if not isinstance(task_id, int):\n        raise TypeError(f\"Task id should be integer, is {type(task_id)}\")\n\n    tid_cache_dir = openml.utils._create_cache_directory_for_id(TASKS_CACHE_DIR_NAME, task_id)\n\n    try:\n        task = _get_task_description(task_id)\n        dataset = get_dataset(task.dataset_id, **get_dataset_kwargs)\n        # List of class labels available in dataset description\n        # Including class labels as part of task meta data handles\n        #   the case where data download was initially disabled\n        if isinstance(task, (OpenMLClassificationTask, OpenMLLearningCurveTask)):\n            task.class_labels = dataset.retrieve_class_labels(task.target_name)\n        # Clustering tasks do not have class labels\n        # and do not offer download_split\n        if download_splits and isinstance(task, OpenMLSupervisedTask):\n            task.download_split()\n    except Exception as e:\n        openml.utils._remove_cache_dir_for_id(TASKS_CACHE_DIR_NAME, tid_cache_dir)\n        raise e\n\n    return task\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.get_tasks","title":"<code>get_tasks(task_ids, download_data=None, download_qualities=None)</code>","text":"<p>Download tasks.</p> <p>This function iterates :meth:<code>openml.tasks.get_task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_ids</code> <code>List[int]</code> <p>A list of task ids to download.</p> required <code>download_data</code> <code>bool(default=True)</code> <p>Option to trigger download of data along with the meta data.</p> <code>None</code> <code>download_qualities</code> <code>bool(default=True)</code> <p>Option to download 'qualities' meta-data in addition to the minimal dataset description.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/tasks/functions.py</code> <pre><code>def get_tasks(\n    task_ids: list[int],\n    download_data: bool | None = None,\n    download_qualities: bool | None = None,\n) -&gt; list[OpenMLTask]:\n    \"\"\"Download tasks.\n\n    This function iterates :meth:`openml.tasks.get_task`.\n\n    Parameters\n    ----------\n    task_ids : List[int]\n        A list of task ids to download.\n    download_data : bool (default = True)\n        Option to trigger download of data along with the meta data.\n    download_qualities : bool (default=True)\n        Option to download 'qualities' meta-data in addition to the minimal dataset description.\n\n    Returns\n    -------\n    list\n    \"\"\"\n    if download_data is None:\n        warnings.warn(\n            \"`download_data` will default to False starting in 0.16. \"\n            \"Please set `download_data` explicitly to suppress this warning.\",\n            stacklevel=1,\n        )\n        download_data = True\n\n    if download_qualities is None:\n        warnings.warn(\n            \"`download_qualities` will default to False starting in 0.16. \"\n            \"Please set `download_qualities` explicitly to suppress this warning.\",\n            stacklevel=1,\n        )\n        download_qualities = True\n\n    tasks = []\n    for task_id in task_ids:\n        tasks.append(\n            get_task(task_id, download_data=download_data, download_qualities=download_qualities)\n        )\n    return tasks\n</code></pre>"},{"location":"reference/tasks/#openml.tasks.list_tasks","title":"<code>list_tasks(task_type=None, offset=None, size=None, tag=None, data_tag=None, status=None, data_name=None, data_id=None, number_instances=None, number_features=None, number_classes=None, number_missing_values=None)</code>","text":"<p>Return a number of tasks having the given tag and task_type</p> <p>Parameters:</p> Name Type Description Default <code>Filter</code> required <code>it</code> required <code>type</code> required <code>offset</code> <code>int</code> <p>the number of tasks to skip, starting from the first</p> <code>None</code> <code>task_type</code> <code>TaskType</code> <p>Refers to the type of task.</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of tasks to show</p> <code>None</code> <code>tag</code> <code>str</code> <p>the tag to include</p> <code>None</code> <code>data_tag</code> <code>str</code> <p>the tag of the dataset</p> <code>None</code> <code>data_id</code> <code>int</code> <code>None</code> <code>status</code> <code>str</code> <code>None</code> <code>data_name</code> <code>str</code> <code>None</code> <code>number_instances</code> <code>int</code> <code>None</code> <code>number_features</code> <code>int</code> <code>None</code> <code>number_classes</code> <code>int</code> <code>None</code> <code>number_missing_values</code> <code>int</code> <code>None</code> <p>Returns:</p> Type Description <code>dataframe</code> <p>All tasks having the given task_type and the give tag. Every task is represented by a row in the data frame containing the following information as columns: task id, dataset id, task_type and status. If qualities are calculated for the associated dataset, some of these are also returned.</p> Source code in <code>openml/tasks/functions.py</code> <pre><code>def list_tasks(  # noqa: PLR0913\n    task_type: TaskType | None = None,\n    offset: int | None = None,\n    size: int | None = None,\n    tag: str | None = None,\n    data_tag: str | None = None,\n    status: str | None = None,\n    data_name: str | None = None,\n    data_id: int | None = None,\n    number_instances: int | None = None,\n    number_features: int | None = None,\n    number_classes: int | None = None,\n    number_missing_values: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a number of tasks having the given tag and task_type\n\n    Parameters\n    ----------\n    Filter task_type is separated from the other filters because\n    it is used as task_type in the task description, but it is named\n    type when used as a filter in list tasks call.\n    offset : int, optional\n        the number of tasks to skip, starting from the first\n    task_type : TaskType, optional\n        Refers to the type of task.\n    size : int, optional\n        the maximum number of tasks to show\n    tag : str, optional\n        the tag to include\n    data_tag : str, optional\n        the tag of the dataset\n    data_id : int, optional\n    status : str, optional\n    data_name : str, optional\n    number_instances : int, optional\n    number_features : int, optional\n    number_classes : int, optional\n    number_missing_values : int, optional\n\n    Returns\n    -------\n    dataframe\n        All tasks having the given task_type and the give tag. Every task is\n        represented by a row in the data frame containing the following information\n        as columns: task id, dataset id, task_type and status. If qualities are\n        calculated for the associated dataset, some of these are also returned.\n    \"\"\"\n    listing_call = partial(\n        _list_tasks,\n        task_type=task_type,\n        tag=tag,\n        data_tag=data_tag,\n        status=status,\n        data_id=data_id,\n        data_name=data_name,\n        number_instances=number_instances,\n        number_features=number_features,\n        number_classes=number_classes,\n        number_missing_values=number_missing_values,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/tasks/functions/","title":"functions","text":""},{"location":"reference/tasks/functions/#openml.tasks.functions.__list_tasks","title":"<code>__list_tasks(api_call)</code>","text":"<p>Returns a Pandas DataFrame with information about OpenML tasks.</p> <p>Parameters:</p> Name Type Description Default <code>api_call</code> <code>str</code> <p>The API call specifying which tasks to return.</p> required <p>Returns:</p> Type Description <code>    A Pandas DataFrame with information about OpenML tasks.</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the XML returned by the OpenML API does not contain 'oml:tasks', '@xmlns:oml', or has an incorrect value for '@xmlns:oml'.</p> <code>KeyError</code> <p>If an invalid key is found in the XML for a task.</p> Source code in <code>openml/tasks/functions.py</code> <pre><code>def __list_tasks(api_call: str) -&gt; pd.DataFrame:  # noqa: C901, PLR0912\n    \"\"\"Returns a Pandas DataFrame with information about OpenML tasks.\n\n    Parameters\n    ----------\n    api_call : str\n        The API call specifying which tasks to return.\n\n    Returns\n    -------\n        A Pandas DataFrame with information about OpenML tasks.\n\n    Raises\n    ------\n    ValueError\n        If the XML returned by the OpenML API does not contain 'oml:tasks', '@xmlns:oml',\n        or has an incorrect value for '@xmlns:oml'.\n    KeyError\n        If an invalid key is found in the XML for a task.\n    \"\"\"\n    xml_string = openml._api_calls._perform_api_call(api_call, \"get\")\n    tasks_dict = xmltodict.parse(xml_string, force_list=(\"oml:task\", \"oml:input\"))\n    # Minimalistic check if the XML is useful\n    if \"oml:tasks\" not in tasks_dict:\n        raise ValueError(f'Error in return XML, does not contain \"oml:runs\": {tasks_dict}')\n\n    if \"@xmlns:oml\" not in tasks_dict[\"oml:tasks\"]:\n        raise ValueError(\n            f'Error in return XML, does not contain \"oml:runs\"/@xmlns:oml: {tasks_dict}'\n        )\n\n    if tasks_dict[\"oml:tasks\"][\"@xmlns:oml\"] != \"http://openml.org/openml\":\n        raise ValueError(\n            \"Error in return XML, value of  \"\n            '\"oml:runs\"/@xmlns:oml is not '\n            f'\"http://openml.org/openml\": {tasks_dict!s}',\n        )\n\n    assert isinstance(tasks_dict[\"oml:tasks\"][\"oml:task\"], list), type(tasks_dict[\"oml:tasks\"])\n\n    tasks = {}\n    procs = _get_estimation_procedure_list()\n    proc_dict = {x[\"id\"]: x for x in procs}\n\n    for task_ in tasks_dict[\"oml:tasks\"][\"oml:task\"]:\n        tid = None\n        try:\n            tid = int(task_[\"oml:task_id\"])\n            task_type_int = int(task_[\"oml:task_type_id\"])\n            try:\n                task_type_id = TaskType(task_type_int)\n            except ValueError as e:\n                warnings.warn(\n                    f\"Could not create task type id for {task_type_int} due to error {e}\",\n                    RuntimeWarning,\n                    stacklevel=2,\n                )\n                continue\n\n            task = {\n                \"tid\": tid,\n                \"ttid\": task_type_id,\n                \"did\": int(task_[\"oml:did\"]),\n                \"name\": task_[\"oml:name\"],\n                \"task_type\": task_[\"oml:task_type\"],\n                \"status\": task_[\"oml:status\"],\n            }\n\n            # Other task inputs\n            for _input in task_.get(\"oml:input\", []):\n                if _input[\"@name\"] == \"estimation_procedure\":\n                    task[_input[\"@name\"]] = proc_dict[int(_input[\"#text\"])][\"name\"]\n                else:\n                    value = _input.get(\"#text\")\n                    task[_input[\"@name\"]] = value\n\n            # The number of qualities can range from 0 to infinity\n            for quality in task_.get(\"oml:quality\", []):\n                if \"#text\" not in quality:\n                    quality_value = 0.0\n                else:\n                    quality[\"#text\"] = float(quality[\"#text\"])\n                    if abs(int(quality[\"#text\"]) - quality[\"#text\"]) &lt; 0.0000001:\n                        quality[\"#text\"] = int(quality[\"#text\"])\n                    quality_value = quality[\"#text\"]\n                task[quality[\"@name\"]] = quality_value\n            tasks[tid] = task\n        except KeyError as e:\n            if tid is not None:\n                warnings.warn(\n                    \"Invalid xml for task %d: %s\\nFrom %s\" % (tid, e, task_),\n                    RuntimeWarning,\n                    stacklevel=2,\n                )\n            else:\n                warnings.warn(f\"Could not find key {e} in {task_}!\", RuntimeWarning, stacklevel=2)\n\n    return pd.DataFrame.from_dict(tasks, orient=\"index\")\n</code></pre>"},{"location":"reference/tasks/functions/#openml.tasks.functions.create_task","title":"<code>create_task(task_type, dataset_id, estimation_procedure_id, target_name=None, evaluation_measure=None, **kwargs)</code>","text":"<p>Create a task based on different given attributes.</p> <p>Builds a task object with the function arguments as attributes. The type of the task object built is determined from the task type id. More information on how the arguments (task attributes), relate to the different possible tasks can be found in the individual task objects at the openml.tasks.task module.</p> <p>Parameters:</p> Name Type Description Default <code>task_type</code> <code>TaskType</code> <p>Id of the task type.</p> required <code>dataset_id</code> <code>int</code> <p>The id of the dataset for the task.</p> required <code>target_name</code> <code>str</code> <p>The name of the feature used as a target. At the moment, only optional for the clustering tasks.</p> <code>None</code> <code>estimation_procedure_id</code> <code>int</code> <p>The id of the estimation procedure.</p> required <code>evaluation_measure</code> <code>str</code> <p>The name of the evaluation measure.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>Other task attributes that are not mandatory for task upload.</p> <code>{}</code> <p>Returns:</p> Type Description <code>(OpenMLClassificationTask, OpenMLRegressionTask)</code> <code>(OpenMLLearningCurveTask, OpenMLClusteringTask)</code> Source code in <code>openml/tasks/functions.py</code> <pre><code>def create_task(\n    task_type: TaskType,\n    dataset_id: int,\n    estimation_procedure_id: int,\n    target_name: str | None = None,\n    evaluation_measure: str | None = None,\n    **kwargs: Any,\n) -&gt; (\n    OpenMLClassificationTask | OpenMLRegressionTask | OpenMLLearningCurveTask | OpenMLClusteringTask\n):\n    \"\"\"Create a task based on different given attributes.\n\n    Builds a task object with the function arguments as\n    attributes. The type of the task object built is\n    determined from the task type id.\n    More information on how the arguments (task attributes),\n    relate to the different possible tasks can be found in\n    the individual task objects at the openml.tasks.task\n    module.\n\n    Parameters\n    ----------\n    task_type : TaskType\n        Id of the task type.\n    dataset_id : int\n        The id of the dataset for the task.\n    target_name : str, optional\n        The name of the feature used as a target.\n        At the moment, only optional for the clustering tasks.\n    estimation_procedure_id : int\n        The id of the estimation procedure.\n    evaluation_measure : str, optional\n        The name of the evaluation measure.\n    kwargs : dict, optional\n        Other task attributes that are not mandatory\n        for task upload.\n\n    Returns\n    -------\n    OpenMLClassificationTask, OpenMLRegressionTask,\n    OpenMLLearningCurveTask, OpenMLClusteringTask\n    \"\"\"\n    if task_type == TaskType.CLUSTERING:\n        task_cls = OpenMLClusteringTask\n    elif task_type == TaskType.LEARNING_CURVE:\n        task_cls = OpenMLLearningCurveTask  # type: ignore\n    elif task_type == TaskType.SUPERVISED_CLASSIFICATION:\n        task_cls = OpenMLClassificationTask  # type: ignore\n    elif task_type == TaskType.SUPERVISED_REGRESSION:\n        task_cls = OpenMLRegressionTask  # type: ignore\n    else:\n        raise NotImplementedError(f\"Task type {task_type:d} not supported.\")\n\n    return task_cls(\n        task_type_id=task_type,\n        task_type=\"None\",  # TODO: refactor to get task type string from ID.\n        data_set_id=dataset_id,\n        target_name=target_name,  # type: ignore\n        estimation_procedure_id=estimation_procedure_id,\n        evaluation_measure=evaluation_measure,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/tasks/functions/#openml.tasks.functions.delete_task","title":"<code>delete_task(task_id)</code>","text":"<p>Delete task with id <code>task_id</code> from the OpenML server.</p> <p>You can only delete tasks which you created and have no runs associated with them.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>OpenML id of the task</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the deletion was successful. False otherwise.</p> Source code in <code>openml/tasks/functions.py</code> <pre><code>def delete_task(task_id: int) -&gt; bool:\n    \"\"\"Delete task with id `task_id` from the OpenML server.\n\n    You can only delete tasks which you created and have\n    no runs associated with them.\n\n    Parameters\n    ----------\n    task_id : int\n        OpenML id of the task\n\n    Returns\n    -------\n    bool\n        True if the deletion was successful. False otherwise.\n    \"\"\"\n    return openml.utils._delete_entity(\"task\", task_id)\n</code></pre>"},{"location":"reference/tasks/functions/#openml.tasks.functions.get_task","title":"<code>get_task(task_id, download_splits=False, **get_dataset_kwargs)</code>","text":"<p>Download OpenML task for a given task ID.</p> <p>Downloads the task representation.</p> <p>Use the <code>download_splits</code> parameter to control whether the splits are downloaded. Moreover, you may pass additional parameter (args or kwargs) that are passed to :meth:<code>openml.datasets.get_dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The OpenML task id of the task to download.</p> required <code>download_splits</code> <code>bool</code> <p>Whether to download the splits as well.</p> <code>False</code> <code>get_dataset_kwargs</code> <code>Any</code> <p>Args and kwargs can be used pass optional parameters to :meth:<code>openml.datasets.get_dataset</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>task</code> <code>OpenMLTask</code> Source code in <code>openml/tasks/functions.py</code> <pre><code>@openml.utils.thread_safe_if_oslo_installed\ndef get_task(\n    task_id: int,\n    download_splits: bool = False,  # noqa: FBT001, FBT002\n    **get_dataset_kwargs: Any,\n) -&gt; OpenMLTask:\n    \"\"\"Download OpenML task for a given task ID.\n\n    Downloads the task representation.\n\n    Use the `download_splits` parameter to control whether the splits are downloaded.\n    Moreover, you may pass additional parameter (args or kwargs) that are passed to\n    :meth:`openml.datasets.get_dataset`.\n\n    Parameters\n    ----------\n    task_id : int\n        The OpenML task id of the task to download.\n    download_splits: bool (default=False)\n        Whether to download the splits as well.\n    get_dataset_kwargs :\n        Args and kwargs can be used pass optional parameters to :meth:`openml.datasets.get_dataset`.\n\n    Returns\n    -------\n    task: OpenMLTask\n    \"\"\"\n    if not isinstance(task_id, int):\n        raise TypeError(f\"Task id should be integer, is {type(task_id)}\")\n\n    tid_cache_dir = openml.utils._create_cache_directory_for_id(TASKS_CACHE_DIR_NAME, task_id)\n\n    try:\n        task = _get_task_description(task_id)\n        dataset = get_dataset(task.dataset_id, **get_dataset_kwargs)\n        # List of class labels available in dataset description\n        # Including class labels as part of task meta data handles\n        #   the case where data download was initially disabled\n        if isinstance(task, (OpenMLClassificationTask, OpenMLLearningCurveTask)):\n            task.class_labels = dataset.retrieve_class_labels(task.target_name)\n        # Clustering tasks do not have class labels\n        # and do not offer download_split\n        if download_splits and isinstance(task, OpenMLSupervisedTask):\n            task.download_split()\n    except Exception as e:\n        openml.utils._remove_cache_dir_for_id(TASKS_CACHE_DIR_NAME, tid_cache_dir)\n        raise e\n\n    return task\n</code></pre>"},{"location":"reference/tasks/functions/#openml.tasks.functions.get_tasks","title":"<code>get_tasks(task_ids, download_data=None, download_qualities=None)</code>","text":"<p>Download tasks.</p> <p>This function iterates :meth:<code>openml.tasks.get_task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_ids</code> <code>List[int]</code> <p>A list of task ids to download.</p> required <code>download_data</code> <code>bool(default=True)</code> <p>Option to trigger download of data along with the meta data.</p> <code>None</code> <code>download_qualities</code> <code>bool(default=True)</code> <p>Option to download 'qualities' meta-data in addition to the minimal dataset description.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> Source code in <code>openml/tasks/functions.py</code> <pre><code>def get_tasks(\n    task_ids: list[int],\n    download_data: bool | None = None,\n    download_qualities: bool | None = None,\n) -&gt; list[OpenMLTask]:\n    \"\"\"Download tasks.\n\n    This function iterates :meth:`openml.tasks.get_task`.\n\n    Parameters\n    ----------\n    task_ids : List[int]\n        A list of task ids to download.\n    download_data : bool (default = True)\n        Option to trigger download of data along with the meta data.\n    download_qualities : bool (default=True)\n        Option to download 'qualities' meta-data in addition to the minimal dataset description.\n\n    Returns\n    -------\n    list\n    \"\"\"\n    if download_data is None:\n        warnings.warn(\n            \"`download_data` will default to False starting in 0.16. \"\n            \"Please set `download_data` explicitly to suppress this warning.\",\n            stacklevel=1,\n        )\n        download_data = True\n\n    if download_qualities is None:\n        warnings.warn(\n            \"`download_qualities` will default to False starting in 0.16. \"\n            \"Please set `download_qualities` explicitly to suppress this warning.\",\n            stacklevel=1,\n        )\n        download_qualities = True\n\n    tasks = []\n    for task_id in task_ids:\n        tasks.append(\n            get_task(task_id, download_data=download_data, download_qualities=download_qualities)\n        )\n    return tasks\n</code></pre>"},{"location":"reference/tasks/functions/#openml.tasks.functions.list_tasks","title":"<code>list_tasks(task_type=None, offset=None, size=None, tag=None, data_tag=None, status=None, data_name=None, data_id=None, number_instances=None, number_features=None, number_classes=None, number_missing_values=None)</code>","text":"<p>Return a number of tasks having the given tag and task_type</p> <p>Parameters:</p> Name Type Description Default <code>Filter</code> required <code>it</code> required <code>type</code> required <code>offset</code> <code>int</code> <p>the number of tasks to skip, starting from the first</p> <code>None</code> <code>task_type</code> <code>TaskType</code> <p>Refers to the type of task.</p> <code>None</code> <code>size</code> <code>int</code> <p>the maximum number of tasks to show</p> <code>None</code> <code>tag</code> <code>str</code> <p>the tag to include</p> <code>None</code> <code>data_tag</code> <code>str</code> <p>the tag of the dataset</p> <code>None</code> <code>data_id</code> <code>int</code> <code>None</code> <code>status</code> <code>str</code> <code>None</code> <code>data_name</code> <code>str</code> <code>None</code> <code>number_instances</code> <code>int</code> <code>None</code> <code>number_features</code> <code>int</code> <code>None</code> <code>number_classes</code> <code>int</code> <code>None</code> <code>number_missing_values</code> <code>int</code> <code>None</code> <p>Returns:</p> Type Description <code>dataframe</code> <p>All tasks having the given task_type and the give tag. Every task is represented by a row in the data frame containing the following information as columns: task id, dataset id, task_type and status. If qualities are calculated for the associated dataset, some of these are also returned.</p> Source code in <code>openml/tasks/functions.py</code> <pre><code>def list_tasks(  # noqa: PLR0913\n    task_type: TaskType | None = None,\n    offset: int | None = None,\n    size: int | None = None,\n    tag: str | None = None,\n    data_tag: str | None = None,\n    status: str | None = None,\n    data_name: str | None = None,\n    data_id: int | None = None,\n    number_instances: int | None = None,\n    number_features: int | None = None,\n    number_classes: int | None = None,\n    number_missing_values: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a number of tasks having the given tag and task_type\n\n    Parameters\n    ----------\n    Filter task_type is separated from the other filters because\n    it is used as task_type in the task description, but it is named\n    type when used as a filter in list tasks call.\n    offset : int, optional\n        the number of tasks to skip, starting from the first\n    task_type : TaskType, optional\n        Refers to the type of task.\n    size : int, optional\n        the maximum number of tasks to show\n    tag : str, optional\n        the tag to include\n    data_tag : str, optional\n        the tag of the dataset\n    data_id : int, optional\n    status : str, optional\n    data_name : str, optional\n    number_instances : int, optional\n    number_features : int, optional\n    number_classes : int, optional\n    number_missing_values : int, optional\n\n    Returns\n    -------\n    dataframe\n        All tasks having the given task_type and the give tag. Every task is\n        represented by a row in the data frame containing the following information\n        as columns: task id, dataset id, task_type and status. If qualities are\n        calculated for the associated dataset, some of these are also returned.\n    \"\"\"\n    listing_call = partial(\n        _list_tasks,\n        task_type=task_type,\n        tag=tag,\n        data_tag=data_tag,\n        status=status,\n        data_id=data_id,\n        data_name=data_name,\n        number_instances=number_instances,\n        number_features=number_features,\n        number_classes=number_classes,\n        number_missing_values=number_missing_values,\n    )\n    batches = openml.utils._list_all(listing_call, offset=offset, limit=size)\n    if len(batches) == 0:\n        return pd.DataFrame()\n\n    return pd.concat(batches)\n</code></pre>"},{"location":"reference/tasks/split/","title":"split","text":""},{"location":"reference/tasks/split/#openml.tasks.split.OpenMLSplit","title":"<code>OpenMLSplit</code>","text":"<p>OpenML Split object.</p> <p>This class manages train-test splits for a dataset across multiple repetitions, folds, and samples.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>int or str</code> <p>The name or ID of the split.</p> required <code>description</code> <code>str</code> <p>A description of the split.</p> required <code>split</code> <code>dict</code> <p>A dictionary containing the splits organized by repetition, fold, and sample.</p> required Source code in <code>openml/tasks/split.py</code> <pre><code>class OpenMLSplit:\n    \"\"\"OpenML Split object.\n\n    This class manages train-test splits for a dataset across multiple\n    repetitions, folds, and samples.\n\n    Parameters\n    ----------\n    name : int or str\n        The name or ID of the split.\n    description : str\n        A description of the split.\n    split : dict\n        A dictionary containing the splits organized by repetition, fold,\n        and sample.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: int | str,\n        description: str,\n        split: dict[int, dict[int, dict[int, tuple[np.ndarray, np.ndarray]]]],\n    ):\n        self.description = description\n        self.name = name\n        self.split: dict[int, dict[int, dict[int, tuple[np.ndarray, np.ndarray]]]] = {}\n\n        # Add splits according to repetition\n        for repetition in split:\n            _rep = int(repetition)\n            self.split[_rep] = OrderedDict()\n            for fold in split[_rep]:\n                self.split[_rep][fold] = OrderedDict()\n                for sample in split[_rep][fold]:\n                    self.split[_rep][fold][sample] = split[_rep][fold][sample]\n\n        self.repeats = len(self.split)\n\n        # TODO(eddiebergman): Better error message\n        if any(len(self.split[0]) != len(self.split[i]) for i in range(self.repeats)):\n            raise ValueError(\"\")\n\n        self.folds = len(self.split[0])\n        self.samples = len(self.split[0][0])\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if (\n            (not isinstance(self, type(other)))\n            or self.name != other.name\n            or self.description != other.description\n            or self.split.keys() != other.split.keys()\n            or any(\n                self.split[repetition].keys() != other.split[repetition].keys()\n                for repetition in self.split\n            )\n        ):\n            return False\n\n        samples = [\n            (repetition, fold, sample)\n            for repetition in self.split\n            for fold in self.split[repetition]\n            for sample in self.split[repetition][fold]\n        ]\n\n        for repetition, fold, sample in samples:\n            self_train, self_test = self.split[repetition][fold][sample]\n            other_train, other_test = other.split[repetition][fold][sample]\n            if not (np.all(self_train == other_train) and np.all(self_test == other_test)):\n                return False\n        return True\n\n    @classmethod\n    def _from_arff_file(cls, filename: Path) -&gt; OpenMLSplit:  # noqa: C901, PLR0912\n        repetitions = None\n        name = None\n\n        pkl_filename = filename.with_suffix(\".pkl.py3\")\n\n        if pkl_filename.exists():\n            with pkl_filename.open(\"rb\") as fh:\n                # TODO(eddiebergman): Would be good to figure out what _split is and assert it is\n                _split = pickle.load(fh)  # noqa: S301\n            repetitions = _split[\"repetitions\"]\n            name = _split[\"name\"]\n\n        # Cache miss\n        if repetitions is None:\n            # Faster than liac-arff and sufficient in this situation!\n            if not filename.exists():\n                raise FileNotFoundError(f\"Split arff {filename} does not exist!\")\n\n            file_data = arff.load(filename.open(\"r\"), return_type=arff.DENSE_GEN)\n            splits = file_data[\"data\"]\n            name = file_data[\"relation\"]\n            attrnames = [attr[0] for attr in file_data[\"attributes\"]]\n\n            repetitions = OrderedDict()\n\n            type_idx = attrnames.index(\"type\")\n            rowid_idx = attrnames.index(\"rowid\")\n            repeat_idx = attrnames.index(\"repeat\")\n            fold_idx = attrnames.index(\"fold\")\n            sample_idx = attrnames.index(\"sample\") if \"sample\" in attrnames else None\n\n            for line in splits:\n                # A line looks like type, rowid, repeat, fold\n                repetition = int(line[repeat_idx])\n                fold = int(line[fold_idx])\n                sample = 0\n                if sample_idx is not None:\n                    sample = int(line[sample_idx])\n\n                if repetition not in repetitions:\n                    repetitions[repetition] = OrderedDict()\n                if fold not in repetitions[repetition]:\n                    repetitions[repetition][fold] = OrderedDict()\n                if sample not in repetitions[repetition][fold]:\n                    repetitions[repetition][fold][sample] = ([], [])\n                split = repetitions[repetition][fold][sample]\n\n                type_ = line[type_idx]\n                if type_ == \"TRAIN\":\n                    split[0].append(line[rowid_idx])\n                elif type_ == \"TEST\":\n                    split[1].append(line[rowid_idx])\n                else:\n                    raise ValueError(type_)\n\n            for repetition in repetitions:\n                for fold in repetitions[repetition]:\n                    for sample in repetitions[repetition][fold]:\n                        repetitions[repetition][fold][sample] = Split(\n                            np.array(repetitions[repetition][fold][sample][0], dtype=np.int32),\n                            np.array(repetitions[repetition][fold][sample][1], dtype=np.int32),\n                        )\n\n            with pkl_filename.open(\"wb\") as fh:\n                pickle.dump({\"name\": name, \"repetitions\": repetitions}, fh, protocol=2)\n\n        assert name is not None\n        return cls(name, \"\", repetitions)\n\n    def get(self, repeat: int = 0, fold: int = 0, sample: int = 0) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Returns the specified data split from the CrossValidationSplit object.\n\n        Parameters\n        ----------\n        repeat : int\n            Index of the repeat to retrieve.\n        fold : int\n            Index of the fold to retrieve.\n        sample : int\n            Index of the sample to retrieve.\n\n        Returns\n        -------\n        numpy.ndarray\n            The data split for the specified repeat, fold, and sample.\n\n        Raises\n        ------\n        ValueError\n            If the specified repeat, fold, or sample is not known.\n        \"\"\"\n        if repeat not in self.split:\n            raise ValueError(f\"Repeat {repeat!s} not known\")\n        if fold not in self.split[repeat]:\n            raise ValueError(f\"Fold {fold!s} not known\")\n        if sample not in self.split[repeat][fold]:\n            raise ValueError(f\"Sample {sample!s} not known\")\n        return self.split[repeat][fold][sample]\n</code></pre>"},{"location":"reference/tasks/split/#openml.tasks.split.OpenMLSplit.get","title":"<code>get(repeat=0, fold=0, sample=0)</code>","text":"<p>Returns the specified data split from the CrossValidationSplit object.</p> <p>Parameters:</p> Name Type Description Default <code>repeat</code> <code>int</code> <p>Index of the repeat to retrieve.</p> <code>0</code> <code>fold</code> <code>int</code> <p>Index of the fold to retrieve.</p> <code>0</code> <code>sample</code> <code>int</code> <p>Index of the sample to retrieve.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The data split for the specified repeat, fold, and sample.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified repeat, fold, or sample is not known.</p> Source code in <code>openml/tasks/split.py</code> <pre><code>def get(self, repeat: int = 0, fold: int = 0, sample: int = 0) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Returns the specified data split from the CrossValidationSplit object.\n\n    Parameters\n    ----------\n    repeat : int\n        Index of the repeat to retrieve.\n    fold : int\n        Index of the fold to retrieve.\n    sample : int\n        Index of the sample to retrieve.\n\n    Returns\n    -------\n    numpy.ndarray\n        The data split for the specified repeat, fold, and sample.\n\n    Raises\n    ------\n    ValueError\n        If the specified repeat, fold, or sample is not known.\n    \"\"\"\n    if repeat not in self.split:\n        raise ValueError(f\"Repeat {repeat!s} not known\")\n    if fold not in self.split[repeat]:\n        raise ValueError(f\"Fold {fold!s} not known\")\n    if sample not in self.split[repeat][fold]:\n        raise ValueError(f\"Sample {sample!s} not known\")\n    return self.split[repeat][fold][sample]\n</code></pre>"},{"location":"reference/tasks/split/#openml.tasks.split.Split","title":"<code>Split</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A single split of a dataset.</p> Source code in <code>openml/tasks/split.py</code> <pre><code>class Split(NamedTuple):\n    \"\"\"A single split of a dataset.\"\"\"\n\n    train: np.ndarray\n    test: np.ndarray\n</code></pre>"},{"location":"reference/tasks/task/","title":"task","text":""},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLClassificationTask","title":"<code>OpenMLClassificationTask</code>","text":"<p>               Bases: <code>OpenMLSupervisedTask</code></p> <p>OpenML Classification object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the Classification task type.</p> required <code>task_type</code> <code>str</code> <p>Name of the Classification task type.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset associated with the Classification task.</p> required <code>target_name</code> <code>str</code> <p>Name of the target variable.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure for the Classification task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Estimation parameters for the Classification task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the data splits for the Classification task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the Classification task (if it already exists on OpenML).</p> <code>None</code> <code>class_labels</code> <code>List of str</code> <p>A list of class labels (for classification tasks).</p> <code>None</code> <code>cost_matrix</code> <code>array</code> <p>A cost matrix (for classification tasks).</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLClassificationTask(OpenMLSupervisedTask):\n    \"\"\"OpenML Classification object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the Classification task type.\n    task_type : str\n        Name of the Classification task type.\n    data_set_id : int\n        ID of the OpenML dataset associated with the Classification task.\n    target_name : str\n        Name of the target variable.\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure for the Classification task.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure.\n    estimation_parameters : dict, default=None\n        Estimation parameters for the Classification task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure.\n    data_splits_url : str, default=None\n        URL of the data splits for the Classification task.\n    task_id : Union[int, None]\n        ID of the Classification task (if it already exists on OpenML).\n    class_labels : List of str, default=None\n        A list of class labels (for classification tasks).\n    cost_matrix : array, default=None\n        A cost matrix (for classification tasks).\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        class_labels: list[str] | None = None,\n        cost_matrix: np.ndarray | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n        )\n        self.class_labels = class_labels\n        self.cost_matrix = cost_matrix\n\n        if cost_matrix is not None:\n            raise NotImplementedError(\"Costmatrix\")\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLClusteringTask","title":"<code>OpenMLClusteringTask</code>","text":"<p>               Bases: <code>OpenMLTask</code></p> <p>OpenML Clustering object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>Task type ID of the OpenML clustering task.</p> required <code>task_type</code> <code>str</code> <p>Task type of the OpenML clustering task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset used in clustering the task.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the OpenML estimation procedure.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the OpenML clustering task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the OpenML estimation procedure used in the clustering task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Parameters used by the OpenML estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the OpenML data splits for the clustering task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Evaluation measure used in the clustering task.</p> <code>None</code> <code>target_name</code> <code>str</code> <p>Name of the target feature (class) that is not part of the feature set for the clustering task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLClusteringTask(OpenMLTask):\n    \"\"\"OpenML Clustering object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        Task type ID of the OpenML clustering task.\n    task_type : str\n        Task type of the OpenML clustering task.\n    data_set_id : int\n        ID of the OpenML dataset used in clustering the task.\n    estimation_procedure_id : int, default=None\n        ID of the OpenML estimation procedure.\n    task_id : Union[int, None]\n        ID of the OpenML clustering task.\n    estimation_procedure_type : str, default=None\n        Type of the OpenML estimation procedure used in the clustering task.\n    estimation_parameters : dict, default=None\n        Parameters used by the OpenML estimation procedure.\n    data_splits_url : str, default=None\n        URL of the OpenML data splits for the clustering task.\n    evaluation_measure : str, default=None\n        Evaluation measure used in the clustering task.\n    target_name : str, default=None\n        Name of the target feature (class) that is not part of the\n        feature set for the clustering task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        estimation_procedure_id: int = 17,\n        task_id: int | None = None,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        evaluation_measure: str | None = None,\n        target_name: str | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            evaluation_measure=evaluation_measure,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            data_splits_url=data_splits_url,\n        )\n\n        self.target_name = target_name\n\n    def get_X(self) -&gt; pd.DataFrame:\n        \"\"\"Get data associated with the current task.\n\n        Returns\n        -------\n        The X data as a dataframe\n        \"\"\"\n        dataset = self.get_dataset()\n        data, *_ = dataset.get_data(target=None)\n        return data\n\n    def _to_dict(self) -&gt; dict[str, dict[str, int | str | list[dict[str, Any]]]]:\n        # Right now, it is not supported as a feature.\n        # Uncomment if it is supported on the server\n        # in the future.\n        # https://github.com/openml/OpenML/issues/925\n        \"\"\"\n        task_dict = task_container['oml:task_inputs']\n        if self.target_name is not None:\n            task_dict['oml:input'].append(\n                OrderedDict([\n                    ('@name', 'target_feature'),\n                    ('#text', self.target_name)\n                ])\n            )\n        \"\"\"\n        return super()._to_dict()\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLClusteringTask.get_X","title":"<code>get_X()</code>","text":"<p>Get data associated with the current task.</p> <p>Returns:</p> Type Description <code>The X data as a dataframe</code> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_X(self) -&gt; pd.DataFrame:\n    \"\"\"Get data associated with the current task.\n\n    Returns\n    -------\n    The X data as a dataframe\n    \"\"\"\n    dataset = self.get_dataset()\n    data, *_ = dataset.get_data(target=None)\n    return data\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLLearningCurveTask","title":"<code>OpenMLLearningCurveTask</code>","text":"<p>               Bases: <code>OpenMLClassificationTask</code></p> <p>OpenML Learning Curve object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the Learning Curve task.</p> required <code>task_type</code> <code>str</code> <p>Name of the Learning Curve task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the dataset that this task is associated with.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature in the dataset.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure to use for evaluating models.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Additional parameters for the estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the file containing the data splits for Learning Curve task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the Learning Curve task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure to use for evaluating models.</p> <code>None</code> <code>class_labels</code> <code>list of str</code> <p>Class labels for Learning Curve tasks.</p> <code>None</code> <code>cost_matrix</code> <code>numpy array</code> <p>Cost matrix for Learning Curve tasks.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLLearningCurveTask(OpenMLClassificationTask):\n    \"\"\"OpenML Learning Curve object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the Learning Curve task.\n    task_type : str\n        Name of the Learning Curve task.\n    data_set_id : int\n        ID of the dataset that this task is associated with.\n    target_name : str\n        Name of the target feature in the dataset.\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure to use for evaluating models.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure.\n    estimation_parameters : dict, default=None\n        Additional parameters for the estimation procedure.\n    data_splits_url : str, default=None\n        URL of the file containing the data splits for Learning Curve task.\n    task_id : Union[int, None]\n        ID of the Learning Curve task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure to use for evaluating models.\n    class_labels : list of str, default=None\n        Class labels for Learning Curve tasks.\n    cost_matrix : numpy array, default=None\n        Cost matrix for Learning Curve tasks.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 13,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        evaluation_measure: str | None = None,\n        class_labels: list[str] | None = None,\n        cost_matrix: np.ndarray | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n            class_labels=class_labels,\n            cost_matrix=cost_matrix,\n        )\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLRegressionTask","title":"<code>OpenMLRegressionTask</code>","text":"<p>               Bases: <code>OpenMLSupervisedTask</code></p> <p>OpenML Regression object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>Task type ID of the OpenML Regression task.</p> required <code>task_type</code> <code>str</code> <p>Task type of the OpenML Regression task.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature used in the Regression task.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the OpenML estimation procedure.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the OpenML estimation procedure.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Parameters used by the OpenML estimation procedure.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the OpenML data splits for the Regression task.</p> <code>None</code> <code>task_id</code> <code>Union[int, None]</code> <p>ID of the OpenML Regression task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Evaluation measure used in the Regression task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLRegressionTask(OpenMLSupervisedTask):\n    \"\"\"OpenML Regression object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        Task type ID of the OpenML Regression task.\n    task_type : str\n        Task type of the OpenML Regression task.\n    data_set_id : int\n        ID of the OpenML dataset.\n    target_name : str\n        Name of the target feature used in the Regression task.\n    estimation_procedure_id : int, default=None\n        ID of the OpenML estimation procedure.\n    estimation_procedure_type : str, default=None\n        Type of the OpenML estimation procedure.\n    estimation_parameters : dict, default=None\n        Parameters used by the OpenML estimation procedure.\n    data_splits_url : str, default=None\n        URL of the OpenML data splits for the Regression task.\n    task_id : Union[int, None]\n        ID of the OpenML Regression task.\n    evaluation_measure : str, default=None\n        Evaluation measure used in the Regression task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 7,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n        evaluation_measure: str | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            target_name=target_name,\n            data_splits_url=data_splits_url,\n        )\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLSupervisedTask","title":"<code>OpenMLSupervisedTask</code>","text":"<p>               Bases: <code>OpenMLTask</code>, <code>ABC</code></p> <p>OpenML Supervised Classification object.</p> <p>Parameters:</p> Name Type Description Default <code>task_type_id</code> <code>TaskType</code> <p>ID of the task type.</p> required <code>task_type</code> <code>str</code> <p>Name of the task type.</p> required <code>data_set_id</code> <code>int</code> <p>ID of the OpenML dataset associated with the task.</p> required <code>target_name</code> <code>str</code> <p>Name of the target feature (the class variable).</p> required <code>estimation_procedure_id</code> <code>int</code> <p>ID of the estimation procedure for the task.</p> <code>None</code> <code>estimation_procedure_type</code> <code>str</code> <p>Type of the estimation procedure for the task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict</code> <p>Estimation parameters for the task.</p> <code>None</code> <code>evaluation_measure</code> <code>str</code> <p>Name of the evaluation measure for the task.</p> <code>None</code> <code>data_splits_url</code> <code>str</code> <p>URL of the data splits for the task.</p> <code>None</code> <code>task_id</code> <code>int | None</code> <p>Refers to the unique identifier of task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLSupervisedTask(OpenMLTask, ABC):\n    \"\"\"OpenML Supervised Classification object.\n\n    Parameters\n    ----------\n    task_type_id : TaskType\n        ID of the task type.\n    task_type : str\n        Name of the task type.\n    data_set_id : int\n        ID of the OpenML dataset associated with the task.\n    target_name : str\n        Name of the target feature (the class variable).\n    estimation_procedure_id : int, default=None\n        ID of the estimation procedure for the task.\n    estimation_procedure_type : str, default=None\n        Type of the estimation procedure for the task.\n    estimation_parameters : dict, default=None\n        Estimation parameters for the task.\n    evaluation_measure : str, default=None\n        Name of the evaluation measure for the task.\n    data_splits_url : str, default=None\n        URL of the data splits for the task.\n    task_id: Union[int, None]\n        Refers to the unique identifier of task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        target_name: str,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n        task_id: int | None = None,\n    ):\n        super().__init__(\n            task_id=task_id,\n            task_type_id=task_type_id,\n            task_type=task_type,\n            data_set_id=data_set_id,\n            estimation_procedure_id=estimation_procedure_id,\n            estimation_procedure_type=estimation_procedure_type,\n            estimation_parameters=estimation_parameters,\n            evaluation_measure=evaluation_measure,\n            data_splits_url=data_splits_url,\n        )\n\n        self.target_name = target_name\n\n    def get_X_and_y(self) -&gt; tuple[pd.DataFrame, pd.Series | pd.DataFrame | None]:\n        \"\"\"Get data associated with the current task.\n\n        Returns\n        -------\n        tuple - X and y\n\n        \"\"\"\n        dataset = self.get_dataset()\n        if self.task_type_id not in (\n            TaskType.SUPERVISED_CLASSIFICATION,\n            TaskType.SUPERVISED_REGRESSION,\n            TaskType.LEARNING_CURVE,\n        ):\n            raise NotImplementedError(self.task_type)\n\n        X, y, _, _ = dataset.get_data(target=self.target_name)\n        return X, y\n\n    def _to_dict(self) -&gt; dict[str, dict]:\n        task_container = super()._to_dict()\n        oml_input = task_container[\"oml:task_inputs\"][\"oml:input\"]  # type: ignore\n        assert isinstance(oml_input, list)\n\n        oml_input.append({\"@name\": \"target_feature\", \"#text\": self.target_name})\n        return task_container\n\n    @property\n    def estimation_parameters(self) -&gt; dict[str, str] | None:\n        \"\"\"Return the estimation parameters for the task.\"\"\"\n        warnings.warn(\n            \"The estimation_parameters attribute will be \"\n            \"deprecated in the future, please use \"\n            \"estimation_procedure['parameters'] instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.estimation_procedure[\"parameters\"]\n\n    @estimation_parameters.setter\n    def estimation_parameters(self, est_parameters: dict[str, str] | None) -&gt; None:\n        self.estimation_procedure[\"parameters\"] = est_parameters\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLSupervisedTask.estimation_parameters","title":"<code>estimation_parameters: dict[str, str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the estimation parameters for the task.</p>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLSupervisedTask.get_X_and_y","title":"<code>get_X_and_y()</code>","text":"<p>Get data associated with the current task.</p> <p>Returns:</p> Type Description <code>tuple - X and y</code> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_X_and_y(self) -&gt; tuple[pd.DataFrame, pd.Series | pd.DataFrame | None]:\n    \"\"\"Get data associated with the current task.\n\n    Returns\n    -------\n    tuple - X and y\n\n    \"\"\"\n    dataset = self.get_dataset()\n    if self.task_type_id not in (\n        TaskType.SUPERVISED_CLASSIFICATION,\n        TaskType.SUPERVISED_REGRESSION,\n        TaskType.LEARNING_CURVE,\n    ):\n        raise NotImplementedError(self.task_type)\n\n    X, y, _, _ = dataset.get_data(target=self.target_name)\n    return X, y\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLTask","title":"<code>OpenMLTask</code>","text":"<p>               Bases: <code>OpenMLBase</code></p> <p>OpenML Task object.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int | None</code> <p>Refers to the unique identifier of OpenML task.</p> required <code>task_type_id</code> <code>TaskType</code> <p>Refers to the type of OpenML task.</p> required <code>task_type</code> <code>str</code> <p>Refers to the OpenML task.</p> required <code>data_set_id</code> <code>int</code> <p>Refers to the data.</p> required <code>estimation_procedure_id</code> <code>int</code> <p>Refers to the type of estimates used.</p> <code>1</code> <code>estimation_procedure_type</code> <code>str | None</code> <p>Refers to the type of estimation procedure used for the OpenML task.</p> <code>None</code> <code>estimation_parameters</code> <code>dict[str, str] | None</code> <p>Estimation parameters used for the OpenML task.</p> <code>None</code> <code>evaluation_measure</code> <code>str | None</code> <p>Refers to the evaluation measure.</p> <code>None</code> <code>data_splits_url</code> <code>str | None</code> <p>Refers to the URL of the data splits used for the OpenML task.</p> <code>None</code> Source code in <code>openml/tasks/task.py</code> <pre><code>class OpenMLTask(OpenMLBase):\n    \"\"\"OpenML Task object.\n\n    Parameters\n    ----------\n    task_id: Union[int, None]\n        Refers to the unique identifier of OpenML task.\n    task_type_id: TaskType\n        Refers to the type of OpenML task.\n    task_type: str\n        Refers to the OpenML task.\n    data_set_id: int\n        Refers to the data.\n    estimation_procedure_id: int\n        Refers to the type of estimates used.\n    estimation_procedure_type: str, default=None\n        Refers to the type of estimation procedure used for the OpenML task.\n    estimation_parameters: [Dict[str, str]], default=None\n        Estimation parameters used for the OpenML task.\n    evaluation_measure: str, default=None\n        Refers to the evaluation measure.\n    data_splits_url: str, default=None\n        Refers to the URL of the data splits used for the OpenML task.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        task_id: int | None,\n        task_type_id: TaskType,\n        task_type: str,\n        data_set_id: int,\n        estimation_procedure_id: int = 1,\n        estimation_procedure_type: str | None = None,\n        estimation_parameters: dict[str, str] | None = None,\n        evaluation_measure: str | None = None,\n        data_splits_url: str | None = None,\n    ):\n        self.task_id = int(task_id) if task_id is not None else None\n        self.task_type_id = task_type_id\n        self.task_type = task_type\n        self.dataset_id = int(data_set_id)\n        self.evaluation_measure = evaluation_measure\n        self.estimation_procedure: _EstimationProcedure = {\n            \"type\": estimation_procedure_type,\n            \"parameters\": estimation_parameters,\n            \"data_splits_url\": data_splits_url,\n        }\n        self.estimation_procedure_id = estimation_procedure_id\n        self.split: OpenMLSplit | None = None\n\n    @classmethod\n    def _entity_letter(cls) -&gt; str:\n        return \"t\"\n\n    @property\n    def id(self) -&gt; int | None:\n        \"\"\"Return the OpenML ID of this task.\"\"\"\n        return self.task_id\n\n    def _get_repr_body_fields(self) -&gt; Sequence[tuple[str, str | int | list[str]]]:\n        \"\"\"Collect all information to display in the __repr__ body.\"\"\"\n        base_server_url = openml.config.get_server_base_url()\n        fields: dict[str, Any] = {\n            \"Task Type Description\": f\"{base_server_url}/tt/{self.task_type_id}\"\n        }\n        if self.task_id is not None:\n            fields[\"Task ID\"] = self.task_id\n            fields[\"Task URL\"] = self.openml_url\n        if self.evaluation_measure is not None:\n            fields[\"Evaluation Measure\"] = self.evaluation_measure\n        if self.estimation_procedure is not None:\n            fields[\"Estimation Procedure\"] = self.estimation_procedure[\"type\"]\n\n        # TODO(eddiebergman): Subclasses could advertise/provide this, instead of having to\n        # have the base class know about it's subclasses.\n        target_name = getattr(self, \"target_name\", None)\n        if target_name is not None:\n            fields[\"Target Feature\"] = target_name\n\n            class_labels = getattr(self, \"class_labels\", None)\n            if class_labels is not None:\n                fields[\"# of Classes\"] = len(class_labels)\n\n            if hasattr(self, \"cost_matrix\"):\n                fields[\"Cost Matrix\"] = \"Available\"\n\n        # determines the order in which the information will be printed\n        order = [\n            \"Task Type Description\",\n            \"Task ID\",\n            \"Task URL\",\n            \"Estimation Procedure\",\n            \"Evaluation Measure\",\n            \"Target Feature\",\n            \"# of Classes\",\n            \"Cost Matrix\",\n        ]\n        return [(key, fields[key]) for key in order if key in fields]\n\n    def get_dataset(self, **kwargs: Any) -&gt; datasets.OpenMLDataset:\n        \"\"\"Download dataset associated with task.\n\n        Accepts the same keyword arguments as the `openml.datasets.get_dataset`.\n        \"\"\"\n        return datasets.get_dataset(self.dataset_id, **kwargs)\n\n    def get_train_test_split_indices(\n        self,\n        fold: int = 0,\n        repeat: int = 0,\n        sample: int = 0,\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Get the indices of the train and test splits for a given task.\"\"\"\n        # Replace with retrieve from cache\n        if self.split is None:\n            self.split = self.download_split()\n\n        return self.split.get(repeat=repeat, fold=fold, sample=sample)\n\n    def _download_split(self, cache_file: Path) -&gt; None:\n        # TODO(eddiebergman): Not sure about this try to read and error approach\n        try:\n            with cache_file.open(encoding=\"utf8\"):\n                pass\n        except OSError:\n            split_url = self.estimation_procedure[\"data_splits_url\"]\n            openml._api_calls._download_text_file(\n                source=str(split_url),\n                output_path=str(cache_file),\n            )\n\n    def download_split(self) -&gt; OpenMLSplit:\n        \"\"\"Download the OpenML split for a given task.\"\"\"\n        # TODO(eddiebergman): Can this every be `None`?\n        assert self.task_id is not None\n        cache_dir = _create_cache_directory_for_id(\"tasks\", self.task_id)\n        cached_split_file = cache_dir / \"datasplits.arff\"\n\n        try:\n            split = OpenMLSplit._from_arff_file(cached_split_file)\n        except OSError:\n            # Next, download and cache the associated split file\n            self._download_split(cached_split_file)\n            split = OpenMLSplit._from_arff_file(cached_split_file)\n\n        return split\n\n    def get_split_dimensions(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get the (repeats, folds, samples) of the split for a given task.\"\"\"\n        if self.split is None:\n            self.split = self.download_split()\n\n        return self.split.repeats, self.split.folds, self.split.samples\n\n    # TODO(eddiebergman): Really need some better typing on all this\n    def _to_dict(self) -&gt; dict[str, dict[str, int | str | list[dict[str, Any]]]]:\n        \"\"\"Creates a dictionary representation of self in a string format (for XML parsing).\"\"\"\n        oml_input = [\n            {\"@name\": \"source_data\", \"#text\": str(self.dataset_id)},\n            {\"@name\": \"estimation_procedure\", \"#text\": str(self.estimation_procedure_id)},\n        ]\n        if self.evaluation_measure is not None:\n            oml_input.append({\"@name\": \"evaluation_measures\", \"#text\": self.evaluation_measure})\n\n        return {\n            \"oml:task_inputs\": {\n                \"@xmlns:oml\": \"http://openml.org/openml\",\n                \"oml:task_type_id\": self.task_type_id.value,  # This is an int from the enum?\n                \"oml:input\": oml_input,\n            }\n        }\n\n    def _parse_publish_response(self, xml_response: dict) -&gt; None:\n        \"\"\"Parse the id from the xml_response and assign it to self.\"\"\"\n        self.task_id = int(xml_response[\"oml:upload_task\"][\"oml:id\"])\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLTask.id","title":"<code>id: int | None</code>  <code>property</code>","text":"<p>Return the OpenML ID of this task.</p>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLTask.download_split","title":"<code>download_split()</code>","text":"<p>Download the OpenML split for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def download_split(self) -&gt; OpenMLSplit:\n    \"\"\"Download the OpenML split for a given task.\"\"\"\n    # TODO(eddiebergman): Can this every be `None`?\n    assert self.task_id is not None\n    cache_dir = _create_cache_directory_for_id(\"tasks\", self.task_id)\n    cached_split_file = cache_dir / \"datasplits.arff\"\n\n    try:\n        split = OpenMLSplit._from_arff_file(cached_split_file)\n    except OSError:\n        # Next, download and cache the associated split file\n        self._download_split(cached_split_file)\n        split = OpenMLSplit._from_arff_file(cached_split_file)\n\n    return split\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLTask.get_dataset","title":"<code>get_dataset(**kwargs)</code>","text":"<p>Download dataset associated with task.</p> <p>Accepts the same keyword arguments as the <code>openml.datasets.get_dataset</code>.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_dataset(self, **kwargs: Any) -&gt; datasets.OpenMLDataset:\n    \"\"\"Download dataset associated with task.\n\n    Accepts the same keyword arguments as the `openml.datasets.get_dataset`.\n    \"\"\"\n    return datasets.get_dataset(self.dataset_id, **kwargs)\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLTask.get_split_dimensions","title":"<code>get_split_dimensions()</code>","text":"<p>Get the (repeats, folds, samples) of the split for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_split_dimensions(self) -&gt; tuple[int, int, int]:\n    \"\"\"Get the (repeats, folds, samples) of the split for a given task.\"\"\"\n    if self.split is None:\n        self.split = self.download_split()\n\n    return self.split.repeats, self.split.folds, self.split.samples\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.OpenMLTask.get_train_test_split_indices","title":"<code>get_train_test_split_indices(fold=0, repeat=0, sample=0)</code>","text":"<p>Get the indices of the train and test splits for a given task.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>def get_train_test_split_indices(\n    self,\n    fold: int = 0,\n    repeat: int = 0,\n    sample: int = 0,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Get the indices of the train and test splits for a given task.\"\"\"\n    # Replace with retrieve from cache\n    if self.split is None:\n        self.split = self.download_split()\n\n    return self.split.get(repeat=repeat, fold=fold, sample=sample)\n</code></pre>"},{"location":"reference/tasks/task/#openml.tasks.task.TaskType","title":"<code>TaskType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Possible task types as defined in OpenML.</p> Source code in <code>openml/tasks/task.py</code> <pre><code>class TaskType(Enum):\n    \"\"\"Possible task types as defined in OpenML.\"\"\"\n\n    SUPERVISED_CLASSIFICATION = 1\n    SUPERVISED_REGRESSION = 2\n    LEARNING_CURVE = 3\n    SUPERVISED_DATASTREAM_CLASSIFICATION = 4\n    CLUSTERING = 5\n    MACHINE_LEARNING_CHALLENGE = 6\n    SURVIVAL_ANALYSIS = 7\n    SUBGROUP_DISCOVERY = 8\n    MULTITASK_REGRESSION = 9\n</code></pre>"}]}